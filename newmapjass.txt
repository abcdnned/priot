globals
//globals from ABC:
constant boolean LIBRARY_ABC=true
    constant integer ABC___HASH = 8191
    timer array ABC___TimerKeyA
    timer array ABC___TimerKeyB
    timer array ABC___TimerKeyC
    trigger array ABC___TriggerKeyA
    trigger array ABC___TriggerKeyB
    trigger array ABC___TriggerKeyC
    dialog array ABC___DialogKeyA
    dialog array ABC___DialogKeyB
    dialog array ABC___DialogKeyC
    region array ABC___RegionKeyA
    region array ABC___RegionKeyB
    region array ABC___RegionKeyC
    button array ABC___ButtonKeyA
    button array ABC___ButtonKeyB
    button array ABC___ButtonKeyC
    
    integer array ABC___TimerValueA
    integer array ABC___TimerValueB
    integer array ABC___TimerValueC
    integer array ABC___TriggerValueA
    integer array ABC___TriggerValueB
    integer array ABC___TriggerValueC
    integer array ABC___DialogValueA
    integer array ABC___DialogValueB
    integer array ABC___DialogValueC
    integer array ABC___RegionValueA
    integer array ABC___RegionValueB
    integer array ABC___RegionValueC
    integer array ABC___ButtonValueA
    integer array ABC___ButtonValueB
    integer array ABC___ButtonValueC
    integer array ABC___TimerCollisionA
    integer array ABC___TimerCollisionB
    integer array ABC___TimerCollisionC
    integer array ABC___TriggerCollisionA
    integer array ABC___TriggerCollisionB
    integer array ABC___TriggerCollisionC
    integer array ABC___DialogCollisionA
    integer array ABC___DialogCollisionB
    integer array ABC___DialogCollisionC
    integer array ABC___RegionCollisionA
    integer array ABC___RegionCollisionB
    integer array ABC___RegionCollisionC 
    integer array ABC___ButtonCollisionA
    integer array ABC___ButtonCollisionB
    integer array ABC___ButtonCollisionC
    
    integer ABC___TimerMaxCollisionA = 0
    integer ABC___TimerMaxCollisionB = 0
    integer ABC___TimerMaxCollisionC = 0
    integer ABC___TriggerMaxCollisionA = 0
    integer ABC___TriggerMaxCollisionB = 0
    integer ABC___TriggerMaxCollisionC = 0
    integer ABC___DialogMaxCollisionA = 0
    integer ABC___DialogMaxCollisionB = 0
    integer ABC___DialogMaxCollisionC = 0
    integer ABC___RegionMaxCollisionA = 0
    integer ABC___RegionMaxCollisionB = 0
    integer ABC___RegionMaxCollisionC = 0 
    integer ABC___ButtonMaxCollisionA = 0
    integer ABC___ButtonMaxCollisionB = 0
    integer ABC___ButtonMaxCollisionC = 0
    
    hashtable ABC___TimerHash
    hashtable ABC___TriggerHash
    hashtable ABC___DialogHash
    hashtable ABC___RegionHash
    hashtable ABC___ButtonHash
//endglobals from ABC
//globals from AIDS:
constant boolean LIBRARY_AIDS=true
        constant boolean AIDS___USE_PERIODIC_RECYCLER = false
        constant real AIDS___PERIOD = 0.03125 // Recycles 32 units/second max.
// Lower to be able to recycle faster.
// Only used if USE_PERIODIC_RECYCLER
// is set to true.

        constant integer AIDS___LEAVE_DETECTION_ABILITY = 'AIDS'
        // The unit stored at an index.
        unit array AIDS___IndexUnit
        integer array AIDS___LockLevel
        // Recycle stack
        integer array AIDS___RecycledIndex
        integer AIDS___MaxRecycledIndex = 0
        
        // Previous highest index
        integer AIDS___MaxIndex = 0
        integer array AIDS___DecayingIndex
        integer AIDS___MaxDecayingIndex=0
        integer AIDS___DecayChecker=0
        timer AIDS___UndefendTimer=CreateTimer()
        integer array AIDS___UndefendIndex
        integer AIDS___UndefendStackIndex=0
        integer array AIDS___UndefendExpiringIndex
        integer AIDS___UndefendExpiringIndexLevel=0
        // The Add/Remove stack (or assign/recycle stack).
        // 
        // Indexing can become recusive since units can be created on index
        // assignment or deallocation.
        // To support this, a stack is used to store the event response results.
        integer AIDS___ARStackLevel=0
        integer array AIDS___ARStackIndex
        unit array AIDS___ARStackUnit
        
        // A later discovery revealed that the Add/Remove stack did not need to be
        // used for deallocation. The alternative used works fine...
        // For structs and such which need to do things on unit index assignment.
        trigger AIDS___OnEnter=CreateTrigger()
        // The same, but for when units pass the initial filter anyway.
        trigger AIDS___OnEnterAllocated=CreateTrigger()
        // For structs and such which need to do things on unit index deallocation.
        trigger AIDS___OnDeallocate=CreateTrigger()
        integer AIDS___getindex
            integer AIDS___UndefendFilterIndex
//endglobals from AIDS
//globals from AIDriver:
constant boolean LIBRARY_AIDriver=true
//endglobals from AIDriver
//globals from AII:
constant boolean LIBRARY_AII=true
        constant integer AII___MAX_THRASH=100
        //Max threshold for leaked event for death detection trigger.
        trigger AII___alloItem=CreateTrigger()
        trigger AII___dealloItem=CreateTrigger() //Callback triggers
trigger AII___pickUpItem=CreateTrigger()
        trigger AII___sellItem=CreateTrigger()
        trigger AII___pawnItem=CreateTrigger() //Event triggers
integer AII___EventStruct=0 //Current callback data
item array AII___HashedItem
        boolean AII___IsInited=false
            trigger AII___dropItem=CreateTrigger()
        constant integer AII___HASH_NEXT=53
        constant integer AII___MAX_HASH_VALUE=8191
        integer array AII___HashedInt
//endglobals from AII
//globals from BufferFunction:
constant boolean LIBRARY_BufferFunction=true
//endglobals from BufferFunction
//globals from Debuff:
constant boolean LIBRARY_Debuff=true
//endglobals from Debuff
//globals from Difficulty:
constant boolean LIBRARY_Difficulty=true
    integer D_HARD=1
    integer D_CRAZY=2
    integer D_HELL=3
    integer Difficulty=D_HARD
    integer GAME_LV = 1
    integer MAX_GAME_LV = 7
    real HORRO_DMG = 0.05
//endglobals from Difficulty
//globals from Distance:
constant boolean LIBRARY_Distance=true
//endglobals from Distance
//globals from DummyCaster:
constant boolean LIBRARY_DummyCaster=true
        // If this is changed, the object merger line must also be changed
        // before the second implementation step is followed.
        constant integer DUMMY_TYPE='dumy'
        
        // This shouldn't be changed, but in some maps perhaps it is necessary.
        constant player DUMMY_OWNER=Player(PLAYER_NEUTRAL_AGGRESSIVE)
        
        // Just because these belong here:
        constant real DummyCaster___CREATED_AT_X=0.0
        constant real DummyCaster___CREATED_AT_Y=0.0
//=====================================================================================
        unit DUMMY=null
//endglobals from DummyCaster
//globals from EffectString:
constant boolean LIBRARY_EffectString=true
//endglobals from EffectString
//globals from EffectZ:
constant boolean LIBRARY_EffectZ=true
        destructable EffectZ___D
        effect EffectZ___E
//endglobals from EffectZ
//globals from Event:
constant boolean LIBRARY_Event=true
//endglobals from Event
//globals from FloatText:
constant boolean LIBRARY_FloatText=true
//endglobals from FloatText
//globals from HashKeyManager:
constant boolean LIBRARY_HashKeyManager=true
    integer currentKey=-1
//endglobals from HashKeyManager
//globals from HashTable:
constant boolean LIBRARY_HashTable=true
hashtable ht = null 
//endglobals from HashTable
//globals from Height:
constant boolean LIBRARY_Height=true
//endglobals from Height
//globals from HeroData:
constant boolean LIBRARY_HeroData=true
//endglobals from HeroData
//globals from HeroStatus:
constant boolean LIBRARY_HeroStatus=true
    trigger herostatus_t
//endglobals from HeroStatus
//globals from Level1:
constant boolean LIBRARY_Level1=true
//endglobals from Level1
//globals from ListModule:
constant boolean LIBRARY_ListModule=true
//endglobals from ListModule
//globals from Lock:
constant boolean LIBRARY_Lock=true
//endglobals from Lock
//globals from Material:
constant boolean LIBRARY_Material=true
    string MC_BULLET = "mc_bullet"
    string MC_UNIT = "mc_unit"
    string MC_ARROW = "mc_arrow"
    string MC_EFFECT = "mc_effect"
    string MC_BUILDING = "mc_building"
    string MC_STONE = "mc_stone"
    string MC_MINE = "mc_mine"
    string MC_WALL = "mc_wall"
    string MC_RING = "mc_ring"
    string GROUND_SMOOTH = "GROUND_SMOOTH"
    string GROUND_DESTROY = "ground_destroy"
    string GROUND_BOUNCE = "ground_bounce"
    string GROUND_STICK = "ground_stick"
//endglobals from Material
//globals from MissleFactory:
constant boolean LIBRARY_MissleFactory=true
//endglobals from MissleFactory
//globals from MonsterDead:
constant boolean LIBRARY_MonsterDead=true
trigger gtrgMonsterDead
//endglobals from MonsterDead
//globals from MonsterTypeData:
constant boolean LIBRARY_MonsterTypeData=true
//endglobals from MonsterTypeData
//globals from Movie:
constant boolean LIBRARY_Movie=true
//endglobals from Movie
//globals from OrderId:
constant boolean LIBRARY_OrderId=true
    integer OI_RIGHT_CLICK_MOVE = 851971
    integer OI_MOVE = 851983
    integer OI_STOP = 851972
//endglobals from OrderId
//globals from RegisterSpell:
constant boolean LIBRARY_RegisterSpell=true
    integer kRegistedSpell
//endglobals from RegisterSpell
//globals from ShootBack:
constant boolean LIBRARY_ShootBack=true
        trigger shoot_back_trg
//endglobals from ShootBack
//globals from ShootSpeed:
constant boolean LIBRARY_ShootSpeed=true
//endglobals from ShootSpeed
//globals from SkillLearn:
constant boolean LIBRARY_SkillLearn=true
//endglobals from SkillLearn
//globals from T32:
constant boolean LIBRARY_T32=true
        constant real T32_PERIOD=0.03125
        constant integer T32_FPS=R2I(1/T32_PERIOD)
        integer Tick=0 // very useful.

//==============================================================================
        trigger T32___Trig=CreateTrigger()
//endglobals from T32
//globals from Table:
constant boolean LIBRARY_Table=true
    hashtable Table___ht = InitHashtable() // The last hashtable you need
integer Table___grow = 2 // Index generation for Tables (above 2)
integer Table___keys = 0 // Index generation for TableArrays (below 0)
integer array Table___list
    integer Table___lpos = 0 // These two are used to recycle Tables
//endglobals from Table
//globals from TechData:
constant boolean LIBRARY_TechData=true
hashtable tdht = null 
integer tdht_cat = 1
integer tdht_name = 2
integer tdht_tech_need = 3
integer tdht_game_lv_need = 4
integer tdht_base_point = 5
    constant integer tKMANA = 'A004'
    constant integer tSTRONG = 'A010'
    constant integer tANTRAD = 'A01J'
    constant integer tDOGE = 'A00U'
    constant integer tFIRE_CHARGE = 'A00V'
    constant integer tSPEED_SHOOT = 'A00R'
    constant integer tAIM_SHOOT = 'A00Q'
    constant integer tFIRE = 'A00V'
    constant integer tFREZZ = 'A00W'
    constant integer tSAVE = 'A011'
    constant integer tMANA_BOOM = 'A013'
    constant integer TT_GENERAL = 0
    constant integer TT_BLADE = 1
    constant integer TT_MAGIC_HUNTER = 2
    constant integer TT_ICE = 3
    constant integer TT_COUNT = 4
    string array TECH_TREE_NAME[TT_COUNT]
    integer array TECH_TREE_COUNT[TT_COUNT]
    TechTree array TECH_TREES[TT_COUNT]
    integer TECH_COUNT = 0
//endglobals from TechData
//globals from Text:
constant boolean LIBRARY_Text=true
//endglobals from Text
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
        constant integer TimerUtils___MAX_HANDLE_ID_COUNT = 408000
        // values lower than 8191: very fast, but very unsafe.
        // values bigger than 8191: not that fast, the bigger the number is the slower the function gets
        // Most maps don't really need a value bigger than 50000 here, but if you are unsure, leave it
        // as the rather inflated value of 408000
        integer array TimerUtils___data[TimerUtils___MAX_HANDLE_ID_COUNT]
        constant integer TimerUtils___MIN_HANDLE_ID=0x100000
        //use a totally random number here, the more improbable someone uses it, the better.
        constant integer TimerUtils___HELD=0x28829022
        timer array TimerUtils___tT
        integer TimerUtils___tN = 0
//endglobals from TimerUtils
//globals from Union:
constant boolean LIBRARY_Union=true
        filterfunc Union___FilterLeisure
//endglobals from Union
//globals from UnitId:
constant boolean LIBRARY_UnitId=true
    integer HERO = 'H002'
    integer ABI_LOCK = 'h005'
    integer ONE_WALL = 'h006'
    integer ONE_WALL_BREAKABLE = 'h007'
//endglobals from UnitId
//globals from Vector:
constant boolean LIBRARY_Vector=true
//endglobals from Vector
//globals from YDWEBase:
constant boolean LIBRARY_YDWEBase=true
//全局哈希表 
	hashtable YDHT = null
	string bj_AllString=".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................"
//鍏ㄥ眬绯荤粺鍙橀噺
    unit bj_lastAbilityCastingUnit=null
    unit bj_lastAbilityTargetUnit=null
    unit bj_lastPoolAbstractedUnit=null
    unitpool bj_lastCreatedUnitPool=null
    item bj_lastPoolAbstractedItem=null
    itempool bj_lastCreatedItemPool=null
    attacktype bj_lastSetAttackType = ATTACK_TYPE_NORMAL
    damagetype bj_lastSetDamageType = DAMAGE_TYPE_NORMAL
    weapontype bj_lastSetWeaponType = WEAPON_TYPE_WHOKNOWS
    real yd_MapMaxX = 0
    real yd_MapMinX = 0
    real yd_MapMaxY = 0
    real yd_MapMinY = 0
    string array YDWEBase___yd_PlayerColor
    trigger array YDWEBase___AbilityCastingOverEventQueue
    integer array YDWEBase___AbilityCastingOverEventType
    integer YDWEBase___AbilityCastingOverEventNumber = 0
//endglobals from YDWEBase
//globals from YDWEPolledWaitNull:
constant boolean LIBRARY_YDWEPolledWaitNull=true
//endglobals from YDWEPolledWaitNull
//globals from YDWETriggerEvent:
constant boolean LIBRARY_YDWETriggerEvent=true
    trigger yd_DamageEventTrigger = null
    trigger array YDWETriggerEvent___DamageEventQueue
    integer YDWETriggerEvent___DamageEventNumber = 0
	
    item bj_lastMovedItemInItemSlot = null
	
    trigger YDWETriggerEvent___MoveItemEventTrigger = null
    trigger array YDWETriggerEvent___MoveItemEventQueue
    integer YDWETriggerEvent___MoveItemEventNumber = 0
//endglobals from YDWETriggerEvent
//globals from YDWETriggerRegisterEnterRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterEnterRectSimpleNull=true
    region yd_NullTempRegion
//endglobals from YDWETriggerRegisterEnterRectSimpleNull
//globals from YDWETriggerRegisterLeaveRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterLeaveRectSimpleNull=true
//endglobals from YDWETriggerRegisterLeaveRectSimpleNull
//globals from AIStrategy:
constant boolean LIBRARY_AIStrategy=true
//endglobals from AIStrategy
//globals from AutoIndex:
constant boolean LIBRARY_AutoIndex=true
//endglobals from AutoIndex
//globals from Constants:
constant boolean LIBRARY_Constants=true
//endglobals from Constants
//globals from Damage:
constant boolean LIBRARY_Damage=true
        constant integer Damage___LIFE_BONUS_ABIL='A000'
        Event Damage___OnDamageEvent
        boolean Damage___EventEnabled=true
        integer Damage___TypeStackLevel=0
        damagetype array Damage___TypeStackValue
        real array Damage___ToBlock
        integer Damage___BlockNum=0
        unit array Damage___BlockUnit
        real array Damage___BlockUnitLife
        real array Damage___BlockRedamage
        unit array Damage___BlockDamageSource
        
        timer Damage___BlockTimer=CreateTimer()
        unit array Damage___RemoveBoosted
        integer Damage___RemoveBoostedMax=0
        
        timer Damage___RemoveBoostedTimer=CreateTimer()
        real Damage___BoostedLifeTemp
        unit Damage___BoostedLifeUnit
        unit Damage___ForUnit
        real Damage___NextHealth
//endglobals from Damage
//globals from Direction:
constant boolean LIBRARY_Direction=true
//endglobals from Direction
//globals from DispatchTechLevel:
constant boolean LIBRARY_DispatchTechLevel=true
//endglobals from DispatchTechLevel
//globals from DoublePacket:
constant boolean LIBRARY_DoublePacket=true
        integer gpacauid='h001'
        integer gpacspl='A001'
        integer kpacau
        integer kRegedPac
//endglobals from DoublePacket
//globals from EquipmentData:
constant boolean LIBRARY_EquipmentData=true
//endglobals from EquipmentData
//globals from GroupUtils:
constant boolean LIBRARY_GroupUtils=true
        //* Group for use with all instant enumerations
        group ENUM_GROUP = CreateGroup()
        //* Temporary references for GroupRefresh
        boolean GroupUtils___Flag = false
        group GroupUtils___Refr = null
        //* Assorted constants
        constant integer GroupUtils___MAX_HANDLE_COUNT = 408000
        constant integer GroupUtils___MIN_HANDLE_ID = 0x100000
        //* Arrays and counter for the group stack
        group array GroupUtils___Groups
        integer array GroupUtils___Status[GroupUtils___MAX_HANDLE_COUNT]
        integer GroupUtils___Count = 0
//endglobals from GroupUtils
//globals from Gun:
constant boolean LIBRARY_Gun=true
//endglobals from Gun
//globals from Heal:
constant boolean LIBRARY_Heal=true
        HealType HEAL_TYPE_NORMAL
        boolean Heal___IsEventEnabled = true
        Event Heal___HealEvent
        unit array Heal___HealerStack
        unit array Heal___TargetStack
        real array Heal___HealAmountStack
        real array Heal___HealBlockStack
        HealType array Heal___TypeStack
        integer Heal___StackLevel = 0 //Prevent the returned value from messing up.
//endglobals from Heal
//globals from ItemData:
constant boolean LIBRARY_ItemData=true
hashtable idht = null 
hashtable ifht1 = null
hashtable ifht2 = null
hashtable ifht3 = null
hashtable ifht4 = null
hashtable ifht5 = null
integer idht_name = 1
integer idht_spell = 2
integer idht_item_type = 3
integer idht_s1 = 4
integer idht_s2 = 5
integer idht_s3 = 6
integer ifht_name = 1
integer ifht_origin = 2
integer ifht_step = 3
integer ifht_lv = 4
integer ifht_max_lv = 5
integer ifht_gold = 6
integer ifht_wood = 7
//endglobals from ItemData
//globals from Job:
constant boolean LIBRARY_Job=true
//endglobals from Job
//globals from JumpFacingStore:
constant boolean LIBRARY_JumpFacingStore=true
    trigger jumpPointFacing_t
//endglobals from JumpFacingStore
//globals from MonsterBonus:
constant boolean LIBRARY_MonsterBonus=true
//endglobals from MonsterBonus
//globals from Move:
constant boolean LIBRARY_Move=true
    rect area
    real lx
    real ry
    real ly
    real rx
    real lz
    real rz
//endglobals from Move
//globals from PUI:
constant boolean LIBRARY_PUI=true
//endglobals from PUI
//globals from Save:
constant boolean LIBRARY_Save=true
    trigger beforesave_t
    trigger dosave_t
//endglobals from Save
//globals from SpellStruct:
constant boolean LIBRARY_SpellStruct=true
        constant real SpellStruct___MAX_UNIT_COLLISION_SIZE=256.0
        group SpellStruct___GROUP=CreateGroup()
        hashtable SpellStruct___STORE=InitHashtable() // attaches to:
// abilid, methodkey
// abilid, unit
// timer, key
// trigger, key
// spellstruct, method (timer)
// spellstruct, method (trigger)
        constant key SpellStruct___ALLOCATOR
        SpellStruct___DefaultsInterface SpellStruct___ThisCastData
        integer SpellStruct___CastingAbility
        constant key SpellStruct___TIMER_DATA
        constant key SpellStruct___TRIGGER_DATA
//endglobals from SpellStruct
//globals from Status:
constant boolean LIBRARY_Status=true
        constant real Status___PERIOD=0.1 // for regen effects.
constant player Status___DUMMY_CASTER_OWNER=Player(PLAYER_NEUTRAL_PASSIVE)
        constant boolean Status___PERMENANTLY_REVEAL=true // reveal all units always, or only during dummy spells

        // To change these, change them also in the externalblock before executing it.
        constant integer Status___ABIL_STUN='A500'
        constant integer Status___ABIL_SILENCE='A501'
        constant integer Status___ABIL_DISARM_BOTH='A502'
        constant integer Status___ABIL_DISARM_MELEE='A503'
        constant integer Status___ABIL_DISARM_RANGE='A504'
        constant integer Status___ABIL_IMMOBOLISE='A505'
        constant integer Status___ABIL_INVISIBLE='A507'
        constant integer Status___ABIL_GHOST='A508'
        constant integer Status___ABIL_DOOM='A509'
        constant integer Status___ABIL_IMMUNITY='A50B'
        constant integer Status___ABIL_HEX='A50C'
        constant integer Status___ABIL_UNLOCUST='A50D'
        constant integer Status___ABIL_NEVER_MISS='A50F'
        constant integer Status___ABIL_ALWAYS_MISS='A50H'
        constant integer Status___ABIL_UNTOUCHABLE='A50J'
        constant integer Status___ABIL_BANISH='A50K'
        constant integer Status___ABIL_PHASE='A50L'
        //private constant integer ABIL_DOUBLE_ATTACK='A50O'
        constant integer Status___ABIL_RESISTANT_SKIN='A50Q'
        constant integer Status___ABIL_REFLECT_PIERCING='A50S'
        constant integer Status___ABIL_DISABLE='A50T'
        
        constant integer Status___ABIL_ARMOR='A5A@'
        constant integer Status___ABIL_DAMAGE='A5B@'
        constant integer Status___ABIL_STR='A5C@'
        constant integer Status___ABIL_AGI='A5D@'
        constant integer Status___ABIL_INT='A5E@'
        constant integer Status___ABIL_ATTACK_SPEED='A5F@'
        constant integer Status___ABIL_HEALTH='A5G@'
        constant integer Status___ABIL_MANA='A5H@'
        
        constant integer Status___LEVELS_ARMOR=10
        constant integer Status___LEVELS_DAMAGE=15
        constant integer Status___LEVELS_STR=10
        constant integer Status___LEVELS_AGI=10
        constant integer Status___LEVELS_INT=10
        constant integer Status___LEVELS_ATTACK_SPEED=9
        constant integer Status___LEVELS_HEALTH=20
        constant integer Status___LEVELS_MANA=20
        
        // To change these, change them also in the externalblock before executing it.
        constant integer Status___BUFF_STUN='B500'
        constant integer Status___BUFF_SILENCE='B501'
        constant integer Status___BUFF_DOOM='B509'
        constant integer Status___BUFF_DISARM_MELEE='B503'
        constant integer Status___BUFF_DISARM_RANGE='B504'
        constant integer Status___BUFF_DISARM_BOTH='B502'
        constant integer Status___BUFF_IMMOBOLISE_GROUND='B505'
        constant integer Status___BUFF_IMMOBOLISE_AIR='B506'
        constant integer Status___BUFF_HEX='B50C'
        constant integer Status___BUFF_BANISH='B50K'
        constant integer Status___BUFF_PHASE='B50L'
        constant integer Status___BUFF_DISABLE='B50T'
        
        constant integer Status___OID_STOP=851972 //stop
constant integer Status___OID_STUN=852231 //firebolt
constant integer Status___OID_SILENCE=852668 //soulburn
constant integer Status___OID_DISARM=852585 //drunkenhaze
constant integer Status___OID_IMMOBOLISE=852106 //ensnare
constant integer Status___OID_DOOM=852583 //doom
constant integer Status___OID_HEX=852502 //hex
constant integer Status___OID_UNLOCUST=852155 //ravenform
constant integer Status___OID_BANISH=852486 //banish
constant integer Status___OID_PHASE=852129 //windwalk
constant integer Status___OID_DISABLE=852252 //creepthunderbolt (hurlboulder)

        unit Status___CASTER_DISARM_BOTH=null
        unit Status___CASTER_DISARM_MELEE=null
        unit Status___CASTER_DISARM_RANGE=null
//endglobals from Status
//globals from VectorLib:
constant boolean LIBRARY_VectorLib=true
//endglobals from VectorLib
//globals from CameraLock:
constant boolean LIBRARY_CameraLock=true
    timer cltimer
//endglobals from CameraLock
//globals from FakeMan:
constant boolean LIBRARY_FakeMan=true
    string LV_FREEZ = "LV_FREEZ"
    string LV_ACTIVE = "LV_ACTIVE"
    string LV_DESTORY = "LV_DESTORY"
    real LV_FREEZ_DISTANCE = 300000000000000
//endglobals from FakeMan
//globals from FogControl:
constant boolean LIBRARY_FogControl=true
    timer fctimer
    fogmodifier array fogms
//endglobals from FogControl
//globals from ItemEquip:
constant boolean LIBRARY_ItemEquip=true
    integer kit
    trigger t
    trigger t2
//endglobals from ItemEquip
//globals from MonsterTargetGroup:
constant boolean LIBRARY_MonsterTargetGroup=true
    group MonsterTargetGroup
//endglobals from MonsterTargetGroup
//globals from ShootTarget:
constant boolean LIBRARY_ShootTarget=true
trigger gtrgShootTarget
real lastshoot = 0
//endglobals from ShootTarget
//globals from StartRoom:
constant boolean LIBRARY_StartRoom=true
    boolean gateOpened = false
//endglobals from StartRoom
//globals from Strong:
constant boolean LIBRARY_Strong=true
    trigger doStrong_t
//endglobals from Strong
//globals from Stun:
constant boolean LIBRARY_Stun=true
//endglobals from Stun
//globals from TargetFilter:
constant boolean LIBRARY_TargetFilter=true
//endglobals from TargetFilter
//globals from AIApproach:
constant boolean LIBRARY_AIApproach=true
    integer sum=0
    integer cur=0
        trigger aitrg
        timer appt
        timer attt
        group appgro
        group attgro
//endglobals from AIApproach
//globals from AIData:
constant boolean LIBRARY_AIData=true
//endglobals from AIData
//globals from AIGroup:
constant boolean LIBRARY_AIGroup=true
DefaultAIGroup gDefaultAIGroup
//endglobals from AIGroup
//globals from CustomDamage:
constant boolean LIBRARY_CustomDamage=true
//endglobals from CustomDamage
//globals from DialogSystem:
constant boolean LIBRARY_DialogSystem=true
//endglobals from DialogSystem
//globals from HorrorOrder:
constant boolean LIBRARY_HorrorOrder=true
//endglobals from HorrorOrder
//globals from Buffer:
constant boolean LIBRARY_Buffer=true
    timer moveTimer
//endglobals from Buffer
//globals from ChooseBonus:
constant boolean LIBRARY_ChooseBonus=true
    trigger choosebonus_t
    trigger usebonus_t
//endglobals from ChooseBonus
//globals from ChooseTech:
constant boolean LIBRARY_ChooseTech=true
    trigger choosetech_t
    trigger usetech_t
//endglobals from ChooseTech
//globals from Radiation:
constant boolean LIBRARY_Radiation=true
    trigger doRadiation_t
//endglobals from Radiation
//globals from Transform:
constant boolean LIBRARY_Transform=true
    trigger transform_t
//endglobals from Transform
//globals from PhysicsSystem:
constant boolean LIBRARY_PhysicsSystem=true
//endglobals from PhysicsSystem
//globals from Missle:
constant boolean LIBRARY_Missle=true
//endglobals from Missle
//globals from Shooter:
constant boolean LIBRARY_Shooter=true
//endglobals from Shooter
//globals from Velocity:
constant boolean LIBRARY_Velocity=true
    real u = 1.5
    real us = 3
    real g = 9.8
    group COLLISION_GROUP
    timer missleMoveTimer
    timer collisionGroupTimer
//endglobals from Velocity
    // User-defined
    real udg_r = 0
    // Generated
    rect gg_rct_lock_1 = null
    rect gg_rct_lock_2 = null
    rect gg_rct_lock_3 = null
    rect gg_rct_lock_11 = null
    rect gg_rct_start = null
    rect gg_rct_start_road_1 = null
    rect gg_rct_start_road_2 = null
    rect gg_rct_start_road_gate = null
    rect gg_rct_gave_guns = null
    trigger gg_trg_StartRoom = null
    trigger gg_trg_level1 = null
    trigger gg_trg_InitJobData = null
    trigger gg_trg_Save = null
    trigger gg_trg_Strong = null
    trigger gg_trg_ItemJump = null
    trigger gg_trg_GunSpell = null
    trigger gg_trg_Jump = null
    trigger gg_trg_JumpFacingStore = null
    trigger gg_trg_InjectionSpeedUp = null
    trigger gg_trg_RegisterSpell = null
    trigger gg_trg_Darts = null
    trigger gg_trg_RetrunDarts = null
    trigger gg_trg_SmartDarts = null
    trigger gg_trg_ShoulderCannon = null
    trigger gg_trg_ItemRetrunDarts = null
    trigger gg_trg_LeaveDarts = null
    trigger gg_trg_BackGrenade = null
    trigger gg_trg_Mine = null
    trigger gg_trg_PushGrenade = null
    trigger gg_trg_Blink = null
    trigger gg_trg_Transport = null
    trigger gg_trg_ElectricWhip = null
    trigger gg_trg_AutoAim = null
    trigger gg_trg_ShootBack = null
    trigger gg_trg_TeckLock = null
    trigger gg_trg_Register = null
    trigger gg_trg_RegisterFly = null
    trigger gg_trg_FogControl = null
    trigger gg_trg_CameraLock = null
    trigger gg_trg_Movie = null
    trigger gg_trg_GV = null
    trigger gg_trg_LearnAbility = null
    trigger gg_trg_TriggerKillHpBuff = null
    trigger gg_trg_TriggerHorro = null
    trigger gg_trg_HorrorOrderFilter = null
    trigger gg_trg_HorrorOrder = null
    trigger gg_trg_OrderId = null
    trigger gg_trg_ShootSpeed = null
    trigger gg_trg_Radiation = null
    trigger gg_trg_ArrayList = null
    trigger gg_trg_ChooseTech = null
    trigger gg_trg_ChooseBonus = null
    trigger gg_trg_TechLevelUp = null
    trigger gg_trg_TechData = null
    trigger gg_trg_Transform = null
    trigger gg_trg_ChangeAbility = null
    trigger gg_trg_DialogSystem = null
    trigger gg_trg_Buffer = null
    trigger gg_trg_BurnBuffer = null
    trigger gg_trg_HorroBuffer = null
    trigger gg_trg_BleedBuffer = null
    trigger gg_trg_IceSlowBuffer = null
    trigger gg_trg_AutoAimBuffer = null
    trigger gg_trg_Debuff = null
    trigger gg_trg_BufferFunction = null
    trigger gg_trg_Constants = null
    trigger gg_trg_PlayerHero = null
    trigger gg_trg_FocuseHero = null
    trigger gg_trg_ItemData = null
    trigger gg_trg_ItemEquip = null
    trigger gg_trg_ItemType = null
    trigger gg_trg_UnitId = null
    trigger gg_trg_FakeMan = null
    trigger gg_trg_MonsterDead = null
    trigger gg_trg_ShootTarget = null
    trigger gg_trg_MonsterTypeData = null
    trigger gg_trg_MonsterBonus = null
    trigger gg_trg_MonsterTargetGroup = null
    trigger gg_trg_DeathEffect = null
    trigger gg_trg_Difficulty = null
    trigger gg_trg_EffectString = null
    trigger gg_trg_SkillLearn = null
    trigger gg_trg_DoublePacket = null
    trigger gg_trg_Missle = null
    trigger gg_trg_MissleFactory = null
    trigger gg_trg_Gun = null
    trigger gg_trg_Shooter = null
    trigger gg_trg_HeroData = null
    trigger gg_trg_EquipmentData = null
    trigger gg_trg_EMData = null
    trigger gg_trg_EvilMarinData = null
    trigger gg_trg_HeroStatus = null
    trigger gg_trg_Velocity = null
    trigger gg_trg_Material = null
    trigger gg_trg_PhysicsSystem = null
    trigger gg_trg_bordercontrol = null
    trigger gg_trg_TargetFilter = null
    trigger gg_trg_ItemInfo = null
    trigger gg_trg_AIStrategy = null
    trigger gg_trg_AIGroup = null
    trigger gg_trg_AIData = null
    trigger gg_trg_AIDriver = null
    trigger gg_trg_AIHurted = null
    trigger gg_trg_DummyCaster = null
    trigger gg_trg_Status = null
    trigger gg_trg_Heal = null
    trigger gg_trg_ABC = null
    trigger gg_trg_AII = null
    trigger gg_trg_Table = null
    trigger gg_trg_Height = null
    trigger gg_trg_AddEffectZ = null
    trigger gg_trg_Move = null
    trigger gg_trg_Vector = null
    trigger gg_trg_FloatText = null
    trigger gg_trg_Text = null
    trigger gg_trg_Direction = null
    trigger gg_trg_SpellStruck = null
    trigger gg_trg_Timer_Utils = null
    trigger gg_trg_HashKeyManager = null
    trigger gg_trg_T32 = null
    trigger gg_trg_HashTable = null
    trigger gg_trg_Distance = null
    trigger gg_trg_AIDS = null
    trigger gg_trg_AIDSCleaner = null
    trigger gg_trg_Event = null
    trigger gg_trg_Damage = null
    trigger gg_trg_CustomDamage = null
    trigger gg_trg_Custom_Congregation = null
    trigger gg_trg_List_Module = null
    trigger gg_trg_Group_Utils = null
    trigger gg_trg_CreateItem = null
    trigger gg_trg_Demo_Usage = null
    trigger gg_trg_eventtest = null
    trigger gg_trg_AIListRunner = null
    trigger gg_trg_AIList = null
    trigger gg_trg_ListTEst = null
    trigger gg_trg_EnemyBugSystem2 = null
    trigger gg_trg_12________2_______u = null
    trigger gg_trg_12________2________2 = null
    trigger gg_trg_12________2________3 = null
    trigger gg_trg_AIApproach = null
    trigger gg_trg____________________002 = null
    trigger gg_trg_TestGun = null
    trigger gg_trg____________________003 = null
    trigger gg_trg_camera = null
    trigger gg_trg_inittest = null
    trigger gg_trg____________________001_______u = null
    trigger gg_trg_Zero_Damage_All = null
    unit gg_unit_h006_0185 = null
    unit gg_unit_h006_0048 = null
    unit gg_unit_h006_0065 = null
    unit gg_unit_h006_0049 = null
    unit gg_unit_h006_0186 = null
    unit gg_unit_h006_0184 = null
    unit gg_unit_h006_0188 = null
    unit gg_unit_h006_0187 = null
    unit gg_unit_u002_0161 = null
    region g_cur_region
    integer cur_player = 0
    integer act1 = 0
    integer act2 = 1
    integer act3 = 2
    boolean g_camera_lock = false
    boolean g_fog = false
    real g_sd_th = 70
    real g_missle_damage = 50
    constant integer ARRAY_SIZE = 1000
    constant real pi = Deg2Rad(180.0)
    
    constant integer iEXP = 'I00E'
    
    constant integer PLAYER_COUNT = 3
    constant integer iUPGADE = 'I004'
    constant integer iFREEUP = 'I00D'
    constant integer iSPEED = 'I003'
    constant integer iJUMP = 'I002'
    constant integer iRETURN = 'I006'
    constant integer iREACT = 'I007'
    constant integer iELECTRIC = 'I008'
    constant integer iBLINK = 'I009'
    constant integer iTRANSPORT = 'I00A'
    constant integer iAUTOAIM = 'I00B'
    constant integer i100G = 'I00C'
    constant integer iLEAVE = 'I00F'
    constant integer iBKGRENADE = 'I00G'
    constant integer iPSGRENADE = 'I00M'
    constant integer iMINE = 'I00J'
    constant integer bICE_MISSLE = 'e005'
    constant integer bFIRE_MISSLE = 'e006'
    constant integer bELECTRIC = 'e008'
    constant integer aRETURN = 'A002'
    constant integer aREACT = 'A00F'
    constant integer aELECTRIC = 'A00G'
    constant integer aBLINK = 'A00I'
    constant integer aTRANSPORT = 'A00J'
    constant integer aAUTOAIM = 'A00K'
    constant integer aLEAVE = 'A016'
    constant integer aBKGRENADE = 'A017'
    constant integer aPSGRENADE = 'A019'
    constant integer aMINE = 'A01B'
    constant integer aBAN_ATTACK = 'A01M'
    constant integer euCOLLISION = 'e004'
    //constant integer BULLET_MAX_SPEED = 180
    constant integer BULLET_RANGE_ADDON = 10
    constant integer LEAVE_COUNT = 10
    constant integer REDAMAGE_DISTANCE = 200
    constant integer WHO_PLAYER_ID = 7
    constant player WHO_PLAYER = Player(7)
    constant real DAMAGE_SPEED = 5
    constant integer MAGIC = 'u001'
    constant integer MAX_BURN_LV = 5000
    constant integer MAX_BLEED_LV = 5000
    constant integer TECH_UNIT = 'H004'
    constant integer sALL = 'A00M'
    constant integer sSTR = 'A00N'
    constant integer sAGI = 'A00O'
    constant integer sINT = 'A00P'
    constant integer SHOOT_SPEED = 'A015'
    constant real GRENADEDEG = Atan2(2, 1)
    constant integer DEFAULT_ARRAYLIST_SIZE = 64
    constant player MONSTER_PLAYER = Player(11)
    constant integer MONSTER_PLAYER_ID = 11
    constant integer EVIL_MARIN = 'h000'
    constant rect array gg_rct_lock
    constant integer SHOTHZ = 100
    constant string MAJOR_AB = "涓绘鍣?
    constant string MINOR_AB = "鍓鍣?
    unit array heros
    unit array techs
    integer SHOOT_GUN=5
    integer SNAKE_GUN=1
    integer MACHINE_GUN=2
    integer ASSASSINATE_GUN=3
    integer ROCKET_GUN=4
    integer GUN=4
    integer HAND=1
    integer ARMOR=2
    integer SHOE=3
    integer OTHER=5
    integer LONGTERM=7
    integer STATIC=6
    integer I_D = 8
    integer I_T = 9
    integer I_N = 10
    integer AB1 = 11
    integer AB2 = 12
    constant string SMALL_BLOOD="Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl"
    constant string HEAL_EFFECT = "Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
    constant string BLADE_BLOOD = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
    constant string E_BLINK_CASTER = "Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
    constant string E_BLINK_TARGET = "Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
    constant string E_TRANSPORT_TARGET = "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"
    constant string E_TRANSPORT_CASTER = "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl"
    constant string E_KILL_MANA = "Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
    constant string E_ELF_BLOOD = "Objects\\Spawnmodels\\Human\\HumanBlood\\HeroBloodElfBlood.mdl"
    constant string E_DOGE = "Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"
    constant string E_TUNDER_CLAP = "Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
    constant string E_CLAP = "Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
    constant string E_MINE_EXPLODE = "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
    constant string E_MANA_BOOM = "Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
    constant string E_GUN_SHOW = "Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"

trigger l__library_init
endglobals
//library ABC:
//==============================================================================
//  Collision check functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerCollisionA takes nothing returns integer
    return ABC___TimerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionB takes nothing returns integer
    return ABC___TimerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionC takes nothing returns integer
    return ABC___TimerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionA takes nothing returns integer
    return ABC___TriggerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionB takes nothing returns integer
    return ABC___TriggerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionC takes nothing returns integer
    return ABC___TriggerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionA takes nothing returns integer
    return ABC___DialogMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionB takes nothing returns integer
    return ABC___DialogMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionC takes nothing returns integer
    return ABC___DialogMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionA takes nothing returns integer
    return ABC___RegionMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionB takes nothing returns integer
    return ABC___RegionMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionC takes nothing returns integer
    return ABC___RegionMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionA takes nothing returns integer
    return ABC___ButtonMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionB takes nothing returns integer
    return ABC___ButtonMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionC takes nothing returns integer
    return ABC___ButtonMaxCollisionC
endfunction
//==============================================================================
//  Set functions
//==============================================================================
//------------------------------------------------------------------------------
function SetTimerStructA takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TimerKeyA[i] == null then
        set ABC___TimerKeyA[i] = key
        set ABC___TimerValueA[i] = value
    else
        call SaveInteger(ABC___TimerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructB takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TimerKeyB[i] == null then
        set ABC___TimerKeyB[i] = key
        set ABC___TimerValueB[i] = value
    else
        call SaveInteger(ABC___TimerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructC takes timer key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TimerKeyC[i] == null then
        set ABC___TimerKeyC[i] = key
        set ABC___TimerValueC[i] = value
    else
        call SaveInteger(ABC___TimerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructA takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TriggerKeyA[i] == null then
        set ABC___TriggerKeyA[i] = key
        set ABC___TriggerValueA[i] = value
    else
        call SaveInteger(ABC___TriggerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructB takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TriggerKeyB[i] == null then
        set ABC___TriggerKeyB[i] = key
        set ABC___TriggerValueB[i] = value
    else
        call SaveInteger(ABC___TriggerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructC takes trigger key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___TriggerKeyC[i] == null then
        set ABC___TriggerKeyC[i] = key
        set ABC___TriggerValueC[i] = value
    else
        call SaveInteger(ABC___TriggerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructA takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___DialogKeyA[i] == null then
        set ABC___DialogKeyA[i] = key
        set ABC___DialogValueA[i] = value
    else
        call SaveInteger(ABC___DialogHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructB takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___DialogKeyB[i] == null then
        set ABC___DialogKeyB[i] = key
        set ABC___DialogValueB[i] = value
    else
        call SaveInteger(ABC___DialogHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructC takes dialog key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___DialogKeyC[i] == null then
        set ABC___DialogKeyC[i] = key
        set ABC___DialogValueC[i] = value
    else
        call SaveInteger(ABC___DialogHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructA takes region key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___RegionKeyA[i] == null then
        set ABC___RegionKeyA[i] = key
        set ABC___RegionValueA[i] = value
    else
        call SaveInteger(ABC___RegionHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructB takes region key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___RegionKeyB[i] == null then
        set ABC___RegionKeyB[i] = key
        set ABC___RegionValueB[i] = value
    else
        call SaveInteger(ABC___RegionHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructC takes region key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___RegionKeyC[i] == null then
        set ABC___RegionKeyC[i] = key
        set ABC___RegionValueC[i] = value
    else
        call SaveInteger(ABC___RegionHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructA takes button key, integer value returns nothing
//textmacro instance: ABC_Set("A", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___ButtonKeyA[i] == null then
        set ABC___ButtonKeyA[i] = key
        set ABC___ButtonValueA[i] = value
    else
        call SaveInteger(ABC___ButtonHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructB takes button key, integer value returns nothing
//textmacro instance: ABC_Set("B", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___ButtonKeyB[i] == null then
        set ABC___ButtonKeyB[i] = key
        set ABC___ButtonValueB[i] = value
    else
        call SaveInteger(ABC___ButtonHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructC takes button key, integer value returns nothing
//textmacro instance: ABC_Set("C", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
    if ABC___ButtonKeyC[i] == null then
        set ABC___ButtonKeyC[i] = key
        set ABC___ButtonValueC[i] = value
    else
        call SaveInteger(ABC___ButtonHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Button", "button")
endfunction
//==============================================================================
//  Get functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerStructA takes timer key returns integer
//textmacro instance: ABC_Get("A", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyA[i] == key then
        return ABC___TimerValueA[i]
    else
        return LoadInteger(ABC___TimerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructB takes timer key returns integer
//textmacro instance: ABC_Get("B", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyB[i] == key then
        return ABC___TimerValueB[i]
    else
        return LoadInteger(ABC___TimerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructC takes timer key returns integer
//textmacro instance: ABC_Get("C", "Timer", "timer")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyC[i] == key then
        return ABC___TimerValueC[i]
    else
        return LoadInteger(ABC___TimerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Get("A", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyA[i] == key then
        return ABC___TriggerValueA[i]
    else
        return LoadInteger(ABC___TriggerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Get("B", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyB[i] == key then
        return ABC___TriggerValueB[i]
    else
        return LoadInteger(ABC___TriggerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Get("C", "Trigger", "trigger")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyC[i] == key then
        return ABC___TriggerValueC[i]
    else
        return LoadInteger(ABC___TriggerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Get("A", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyA[i] == key then
        return ABC___DialogValueA[i]
    else
        return LoadInteger(ABC___DialogHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Get("B", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyB[i] == key then
        return ABC___DialogValueB[i]
    else
        return LoadInteger(ABC___DialogHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Get("C", "Dialog", "dialog")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyC[i] == key then
        return ABC___DialogValueC[i]
    else
        return LoadInteger(ABC___DialogHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructA takes region key returns integer
//textmacro instance: ABC_Get("A", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyA[i] == key then
        return ABC___RegionValueA[i]
    else
        return LoadInteger(ABC___RegionHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructB takes region key returns integer
//textmacro instance: ABC_Get("B", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyB[i] == key then
        return ABC___RegionValueB[i]
    else
        return LoadInteger(ABC___RegionHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructC takes region key returns integer
//textmacro instance: ABC_Get("C", "Region", "region")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyC[i] == key then
        return ABC___RegionValueC[i]
    else
        return LoadInteger(ABC___RegionHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructA takes button key returns integer
//textmacro instance: ABC_Get("A", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyA[i] == key then
        return ABC___ButtonValueA[i]
    else
        return LoadInteger(ABC___ButtonHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructB takes button key returns integer
//textmacro instance: ABC_Get("B", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyB[i] == key then
        return ABC___ButtonValueB[i]
    else
        return LoadInteger(ABC___ButtonHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructC takes button key returns integer
//textmacro instance: ABC_Get("C", "Button", "button")
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyC[i] == key then
        return ABC___ButtonValueC[i]
    else
        return LoadInteger(ABC___ButtonHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Button", "button")
endfunction
//==============================================================================
//  Clear functions
//==============================================================================
//------------------------------------------------------------------------------
function ClearTimerStructA takes timer key returns integer
//textmacro instance: ABC_Clear("A", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyA[i] == key then
        set ret = ABC___TimerValueA[i]
        set ABC___TimerKeyA[i] = null
        set ABC___TimerValueA[i] = 0
    else
        if HaveSavedInteger(ABC___TimerHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TimerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructB takes timer key returns integer
//textmacro instance: ABC_Clear("B", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyB[i] == key then
        set ret = ABC___TimerValueB[i]
        set ABC___TimerKeyB[i] = null
        set ABC___TimerValueB[i] = 0
    else
        if HaveSavedInteger(ABC___TimerHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TimerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructC takes timer key returns integer
//textmacro instance: ABC_Clear("C", "Timer", "timer")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TimerKeyC[i] == key then
        set ret = ABC___TimerValueC[i]
        set ABC___TimerKeyC[i] = null
        set ABC___TimerValueC[i] = 0
    else
        if HaveSavedInteger(ABC___TimerHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TimerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Clear("A", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyA[i] == key then
        set ret = ABC___TriggerValueA[i]
        set ABC___TriggerKeyA[i] = null
        set ABC___TriggerValueA[i] = 0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TriggerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Clear("B", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyB[i] == key then
        set ret = ABC___TriggerValueB[i]
        set ABC___TriggerKeyB[i] = null
        set ABC___TriggerValueB[i] = 0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TriggerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Clear("C", "Trigger", "trigger")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___TriggerKeyC[i] == key then
        set ret = ABC___TriggerValueC[i]
        set ABC___TriggerKeyC[i] = null
        set ABC___TriggerValueC[i] = 0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC___TriggerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Clear("A", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyA[i] == key then
        set ret = ABC___DialogValueA[i]
        set ABC___DialogKeyA[i] = null
        set ABC___DialogValueA[i] = 0
    else
        if HaveSavedInteger(ABC___DialogHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC___DialogHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Clear("B", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyB[i] == key then
        set ret = ABC___DialogValueB[i]
        set ABC___DialogKeyB[i] = null
        set ABC___DialogValueB[i] = 0
    else
        if HaveSavedInteger(ABC___DialogHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC___DialogHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Clear("C", "Dialog", "dialog")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___DialogKeyC[i] == key then
        set ret = ABC___DialogValueC[i]
        set ABC___DialogKeyC[i] = null
        set ABC___DialogValueC[i] = 0
    else
        if HaveSavedInteger(ABC___DialogHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC___DialogHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructA takes region key returns integer
//textmacro instance: ABC_Clear("A", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyA[i] == key then
        set ret = ABC___RegionValueA[i]
        set ABC___RegionKeyA[i] = null
        set ABC___RegionValueA[i] = 0
    else
        if HaveSavedInteger(ABC___RegionHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC___RegionHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructB takes region key returns integer
//textmacro instance: ABC_Clear("B", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyB[i] == key then
        set ret = ABC___RegionValueB[i]
        set ABC___RegionKeyB[i] = null
        set ABC___RegionValueB[i] = 0
    else
        if HaveSavedInteger(ABC___RegionHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC___RegionHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructC takes region key returns integer
//textmacro instance: ABC_Clear("C", "Region", "region")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___RegionKeyC[i] == key then
        set ret = ABC___RegionValueC[i]
        set ABC___RegionKeyC[i] = null
        set ABC___RegionValueC[i] = 0
    else
        if HaveSavedInteger(ABC___RegionHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC___RegionHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructA takes button key returns integer
//textmacro instance: ABC_Clear("A", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyA[i] == key then
        set ret = ABC___ButtonValueA[i]
        set ABC___ButtonKeyA[i] = null
        set ABC___ButtonValueA[i] = 0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'A', GetHandleId(key)) then
            set ret = LoadInteger(ABC___ButtonHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructA("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructB takes button key returns integer
//textmacro instance: ABC_Clear("B", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyB[i] == key then
        set ret = ABC___ButtonValueB[i]
        set ABC___ButtonKeyB[i] = null
        set ABC___ButtonValueB[i] = 0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'B', GetHandleId(key)) then
            set ret = LoadInteger(ABC___ButtonHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructB("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructC takes button key returns integer
//textmacro instance: ABC_Clear("C", "Button", "button")
    local integer ret
    local integer i = GetHandleId(key)
    set i = i - (i / ABC___HASH) * ABC___HASH
	
    if ABC___ButtonKeyC[i] == key then
        set ret = ABC___ButtonValueC[i]
        set ABC___ButtonKeyC[i] = null
        set ABC___ButtonValueC[i] = 0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'C', GetHandleId(key)) then
            set ret = LoadInteger(ABC___ButtonHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructC("+I2S(GetHandleId(key))+") - clear attempt on bad key")
            set ret = 0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Button", "button")
endfunction
//==============================================================================
//  Initialization
//==============================================================================
function ABC___Init takes nothing returns nothing
    set ABC___TimerKeyA[ABC___HASH-1] = null
    set ABC___TimerKeyB[ABC___HASH-1] = null
    set ABC___TimerKeyC[ABC___HASH-1] = null
    set ABC___TriggerKeyA[ABC___HASH-1] = null
    set ABC___TriggerKeyB[ABC___HASH-1] = null
    set ABC___TriggerKeyC[ABC___HASH-1] = null
    set ABC___DialogKeyA[ABC___HASH-1] = null
    set ABC___DialogKeyB[ABC___HASH-1] = null
    set ABC___DialogKeyC[ABC___HASH-1] = null
    set ABC___RegionKeyA[ABC___HASH-1] = null
    set ABC___RegionKeyB[ABC___HASH-1] = null
    set ABC___RegionKeyC[ABC___HASH-1] = null
    set ABC___ButtonKeyA[ABC___HASH-1] = null
    set ABC___ButtonKeyB[ABC___HASH-1] = null
    set ABC___ButtonKeyC[ABC___HASH-1] = null
    
    set ABC___TimerValueA[ABC___HASH-1] = 0
    set ABC___TimerValueB[ABC___HASH-1] = 0
    set ABC___TimerValueC[ABC___HASH-1] = 0
    set ABC___TriggerValueA[ABC___HASH-1] = 0
    set ABC___TriggerValueB[ABC___HASH-1] = 0
    set ABC___TriggerValueC[ABC___HASH-1] = 0
    set ABC___DialogValueA[ABC___HASH-1] = 0
    set ABC___DialogValueB[ABC___HASH-1] = 0
    set ABC___DialogValueC[ABC___HASH-1] = 0
    set ABC___RegionValueA[ABC___HASH-1] = 0
    set ABC___RegionValueB[ABC___HASH-1] = 0
    set ABC___RegionValueC[ABC___HASH-1] = 0 
    set ABC___ButtonValueA[ABC___HASH-1] = 0
    set ABC___ButtonValueB[ABC___HASH-1] = 0
    set ABC___ButtonValueC[ABC___HASH-1] = 0
    
    set ABC___TimerCollisionA[ABC___HASH-1] = 0
    set ABC___TimerCollisionB[ABC___HASH-1] = 0
    set ABC___TimerCollisionC[ABC___HASH-1] = 0
    set ABC___TriggerCollisionA[ABC___HASH-1] = 0
    set ABC___TriggerCollisionB[ABC___HASH-1] = 0
    set ABC___TriggerCollisionC[ABC___HASH-1] = 0
    set ABC___DialogCollisionA[ABC___HASH-1] = 0
    set ABC___DialogCollisionB[ABC___HASH-1] = 0
    set ABC___DialogCollisionC[ABC___HASH-1] = 0
    set ABC___RegionCollisionA[ABC___HASH-1] = 0
    set ABC___RegionCollisionB[ABC___HASH-1] = 0
    set ABC___RegionCollisionC[ABC___HASH-1] = 0 
    set ABC___ButtonCollisionA[ABC___HASH-1] = 0
    set ABC___ButtonCollisionB[ABC___HASH-1] = 0
    set ABC___ButtonCollisionC[ABC___HASH-1] = 0
    
    set ABC___TimerHash = InitHashtable()
    set ABC___TriggerHash = InitHashtable()
    set ABC___DialogHash = InitHashtable()
    set ABC___RegionHash = InitHashtable()
    set ABC___ButtonHash = InitHashtable()
endfunction

//library ABC ends
//library AIDS:
    //==============================================================================
    // Configurables
    //
    
    function AIDS___UnitIndexingFilter takes unit u returns boolean
        return true
    endfunction
    
    //==============================================================================
    // System code
    //
    
    //==============================================================================
    
    //==============================================================================
    
    
    //==============================================================================
    
    constant function AIDS_GetEnteringIndexUnit takes nothing returns unit
        return AIDS___ARStackUnit[AIDS___ARStackLevel]
    endfunction
    
    function AIDS_GetIndexOfEnteringUnit takes nothing returns integer
        // Called in AIDS structs when units do not pass the initial AIDS filter.
        
        if AIDS___ARStackIndex[AIDS___ARStackLevel]==0 then
            // Get new index, from recycler first, else new.
            // Store the current index on the (new) top level of the AR stack.
            if AIDS___MaxRecycledIndex==0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex+1
                set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___MaxIndex
            else // Get from recycle stack.
set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex-1
            endif
            
            // Store index on unit.
            call SetUnitUserData(AIDS___ARStackUnit[AIDS___ARStackLevel],AIDS___ARStackIndex[AIDS___ARStackLevel])
            set AIDS___IndexUnit[AIDS___ARStackIndex[AIDS___ARStackLevel]]=AIDS___ARStackUnit[AIDS___ARStackLevel]
            
            // Add index to recycle list.
            set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex+1
            set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___ARStackIndex[AIDS___ARStackLevel]
        endif
        
        return AIDS___ARStackIndex[AIDS___ARStackLevel]
    endfunction
    
    constant function AIDS_GetIndexOfEnteringUnitAllocated takes nothing returns integer
        // Called in AIDS structs when units have passed the initial AIDS filter.
        return AIDS___ARStackIndex[AIDS___ARStackLevel]
    endfunction
    constant function AIDS_GetDecayingIndex takes nothing returns integer
        static if AIDS___USE_PERIODIC_RECYCLER then
            return AIDS___DecayingIndex[AIDS___DecayChecker]
        else
            return AIDS___UndefendExpiringIndex[AIDS___UndefendExpiringIndexLevel]
        endif
    endfunction
    
    //==============================================================================
    
    function AIDS_RegisterOnEnter takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnEnter,b)
    endfunction
    function AIDS_RegisterOnEnterAllocated takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnEnterAllocated,b)
    endfunction
    function AIDS_RegisterOnDeallocate takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS___OnDeallocate,b)
    endfunction
    
    //==============================================================================
    function GetIndexUnit takes integer index returns unit
        
        return AIDS___IndexUnit[index]
    endfunction
    
    function GetUnitId takes unit u returns integer
        
        return GetUnitUserData(u)
    endfunction
    
    function GetUnitIndex takes unit u returns integer // Cannot be recursive.
        
        set AIDS___getindex=GetUnitUserData(u)
        
        if AIDS___getindex==0 then
            // Get new index, from recycler first, else new.
            // Store the current index in getindex.
            if AIDS___MaxRecycledIndex==0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex+1
                set AIDS___getindex=AIDS___MaxIndex
            else // Get from recycle stack.
set AIDS___getindex=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex-1
            endif
            
            // Store index on unit.
            call SetUnitUserData(u,AIDS___getindex)
            set AIDS___IndexUnit[AIDS___getindex]=u
            
            static if AIDS___USE_PERIODIC_RECYCLER then
                
                // Add index to recycle list.
                set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex+1
                set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___getindex
                
            else
            
                // Add leave detection ability.
                call UnitAddAbility(AIDS___ARStackUnit[AIDS___ARStackLevel],AIDS___LEAVE_DETECTION_ABILITY)
                call UnitMakeAbilityPermanent(AIDS___ARStackUnit[AIDS___ARStackLevel],true,AIDS___LEAVE_DETECTION_ABILITY)
                
            endif
            
            // Do not fire things here. No AIDS structs will be made at this point.
        endif
        
        return AIDS___getindex
    endfunction
    
    //==============================================================================
    function AIDS_AddLock takes integer index returns nothing
        set AIDS___LockLevel[index]=AIDS___LockLevel[index]+1
    endfunction
    function AIDS_RemoveLock takes integer index returns nothing
        set AIDS___LockLevel[index]=AIDS___LockLevel[index]-1
        
        static if not AIDS___USE_PERIODIC_RECYCLER then
            if GetUnitUserData(AIDS___IndexUnit[index])==0 and AIDS___LockLevel[index]==0 then
                
                // Increment stack for recursion.
                set AIDS___UndefendExpiringIndexLevel=AIDS___UndefendExpiringIndexLevel+1
                set AIDS___UndefendExpiringIndex[AIDS___UndefendExpiringIndexLevel]=index
                
                // Fire things.
                call TriggerEvaluate(AIDS___OnDeallocate)
                
                // Decrement stack for recursion.
                set AIDS___UndefendExpiringIndexLevel=AIDS___UndefendExpiringIndexLevel-1
                
                // Add the index to the recycler stack.
                set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex+1
                set AIDS___RecycledIndex[AIDS___MaxRecycledIndex]=index
                
                // Null the unit.
                set AIDS___IndexUnit[index]=null
                
            endif
        endif
    endfunction
    
    //==============================================================================
    static if AIDS___USE_PERIODIC_RECYCLER then
        
        function AIDS___PeriodicRecycler takes nothing returns nothing
            if AIDS___MaxDecayingIndex>0 then
                set AIDS___DecayChecker=AIDS___DecayChecker+1
                if AIDS___DecayChecker>AIDS___MaxDecayingIndex then
                    set AIDS___DecayChecker=1
                endif
                if GetUnitUserData(AIDS___IndexUnit[AIDS___DecayingIndex[AIDS___DecayChecker]])==0 then
                if AIDS___LockLevel[AIDS___DecayingIndex[AIDS___DecayChecker]]==0 then
                    
                    // Fire things.
                    call TriggerEvaluate(AIDS___OnDeallocate)
                    
                    // Add the index to the recycler stack.
                    set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex+1
                    set AIDS___RecycledIndex[AIDS___MaxRecycledIndex]=AIDS___DecayingIndex[AIDS___DecayChecker]
                    
                    // Null the unit.
                    set AIDS___IndexUnit[AIDS___DecayingIndex[AIDS___DecayChecker]]=null
                    
                    // Remove index from decay list.
                    set AIDS___DecayingIndex[AIDS___DecayChecker]=AIDS___DecayingIndex[AIDS___MaxDecayingIndex]
                    set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex-1
                    
                endif
                endif
            endif
        endfunction
        
    else
        
        function AIDS___UndefendFilter takes nothing returns boolean
            return IsUnitType(GetFilterUnit(),UNIT_TYPE_DEAD)
        endfunction
        
        function AIDS___OnUndefendTimer takes nothing returns nothing
            loop
                exitwhen AIDS___UndefendStackIndex==0
                
                set AIDS___UndefendStackIndex=AIDS___UndefendStackIndex-1
                set AIDS___UndefendExpiringIndex[0]=AIDS___UndefendIndex[AIDS___UndefendStackIndex]
                
                if AIDS___IndexUnit[AIDS___UndefendExpiringIndex[0]]!=null then
                if GetUnitUserData(AIDS___IndexUnit[AIDS___UndefendExpiringIndex[0]])==0 then
                if AIDS___LockLevel[AIDS___UndefendExpiringIndex[0]]==0 then
                    
                    // Fire things.
                    call TriggerEvaluate(AIDS___OnDeallocate)
                    
                    // Add the index to the recycler stack.
                    set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex+1
                    set AIDS___RecycledIndex[AIDS___MaxRecycledIndex]=AIDS___UndefendExpiringIndex[0]
                    
                    // Null the unit.
                    set AIDS___IndexUnit[AIDS___UndefendExpiringIndex[0]]=null
                    
                endif
                endif
                endif
                
            endloop
        endfunction
        
        function AIDS___OnUndefend takes nothing returns boolean
            if GetIssuedOrderId()==852056 then // If undefend then...
set AIDS___UndefendFilterIndex=GetUnitUserData(GetOrderedUnit())
                
                if AIDS___UndefendIndex[AIDS___UndefendStackIndex-1]!=AIDS___UndefendFilterIndex then // Efficiency perk.
set AIDS___UndefendIndex[AIDS___UndefendStackIndex]=AIDS___UndefendFilterIndex
                    set AIDS___UndefendStackIndex=AIDS___UndefendStackIndex+1
                    
                    call TimerStart(AIDS___UndefendTimer,0,false,function AIDS___OnUndefendTimer)
                endif
            endif
            
            return false
        endfunction
        
    endif
    
    //==============================================================================
    function AIDS_IndexEnum takes nothing returns boolean // Can be recursive...
// Start by adding another level on the AR stack (for recursion's sake).
set AIDS___ARStackLevel=AIDS___ARStackLevel+1
        
        // Store the current unit on the (new) top level of the AR stack.
        set AIDS___ARStackUnit[AIDS___ARStackLevel]=GetFilterUnit()
        
        if GetUnitUserData(AIDS___ARStackUnit[AIDS___ARStackLevel])==0 then // Has not been indexed.

            if AIDS___UnitIndexingFilter(AIDS___ARStackUnit[AIDS___ARStackLevel]) then
                
                // Get new index, from recycler first, else new.
                // Store the current index on the (new) top level of the AR stack.
                if AIDS___MaxRecycledIndex==0 then // Get new.
set AIDS___MaxIndex=AIDS___MaxIndex+1
                    set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___MaxIndex
                else // Get from recycle stack.
set AIDS___ARStackIndex[AIDS___ARStackLevel]=AIDS___RecycledIndex[AIDS___MaxRecycledIndex]
                    set AIDS___MaxRecycledIndex=AIDS___MaxRecycledIndex-1
                endif
                
                // Store index on unit.
                call SetUnitUserData(AIDS___ARStackUnit[AIDS___ARStackLevel],AIDS___ARStackIndex[AIDS___ARStackLevel])
                set AIDS___IndexUnit[AIDS___ARStackIndex[AIDS___ARStackLevel]]=AIDS___ARStackUnit[AIDS___ARStackLevel]
                
                static if AIDS___USE_PERIODIC_RECYCLER then
                    
                    // Add index to recycle list.
                    set AIDS___MaxDecayingIndex=AIDS___MaxDecayingIndex+1
                    set AIDS___DecayingIndex[AIDS___MaxDecayingIndex]=AIDS___ARStackIndex[AIDS___ARStackLevel]
                    
                else
                    
                    // Add leave detection ability.
                    call UnitAddAbility(AIDS___ARStackUnit[AIDS___ARStackLevel],AIDS___LEAVE_DETECTION_ABILITY)
                    call UnitMakeAbilityPermanent(AIDS___ARStackUnit[AIDS___ARStackLevel],true,AIDS___LEAVE_DETECTION_ABILITY)
                    
                endif
                
                // Fire things.
                call TriggerEvaluate(AIDS___OnEnter)
                
            else
                
                // The unit did not pass the filters, so does not need to be auto indexed.
                // However, for certain AIDS structs, it may still require indexing.
                // These structs may index the unit on their creation.
                // We flag that an index must be assigned by setting the current index to 0.
                set AIDS___ARStackIndex[AIDS___ARStackLevel]=0
                
                // Fire things.
                call TriggerEvaluate(AIDS___OnEnter)
                
            endif
            
        endif
        
        // Decrement the stack.
        set AIDS___ARStackLevel=AIDS___ARStackLevel-1
        
        return false
    endfunction
    
    //==============================================================================
    function AIDS___InitAIDS takes nothing returns nothing
        local region r=CreateRegion()
        
        local group g=CreateGroup()
        local integer n=15
        
        static if AIDS___USE_PERIODIC_RECYCLER then
            
            call TimerStart(AIDS___UndefendTimer,AIDS___PERIOD,true,function AIDS___PeriodicRecycler)
            
        else
            
            local trigger t=CreateTrigger()
            
            loop
                call TriggerRegisterPlayerUnitEvent(t,Player(n),EVENT_PLAYER_UNIT_ISSUED_ORDER,Filter(function AIDS___UndefendFilter))
                call SetPlayerAbilityAvailable(Player(n),AIDS___LEAVE_DETECTION_ABILITY,false)
                // Capture "undefend" orders.
                exitwhen n==0
                set n=n-1
            endloop
            set n=15
            
            call TriggerAddCondition(t,Filter(function AIDS___OnUndefend))
            set t=null
            
        endif
        
        // This must be done first, due to recursion. :)
        call RegionAddRect(r,GetWorldBounds())
        call TriggerRegisterEnterRegion(CreateTrigger(),r,Filter(function AIDS_IndexEnum))
        set r=null
        
        loop
            call GroupEnumUnitsOfPlayer(g,Player(n),Filter(function AIDS_IndexEnum))
            //Enum every non-filtered unit on the map during initialization and assign it a unique
            //index. By using GroupEnumUnitsOfPlayer, even units with Locust can be detected.
            exitwhen n==0
            set n=n-1
        endloop
        call DestroyGroup(g)
        set g=null
    endfunction
    
    //==============================================================================
    struct AIDS_DEFAULT extends array
        method AIDS_onCreate takes nothing returns nothing
        endmethod
        method AIDS_onDestroy takes nothing returns nothing
        endmethod
        
        static method AIDS_filter takes unit u returns boolean
            return AIDS___UnitIndexingFilter(u)
        endmethod
        
        static method AIDS_onInit takes nothing returns nothing
        endmethod
    endstruct
    
    //===========================================================================
    //  Never create or destroy AIDS structs directly.
    //  Also, do not initialise members except by using the AIDS_onCreate method.
    //===========================================================================

//library AIDS ends
//library AIDriver:
function AIDriver___GetStrategy takes unit u returns IAIStrategy
local integer tid=GetUnitTypeId(u)
local IAIStrategy s=DefaultAIStrategy.findStrategy(tid)
if s==0 then
    return DefaultAIStrategy.getFirst()
endif
return s
endfunction
function TargetInRange takes unit u ,real r returns nothing
endfunction
function BeHurted takes unit u returns nothing
local IAIStrategy s=AIDriver___GetStrategy(u)
call s.beHurted(u)
endfunction
function GetInMap takes unit u returns nothing
local IAIStrategy s=AIDriver___GetStrategy(u)
call s.getInMap(u)
endfunction

//library AIDriver ends
//library AII:


    
    
    static if LIBRARY_UID then
    endif
    
    function AII___FireEvent takes trigger trig, integer dat returns nothing
        local integer old=AII___EventStruct
        set AII___EventStruct=dat
        call TriggerEvaluate(trig)
        set AII___EventStruct=old
        //Bye bye to stack. :)
    endfunction
    
    function AII___Hash takes widget w returns integer
        local integer int=GetHandleId(w)
        local integer hash=int-(int/AII___MAX_HASH_VALUE)*AII___MAX_HASH_VALUE
        loop
            exitwhen AII___HashedInt[hash]==int
            if AII___HashedInt[hash]==0 then
                set AII___HashedInt[hash]=int
                return hash
            endif
            set hash=hash+AII___HASH_NEXT
            if hash>=AII___MAX_HASH_VALUE then
                set hash=hash-AII___MAX_HASH_VALUE
            endif
        endloop
        return hash
    endfunction
    //Handy function from Jesus4Lyf
    
    function AII___RemoveHash takes integer int returns nothing
        local integer hash=int-(int/AII___MAX_HASH_VALUE)*AII___MAX_HASH_VALUE
        loop
            if AII___HashedInt[hash]==int then
                set AII___HashedInt[hash]=0
                return
            endif
            set hash=hash+AII___HASH_NEXT
            if hash>=AII___MAX_HASH_VALUE then
                set hash=hash-AII___MAX_HASH_VALUE
            endif
        endloop
        //To cleaned up unused values.
    endfunction
    
    struct AII___ItemStruct
        private static trigger trig=CreateTrigger()
        private static integer thrashCount=0
        item it
        private integer hid
        private integer lockLevel
        private thistype prevA //A=Active, B=Thrash
private thistype nextA
        
        private static method refreshEventTrigger takes nothing returns nothing
            //See if the thrash is trigger is necessary to clean or not.
            local thistype this
            set thistype.thrashCount=thistype.thrashCount+1
            if thistype.thrashCount>=AII___MAX_THRASH then
            //If the thrash is over the default number, refresh the trigger. 
                call DisableTrigger(this.trig)
                call TriggerClearConditions(this.trig)
                call DestroyTrigger(this.trig)
                set thistype.trig=CreateTrigger()
                call TriggerAddCondition(thistype.trig,Condition(function thistype.onDeath))
                //Reset the trigger.
                set this=thistype(0).nextA
                loop
                    exitwhen this==0
                    call TriggerRegisterDeathEvent(this.trig,this.it)
                    //Reregister back the event.
                    set this=this.nextA
                endloop
                set thistype.thrashCount=0
            endif
        endmethod
        
        private static method onDeath takes nothing returns boolean
            call thistype(GetItemUserData(AII___HashedItem[AII___Hash(GetTriggerWidget())])).manageLock(false) //Get the attached item.
//Item is removed.
return false
        endmethod
        
        private static thistype array toFireDeallocate
        private static integer tFDCount=0
        
        private method addToActive takes nothing returns nothing
            set thistype(0).nextA.prevA=this
            set this.nextA=thistype(0).nextA
            set thistype(0).nextA=this
            set this.prevA=thistype(0)
        endmethod
        
        private method removeFromActive takes nothing returns nothing
            set this.prevA.nextA=this.nextA
            set this.nextA.prevA=this.prevA
        endmethod
        
        method remove takes nothing returns nothing
            call AII___FireEvent(AII___dealloItem,this)
            call this.removeFromActive()
            call AII___RemoveHash(this.hid)
            call thistype.refreshEventTrigger()
            set this.it=null
            if AII___IsInited then
                call this.deallocate()
            else
                set tFDCount=tFDCount+1
                set toFireDeallocate[tFDCount]=this
            endif
        endmethod
        
        method manageLock takes boolean b returns nothing
            if b then
                set this.lockLevel=this.lockLevel+1
            else
                set this.lockLevel=this.lockLevel-1
                if this.lockLevel==0 then
                    call this.remove()
                endif
            endif
        endmethod
        
        static method load takes item i returns thistype
            local thistype this
            set this=GetItemUserData(i)
            if i==null then //If item is null, then no point to index it..
return 0
            endif
            if this==0 then //Okay, the item is not indexed.
set this=thistype.allocate()
                set this.it=i
                set this.hid=GetHandleId(this.it)
                call TriggerRegisterDeathEvent(thistype.trig,this.it) //Register item death event.
set AII___HashedItem[AII___Hash(this.it)]=this.it//Attach the item to itself.
                set this.lockLevel=1
                
                call SetItemUserData(i,this)
                call AII___FireEvent(AII___alloItem,this) //Fire event!

                call this.addToActive()
            endif
            return this
        endmethod
        
        static method refireAllocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local thistype this=thistype(0).nextA
            call TriggerAddCondition(trig,c)
            loop
                exitwhen this==0
                call AII___FireEvent(trig,this)
                set this=this.nextA
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endmethod
        
        static method refireDeallocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local integer count=tFDCount
            call TriggerAddCondition(trig,c)
            loop
            exitwhen count==0
                call AII___FireEvent(trig,toFireDeallocate[count])
                set count=count-1
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endmethod
        
        private static method flag takes nothing returns nothing
            //Indicates the game is initialized.
            local integer count=tFDCount
            loop
            exitwhen count==0
                call toFireDeallocate[count].deallocate()
                set count=count-1
            endloop
            set AII___IsInited=true
            call PauseTimer(GetExpiredTimer())
            call DestroyTimer(GetExpiredTimer())
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(thistype.trig,Condition(function thistype.onDeath))
            call TimerStart(CreateTimer(),0.0,false,function thistype.flag)
        endmethod
    endstruct
    function GetItemId takes item i returns integer
        return GetItemUserData(i)
    endfunction
    
    function GetItemById takes integer i returns item
        return AII___ItemStruct(i).it
    endfunction
    
    function CreateItemEx takes integer itemid, real x, real y returns item
        return AII___ItemStruct.load(CreateItem(itemid,x,y)).it
    endfunction
    
    module AII___AIIInit
        private static method onInit takes nothing returns nothing
            local group g=CreateGroup()
            local rect world=GetWorldBounds()
            
            call EnumItemsInRect(world,Condition(function thistype.indexPreplaced),null)
            call GroupEnumUnitsInRect(g,world,Condition(function thistype.indexItemOnUnit))
            call RemoveRect(world)
            call DestroyGroup(g)
            set g=null
            set world=null
        
            call TriggerRegisterAnyUnitEventBJ(AII___pickUpItem,EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII___sellItem,EVENT_PLAYER_UNIT_SELL_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII___pawnItem,EVENT_PLAYER_UNIT_PAWN_ITEM)
            
            call TriggerAddCondition(AII___pickUpItem,Condition(function thistype.onPickUp))
            call TriggerAddCondition(AII___sellItem,Condition(function thistype.onSell))
            call TriggerAddCondition(AII___pawnItem,Condition(function thistype.onPawn))
        endmethod
    endmodule
    
    struct AII___Initializer extends array
        private static method onPickUp takes nothing returns boolean
            call AII___ItemStruct.load(GetManipulatedItem())
            return false
        endmethod
        
        private static method onSell takes nothing returns boolean
            call AII___ItemStruct.load(GetSoldItem())
            return false
        endmethod
        
        private static method onPawn takes nothing returns boolean
            static if LIBRARY_UID then
                call AII___FireEvent(AII___dropItem,AII___ItemStruct.load(GetSoldItem()))
            endif
            call AII___ItemStruct.load(GetSoldItem()).manageLock(false)
            return false
        endmethod
        
        private static method indexPreplaced takes nothing returns boolean
            call AII___ItemStruct.load(GetFilterItem())
            return false
        endmethod
        
        private static method indexItemOnUnit takes nothing returns boolean
            local unit u=GetFilterUnit()
            local integer i = 0
            local integer maxSize = UnitInventorySize(u)
            local AII___ItemStruct it
            loop
            exitwhen i == maxSize
                call AII___ItemStruct.load(UnitItemInSlot(u,i))
                set i = i + 1
            endloop
            set u=null
            return false
        endmethod
    
        implement AII___AIIInit
    endstruct
    
    module AII
        readonly boolean flag
        method operator item takes nothing returns item
            return AII___ItemStruct(this).it
        endmethod
        method AII_addLock takes nothing returns nothing
            call AII___ItemStruct(this).manageLock(true)
        endmethod
        method AII_removeLock takes nothing returns nothing
            call AII___ItemStruct(this).manageLock(false) 
        endmethod
        static method operator [] takes item i returns thistype
            return GetItemId(i)
        endmethod
        
        private static method aiicreate takes nothing returns boolean
            local thistype this=AII___EventStruct
            static if thistype.AII_filter.exists then
                if thistype.AII_filter(this.item) then
                    static if thistype.AII_onCreate.exists then
                        call this.AII_onCreate()
                    endif
                    set this.flag=true
                endif
            else
                static if thistype.AII_onCreate.exists then
                    call this.AII_onCreate()
                endif
                set this.flag=true
            endif
            return false
        endmethod
        private static method aiidestroy takes nothing returns boolean
            local thistype this=AII___EventStruct
            if this.flag then
                static if thistype.AII_onDestroy.exists then
                    call this.AII_onDestroy()
                endif
                set this.flag=false
            endif
            return false
        endmethod
        
        static if thistype.AII_onDrop.exists then
            private static method aiidrophook takes nothing returns boolean
                if thistype(AII___EventStruct).flag then
                    call thistype(AII___EventStruct).AII_onDrop()
                endif
                return false
            endmethod
        endif
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(AII___alloItem,Condition(function thistype.aiicreate))
            call TriggerAddCondition(AII___dealloItem,Condition(function thistype.aiidestroy))
            static if thistype.AII_onDrop.exists then
                call TriggerAddCondition(AII___dropItem,Condition(function thistype.aiidrophook))
            endif
            if AII___IsInited==false then
                call AII___ItemStruct.refireAllocateCallback(Condition(function thistype.aiicreate))
                call AII___ItemStruct.refireDeallocateCallback(Condition(function thistype.aiidestroy))
            endif
        endmethod
    endmodule

//library AII ends
//library BufferFunction:
function ApplyBurn takes unit source, unit target, real dam, real time returns nothing
    local integer burnlv = Material[target].burnlv
    local BurnBuffer debuff
    if burnlv < MAX_BURN_LV then
        set debuff = BurnBuffer.create(target,R2I(time*50),source,dam/2)
        call debuff.start()
    endif
endfunction
function ApplyBleed takes unit source, unit target, real dam, real time returns nothing
    local integer bleedlv = Material[target].bleedlv
    local BleedBuffer debuff
    if bleedlv < MAX_BLEED_LV then
        set debuff = BleedBuffer.create(target,R2I(time*50),source,dam/2)
        call debuff.start()
    endif
endfunction
function ApplyIceSlow takes unit target, real time returns nothing
    call IceSlowBuffer.create(target,R2I(time*50)).start()
endfunction
function ApplyHorro takes unit target, unit source, real time returns nothing
    local boolean status = Material[target].horro
    local HorroBuffer debuff
    if not status then
        set debuff = HorroBuffer.create(target,source,R2I(time*50))
        call debuff.start()
    endif
endfunction

//library BufferFunction ends
//library Debuff:
function IceStar takes unit s, unit target returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call IssueTargetOrderById( dummy, 852226,target )
    set dummy = null
endfunction
function ElectricBlow takes unit s, unit target returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call IssueTargetOrderById( dummy, 852111,target )
    set dummy = null
endfunction
function Clap takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A01A', lv)
    call IssueImmediateOrderById( dummy, 852096 )
    set dummy = null
endfunction
function Stun takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A018', lv)
    call IssueTargetOrderById( dummy, 852095,target )
    set dummy = null
endfunction
function Frezz takes unit s, unit target, integer lv returns nothing
    local unit dummy
    set dummy = CreateUnit(GetOwningPlayer(s),MAGIC,GetUnitX(target),GetUnitY(target),0)
    call SetUnitAbilityLevel(dummy, 'A01C', lv)
    call IssueTargetOrderById( dummy, 852231,target )
    set dummy = null
endfunction

//library Debuff ends
//library Difficulty:
function SetDifficulty takes integer diff returns nothing 
    if diff==D_HARD or diff==D_CRAZY or diff==D_HELL then
        set Difficulty=diff
    endif
endfunction

//library Difficulty ends
//library Distance:
    function DistanceTwoUnits takes unit u,unit t returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real tx=GetUnitX(t)
        local real ty=GetUnitY(t)
        local real dis=SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
        return dis
    endfunction
    
    function DistanceUnitAndXY takes unit u, real x, real y returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real dis=SquareRoot(Pow(y-uy,2)+Pow(x-ux,2))
        return dis
    endfunction
    
    function DistanceTwo takes real ux,real uy, real tx, real ty returns real
        return SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
    endfunction

//library Distance ends
//library DummyCaster:
    // If you're looking for where the 'dumy' type is declared, it is declared
    // in the object merger line at the end of "How to implement?" in the above
    // documentation.
    
    struct DummyCaster___Initializer extends array // "extends array" removes
// create/destoy methods.
// The initialisation is done this way because struct initialisers are
// called before library initialisers, making this important for adding
// abilities on map initialisation.
private static method onInit takes nothing returns nothing
            set DUMMY=CreateUnit(DUMMY_OWNER,DUMMY_TYPE,DummyCaster___CREATED_AT_X,DummyCaster___CREATED_AT_Y,0)
        endmethod
    endstruct

//library DummyCaster ends
//library EffectString:
function CreateEffect takes string e, real x, real y returns nothing
    call DestroyEffect( AddSpecialEffect(e,x,y))
endfunction

//library EffectString ends
//library EffectZ:
//  _________________________________________
// +-----------------------------------------+
// |             E F F E C T   Z             |
// +-----------------------------------------+
// | - Feel free to take these out of this   |
// |   library and put them directly into    |
// |   your code.                            |
// | - I don't care about credit. I haven't  |
// |   even included my name here. :]        |
// +-----------------------------------------+
//  藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
    function AddSpecialEffectZ takes string modelName, real x, real y, real z returns effect
        set EffectZ___D = CreateDestructableZ( 'OTip', x, y, z, 0., 1., 0)
        set EffectZ___E = AddSpecialEffect(modelName, x, y)
        call RemoveDestructable(EffectZ___D)
        return EffectZ___E
    endfunction
    
    function AddSpecialEffectLocZ takes string modelName, location where, real z returns effect
        set EffectZ___D = CreateDestructableZ( 'OTip', GetLocationX(where), GetLocationY(where), z, 0., 1., 0)
        set EffectZ___E = AddSpecialEffectLoc(modelName, where)
        call RemoveDestructable(EffectZ___D)
        return EffectZ___E
    endfunction

//library EffectZ ends
//library Event:
    ///////////////
    // EventRegs //
    ////////////////////////////////////////////////////////////////////////////
    // For reading this far, you can learn one thing more.
    // Unlike normal Warcraft III events, you can attach to Event registries.
    // 
    // Event Registries are registrations of one trigger on one event.
    // These cannot be created or destroyed, just attached to.
    //
    // It is VERY efficient for loading and saving data.
    // 
    //  Functions:
    //         - set eventReg.data = someStruct --> Store data.
    //         - eventReg.data                  --> Retreive data.
    //         - Event.getTriggeringEventReg()  --> Get the triggering EventReg.
    //         - eventReg.destroy()             --> Undo this registration.
    // 
    struct EventReg extends array
        integer data
        method clear takes nothing returns nothing
            set this.data=0
        endmethod
        method destroy takes nothing returns nothing
            call Event(this).Event___destroyNode()
        endmethod
    endstruct
    
    module Event___Stack
        static thistype top=0
        static method increment takes nothing returns nothing
            set thistype.top=thistype(thistype.top+1)
        endmethod
        static method decrement takes nothing returns nothing
            set thistype.top=thistype(thistype.top-1)
        endmethod
    endmodule
    
    struct Event___EventStack extends array
        implement Event___Stack
        Event current
    endstruct
    
    struct Event
        private trigger trig
        private thistype next
        private thistype prev
        
        static method getTriggeringEventReg takes nothing returns EventReg
            return Event___EventStack.top.current
        endmethod
        
        static method create takes nothing returns Event
            local Event this=Event.allocate()
            set this.next=this
            set this.prev=this
            return this
        endmethod
        
        private static trigger currentTrigger
        method fire takes nothing returns nothing
            local thistype curr=this.next
            call Event___EventStack.increment()
            loop
                exitwhen curr==this
                set thistype.currentTrigger=curr.trig
                if IsTriggerEnabled(thistype.currentTrigger) then
                    set Event___EventStack.top.current=curr
                    if TriggerEvaluate(thistype.currentTrigger) then
                        call TriggerExecute(thistype.currentTrigger)
                    endif
                else
                    call EnableTrigger(thistype.currentTrigger) // Was trigger destroyed?
if IsTriggerEnabled(thistype.currentTrigger) then
                        call DisableTrigger(thistype.currentTrigger)
                    else // If trigger destroyed...
set curr.next.prev=curr.prev
                        set curr.prev.next=curr.next
                        call curr.deallocate()
                    endif
                endif
                set curr=curr.next
            endloop
            call Event___EventStack.decrement()
        endmethod
        method register takes trigger t returns EventReg
            local Event new=Event.allocate()
            set new.prev=this.prev
            set this.prev.next=new
            set this.prev=new
            set new.next=this
            
            set new.trig=t
            
            call EventReg(new).clear()
            return new
        endmethod
        method Event___destroyNode takes nothing returns nothing // called on EventReg
set this.prev.next=this.next
            set this.next.prev=this.prev
            call this.deallocate()
        endmethod
        method unregister takes trigger t returns nothing
            local thistype curr=this.next
            loop
                exitwhen curr==this
                if curr.trig==t then
                    set curr.next.prev=curr.prev
                    set curr.prev.next=curr.next
                    call curr.deallocate()
                    return
                endif
                set curr=curr.next
            endloop
        endmethod
        
        method destroy takes nothing returns nothing
            local thistype curr=this.next
            loop
                call curr.deallocate()
                exitwhen curr==this
                set curr=curr.next
            endloop
        endmethod
        method chainDestroy takes nothing returns nothing
            call this.destroy() // backwards compatability.
endmethod
    endstruct
    
    /////////////////////////////////////////////////////
    // Demonstration Functions & Alternative Interface //
    ////////////////////////////////////////////////////////////////////////////
    // What this would look like in normal WC3 style JASS (should all inline).
    // 
    function CreateEvent takes nothing returns Event
        return Event.create()
    endfunction
    function DestroyEvent takes Event whichEvent returns nothing
        call whichEvent.chainDestroy()
    endfunction
    function FireEvent takes Event whichEvent returns nothing
        call whichEvent.fire()
    endfunction
    function TriggerRegisterEvent takes trigger whichTrigger, Event whichEvent returns EventReg
        return whichEvent.register(whichTrigger)
    endfunction
    
    // And for EventRegs...
    function SetEventRegData takes EventReg whichEventReg, integer data returns nothing
        set whichEventReg.data=data
    endfunction
    function GetEventRegData takes EventReg whichEventReg returns integer
        return whichEventReg.data
    endfunction
    function GetTriggeringEventReg takes nothing returns integer
        return Event.getTriggeringEventReg()
    endfunction

//library Event ends
//library FloatText:
function DisplayFloatText takes real x, real y, string msg, real life returns nothing
    local location p = Location(x, y)
    call CreateTextTagLocBJ( msg, p, 100, 10, 100, 100, 100, 0 )
    call SetTextTagPermanent( GetLastCreatedTextTag(), false )
    call SetTextTagLifespan( GetLastCreatedTextTag(), life )
    set p = null
endfunction

//library FloatText ends
//library HashKeyManager:
function GetNewKey takes nothing returns integer
    set currentKey=currentKey+1
    return currentKey
endfunction

//library HashKeyManager ends
//library HashTable:
function InitHashTable takes nothing returns nothing
    call FlushParentHashtable( ht )
    set ht = InitHashtable() 
endfunction

//library HashTable ends
//library Height:
    function getTerrianHeight takes real x, real y returns real
        local location l = Location(x, y)
        local real h = GetLocationZ(l)
        call RemoveLocation(l)
        set l = null
        return h
    endfunction
    
    function getUnitHeight takes unit u returns real
        local real x = GetUnitX(u)
        local real y = GetUnitY(u)
        local real f = GetUnitFlyHeight(u)
        local real h = getTerrianHeight(x, y)
        return f + h
    endfunction

//library Height ends
//library HeroData:
//textmacro instance: CreateArrayList("TechRecord")
struct TechRecord
    integer size
    integer array itms[DEFAULT_ARRAYLIST_SIZE]
    
    static method create takes nothing returns TechRecord
        local TechRecord m=TechRecord.allocate()
        set m.size = 0
        return m
    endmethod
    
    method addItem takes integer itm returns nothing
        set itms[size] = itm
        set size = size + 1
    endmethod
endstruct
//end of: CreateArrayList("TechRecord")
struct TechCounter
    integer array cnt[TT_COUNT]
    integer size
endstruct
struct IHeroData
    real shoot_energy_max
    real shoot_energy_reg
    real shoot_energy
    unit shoot_target
    real shoot_range_buff
    //real shoot_speed_buff
    real shoot_rist
    real a_shoot_back
    real a_shoot_back_log
    //integer last_shoot_tick
    boolean reload
    real kill_mana_percent
    real mana_boom_percent
    TechRecord tech_record
    TechCounter tech_counter
    integer up_point
    integer bonus_point
    integer bullets
    real shoot_split
    real save
    real beforesave
    real strong
    real antrad
    real doge
    real frezz
    real fire_charge
    real machine_gun_buff
    real jump_direction
    unit abi_lock
    real vision
    integer array equips[20]
endstruct

//library HeroData ends
//library HeroStatus:
function HeroStatusCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local integer s = GetLearnedSkillBJ()
    if s == sALL then
        call SetHeroStr( u, ( GetHeroStr(u, false) + 1 ), true )
        call SetHeroAgi( u, ( GetHeroAgi(u, false) + 1 ), true )
        call SetHeroInt( u, ( GetHeroInt(u, false) + 1 ), true )
    elseif s == sSTR then
        call SetHeroStr( u, ( GetHeroStr(u, false) + 2 ), true )
    elseif s == sAGI then
        call SetHeroAgi( u, ( GetHeroAgi(u, false) + 2 ), true )
    elseif s == sINT then
        call SetHeroInt( u, ( GetHeroInt(u, false) + 2 ), true )
    endif
    set u = null
endfunction
function InitHeroStatus takes nothing returns nothing
local trigger herostatus_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( herostatus_t, EVENT_PLAYER_HERO_SKILL )
call TriggerAddCondition(herostatus_t,function HeroStatusCondition)
set herostatus_t=null
endfunction

//library HeroStatus ends
//library Level1:
function startLevel takes nothing returns nothing
endfunction
function endLevel takes nothing returns nothing
endfunction
function InitLevel1 takes nothing returns nothing
endfunction

//library Level1 ends
//library ListModule:
//===========================================================================
// Information: 
//==============
//
//     This module allows you to create a linked list containing all of the allocated
// instances of a struct. Iterating through a linked list is slightly faster than the
// typical method of looping through an array containing all of the instances. However,
// getting a random struct from a list is an O(n) operation instead of O(1) as with
// SetModule. This should be a good trade as most systems don't need random access.
//
//     There is no speed loss while iterating through structs compared to doing
// it yourself, since all of method calls used while iterating get inlined. The best
// use for this module is to hide a lot of ugly low-level code from your systems.
//
// How to use List:
//==================
//
//     Implement the List module in your struct. Your struct will gain all of the
// following methods:
//
// (static) getLength: Returns an integer indicating the number of structs in the list.
//
// (static) getRandom: Returns a random struct from the list. Note that this is rather
//                     slow due to the fact that this is a linked list implementation.
//
// (static) getFirst: Returns the first struct in the list.
//
// (static) getLast: Returns the last struct in the list.
//
// getNext: Returns the next struct in the list.
//
// getPrev: Returns the previous struct in the list.
//
// inList: Returns a boolean indicating whether this struct is in the list.
//
// addList: Adds this struct to the list. Returns false if adding failed because the
//          list is being destroyed or the struct was already in the list.
//
// removeList: Removes this struct from the list. Returns false if removal failed 
//             because the struct was not in the list.
//
// (static) destroyList: Destroys all of the structs in the list.
//
// Example of List usage:
//========================
//
// struct YourStruct
//     implement List
//
//     static method create takes nothing returns YourStruct
//         local YourStruct ys = .allocate()
//             call ys.addList()
//         return ys
//     endmethod
//
//     method onDestroy takes nothing returns nothing
//         call .removeList()
//     endmethod
//
//     static method GetRandomStruct takes nothing returns YourStruct
//         return .getRandom() //That was easy... but slow.
//     endmethod
//
//     static method LoopThroughAllYourStructs takes nothing returns nothing
//         local YourStruct ys = .getFirst() //This is inlined to a variable read.
//             loop
//                 exitwhen ys == 0
//                 //Do something with the YourStruct instance here.
//                 set ys = ys.getNext() //This is inlined to an array read.
//             endloop
//     endmethod
// endstruct
//
//===========================================================================
    module List
    
        private static boolean destroyinglist = false
        private static thistype length = 0
        private static thistype first = 0
        private static thistype last = 0
    
        private thistype prev = 0
        private thistype next = 0
        private boolean inlist = false
    
        static method getLength takes nothing returns integer
            return .length
        endmethod
    
        static method getFirst takes nothing returns thistype
            return .first
        endmethod
    
        static method getLast takes nothing returns thistype
            return .last
        endmethod
    
        static method getRandom takes nothing returns thistype
            local thistype s = .first
            local thistype array list
            local integer n = -1
            loop
                exitwhen s == 0
                set n = n + 1
                set list[n] = s
                set s = s.next
            endloop
            if n == -1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endmethod
    
        method getNext takes nothing returns thistype
            return .next
        endmethod
    
        method getPrev takes nothing returns thistype
            return .prev
        endmethod
    
        method inList takes nothing returns boolean
            return .inlist
        endmethod
        method addList takes nothing returns boolean
            if not .inlist and not .destroyinglist then
                set .inlist = true
                if .first == 0 then
                    set .first = this
                else
                    set .prev = .last
                    set .prev.next = this
                endif
                set .last = this
                set .length = .length + 1
                return true
            endif
            return false
        endmethod
    
        method removeList takes nothing returns boolean
            if .inlist then
                if .destroyinglist then
                    return true
                endif
                set .inlist = false
                if .first == this then
                    set .first = .next
                endif
                if .last == this then
                    set .last = .prev
                endif
                set .prev.next = .next
                set .next.prev = .prev
                set .length = .length - 1
                return true
            endif
            return false
        endmethod
    
        static method destroyList takes nothing returns nothing
            local thistype s = .first
            if not .destroyinglist then
                loop
                    exitwhen s == 0
                    set .destroyinglist = false
                    call s.removeList()
                    set .destroyinglist = true
                    call s.destroy()
                    set s = s.next
                endloop
                set .destroyinglist = false
            endif
        endmethod
    
    endmodule

//library ListModule ends
//library Lock:
function EnableAllAbi takes unit u returns nothing
    local integer i = 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable( Player(0), i, true)
        set i = i + 1
    endloop
endfunction
function DisableAllAbi takes unit u returns nothing
    local integer i = 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable( Player(0), i, false)
        set i = i + 1
    endloop
endfunction
function EnableAbiLock takes integer i returns nothing
    set EquipmentData[heros[i]].heroData.abi_lock = CreateUnit(Player(i), ABI_LOCK, GetRectCenterX(gg_rct_lock[i]), GetRectCenterY(gg_rct_lock[i]), 0)
endfunction
function DisableAbiLock takes integer i returns nothing
    call RemoveUnit(EquipmentData[heros[i]].heroData.abi_lock)
endfunction

//library Lock ends
//library Material:
struct Material extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    
    string clazz //bullet unit energy
real hardness
    real bounce
    real volume
    real weight
    real airk
    string fakelv
    string ground_action
    integer burnlv
    integer bleedlv
    boolean horro
    real horro_dmg
    real anti_horro
    real kill_hp
    integer shot_tick
    integer shot_fast_buff
    real last_shoot
    
    static method AIDS_filter takes unit u returns boolean
        return true
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        local integer ut = GetUnitTypeId(.unit)
        set this.burnlv = 0
        set this.bleedlv = 0
        set this.horro = false
        set this.horro_dmg = HORRO_DMG
        set this.anti_horro = 0
        set this.clazz = MC_UNIT
        set this.hardness = 10
        set this.bounce = 0.2
        set this.volume = 100
        set this.weight = 100
        set this.airk = 0.75
        set this.fakelv = LV_FREEZ
        set this.shot_tick = 0
        set this.shot_fast_buff = 0
        set this.last_shoot = 0
        if ut == ONE_WALL or ut == ONE_WALL_BREAKABLE then
            set this.clazz = MC_WALL
        elseif ut == 'ncop' or ut == 'ncp2' or ut == 'ncp3' then
            set this.clazz = MC_RING
        elseif ut == HERO then
            set this.clazz = MC_UNIT
            set this.hardness = 10
            set this.bounce = 0.2
            set this.volume = 150
            set this.weight = 100
            set this.airk = 0.75
            set this.fakelv = LV_ACTIVE
            set this.ground_action = GROUND_BOUNCE
            set this.horro_dmg = 0.01
            set this.anti_horro = 0
            set this.kill_hp = 0
//textmacro instance: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e000' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e001' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e002' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
elseif ut == 'e003' then
    set this.clazz = MC_ARROW
    set this.hardness = 100
    set this.bounce = 1
    set this.volume = 75
    set this.weight = 2
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_SMOOTH
    
//end of: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
//textmacro instance: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e004' then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e009' then
    set this.clazz = MC_STONE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 5
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00A' then
    set this.clazz = MC_STONE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 5
    set this.airk = 0.005
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
elseif ut == 'e00B' then
    set this.clazz = MC_MINE
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 200
    set this.weight = 30
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_STICK
    
//end of: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
//textmacro instance: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bICE_MISSLE then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bFIRE_MISSLE then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == MAGIC then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == DUMMY_TYPE then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bELECTRIC then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == TECH_UNIT then
    set this.clazz = MC_EFFECT
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00E' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 150
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00F' then
    set this.clazz = MC_BULLET
    set this.hardness = 100
    set this.bounce = 0.5
    set this.volume = 50
    set this.weight = 0.01
    set this.airk = 0
    set this.fakelv = LV_DESTORY
    set this.ground_action = GROUND_DESTROY
    
//end of: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
        endif
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
    endmethod
       
    
endstruct

//library Material ends
//library MissleFactory:
interface IMissleFactory
    method createMissle takes unit owner returns IMissle
endinterface
struct SmartDartsFactory extends IMissleFactory
    unit t
    static method create takes unit target returns thistype
        local thistype s = thistype.allocate()
        set s.t = target
        return s
    endmethod
    method createMissle takes unit owner returns IMissle
        local IMissle m = SmartDarts.create(owner, t)
        return m
    endmethod
endstruct
//textmacro instance: MissleFactory("DefaultMissleFactory","Missle")
struct DefaultMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=Missle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("DefaultMissleFactory","Missle")
//textmacro instance: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
struct ShootGunMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ShootGunMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
//textmacro instance: MissleFactory("SmallDartsFactory","SmallDarts")
struct SmallDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=SmallDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("SmallDartsFactory","SmallDarts")
//textmacro instance: MissleFactory("ReturnDartsFactory","ReturnDarts")
struct ReturnDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ReturnDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ReturnDartsFactory","ReturnDarts")
//textmacro instance: MissleFactory("LeaveDartsFactory","LeaveDarts")
struct LeaveDartsFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=LeaveDarts.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("LeaveDartsFactory","LeaveDarts")
//textmacro instance: MissleFactory("IceMissleFactory","IceMissle")
struct IceMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=IceMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("IceMissleFactory","IceMissle")
//textmacro instance: MissleFactory("FireMissleFactory","FireMissle")
struct FireMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=FireMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("FireMissleFactory","FireMissle")
//textmacro instance: MissleFactory("ElectricWhipFactory","ElectricWhip")
struct ElectricWhipFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ElectricWhip.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ElectricWhipFactory","ElectricWhip")
//textmacro instance: MissleFactory("BackGrenadeFactory","BackGrenade")
struct BackGrenadeFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=BackGrenade.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("BackGrenadeFactory","BackGrenade")
//textmacro instance: MissleFactory("PushGrenadeFactory","PushGrenade")
struct PushGrenadeFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=PushGrenade.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("PushGrenadeFactory","PushGrenade")
//textmacro instance: MissleFactory("MineFactory","Mine")
struct MineFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=Mine.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("MineFactory","Mine")
//textmacro instance: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
struct ShoulderCannonFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=ShoulderCannonMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
//textmacro instance: MissleFactory("SpearMissleFactory","SpearMissle")
struct SpearMissleFactory extends IMissleFactory
    method createMissle takes unit owner returns IMissle
        local IMissle m=SpearMissle.create(owner)
        return m
    endmethod
endstruct
//end of: MissleFactory("SpearMissleFactory","SpearMissle")

//library MissleFactory ends
//library MonsterDead:
function InitMonsterDead takes nothing returns nothing
set gtrgMonsterDead=CreateTrigger()
call TriggerRegisterPlayerUnitEventSimple( gtrgMonsterDead, Player(11), EVENT_PLAYER_UNIT_DEATH )
endfunction

//library MonsterDead ends
//library MonsterTypeData:
function InitMonsterTypeData takes nothing returns nothing
call DefaultTypeData.create()
endfunction
interface IMonsterTypeData 
method getDeadGold takes nothing returns integer
method getDeadWood takes nothing returns integer
method getTypeId takes nothing returns integer
endinterface
struct DefaultTypeData extends IMonsterTypeData
implement List
static method create takes nothing returns DefaultTypeData
local DefaultTypeData s=DefaultTypeData.allocate()
call s.addList()
return s
endmethod
method onDestroy takes nothing returns nothing
call removeList()
endmethod
method getTypeId takes nothing returns integer
return 123
endmethod
method getDeadGold takes nothing returns integer
return 2
endmethod
method getDeadWood takes nothing returns integer
return 0
endmethod
static method findTypeData takes integer typeid returns IMonsterTypeData
local DefaultTypeData p=getFirst()
loop
    exitwhen p==0
    if p.getTypeId()==typeid then
        return p
    endif
    set p=p.getNext()
endloop
return getFirst()
endmethod
endstruct

//library MonsterTypeData ends
//library Movie:
function MovieSay takes integer id, string msg returns nothing
    call TransmissionFromUnitWithNameBJ( GetPlayersAll(), heros[id], GetPlayerName(Player(id)), null, msg, bj_TIMETYPE_ADD, 1, true )
endfunction
function MovieStart takes nothing returns nothing
    call CinematicModeExBJ( true, GetPlayersAll(), 0.2 )
endfunction
function MovieEnd takes nothing returns nothing
    call CinematicModeExBJ( false, GetPlayersAll(), 0.2 )
endfunction
function Seen takes rect r returns nothing
    local integer i = 0
    loop
        exitwhen i >= PLAYER_COUNT
        if heros[i] != null then
            call CreateFogModifierRectBJ( true, Player(i), FOG_OF_WAR_VISIBLE, r)
        endif
    endloop
endfunction
function LockAgain takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= 3
        if heros[i] != null then
            call SetCameraTargetControllerNoZForPlayer( Player(i), heros[i], 0, 0, false )
        endif
        set i = i + 1
    endloop
endfunction
function StopShake takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= 3
        call CameraClearNoiseForPlayer( Player(i) )
        set i = i + 1
    endloop
endfunction
function StartShake takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i >= 3
        call CameraSetEQNoiseForPlayer( Player(i), 3 )
        if heros[i] != null then
            call IssueImmediateOrderById(heros[i], OI_STOP)
        endif
        set i = i + 1
    endloop
endfunction
function MoveCamera takes real x, real y returns nothing
    call PanCameraToTimed( x,y, 0.50 )
endfunction

//library Movie ends
//library OrderId:

//library OrderId ends
//library RegisterSpell:
function InitRegisterSpell takes nothing returns nothing
    set kRegistedSpell=GetNewKey()
endfunction
function RegisterSpell takes unit u returns nothing
local boolean registed=LoadBoolean(ht,GetHandleId(u),kRegistedSpell)
if registed==false then
//textmacro instance: RegisterSpell("'A002'")
call UnitAddAbility(u,'A002')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A002', false )
//end of: RegisterSpell("'A002'")
//textmacro instance: RegisterSpell("'A003'")
call UnitAddAbility(u,'A003')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A003', false )
//end of: RegisterSpell("'A003'")
//textmacro instance: RegisterSpell("'A004'")
call UnitAddAbility(u,'A004')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A004', false )
//end of: RegisterSpell("'A004'")
//textmacro instance: RegisterSpell("'A005'")
call UnitAddAbility(u,'A005')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A005', false )
//end of: RegisterSpell("'A005'")
//textmacro instance: RegisterSpell("'A006'")
call UnitAddAbility(u,'A006')
call SetPlayerAbilityAvailable( GetOwningPlayer(u), 'A006', false )
//end of: RegisterSpell("'A006'")
call SaveBoolean(ht,GetHandleId(u),kRegistedSpell,true)
endif
endfunction

//library RegisterSpell ends
//library ShootBack:
function ShootBackCondition takes nothing returns boolean
    local unit tu = GetTriggerUnit()
    if GetIssuedOrderIdBJ() == String2OrderIdBJ("unimmolation") and GetUnitTypeId(tu) == HERO then
        set EquipmentData[tu].heroData.a_shoot_back = EquipmentData[tu].heroData.a_shoot_back - EquipmentData[tu].heroData.a_shoot_back_log
        set EquipmentData[tu].heroData.a_shoot_back_log = 0.0
    endif
    set tu = null
    return false
endfunction
function ShootBackInitializer takes nothing returns nothing
    set shoot_back_trg = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( shoot_back_trg, EVENT_PLAYER_UNIT_ISSUED_ORDER )
    call TriggerAddCondition(shoot_back_trg, Condition(function ShootBackCondition))
endfunction

//library ShootBack ends
//library ShootSpeed:
    function IncShootSpeed takes integer pid returns nothing
        call IncUnitAbilityLevel(heros[pid],SHOOT_SPEED)
    endfunction

//library ShootSpeed ends
//library SkillLearn:
function InitSpellBook takes nothing returns nothing
    local integer ut = GetUnitTypeId(GetTriggerUnit())
    if ut == HERO then
    call BJDebugMsg("init spell book")
    endif
endfunction
function GetSkillId takes integer it returns integer
    return -1
endfunction
function LearnSkill takes nothing returns nothing
    local integer it = GetItemTypeId(GetManipulatedItem())
    local integer skill = GetSkillId(it)
    if skill != -1 then
    endif
endfunction
function InitSkillLearn takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
local region rectRegion = CreateRegion()
call RegionAddRect(rectRegion, GetPlayableMapRect())
call TriggerRegisterEnterRegion(t, rectRegion, null)
call TriggerAddCondition(t,function InitSpellBook)
call TriggerRegisterAnyUnitEventBJ( t2, EVENT_PLAYER_UNIT_USE_ITEM )
call TriggerAddCondition(t2,function LearnSkill)
set t=null
set t2=null
set rectRegion = null
endfunction

//library SkillLearn ends
//library T32:
    
    //==============================================================================
    // The standard T32 module, T32x.
    //
    module T32x
        private thistype next
        private thistype prev
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                call this.periodic()
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            set thistype(0).next.prev=this
            set this.next=thistype(0).next
            set thistype(0).next=this
            set this.prev=thistype(0)
        endmethod
        
        method stopPeriodic takes nothing returns nothing
            // This is some real magic.
            set this.prev.next=this.next
            set this.next.prev=this.prev
            // This will even work for the starting element.
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32___Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // The standard T32 module with added safety checks on .startPeriodic() and
    // .stopPeriodic(), T32xs.
    //
    module T32xs
        private thistype next
        private thistype prev
        private boolean runningPeriodic
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                call this.periodic()
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            if not this.runningPeriodic then
                set thistype(0).next.prev=this
                set this.next=thistype(0).next
                set thistype(0).next=this
                set this.prev=thistype(0)
                
                set this.runningPeriodic=true
            endif
        endmethod
        
        method stopPeriodic takes nothing returns nothing
            if this.runningPeriodic then
                // This is some real magic.
                set this.prev.next=this.next
                set this.next.prev=this.prev
                // This will even work for the starting element.
                
                set this.runningPeriodic=false
            endif
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32___Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // The original T32 module, for backwards compatability only.
    //
    module T32 // deprecated.
private thistype next
        private thistype prev
        
        private static method PeriodicLoop takes nothing returns boolean
            local thistype this=thistype(0).next
            loop
                exitwhen this==0
                if this.periodic() then
                    // This is some real magic.
                    set this.prev.next=this.next
                    set this.next.prev=this.prev
                    // This will even work for the starting element.
                endif
                set this=this.next
            endloop
            return false
        endmethod
        method startPeriodic takes nothing returns nothing
            set thistype(0).next.prev=this
            set this.next=thistype(0).next
            set thistype(0).next=this
            set this.prev=thistype(0)
        endmethod
        
        private static method onInit takes nothing returns nothing
            call TriggerAddCondition(T32___Trig,Condition(function thistype.PeriodicLoop))
        endmethod
    endmodule
    
    //==============================================================================
    // System Core.
    //
    function T32___OnExpire takes nothing returns nothing
        set Tick=Tick+1
        call TriggerEvaluate(T32___Trig)
    endfunction
    
    function T32___OnInit takes nothing returns nothing
        call TimerStart(CreateTimer(),T32_PERIOD,true,function T32___OnExpire)
    endfunction

//library T32 ends
//library Table:

    
    
//textmacro instance: NEW_TABLE("Real", "Real", "real", "true")
struct Table___reals extends array
    static if (true) then
        method operator [] takes integer key returns real
            return LoadReal(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, real value returns nothing
        call SaveReal(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedReal(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedReal(Table___ht, this, key)
    endmethod
endstruct
module Table___realm
    method operator real takes nothing returns Table___reals
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Real", "Real", "real", "true")
//textmacro instance: NEW_TABLE("Boolean", "Boolean", "boolean", "true")
struct Table___booleans extends array
    static if (true) then
        method operator [] takes integer key returns boolean
            return LoadBoolean(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, boolean value returns nothing
        call SaveBoolean(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedBoolean(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedBoolean(Table___ht, this, key)
    endmethod
endstruct
module Table___booleanm
    method operator boolean takes nothing returns Table___booleans
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Boolean", "Boolean", "boolean", "true")
//textmacro instance: NEW_TABLE("String", "Str", "string", "true")
struct Table___strings extends array
    static if (true) then
        method operator [] takes integer key returns string
            return LoadStr(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, string value returns nothing
        call SaveStr(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedString(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedString(Table___ht, this, key)
    endmethod
endstruct
module Table___stringm
    method operator string takes nothing returns Table___strings
        return this
    endmethod
endmodule
//end of: NEW_TABLE("String", "Str", "string", "true")
//textmacro instance: NEW_TABLE("Handle", "PlayerHandle", "player", "true")
struct Table___players extends array
    static if (true) then
        method operator [] takes integer key returns player
            return LoadPlayerHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, player value returns nothing
        call SavePlayerHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___playerm
    method operator player takes nothing returns Table___players
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "PlayerHandle", "player", "true")
//textmacro instance: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")
struct Table___widgets extends array
    static if (true) then
        method operator [] takes integer key returns widget
            return LoadWidgetHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, widget value returns nothing
        call SaveWidgetHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___widgetm
    method operator widget takes nothing returns Table___widgets
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")
//textmacro instance: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")
struct Table___destructables extends array
    static if (true) then
        method operator [] takes integer key returns destructable
            return LoadDestructableHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, destructable value returns nothing
        call SaveDestructableHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___destructablem
    method operator destructable takes nothing returns Table___destructables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemHandle", "item", "true")
struct Table___items extends array
    static if (true) then
        method operator [] takes integer key returns item
            return LoadItemHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, item value returns nothing
        call SaveItemHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___itemm
    method operator item takes nothing returns Table___items
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ItemHandle", "item", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitHandle", "unit", "true")
struct Table___units extends array
    static if (true) then
        method operator [] takes integer key returns unit
            return LoadUnitHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, unit value returns nothing
        call SaveUnitHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___unitm
    method operator unit takes nothing returns Table___units
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UnitHandle", "unit", "true")
//textmacro instance: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")
struct Table___abilitys extends array
    static if (true) then
        method operator [] takes integer key returns ability
            return LoadAbilityHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, ability value returns nothing
        call SaveAbilityHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___abilitym
    method operator ability takes nothing returns Table___abilitys
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerHandle", "timer", "true")
struct Table___timers extends array
    static if (true) then
        method operator [] takes integer key returns timer
            return LoadTimerHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, timer value returns nothing
        call SaveTimerHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___timerm
    method operator timer takes nothing returns Table___timers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TimerHandle", "timer", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")
struct Table___triggers extends array
    static if (true) then
        method operator [] takes integer key returns trigger
            return LoadTriggerHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, trigger value returns nothing
        call SaveTriggerHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___triggerm
    method operator trigger takes nothing returns Table___triggers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")
struct Table___triggerconditions extends array
    static if (true) then
        method operator [] takes integer key returns triggercondition
            return LoadTriggerConditionHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___triggerconditionm
    method operator triggercondition takes nothing returns Table___triggerconditions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")
struct Table___triggeractions extends array
    static if (true) then
        method operator [] takes integer key returns triggeraction
            return LoadTriggerActionHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, triggeraction value returns nothing
        call SaveTriggerActionHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___triggeractionm
    method operator triggeraction takes nothing returns Table___triggeractions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")
struct Table___events extends array
    static if (true) then
        method operator [] takes integer key returns event
            return LoadTriggerEventHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, event value returns nothing
        call SaveTriggerEventHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___eventm
    method operator event takes nothing returns Table___events
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")
//textmacro instance: NEW_TABLE("Handle", "ForceHandle", "force", "true")
struct Table___forces extends array
    static if (true) then
        method operator [] takes integer key returns force
            return LoadForceHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, force value returns nothing
        call SaveForceHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___forcem
    method operator force takes nothing returns Table___forces
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ForceHandle", "force", "true")
//textmacro instance: NEW_TABLE("Handle", "GroupHandle", "group", "true")
struct Table___groups extends array
    static if (true) then
        method operator [] takes integer key returns group
            return LoadGroupHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, group value returns nothing
        call SaveGroupHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___groupm
    method operator group takes nothing returns Table___groups
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "GroupHandle", "group", "true")
//textmacro instance: NEW_TABLE("Handle", "LocationHandle", "location", "true")
struct Table___locations extends array
    static if (true) then
        method operator [] takes integer key returns location
            return LoadLocationHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, location value returns nothing
        call SaveLocationHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___locationm
    method operator location takes nothing returns Table___locations
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LocationHandle", "location", "true")
//textmacro instance: NEW_TABLE("Handle", "RectHandle", "rect", "true")
struct Table___rects extends array
    static if (true) then
        method operator [] takes integer key returns rect
            return LoadRectHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, rect value returns nothing
        call SaveRectHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___rectm
    method operator rect takes nothing returns Table___rects
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "RectHandle", "rect", "true")
//textmacro instance: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")
struct Table___boolexprs extends array
    static if (true) then
        method operator [] takes integer key returns boolexpr
            return LoadBooleanExprHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, boolexpr value returns nothing
        call SaveBooleanExprHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___boolexprm
    method operator boolexpr takes nothing returns Table___boolexprs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")
//textmacro instance: NEW_TABLE("Handle", "SoundHandle", "sound", "true")
struct Table___sounds extends array
    static if (true) then
        method operator [] takes integer key returns sound
            return LoadSoundHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, sound value returns nothing
        call SaveSoundHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___soundm
    method operator sound takes nothing returns Table___sounds
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "SoundHandle", "sound", "true")
//textmacro instance: NEW_TABLE("Handle", "EffectHandle", "effect", "true")
struct Table___effects extends array
    static if (true) then
        method operator [] takes integer key returns effect
            return LoadEffectHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, effect value returns nothing
        call SaveEffectHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___effectm
    method operator effect takes nothing returns Table___effects
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "EffectHandle", "effect", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")
struct Table___unitpools extends array
    static if (true) then
        method operator [] takes integer key returns unitpool
            return LoadUnitPoolHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, unitpool value returns nothing
        call SaveUnitPoolHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___unitpoolm
    method operator unitpool takes nothing returns Table___unitpools
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")
struct Table___itempools extends array
    static if (true) then
        method operator [] takes integer key returns itempool
            return LoadItemPoolHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, itempool value returns nothing
        call SaveItemPoolHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___itempoolm
    method operator itempool takes nothing returns Table___itempools
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestHandle", "quest", "true")
struct Table___quests extends array
    static if (true) then
        method operator [] takes integer key returns quest
            return LoadQuestHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, quest value returns nothing
        call SaveQuestHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___questm
    method operator quest takes nothing returns Table___quests
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "QuestHandle", "quest", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")
struct Table___questitems extends array
    static if (true) then
        method operator [] takes integer key returns questitem
            return LoadQuestItemHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, questitem value returns nothing
        call SaveQuestItemHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___questitemm
    method operator questitem takes nothing returns Table___questitems
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")
//textmacro instance: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")
struct Table___defeatconditions extends array
    static if (true) then
        method operator [] takes integer key returns defeatcondition
            return LoadDefeatConditionHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___defeatconditionm
    method operator defeatcondition takes nothing returns Table___defeatconditions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")
struct Table___timerdialogs extends array
    static if (true) then
        method operator [] takes integer key returns timerdialog
            return LoadTimerDialogHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, timerdialog value returns nothing
        call SaveTimerDialogHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___timerdialogm
    method operator timerdialog takes nothing returns Table___timerdialogs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")
//textmacro instance: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")
struct Table___leaderboards extends array
    static if (true) then
        method operator [] takes integer key returns leaderboard
            return LoadLeaderboardHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, leaderboard value returns nothing
        call SaveLeaderboardHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___leaderboardm
    method operator leaderboard takes nothing returns Table___leaderboards
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")
struct Table___multiboards extends array
    static if (true) then
        method operator [] takes integer key returns multiboard
            return LoadMultiboardHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, multiboard value returns nothing
        call SaveMultiboardHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___multiboardm
    method operator multiboard takes nothing returns Table___multiboards
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")
struct Table___multiboarditems extends array
    static if (true) then
        method operator [] takes integer key returns multiboarditem
            return LoadMultiboardItemHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___multiboarditemm
    method operator multiboarditem takes nothing returns Table___multiboarditems
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")
//textmacro instance: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")
struct Table___trackables extends array
    static if (true) then
        method operator [] takes integer key returns trackable
            return LoadTrackableHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, trackable value returns nothing
        call SaveTrackableHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___trackablem
    method operator trackable takes nothing returns Table___trackables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")
//textmacro instance: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")
struct Table___dialogs extends array
    static if (true) then
        method operator [] takes integer key returns dialog
            return LoadDialogHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, dialog value returns nothing
        call SaveDialogHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___dialogm
    method operator dialog takes nothing returns Table___dialogs
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")
//textmacro instance: NEW_TABLE("Handle", "ButtonHandle", "button", "true")
struct Table___buttons extends array
    static if (true) then
        method operator [] takes integer key returns button
            return LoadButtonHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, button value returns nothing
        call SaveButtonHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___buttonm
    method operator button takes nothing returns Table___buttons
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ButtonHandle", "button", "true")
//textmacro instance: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")
struct Table___texttags extends array
    static if (true) then
        method operator [] takes integer key returns texttag
            return LoadTextTagHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, texttag value returns nothing
        call SaveTextTagHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___texttagm
    method operator texttag takes nothing returns Table___texttags
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")
//textmacro instance: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")
struct Table___lightnings extends array
    static if (true) then
        method operator [] takes integer key returns lightning
            return LoadLightningHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, lightning value returns nothing
        call SaveLightningHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___lightningm
    method operator lightning takes nothing returns Table___lightnings
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")
//textmacro instance: NEW_TABLE("Handle", "ImageHandle", "image", "true")
struct Table___images extends array
    static if (true) then
        method operator [] takes integer key returns image
            return LoadImageHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, image value returns nothing
        call SaveImageHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___imagem
    method operator image takes nothing returns Table___images
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "ImageHandle", "image", "true")
//textmacro instance: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")
struct Table___ubersplats extends array
    static if (true) then
        method operator [] takes integer key returns ubersplat
            return LoadUbersplatHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, ubersplat value returns nothing
        call SaveUbersplatHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___ubersplatm
    method operator ubersplat takes nothing returns Table___ubersplats
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")
//textmacro instance: NEW_TABLE("Handle", "RegionHandle", "region", "true")
struct Table___regions extends array
    static if (true) then
        method operator [] takes integer key returns region
            return LoadRegionHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, region value returns nothing
        call SaveRegionHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___regionm
    method operator region takes nothing returns Table___regions
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "RegionHandle", "region", "true")
//textmacro instance: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")
struct Table___fogstates extends array
    static if (true) then
        method operator [] takes integer key returns fogstate
            return LoadFogStateHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, fogstate value returns nothing
        call SaveFogStateHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___fogstatem
    method operator fogstate takes nothing returns Table___fogstates
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")
//textmacro instance: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")
struct Table___fogmodifiers extends array
    static if (true) then
        method operator [] takes integer key returns fogmodifier
            return LoadFogModifierHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, fogmodifier value returns nothing
        call SaveFogModifierHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___fogmodifierm
    method operator fogmodifier takes nothing returns Table___fogmodifiers
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")
//textmacro instance: NEW_TABLE("Handle", "AgentHandle", "agent", "false")
struct Table___agents extends array
    static if (false) then
        method operator [] takes integer key returns agent
            return LoadAgentHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, agent value returns nothing
        call SaveAgentHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___agentm
    method operator agent takes nothing returns Table___agents
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "AgentHandle", "agent", "false")
//textmacro instance: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")
struct Table___hashtables extends array
    static if (true) then
        method operator [] takes integer key returns hashtable
            return LoadHashtableHandle(Table___ht, this, key)
        endmethod
    endif
    method operator []= takes integer key, hashtable value returns nothing
        call SaveHashtableHandle(Table___ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endmethod
endstruct
module Table___hashtablem
    method operator hashtable takes nothing returns Table___hashtables
        return this
    endmethod
endmodule
//end of: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")
struct Table extends array
    
    // Implement modules for intuitive type-syntax
    implement Table___realm
    implement Table___booleanm
    implement Table___stringm
    implement Table___playerm
    implement Table___widgetm
    implement Table___destructablem
    implement Table___itemm
    implement Table___unitm
    implement Table___abilitym
    implement Table___timerm
    implement Table___triggerm
    implement Table___triggerconditionm
    implement Table___triggeractionm
    implement Table___eventm
    implement Table___forcem
    implement Table___groupm
    implement Table___locationm
    implement Table___rectm
    implement Table___boolexprm
    implement Table___soundm
    implement Table___effectm
    implement Table___unitpoolm
    implement Table___itempoolm
    implement Table___questm
    implement Table___questitemm
    implement Table___defeatconditionm
    implement Table___timerdialogm
    implement Table___leaderboardm
    implement Table___multiboardm
    implement Table___multiboarditemm
    implement Table___trackablem
    implement Table___dialogm
    implement Table___buttonm
    implement Table___texttagm
    implement Table___lightningm
    implement Table___imagem
    implement Table___ubersplatm
    implement Table___regionm
    implement Table___fogstatem
    implement Table___fogmodifierm
    implement Table___agentm
    implement Table___hashtablem
    
    
    // set this = tb[GetSpellAbilityId()]
    method operator [] takes integer key returns Table
        return LoadInteger(Table___ht, this, key)
    endmethod
    
    // set tb[389034] = 8192
    method operator []= takes integer key, Table tb returns nothing
        call SaveInteger(Table___ht, this, key, tb)
    endmethod
    
    // set b = tb.has(2493223)
    method has takes integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key)
    endmethod
    
    // call tb.remove(294080)
    method remove takes integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key)
    endmethod
    
    // Remove all data from a Table instance
    method flush takes nothing returns nothing
        call FlushChildHashtable(Table___ht, this)
    endmethod
    
    // local Table tb = Table.create()
    static method create takes nothing returns Table
        if (Table___lpos == 0) then
            set Table___grow = Table___grow + 1
            return Table___grow
        endif
        set Table___lpos = Table___lpos - 1
        return Table___list[Table___lpos]
    endmethod
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    method destroy takes nothing returns nothing
        call this.flush()
        static if (false) then
            if (integer(this) < 3) then
                call BJDebugMsg("Table Error: Tried to destroy an invalid Table instance: " + I2S(this))
                return
            elseif (Table(2).boolean[this]) then
                call BJDebugMsg("Table Error: Tried to double-free instance: " + I2S(this))
                return
            endif
            // The reserved Table(2) index detects double-free of instances
            // if running in debug mode.
            set Table(2).boolean[this] = true
        endif
        if (Table___lpos < 8191) then
            set Table___list[Table___lpos] = this
            set Table___lpos = Table___lpos + 1
        endif
    endmethod
    
//ignored textmacro command: TABLE_BC_METHODS()
    
endstruct
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
struct TableArray extends array
    
    // Returns a new TableArray to do your bidding. Simply use:
    //
    //     local TableArray ta = TableArray[arraySize]
    //
    static method operator [] takes integer arraySize returns TableArray
        local Table tb = Table(1)[arraySize] // Table(1) indexes arraySizes
local TableArray ta // and instances.
local integer i
        if (integer(tb) == 0 or tb[0] == 0) then
            set Table___keys = Table___keys - arraySize // Negative values are reserved...
set Table(1)[Table___keys] = arraySize // This remembers the array size
set ta = Table___keys // All TableArray IDs are below 0
else
            set i = tb[0] // Get the last-destroyed TableArray's index
call tb.remove(0) // Clear data as we go along
set tb[0] = i - 1 // Decrease and save the recycle count
set ta = tb[i] // Retrieve the old TableArray's instance
call tb.remove(i) // Remove the old TableArray's node
        endif
        return ta
    endmethod
    
    // Returns the size of the TableArray (arraySize)
    method operator size takes nothing returns integer
        return Table(1)[this]
    endmethod
    
    // ta[integer a].unit[integer b] = unit u
    // ta[integer a][integer c] = integer d
    //
    // Inline-friendly when not running in debug mode
    //
    method operator [] takes integer key returns Table
        static if (false) then
            if (integer(this) >= 0) then
                call BJDebugMsg("TableArray Error: " + I2S(this) + " is not a valid TableArray instance")
                return 0
            endif
            if (key < 0 or key >= this.size) then
                call BJDebugMsg("TableArray Error: Tried to lookup key [" + I2S(key) + "] which is outside array bounds [" + I2S(this.size) + "]")
                return 0
            endif
        endif
        return this + key
    endmethod
    
    // Destroys a TableArray without flushing it; assumed you'd call .flush()
    // if you want it flushed too. This is public so that if you are flushing
    // instances the whole time you don't waste efficiency when disposing the
    // TableArray.
    //
    method destroy takes nothing returns nothing
        local integer i
        local Table tb = Table(1)[this.size]
        static if (false) then
            if (integer(this) >= 0 or this.size <= 0) then
                call BJDebugMsg("TableArray Error: Tried to destroy an invalid instance (" + I2S(this) + ")")
                return
            elseif (Table(2).boolean[this]) then
                call BJDebugMsg("TableArray Error: Tried to double-free instance: " + I2S(this))
                return
            endif
            set Table(2).boolean[this] = true
        endif
        if (integer(tb) == 0) then
            set tb = Table.create() // A Table to remember old indexes
set Table(1)[this.size] = tb // Save it in the reserved key (1)
set i = 1 // The recycle count is initially 1
else
            set i = tb[0] + 1 // Increase recycle count
call tb.remove(0) // Remove the "recycle count" node
endif
        set tb[0] = i // Save recycle count
set tb[i] = this // Save this under recycle count's index
endmethod
    
    // All you need to know about this one is that it won't hit the op limit.
    private static method clean takes Table tb, integer end returns nothing
        local integer i = tb + 4096
        if (i < end) then
            call clean.evaluate(i, end)
            set end = i
        endif
        loop
            call tb.flush()
            set tb = tb + 1
            exitwhen integer(tb) == end
        endloop
    endmethod
    
    // Flushes the TableArray and also destroys it. Doesn't get any more
    // similar to the FlushParentHashtable native than this.
    //
    method flush takes nothing returns nothing
        local integer end = this.size + this
        if (integer(this) < end) then
            call clean.evaluate(this, end)
            call this.destroy()
        endif
    endmethod
    
endstruct
    

//library Table ends
//library TechData:
struct TechData
    string name
    integer cat
    static method create takes string name, integer cat returns TechData
        local TechData m=TechData.allocate()
        set m.name = name
        set m.cat = cat
        return m
    endmethod
endstruct
//textmacro instance: CreateArrayList("TechTree")
struct TechTree
    integer size
    integer array itms[DEFAULT_ARRAYLIST_SIZE]
    
    static method create takes nothing returns TechTree
        local TechTree m=TechTree.allocate()
        set m.size = 0
        return m
    endmethod
    
    method addItem takes integer itm returns nothing
        set itms[size] = itm
        set size = size + 1
    endmethod
endstruct
//end of: CreateArrayList("TechTree")
function InitTechData takes nothing returns nothing
    local integer i = 0
    
    set TECH_TREE_NAME[0] = "TREE_GENERAL"
    set TECH_TREE_NAME[1] = "TREE_BLADE"
    set TECH_TREE_NAME[2] = "TREE_MAGIC_HUNTER"
    
    loop
        exitwhen i >= TT_COUNT
        set TECH_TREE_COUNT[i] = 0
        set TECH_TREES[i] = TechTree.create()
        set i = i + 1
    endloop
    
    call FlushParentHashtable(tdht)
    set tdht = InitHashtable()
//textmacro instance: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht,tKMANA,tdht_name,"閫€榄斿垉")
    call SaveInteger(tdht,tKMANA,tdht_cat,TT_MAGIC_HUNTER)
    call SaveInteger(tdht,tKMANA,tdht_tech_need,0)
    call SaveInteger(tdht,tKMANA,tdht_game_lv_need,1)
    call SaveInteger(tdht,tKMANA,tdht_base_point,0)
    call TECH_TREES[TT_MAGIC_HUNTER].addItem(tKMANA)
    set TECH_TREE_COUNT[TT_MAGIC_HUNTER] = TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSTRONG,tdht_name,"浣撹川澧炲己")
    call SaveInteger(tdht,tSTRONG,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSTRONG,tdht_tech_need,0)
    call SaveInteger(tdht,tSTRONG,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSTRONG,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSTRONG)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tDOGE,tdht_name,"闂伩")
    call SaveInteger(tdht,tDOGE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tDOGE,tdht_tech_need,0)
    call SaveInteger(tdht,tDOGE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tDOGE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tDOGE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSPEED_SHOOT,tdht_name,"鎬ラ€熷皠鍑?)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_tech_need,0)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSPEED_SHOOT,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSPEED_SHOOT)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tAIM_SHOOT,tdht_name,"绮惧噯灏勫嚮")
    call SaveInteger(tdht,tAIM_SHOOT,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_tech_need,0)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_game_lv_need,1)
    call SaveInteger(tdht,tAIM_SHOOT,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tAIM_SHOOT)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tSAVE,tdht_name,"鑺傝兘")
    call SaveInteger(tdht,tSAVE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tSAVE,tdht_tech_need,0)
    call SaveInteger(tdht,tSAVE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tSAVE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tSAVE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
    call SaveStr(tdht,tFREZZ,tdht_name,"鎬ュ喕")
    call SaveInteger(tdht,tFREZZ,tdht_cat,TT_ICE)
    call SaveInteger(tdht,tFREZZ,tdht_tech_need,0)
    call SaveInteger(tdht,tFREZZ,tdht_game_lv_need,1)
    call SaveInteger(tdht,tFREZZ,tdht_base_point,0)
    call TECH_TREES[TT_ICE].addItem(tFREZZ)
    set TECH_TREE_COUNT[TT_ICE] = TECH_TREE_COUNT[TT_ICE] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
//textmacro instance: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht,tMANA_BOOM,tdht_name,"鑳介噺鐖嗙偢")
    call SaveInteger(tdht,tMANA_BOOM,tdht_cat,TT_MAGIC_HUNTER)
    call SaveInteger(tdht,tMANA_BOOM,tdht_tech_need,0)
    call SaveInteger(tdht,tMANA_BOOM,tdht_game_lv_need,1)
    call SaveInteger(tdht,tMANA_BOOM,tdht_base_point,0)
    call TECH_TREES[TT_MAGIC_HUNTER].addItem(tMANA_BOOM)
    set TECH_TREE_COUNT[TT_MAGIC_HUNTER] = TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tANTRAD,tdht_name,"杈愬皠鎶垫姉")
    call SaveInteger(tdht,tANTRAD,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tANTRAD,tdht_tech_need,0)
    call SaveInteger(tdht,tANTRAD,tdht_game_lv_need,1)
    call SaveInteger(tdht,tANTRAD,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tANTRAD)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht,tFIRE_CHARGE,tdht_name,"鐑堢劙鍏呰兘")
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_cat,TT_GENERAL)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_tech_need,0)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_game_lv_need,1)
    call SaveInteger(tdht,tFIRE_CHARGE,tdht_base_point,0)
    call TECH_TREES[TT_GENERAL].addItem(tFIRE_CHARGE)
    set TECH_TREE_COUNT[TT_GENERAL] = TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT = TECH_COUNT + 1
//end of: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
endfunction

//library TechData ends
//library Text:
function DisplayText takes player p, string msg returns nothing
    call DisplayTextToPlayer( p, 0, 0, msg )
endfunction
function DisplayInfo takes player p, string msg returns nothing
    call DisplayTextToPlayer( p, 0, 0, msg )
endfunction

//library Text ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (Purple flavor for 1.23b or later)
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: http://www.wc3c.net/
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Purple Flavor: Slower than the red flavor by a multiplication and a
//*             division, and as such faster than the blue flavor. Has
//*             a theoretical limit of timers, which is HASH_SIZE, but
//*             you should keep your timer count below 3/4 of that to
//*             insure good performance of the NewTimer function.
//*
//* Credits:  * Hash algorithm by Cohadar (used in an early version
//*             of his ABCT timer system)
//*
//*           * TimerUtils "interface" by Vexorian.
//*
//*           * This library by Iron_Doors.
//*
//********************************************************************
//================================================================
    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t, integer value returns nothing
        set TimerUtils___data[GetHandleId(t)-TimerUtils___MIN_HANDLE_ID]=value
    endfunction
    function GetTimerData takes timer t returns integer
        return TimerUtils___data[GetHandleId(t)-TimerUtils___MIN_HANDLE_ID]
    endfunction
    function NewTimer takes nothing returns timer
        if (TimerUtils___tN==0) then
            set TimerUtils___tT[0]=CreateTimer()
        else
            set TimerUtils___tN=TimerUtils___tN-1
        endif
        call SetTimerData(TimerUtils___tT[TimerUtils___tN],0)
     return TimerUtils___tT[TimerUtils___tN]
    endfunction
    function ReleaseTimer takes timer t returns nothing
        if(t==null) then
            return
        endif
        if (TimerUtils___tN==8191) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if(GetTimerData(t)==TimerUtils___HELD) then
                return
            endif
            call SetTimerData(t,TimerUtils___HELD)
            set TimerUtils___tT[TimerUtils___tN]=t
            set TimerUtils___tN=TimerUtils___tN+1
        endif 
    endfunction

//library TimerUtils ends
//library Union:
    
    
    // If your Warcraft version isn`t 1.24 delete it, or must preserve the function.
   // function GetHandleId takes handle h returns integer
    //    return h
    //    return 0
    //endfunction
    function Adaptation takes nothing returns boolean
        return true
    endfunction
    
    function Incident takes playerunitevent case, conditionfunc cond, code act returns nothing
        local trigger t = CreateTrigger()
        local integer index = 0
        loop
            call TriggerRegisterPlayerUnitEvent(t, Player(index), case, Union___FilterLeisure)
            set index = index + 1
            exitwhen index == 12
        endloop
        call TriggerAddCondition(t, cond)
        call TriggerAddAction(t, act)
        set t = null
    endfunction
    
    function Init takes nothing returns nothing
        set Union___FilterLeisure = Filter(function Adaptation)
    endfunction
    

//library Union ends
//library UnitId:
function IsHero takes unit u returns boolean
    return GetUnitTypeId(u) == HERO
endfunction
function IsBoss takes unit u returns boolean
    local integer t = GetUnitTypeId(u)
    if t == 'u002' or t == 'u004' then
        return true
    endif
    return false
endfunction

//library UnitId ends
//library Vector:
//*****************************************************************
//*  VECTOR LIBRARY
//*
//*  written by: Anitarf
//*
//*  The library contains a struct named vector, which represents a
//*  point in 3D space. As such, it has three real members, one for
//*  each coordinate: x, y, z. It also has the following methods:
//*
//*        static method create takes real x, real y, real z returns vector
//*  Creates a new vector with the given coordinates.
//*
//*        method getLength takes nothing returns real
//*  Returns the length of the vector it is called on.
//*
//*        static method sum takes vector augend, vector addend returns vector
//*  Returns the sum of two vectors as a new vector.
//*
//*        method add takes vector addend returns nothing
//*  Similar to sum, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by adding the "added" to it.
//*
//*        static method difference takes vector minuend, vector subtrahend returns vector
//*  Returns the difference between two vectors as a new vector.
//*
//*        method subtract takes vector subtrahend returns nothing
//*  Similar to difference, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by subtracting the "subtrahend" from it.
//*
//*        method scale takes real factor returns nothing
//*  Scales the vector it is called on by the given factor.
//*
//*        method setLength takes real length returns nothing
//*  Sets the length of the vector it is called on to the given value, maintaining its orientation.
//*
//*        static method dotProduct takes vector a, vector b returns real
//*  Calculates the dot product (also called scalar product) of two vectors.
//*
//*        static method crossProduct takes vector a, vector b returns vector
//*  Calculates the cross product (also called vector product) of two vectors
//*  and returns it as a new vector.
//*
//*        static method tripleProductScalar takes vector a, vector b, vector c returns real
//*  Calculates the triple scalar product of three vectors.
//*
//*        static method tripleProductVector takes vector a, vector b, vector c returns vector
//*  Calculates the triple vector product of three vectors and returns it as a new vector.
//*
//*
//*        static method projectionVector takes vector projected, vector direction returns vector
//*  Calculates the projection of the vector "projected" onto the vector "direction"
//*  and returns it as a new vector.
//*  Returns null if the vector "direction" has a length of 0.
//*
//*        method projectVector takes vector direction returns nothing
//*  Projects the vector it is called on onto the vector "direction".
//*  Does nothing if the vector "direction" has a length of 0.
//*
//*        static method projectionPlane takes vector projected, vector normal returns vector
//*  Calculates the projection of the vector "projected" onto a plane defined by
//*  its normal vector and returns it as a new vector.
//*  Returns null if the vector "normal" has a length of 0.
//*
//*        method projectPlane takes vector normal returns nothing
//*  Projects the vector it is called on onto a plane defined by its normal vector.
//*  Does nothing if the vector "normal" has a length of 0.
//*
//*        static method getAngle takes vector a, vector b returns real
//*  Returns the angle between two vectors, in radians, returns a value between 0 and pi.
//*  Returns 0.0 if any of the vectors are 0 units long.
//*
//*        method rotate takes vector axis, real angle returns nothing
//*  Rotates the vector it is called on around the axis defined by the vector "axis"
//*  by the given angle, which should be input in radians.
//*  Does nothing if axis is 0 units long.
//*
//*
//*        static method createTerrainPoint takes real x, real y returns vector
//*  Creates a vector to the given terrain coordinate, taking its z height into account.
//*
//*        method getTerrainPoint takes real x, real y returns nothing
//*  Sets the vector it is called on to the given terrain coordinate, taking its z height into account.
//*
//*        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
//*  Creates the normal vector of the terrain at given coordinates. "sampleRadius" defines
//*  how far apart the reference points will be, if they are further apart, the result will
//*  be an impression of smoother terrain; normaly the value should be between 0 and 128.
//*
//*        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
//*  Sets the vector it is called on to the normal of the terrain at given coordinates.
//*
//*
//*        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
//*  Determines if a point is within a given cylinder. The cylinder's origin vector points
//*  to the center of one of the two paralel circular sides, and the height vector points
//*  from the origin point to the center of the other of the two paralel circular sides.
//*  Returns false if the point is not in the cylinder or if the vector cylinderHeight is 0 units long.
//*
//*        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
//*  Determines if a point is within a given cone. The cone's origin vector points to the
//*  center of the circular side, and the height vector points from the origin point to
//*  the tip of the cone.
//*  Returns false if the point is not in the cylinder or if the vector coneHeight is 0 units long.
//*
//*        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
//*  Determines if a point is within a give sphere. The sphere's origin vector points to the
//*  center of the sphere.
//*  Returns false if the point is not in the sphere.
//*****************************************************************
    struct vector
        real x
        real y
        real z
        
        static method create takes real x, real y, real z returns vector
            local vector v = vector.allocate()
            set v.x=x
            set v.y=y
            set v.z=z
            return v
        endmethod
        
        method getLength takes nothing returns real
          return SquareRoot(.x*.x + .y*.y + .z*.z)
        endmethod
        
        method reverse takes nothing returns nothing
            set this.x = -this.x
            set this.y = -this.y
            set this.z = -this.z
        endmethod
        
        static method unitVector takes vector v returns vector
            local vector uv = vector.allocate()
            local real length = v.getLength()
            if length == 0 then
                return vector.create(0,0,0)
            endif
            set uv.x = v.x/length
            set uv.y = v.y/length
            set uv.z = v.z/length
            return uv
        endmethod
        
        static method sum takes vector augend, vector addend returns vector
            local vector v = vector.allocate()
            set v.x = augend.x+addend.x
            set v.y = augend.y+addend.y
            set v.z = augend.z+addend.z
            return v
        endmethod
        method add takes vector addend returns nothing
            set this.x=this.x+addend.x
            set this.y=this.y+addend.y
            set this.z=this.z+addend.z
        endmethod
        
        static method difference takes vector minuend, vector subtrahend returns vector
            local vector v = vector.allocate()
            set v.x = minuend.x-subtrahend.x
            set v.y = minuend.y-subtrahend.y
            set v.z = minuend.z-subtrahend.z
            return v
        endmethod
        method subtract takes vector subtrahend returns nothing
            set this.x=this.x-subtrahend.x
            set this.y=this.y-subtrahend.y
            set this.z=this.z-subtrahend.z
        endmethod
        
        method scale takes real factor returns nothing
            set this.x=this.x*factor
            set this.y=this.y*factor
            set this.z=this.z*factor
        endmethod
        
        static method scale2 takes vector v, real factor returns vector
            local vector r = vector.allocate()
            set r.x=v.x*factor
            set r.y=v.y*factor
            set r.z=v.z*factor
            return r
        endmethod
        
        method setLength takes real length returns nothing
            local real l = SquareRoot(.x*.x + .y*.y + .z*.z)
            if l == 0.0 then
                return
            endif
            set l = length/l
            set this.x = this.x*l
            set this.y = this.y*l
            set this.z = this.z*l
        endmethod
        
        static method dotProduct takes vector a, vector b returns real
            return (a.x*b.x+a.y*b.y+a.z*b.z)
        endmethod
        
        static method crossProduct takes vector a, vector b returns vector
            local vector v = vector.allocate()
            set v.x = a.y*b.z - a.z*b.y
            set v.y = a.z*b.x - a.x*b.z
            set v.z = a.x*b.y - a.y*b.x
            return v
        endmethod
        static method tripleProductScalar takes vector a, vector b, vector c returns real
            return ((a.y*b.z - a.z*b.y)*c.x+(a.z*b.x - a.x*b.z)*c.y+(a.x*b.y - a.y*b.x)*c.z)
        endmethod
        static method tripleProductVector takes vector a, vector b, vector c returns vector
            local vector v = vector.allocate()
            local real n = a.x*c.x+a.y*c.y+a.z*c.z
            local real m = a.x*b.x+a.y*b.y+a.z*b.z
            set v.x = b.x*n-c.x*m
            set v.y = b.y*n-c.y*m
            set v.z = b.z*n-c.z*m
            return v
        endmethod
// ================================================================
        static method projectionVector takes vector projected, vector direction returns vector
            local vector v = vector.allocate()
            local real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
            if l == 0.0 then
                call v.destroy()
                return 0
            endif
            set l = (projected.x*direction.x+projected.y*direction.y+projected.z*direction.z) / l
            set v.x = direction.x*l
            set v.y = direction.y*l
            set v.z = direction.z*l
            return v
        endmethod
        method projectVector takes vector direction returns nothing
            local real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
            if l == 0.0 then
                return
            endif
            set l = (this.x*direction.x+this.y*direction.y+this.z*direction.z) / l
            set this.x = direction.x*l
            set this.y = direction.y*l
            set this.z = direction.z*l
        endmethod
        static method projectionPlane takes vector projected, vector normal returns vector
            local vector v = vector.allocate()
            local real l = normal.x*normal.x+normal.y*normal.y+normal.z*normal.z
            if l == 0.0 then
                call v.destroy()
                return 0
            endif
            set l = (projected.x*normal.x+projected.y*normal.y+projected.z*normal.z) / l
            set v.x = projected.x - normal.x*l
            set v.y = projected.y - normal.y*l
            set v.z = projected.z - normal.z*l
            return v
        endmethod
        method projectPlane takes vector normal returns nothing
            local real l = normal.x*normal.x+normal.y*normal.y+normal.z*normal.z
            if l == 0.0 then
                return
            endif
            set l = (this.x*normal.x+this.y*normal.y+this.z*normal.z) / l
            set this.x = this.x - normal.x*l
            set this.y = this.y - normal.y*l
            set this.z = this.z - normal.z*l
        endmethod
        static method getAngle takes vector a, vector b returns real
            local real l = SquareRoot(a.x*a.x + a.y*a.y + a.z*a.z)*SquareRoot(b.x*b.x + b.y*b.y + b.z*b.z)
            if l == 0 then
                return 0.0
            endif
            return Acos((a.x*b.x+a.y*b.y+a.z*b.z)/l) //angle is returned in radians
endmethod
        
        method rotate takes vector axis, real angle returns nothing //angle is taken in radians
local real xx
            local real xy
            local real xz
            local real yx
            local real yy
            local real yz
            local real zx
            local real zy
            local real zz
            local real al = axis.x*axis.x+axis.y*axis.y+axis.z*axis.z //axis length^2
local real f
            local real c = Cos(angle)
            local real s = Sin(angle)
            if al == 0.0 then
                return
            endif
            set f = (this.x*axis.x+this.y*axis.y+this.z*axis.z) / al
            set zx = axis.x*f
            set zy = axis.y*f
            set zz = axis.z*f //axis component of rotated vector
set xx = this.x-zx
            set xy = this.y-zy
            set xz = this.z-zz //component of vector perpendicular to axis
set al = SquareRoot(al)
            set yx = (axis.y*xz - axis.z*xy)/al
            set yy = (axis.z*xx - axis.x*xz)/al //y same length as x by using cross product and dividing with axis length
set yz = (axis.x*xy - axis.y*xx)/al //x,y - coordinate system in which we rotate
set this.x=xx*c+yx*s+zx
            set this.y=xy*c+yy*s+zy
            set this.z=xz*c+yz*s+zz
        endmethod
        
// ================================================================
        private static location loc = Location(0.0,0.0)
        static method createTerrainPoint takes real x, real y returns vector
            local vector v = vector.allocate()
            call MoveLocation(vector.loc,x,y)
            set v.x=x
            set v.y=y
            set v.z=GetLocationZ(loc)
            return v
        endmethod
        method getTerrainPoint takes real x, real y returns nothing
            call MoveLocation(vector.loc,x,y)
            set this.x=x
            set this.y=y
            set this.z=GetLocationZ(loc)
        endmethod
        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
            local vector v = vector.allocate()
            local real zx
            local real zy
            call MoveLocation(vector.loc, x-sampleRadius, y)
            set zx=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x+sampleRadius, y)
            set zx=zx-GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y-sampleRadius)
            set zy=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y+sampleRadius)
            set zy=zy-GetLocationZ(vector.loc)
            set sampleRadius=2*sampleRadius
            set v.x = zx*sampleRadius
            set v.y = zy*sampleRadius
            set v.z = sampleRadius*sampleRadius
            return v
        endmethod
        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
            local real zx
            local real zy
            call MoveLocation(vector.loc, x-sampleRadius, y)
            set zx=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x+sampleRadius, y)
            set zx=zx-GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y-sampleRadius)
            set zy=GetLocationZ(vector.loc)
            call MoveLocation(vector.loc, x, y+sampleRadius)
            set zy=zy-GetLocationZ(vector.loc)
            set sampleRadius=2*sampleRadius
            set this.x = zx*sampleRadius
            set this.y = zy*sampleRadius
            set this.z = sampleRadius*sampleRadius
        endmethod
// ================================================================
        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
            local real l
            local real x = this.x-cylinderOrigin.x
            local real y = this.y-cylinderOrigin.y
            local real z = this.z-cylinderOrigin.z
            if x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z < 0.0 then //point below cylinder
return false
            endif
            
            set x = x-cylinderHeight.x
            set y = y-cylinderHeight.y
            set z = z-cylinderHeight.z
            if x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z > 0.0 then //point above cylinder
return false
            endif
            
            set l = cylinderHeight.x*cylinderHeight.x+cylinderHeight.y*cylinderHeight.y+cylinderHeight.z*cylinderHeight.z
            if l == 0.0 then
                return false
            endif
            set l = (x*cylinderHeight.x+y*cylinderHeight.y+z*cylinderHeight.z) / l
            set x = x - cylinderHeight.x*l
            set y = y - cylinderHeight.y*l
            set z = z - cylinderHeight.z*l
            if x*x+y*y+z*z > cylinderRadius*cylinderRadius then //point outside cylinder
return false
            endif
            
            return true
        endmethod
        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
            local real l
            local real x = this.x-coneOrigin.x
            local real y = this.y-coneOrigin.y
            local real z = this.z-coneOrigin.z
            if x*coneHeight.x+y*coneHeight.y+z*coneHeight.z < 0.0 then //point below cone
return false
            endif
            
            set l = coneHeight.x*coneHeight.x+coneHeight.y*coneHeight.y+coneHeight.z*coneHeight.z
            if l == 0.0 then
                return false
            endif
            set l = (x*coneHeight.x+y*coneHeight.y+z*coneHeight.z) / l
            set x = x - coneHeight.x*l
            set y = y - coneHeight.y*l
            set z = z - coneHeight.z*l
            if SquareRoot(x*x+y*y+z*z) > coneRadius*(1.0-l) then //point outside cone
return false
            endif
            
            return true
        endmethod
        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
            if sphereRadius*sphereRadius < ((this.x-sphereOrigin.x)*(this.x-sphereOrigin.x)+(this.y-sphereOrigin.y)*(this.y-sphereOrigin.y)+(this.z-sphereOrigin.z)*(this.z-sphereOrigin.z)) then
                return false
            endif
            return true
        endmethod
    endstruct

//library Vector ends
//library YDWEBase:
//===========================================================================
//HashTable
//===========================================================================
//===========================================================================
//Return bug
//===========================================================================
function YDWEH2I takes handle h returns integer
    return GetHandleId(h)
endfunction
//清空
function YDWEFlushAllData takes nothing returns nothing
    call FlushParentHashtable(YDHT)
endfunction
function YDWEFlushMissionByInteger takes integer i returns nothing
    call FlushChildHashtable(YDHT,i)
endfunction
function YDWEFlushMissionByString takes string s returns nothing
    call FlushChildHashtable(YDHT,StringHash(s))
endfunction
function YDWEFlushStoredIntegerByInteger takes integer i,integer j returns nothing
    call RemoveSavedInteger(YDHT,i,j)
endfunction
function YDWEFlushStoredIntegerByString takes string s1,string s2 returns nothing
    call RemoveSavedInteger(YDHT,StringHash(s1),StringHash(s2))
endfunction
function YDWEHaveSavedIntegerByInteger takes integer i,integer j returns boolean
    return HaveSavedInteger(YDHT,i,j)
endfunction
function YDWEHaveSavedIntegerByString takes string s1,string s2 returns boolean
    return HaveSavedInteger(YDHT,StringHash(s1),StringHash(s2))
endfunction
//store and get integer
function YDWESaveIntegerByInteger takes integer pTable,integer pKey,integer i returns nothing
    call SaveInteger(YDHT,pTable,pKey,i)
endfunction
function YDWESaveIntegerByString takes string pTable,string pKey,integer i returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),i)
endfunction
function YDWEGetIntegerByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetIntegerByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get real
function YDWESaveRealByInteger takes integer pTable,integer pKey,real r returns nothing
    call SaveReal(YDHT,pTable,pKey,r)
endfunction
function YDWESaveRealByString takes string pTable,string pKey,real r returns nothing
    call SaveReal(YDHT,StringHash(pTable),StringHash(pKey),r)
endfunction
function YDWEGetRealByInteger takes integer pTable,integer pKey returns real
    return LoadReal(YDHT,pTable,pKey)
endfunction
function YDWEGetRealByString takes string pTable,string pKey returns real
    return LoadReal(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get string
function YDWESaveStringByInteger takes integer pTable,integer pKey,string s returns nothing
    call SaveStr(YDHT,pTable,pKey,s)
endfunction
function YDWESaveStringByString takes string pTable,string pKey,string s returns nothing
    call SaveStr(YDHT,StringHash(pTable),StringHash(pKey),s)
endfunction
function YDWEGetStringByInteger takes integer pTable,integer pKey returns string
    return LoadStr(YDHT,pTable,pKey)
endfunction
function YDWEGetStringByString takes string pTable,string pKey returns string
    return LoadStr(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//store and get boolean
function YDWESaveBooleanByInteger takes integer pTable,integer pKey,boolean b returns nothing
    call SaveBoolean(YDHT,pTable,pKey,b)
endfunction
function YDWESaveBooleanByString takes string pTable,string pKey,boolean b returns nothing
    call SaveBoolean(YDHT,StringHash(pTable),StringHash(pKey),b)
endfunction
function YDWEGetBooleanByInteger takes integer pTable,integer pKey returns boolean
    return LoadBoolean(YDHT,pTable,pKey)
endfunction
function YDWEGetBooleanByString takes string pTable,string pKey returns boolean
    return LoadBoolean(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Unit
function YDWESaveUnitByInteger takes integer pTable,integer pKey,unit u returns nothing
    call SaveUnitHandle(YDHT,pTable,pKey,u)
endfunction
function YDWESaveUnitByString takes string pTable,string pKey,unit u returns nothing
    call SaveUnitHandle(YDHT,StringHash(pTable),StringHash(pKey),u)
endfunction
function YDWEGetUnitByInteger takes integer pTable,integer pKey returns unit
    return LoadUnitHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetUnitByString takes string pTable,string pKey returns unit
    return LoadUnitHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert UnitID
function YDWESaveUnitIDByInteger takes integer pTable,integer pKey,integer uid returns nothing
    call SaveInteger(YDHT,pTable,pKey,uid)
endfunction
function YDWESaveUnitIDByString takes string pTable,string pKey,integer uid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),uid)
endfunction
function YDWEGetUnitIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetUnitIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert AbilityID
function YDWESaveAbilityIDByInteger takes integer pTable,integer pKey,integer abid returns nothing
    call SaveInteger(YDHT,pTable,pKey,abid)
endfunction
function YDWESaveAbilityIDByString takes string pTable,string pKey,integer abid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),abid)
endfunction
function YDWEGetAbilityIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetAbilityIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Player
function YDWESavePlayerByInteger takes integer pTable,integer pKey,player p returns nothing
    call SavePlayerHandle(YDHT,pTable,pKey,p)
endfunction
function YDWESavePlayerByString takes string pTable,string pKey,player p returns nothing
    call SavePlayerHandle(YDHT,StringHash(pTable),StringHash(pKey),p)
endfunction
function YDWEGetPlayerByInteger takes integer pTable,integer pKey returns player
    return LoadPlayerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetPlayerByString takes string pTable,string pKey returns player
    return LoadPlayerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Item
function YDWESaveItemByInteger takes integer pTable,integer pKey,item it returns nothing
    call SaveItemHandle(YDHT,pTable,pKey,it)
endfunction
function YDWESaveItemByString takes string pTable,string pKey,item it returns nothing
    call SaveItemHandle(YDHT,StringHash(pTable),StringHash(pKey),it)
endfunction
function YDWEGetItemByInteger takes integer pTable,integer pKey returns item
    return LoadItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetItemByString takes string pTable,string pKey returns item
    return LoadItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert ItemID
function YDWESaveItemIDByInteger takes integer pTable,integer pKey,integer itid returns nothing
    call SaveInteger(YDHT,pTable,pKey,itid)
endfunction
function YDWESaveItemIDByString takes string pTable,string pKey,integer itid returns nothing
    call SaveInteger(YDHT,StringHash(pTable),StringHash(pKey),itid)
endfunction
function YDWEGetItemIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT,pTable,pKey)
endfunction
function YDWEGetItemIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Timer
function YDWESaveTimerByInteger takes integer pTable,integer pKey,timer t returns nothing
    call SaveTimerHandle(YDHT,pTable,pKey,t)
endfunction
function YDWESaveTimerByString takes string pTable,string pKey,timer t returns nothing
    call SaveTimerHandle(YDHT,StringHash(pTable),StringHash(pKey),t)
endfunction
function YDWEGetTimerByInteger takes integer pTable,integer pKey returns timer
    return LoadTimerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTimerByString takes string pTable,string pKey returns timer
    return LoadTimerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Trigger
function YDWESaveTriggerByInteger takes integer pTable,integer pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT,pTable,pKey,trg)
endfunction
function YDWESaveTriggerByString takes string pTable,string pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT,StringHash(pTable),StringHash(pKey),trg)
endfunction
function YDWEGetTriggerByInteger takes integer pTable,integer pKey returns trigger
    return LoadTriggerHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerByString takes string pTable,string pKey returns trigger
    return LoadTriggerHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Location
function YDWESaveLocationByInteger takes integer pTable,integer pKey,location pt returns nothing
    call SaveLocationHandle(YDHT,pTable,pKey,pt)
endfunction
function YDWESaveLocationByString takes string pTable,string pKey,location pt returns nothing
    call SaveLocationHandle(YDHT,StringHash(pTable),StringHash(pKey),pt)
endfunction
function YDWEGetLocationByInteger takes integer pTable,integer pKey returns location
    return LoadLocationHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLocationByString takes string pTable,string pKey returns location
    return LoadLocationHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Group
function YDWESaveGroupByInteger takes integer pTable,integer pKey,group g returns nothing
    call SaveGroupHandle(YDHT,pTable,pKey,g)
endfunction
function YDWESaveGroupByString takes string pTable,string pKey,group g returns nothing
    call SaveGroupHandle(YDHT,StringHash(pTable),StringHash(pKey),g)
endfunction
function YDWEGetGroupByInteger takes integer pTable,integer pKey returns group
    return LoadGroupHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetGroupByString takes string pTable,string pKey returns group
    return LoadGroupHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Multiboard
function YDWESaveMultiboardByInteger takes integer pTable,integer pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT,pTable,pKey,m)
endfunction
function YDWESaveMultiboardByString takes string pTable,string pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT,StringHash(pTable),StringHash(pKey),m)
endfunction
function YDWEGetMultiboardByInteger takes integer pTable,integer pKey returns multiboard
    return LoadMultiboardHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetMultiboardByString takes string pTable,string pKey returns multiboard
    return LoadMultiboardHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert MultiboardItem
function YDWESaveMultiboardItemByInteger takes integer pTable,integer pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT,pTable,pKey,mt)
endfunction
function YDWESaveMultiboardItemByString takes string pTable,string pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT,StringHash(pTable),StringHash(pKey),mt)
endfunction
function YDWEGetMultiboardItemByInteger takes integer pTable,integer pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetMultiboardItemByString takes string pTable,string pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert TextTag
function YDWESaveTextTagByInteger takes integer pTable,integer pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT,pTable,pKey,tt)
endfunction
function YDWESaveTextTagByString takes string pTable,string pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT,StringHash(pTable),StringHash(pKey),tt)
endfunction
function YDWEGetTextTagByInteger takes integer pTable,integer pKey returns texttag
    return LoadTextTagHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTextTagByString takes string pTable,string pKey returns texttag
    return LoadTextTagHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Lightning
function YDWESaveLightningByInteger takes integer pTable,integer pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT,pTable,pKey,ln)
endfunction
function YDWESaveLightningByString takes string pTable,string pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT,StringHash(pTable),StringHash(pKey),ln)
endfunction
function YDWEGetLightningByInteger takes integer pTable,integer pKey returns lightning
    return LoadLightningHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLightningByString takes string pTable,string pKey returns lightning
    return LoadLightningHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Region
function YDWESaveRegionByInteger takes integer pTable,integer pKey,region rn returns nothing
    call SaveRegionHandle(YDHT,pTable,pKey,rn)
endfunction
function YDWESaveRegionByString takes string pTable,string pKey,region rt returns nothing
    call SaveRegionHandle(YDHT,StringHash(pTable),StringHash(pKey),rt)
endfunction
function YDWEGetRegionByInteger takes integer pTable,integer pKey returns region
    return LoadRegionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetRegionByString takes string pTable,string pKey returns region
    return LoadRegionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Rect
function YDWESaveRectByInteger takes integer pTable,integer pKey,rect rn returns nothing
    call SaveRectHandle(YDHT,pTable,pKey,rn)
endfunction
function YDWESaveRectByString takes string pTable,string pKey,rect rt returns nothing
    call SaveRectHandle(YDHT,StringHash(pTable),StringHash(pKey),rt)
endfunction
function YDWEGetRectByInteger takes integer pTable,integer pKey returns rect
    return LoadRectHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetRectByString takes string pTable,string pKey returns rect
    return LoadRectHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Leaderboard
function YDWESaveLeaderboardByInteger takes integer pTable,integer pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT,pTable,pKey,lb)
endfunction
function YDWESaveLeaderboardByString takes string pTable,string pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT,StringHash(pTable),StringHash(pKey),lb)
endfunction
function YDWEGetLeaderboardByInteger takes integer pTable,integer pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetLeaderboardByString takes string pTable,string pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Effect
function YDWESaveEffectByInteger takes integer pTable,integer pKey,effect e returns nothing
    call SaveEffectHandle(YDHT,pTable,pKey,e)
endfunction
function YDWESaveEffectByString takes string pTable,string pKey,effect e returns nothing
    call SaveEffectHandle(YDHT,StringHash(pTable),StringHash(pKey),e)
endfunction
function YDWEGetEffectByInteger takes integer pTable,integer pKey returns effect
    return LoadEffectHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetEffectByString takes string pTable,string pKey returns effect
    return LoadEffectHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert Destructable
function YDWESaveDestructableByInteger takes integer pTable,integer pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT,pTable,pKey,da)
endfunction
function YDWESaveDestructableByString takes string pTable,string pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT,StringHash(pTable),StringHash(pKey),da)
endfunction
function YDWEGetDestructableByInteger takes integer pTable,integer pKey returns destructable
    return LoadDestructableHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetDestructableByString takes string pTable,string pKey returns destructable
    return LoadDestructableHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert triggercondition
function YDWESaveTriggerConditionByInteger takes integer pTable,integer pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT,pTable,pKey,tc)
endfunction
function YDWESaveTriggerConditionByString takes string pTable,string pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT,StringHash(pTable),StringHash(pKey),tc)
endfunction
function YDWEGetTriggerConditionByInteger takes integer pTable,integer pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerConditionByString takes string pTable,string pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert triggeraction
function YDWESaveTriggerActionByInteger takes integer pTable,integer pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT,pTable,pKey,ta)
endfunction
function YDWESaveTriggerActionByString takes string pTable,string pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT,StringHash(pTable),StringHash(pKey),ta)
endfunction
function YDWEGetTriggerActionByInteger takes integer pTable,integer pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerActionByString takes string pTable,string pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert event
function YDWESaveTriggerEventByInteger takes integer pTable,integer pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT,pTable,pKey,et)
endfunction
function YDWESaveTriggerEventByString takes string pTable,string pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT,StringHash(pTable),StringHash(pKey),et)
endfunction
function YDWEGetTriggerEventByInteger takes integer pTable,integer pKey returns event
    return LoadTriggerEventHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTriggerEventByString takes string pTable,string pKey returns event
    return LoadTriggerEventHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert force
function YDWESaveForceByInteger takes integer pTable,integer pKey,force fc returns nothing
    call SaveForceHandle(YDHT,pTable,pKey,fc)
endfunction
function YDWESaveForceByString takes string pTable,string pKey,force fc returns nothing
    call SaveForceHandle(YDHT,StringHash(pTable),StringHash(pKey),fc)
endfunction
function YDWEGetForceByInteger takes integer pTable,integer pKey returns force
    return LoadForceHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetForceByString takes string pTable,string pKey returns force
    return LoadForceHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert boolexpr
function YDWESaveBoolexprByInteger takes integer pTable,integer pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT,pTable,pKey,be)
endfunction
function YDWESaveBoolexprByString takes string pTable,string pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT,StringHash(pTable),StringHash(pKey),be)
endfunction
function YDWEGetBoolexprByInteger takes integer pTable,integer pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetBoolexprByString takes string pTable,string pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert sound
function YDWESaveSoundByInteger takes integer pTable,integer pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT,pTable,pKey,sd)
endfunction
function YDWESaveSoundByString takes string pTable,string pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT,StringHash(pTable),StringHash(pKey),sd)
endfunction
function YDWEGetSoundByInteger takes integer pTable,integer pKey returns sound
    return LoadSoundHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetSoundByString takes string pTable,string pKey returns sound
    return LoadSoundHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert timerdialog
function YDWESaveTimerDialogByInteger takes integer pTable,integer pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT,pTable,pKey,td)
endfunction
function YDWESaveTimerDialogByString takes string pTable,string pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT,StringHash(pTable),StringHash(pKey),td)
endfunction
function YDWEGetTimerDialogByInteger takes integer pTable,integer pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTimerDialogByString takes string pTable,string pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert trackable
function YDWESaveTrackableByInteger takes integer pTable,integer pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT,pTable,pKey,ta)
endfunction
function YDWESaveTrackableByString takes string pTable,string pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT,StringHash(pTable),StringHash(pKey),ta)
endfunction
function YDWEGetTrackableByInteger takes integer pTable,integer pKey returns trackable
    return LoadTrackableHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetTrackableByString takes string pTable,string pKey returns trackable
    return LoadTrackableHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert dialog
function YDWESaveDialogByInteger takes integer pTable,integer pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT,pTable,pKey,d)
endfunction
function YDWESaveDialogByString takes string pTable,string pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT,StringHash(pTable),StringHash(pKey),d)
endfunction
function YDWEGetDialogByInteger takes integer pTable,integer pKey returns dialog
    return LoadDialogHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetDialogByString takes string pTable,string pKey returns dialog
    return LoadDialogHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert button
function YDWESaveButtonByInteger takes integer pTable,integer pKey,button bt returns nothing
    call SaveButtonHandle(YDHT,pTable,pKey,bt)
endfunction
function YDWESaveButtonByString takes string pTable,string pKey,button bt returns nothing
    call SaveButtonHandle(YDHT,StringHash(pTable),StringHash(pKey),bt)
endfunction
function YDWEGetButtonByInteger takes integer pTable,integer pKey returns button
    return LoadButtonHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetButtonByString takes string pTable,string pKey returns button
    return LoadButtonHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert quest
function YDWESaveQuestByInteger takes integer pTable,integer pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT,pTable,pKey,qt)
endfunction
function YDWESaveQuestByString takes string pTable,string pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT,StringHash(pTable),StringHash(pKey),qt)
endfunction
function YDWEGetQuestByInteger takes integer pTable,integer pKey returns quest
    return LoadQuestHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetQuestByString takes string pTable,string pKey returns quest
    return LoadQuestHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
//Covert questitem
function YDWESaveQuestItemByInteger takes integer pTable,integer pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT,pTable,pKey,qi)
endfunction
function YDWESaveQuestItemByString takes string pTable,string pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT,StringHash(pTable),StringHash(pKey),qi)
endfunction
function YDWEGetQuestItemByInteger takes integer pTable,integer pKey returns questitem
    return LoadQuestItemHandle(YDHT,pTable,pKey)
endfunction
function YDWEGetQuestItemByString takes string pTable,string pKey returns questitem
    return LoadQuestItemHandle(YDHT,StringHash(pTable),StringHash(pKey))
endfunction
function YDWES2I takes string s returns integer
    return StringHash(s)
endfunction
function YDWESaveAbilityHandleBJ takes integer AbilityID, integer key, integer missionKey, hashtable table returns nothing
    call SaveInteger(table,missionKey,key,AbilityID)
endfunction
function YDWESaveAbilityHandle takes hashtable table, integer parentKey, integer childKey, integer AbilityID returns nothing
    call SaveInteger(table,parentKey,childKey,AbilityID)
endfunction
function YDWELoadAbilityHandleBJ takes integer key, integer missionKey, hashtable table returns integer
    return LoadInteger(table,missionKey,key)
endfunction
function YDWELoadAbilityHandle takes hashtable table, integer parentKey, integer childKey returns integer
    return LoadInteger(table,parentKey,childKey)
endfunction
//===========================================================================
//杩斿洖鍙傛暟
//===========================================================================
//鍦板浘杈圭晫鍒ゆ柇
function YDWECoordinateX takes real x returns real
    return RMinBJ(RMaxBJ(x, yd_MapMinX), yd_MapMaxX)
endfunction
function YDWECoordinateY takes real y returns real
    return RMinBJ(RMaxBJ(y, yd_MapMinY), yd_MapMaxY)
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮窛绂?
function YDWEDistanceBetweenUnits takes unit a,unit b returns real
    return SquareRoot((GetUnitX(a)-GetUnitX(b))*(GetUnitX(a)-GetUnitX(b))+(GetUnitY(a)-GetUnitY(b))*(GetUnitY(a)-GetUnitY(b)))
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮搴?
function YDWEAngleBetweenUnits takes unit fromUnit, unit toUnit returns real
    return bj_RADTODEG * Atan2(GetUnitY(toUnit) - GetUnitY(fromUnit), GetUnitX(toUnit) - GetUnitX(fromUnit))
endfunction
//鐢熸垚鍖哄煙
function YDWEGetRect takes real x,real y,real width, real height returns rect
    return Rect( x - width*0.5, y - height*0.5, x + width*0.5, y + height*0.5 )
endfunction
//===========================================================================
//璁剧疆鍗曚綅鍙互椋炶
//===========================================================================
function YDWEFlyEnable takes unit u returns nothing
    call UnitAddAbility(u,'Amrf')
    call UnitRemoveAbility(u,'Amrf')
endfunction
//===========================================================================
//瀛楃绐滀笌ID杞崲
//===========================================================================
function YDWEId2S takes integer value returns string
    local string charMap=bj_AllString
    local string result = ""
    local integer remainingValue = value
    local integer charValue
    local integer byteno
    set byteno = 0
    loop
        set charValue = ModuloInteger(remainingValue, 256)
        set remainingValue = remainingValue / 256
        set result = SubString(charMap, charValue, charValue + 1) + result
        set byteno = byteno + 1
        exitwhen byteno == 4
    endloop
    return result
endfunction
function YDWES2Id takes string targetstr returns integer
    local string originstr=bj_AllString
    local integer strlength=StringLength(targetstr)
    local integer a=0 //鍒嗛儴褰撳墠鏁板瓧
local integer b=0 //褰撳墠澶勭悊瀛?
local integer numx=1 //浣嶆潈
local integer result=0
    loop
    exitwhen b>strlength-1
        set numx=R2I(Pow(256,strlength-1-b))
        set a=1
        loop
            exitwhen a>255
            if SubString(targetstr,b,b+1)==SubString(originstr,a,a+1) then
                set result=result+a*numx
                set a=256
            endif
            set a=a+1
        endloop
        set b=b+1
    endloop
    return result
endfunction
function YDWES2UnitId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function YDWES2ItemId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function GetLastAbilityCastingUnit takes nothing returns unit
    return bj_lastAbilityCastingUnit
endfunction
function GetLastAbilityTargetUnit takes nothing returns unit
    return bj_lastAbilityTargetUnit
endfunction
function YDWESetMapLimitCoordinate takes real MinX,real MaxX,real MinY,real MaxY returns nothing
    set yd_MapMaxX=MaxX
    set yd_MapMinX=MinX
    set yd_MapMaxY=MaxY
    set yd_MapMinY=MinY
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//YDWE鐗规畩鎶€鑳界粨鏉熶簨浠?
function YDWESyStemAbilityCastingOverTriggerAction takes unit hero, integer index returns nothing
	local integer i = 0
    loop
        exitwhen i >= YDWEBase___AbilityCastingOverEventNumber
        if YDWEBase___AbilityCastingOverEventType[i] == index then
            set bj_lastAbilityCastingUnit = hero 
			if YDWEBase___AbilityCastingOverEventQueue[i] != null and TriggerEvaluate(YDWEBase___AbilityCastingOverEventQueue[i]) and IsTriggerEnabled(YDWEBase___AbilityCastingOverEventQueue[i]) then
				call TriggerExecute(YDWEBase___AbilityCastingOverEventQueue[i])
			endif
		endif
        set i = i + 1 
    endloop
endfunction
//===========================================================================  
//YDWE鎶€鑳芥崟鎹変簨浠?
//===========================================================================  
function YDWESyStemAbilityCastingOverRegistTrigger takes trigger trg,integer index returns nothing 
	set YDWEBase___AbilityCastingOverEventQueue[YDWEBase___AbilityCastingOverEventNumber] = trg
	set YDWEBase___AbilityCastingOverEventType[YDWEBase___AbilityCastingOverEventNumber] = index
	set YDWEBase___AbilityCastingOverEventNumber = YDWEBase___AbilityCastingOverEventNumber + 1 
endfunction 
//===========================================================================
//绯荤粺鍑芥暟瀹屽杽
//===========================================================================
function YDWECreateUnitPool takes nothing returns nothing
    set bj_lastCreatedUnitPool=CreateUnitPool()
endfunction
function YDWEPlaceRandomUnit takes unitpool up,player p,real x,real y,real face returns nothing //unitpool,player,real,real,real
set bj_lastPoolAbstractedUnit=PlaceRandomUnit(up,p,x,y,face)
endfunction
function YDWEGetLastUnitPool takes nothing returns unitpool
    return bj_lastCreatedUnitPool
endfunction
function YDWEGetLastPoolAbstractedUnit takes nothing returns unit
    return bj_lastPoolAbstractedUnit
endfunction
function YDWECreateItemPool takes nothing returns nothing
    set bj_lastCreatedItemPool=CreateItemPool()
endfunction
function YDWEPlaceRandomItem takes itempool ip,real x,real y returns nothing //unitpool,player,real,real,real
set bj_lastPoolAbstractedItem=PlaceRandomItem(ip,x,y)
endfunction
function YDWEGetLastItemPool takes nothing returns itempool
    return bj_lastCreatedItemPool
endfunction
function YDWEGetLastPoolAbstractedItem takes nothing returns item
    return bj_lastPoolAbstractedItem
endfunction
function YDWESetAttackDamageWeaponType takes attacktype at,damagetype dt,weapontype wt returns nothing
    set bj_lastSetAttackType=at
    set bj_lastSetDamageType=dt
    set bj_lastSetWeaponType=wt
endfunction
//unitpool bj_lastCreatedPool=null
//unit bj_lastPoolAbstractedUnit=null
function YDWEGetPlayerColorString takes player p, string s returns string
    return YDWEBase___yd_PlayerColor[GetHandleId(GetPlayerColor(p))] + s + "|r"
endfunction
//===========================================================================
//===========================================================================
//绯荤粺鍑芥暟琛ュ厖
//===========================================================================
//===========================================================================
function YDWEGetUnitItemSoftId takes unit hero,item it returns integer
    local integer i = 0
    loop
         exitwhen i > 5
         if UnitItemInSlot(hero, i) == it then
            return i + 1
         endif
         set i = i + 1
    endloop
    return 0
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//===========================================================================
//鏄剧ず鐗堟湰
function YDWEVersion_Display takes nothing returns boolean
    call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 30,"|cFF1E90FF褰撳墠缂栬緫鍣ㄧ増鏈负锛?|r|cFF00FF00YDWE " + "1.26.9.617")
    return false
endfunction
function YDWEVersion_Init takes nothing returns nothing
    local trigger t = CreateTrigger()
    local integer i = 0
    loop
        exitwhen i == 12
        call TriggerRegisterPlayerChatEvent(t, Player(i), "YDWE Version", true)
        set i = i + 1
    endloop
    call TriggerAddCondition(t, Condition(function YDWEVersion_Display))
    set t = null
endfunction
function InitializeYD takes nothing returns nothing
     set YDHT=InitHashtable() 
	//=================璁剧疆鍙橀噺=====================
	set yd_MapMinX = GetCameraBoundMinX() - GetCameraMargin(CAMERA_MARGIN_LEFT)
	set yd_MapMinY = GetCameraBoundMinY() - GetCameraMargin(CAMERA_MARGIN_BOTTOM)
	set yd_MapMaxX = GetCameraBoundMaxX() + GetCameraMargin(CAMERA_MARGIN_RIGHT)
	set yd_MapMaxY = GetCameraBoundMaxY() + GetCameraMargin(CAMERA_MARGIN_TOP)
	
    set YDWEBase___yd_PlayerColor [0] = "|cFFFF0303"
    set YDWEBase___yd_PlayerColor [1] = "|cFF0042FF"
    set YDWEBase___yd_PlayerColor [2] = "|cFF1CE6B9"
    set YDWEBase___yd_PlayerColor [3] = "|cFF540081"
    set YDWEBase___yd_PlayerColor [4] = "|cFFFFFC01"
    set YDWEBase___yd_PlayerColor [5] = "|cFFFE8A0E"
    set YDWEBase___yd_PlayerColor [6] = "|cFF20C000"
    set YDWEBase___yd_PlayerColor [7] = "|cFFE55BB0"
    set YDWEBase___yd_PlayerColor [8] = "|cFF959697"
    set YDWEBase___yd_PlayerColor [9] = "|cFF7EBFF1"
    set YDWEBase___yd_PlayerColor[10] = "|cFF106246"
    set YDWEBase___yd_PlayerColor[11] = "|cFF4E2A04"
    set YDWEBase___yd_PlayerColor[12] = "|cFF282828"
    set YDWEBase___yd_PlayerColor[13] = "|cFF282828"
    set YDWEBase___yd_PlayerColor[14] = "|cFF282828"
    set YDWEBase___yd_PlayerColor[15] = "|cFF282828"
    //=================鏄剧ず鐗堟湰=====================
    call YDWEVersion_Init()
endfunction

//library YDWEBase ends
//library YDWEPolledWaitNull:
function YDWEPolledWaitNull takes real duration returns nothing
    local timer t
    local real timeRemaining
    if (duration > 0) then
        set t = CreateTimer()
        call TimerStart(t, duration, false, null)
        loop
            set timeRemaining = TimerGetRemaining(t)
            exitwhen timeRemaining <= 0
            // If we have a bit of time left, skip past 10% of the remaining
            // duration instead of checking every interval, to minimize the
            // polling on long waits.
            if (timeRemaining > bj_POLLED_WAIT_SKIP_THRESHOLD) then
                call TriggerSleepAction(0.1 * timeRemaining)
            else
                call TriggerSleepAction(bj_POLLED_WAIT_INTERVAL)
            endif
        endloop
        call DestroyTimer(t)
    endif
    set t = null
endfunction

//library YDWEPolledWaitNull ends
//library YDWETriggerEvent:
	
//===========================================================================  
//任意单位伤害事件 
//===========================================================================
function YDWEAnyUnitDamagedTriggerAction takes nothing returns nothing
    local integer i = 0
    
    loop
        exitwhen i >= YDWETriggerEvent___DamageEventNumber
        if YDWETriggerEvent___DamageEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent___DamageEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent___DamageEventQueue[i]) then
            call TriggerExecute(YDWETriggerEvent___DamageEventQueue[i])
        endif
        set i = i + 1 
    endloop 
endfunction
function YDWEAnyUnitDamagedFilter takes nothing returns boolean 
    if GetUnitAbilityLevel(GetFilterUnit(), 'Aloc') <= 0 then 
        call TriggerRegisterUnitEvent(yd_DamageEventTrigger, GetFilterUnit(), EVENT_UNIT_DAMAGED)
    endif
    return false
endfunction
function YDWEAnyUnitDamagedEnumUnit takes nothing returns nothing 
    local trigger t = CreateTrigger()
    local region r = CreateRegion()
    local group g = CreateGroup()
    call RegionAddRect(r, GetWorldBounds())
    call TriggerRegisterEnterRegion(t, r, Condition(function YDWEAnyUnitDamagedFilter))
    call GroupEnumUnitsInRect(g, GetWorldBounds(), Condition(function YDWEAnyUnitDamagedFilter))
    call DestroyGroup(g)
    set r = null
    set t = null
    set g = null
endfunction
	
function YDWESyStemAnyUnitDamagedRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent___DamageEventNumber == 0 then
        set yd_DamageEventTrigger = CreateTrigger()
        call TriggerAddAction(yd_DamageEventTrigger, function YDWEAnyUnitDamagedTriggerAction) 
        call YDWEAnyUnitDamagedEnumUnit()
    endif 
    
    set YDWETriggerEvent___DamageEventQueue[YDWETriggerEvent___DamageEventNumber] = trg
    set YDWETriggerEvent___DamageEventNumber = YDWETriggerEvent___DamageEventNumber + 1
endfunction
//===========================================================================  
//移动物品事件 
//===========================================================================  
function YDWESyStemItemUnmovableTriggerAction takes nothing returns nothing
    local integer i = 0
    
    if GetIssuedOrderId() >= 852002 and GetIssuedOrderId() <= 852007 then 
		set bj_lastMovedItemInItemSlot = GetOrderTargetItem() 
    	loop
        	exitwhen i >= YDWETriggerEvent___MoveItemEventNumber
        	if YDWETriggerEvent___MoveItemEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent___MoveItemEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent___MoveItemEventQueue[i]) then
        	    call TriggerExecute(YDWETriggerEvent___MoveItemEventQueue[i])
        	endif
        	set i = i + 1 
    	endloop 
	endif	
endfunction
function YDWESyStemItemUnmovableRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent___MoveItemEventNumber == 0 then
        set YDWETriggerEvent___MoveItemEventTrigger = CreateTrigger()
        call TriggerAddAction(YDWETriggerEvent___MoveItemEventTrigger, function YDWESyStemItemUnmovableTriggerAction) 
        call TriggerRegisterAnyUnitEventBJ(YDWETriggerEvent___MoveItemEventTrigger, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    endif 
    
    set YDWETriggerEvent___MoveItemEventQueue[YDWETriggerEvent___MoveItemEventNumber] = trg
    set YDWETriggerEvent___MoveItemEventNumber = YDWETriggerEvent___MoveItemEventNumber + 1
endfunction
function GetLastMovedItemInItemSlot takes nothing returns item
    return bj_lastMovedItemInItemSlot
endfunction

//library YDWETriggerEvent ends
//library YDWETriggerRegisterEnterRectSimpleNull:
function YDWETriggerRegisterEnterRectSimpleNull takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion = rectRegion
    set rectRegion = null
    return TriggerRegisterEnterRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterEnterRectSimpleNull ends
//library YDWETriggerRegisterLeaveRectSimpleNull:
function YDWETriggerRegisterLeaveRectSimpleNull takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion = rectRegion
    set rectRegion = null
    return TriggerRegisterLeaveRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterLeaveRectSimpleNull ends
//library AIStrategy:
function InitAIStrategy takes nothing returns nothing
call DefaultAIStrategy.create()
endfunction
interface IAIStrategy 
method targetInRange takes unit u ,real r returns nothing
method beHurted takes unit u returns nothing
method getInMap takes unit u
method getTypeId takes nothing returns integer
endinterface
struct DefaultAIStrategy extends IAIStrategy
implement List
static method create takes nothing returns DefaultAIStrategy
local DefaultAIStrategy s=DefaultAIStrategy.allocate()
call s.addList()
return s
endmethod
method onDestroy takes nothing returns nothing
call removeList()
endmethod
method getTypeId takes nothing returns integer
return 123
endmethod
method targetInRange takes unit u,real r returns nothing
endmethod
method beHurted takes unit u returns nothing
local unit tu=AIData[u].targetUnit
local real d=DistanceTwoUnits(u,tu)
if d>800 then
call IssuePointOrderById( u, 851983, GetUnitX(tu), GetUnitY(tu))
endif
endmethod
method getInMap takes unit u returns nothing
call gDefaultAIGroup.addUnit(u)
endmethod
static method findStrategy takes integer typeid returns IAIStrategy
local DefaultAIStrategy p=getFirst()
loop
    exitwhen p==0
    if p.getTypeId()==typeid then
        return p
    endif
    set p=p.getNext()
endloop
return p
endmethod
endstruct

//library AIStrategy ends
//library AutoIndex:
    module AutoData
        private static thistype array data
        
        // Fixed up the below to use thsitype instead of integer.
        static method operator []= takes unit u, thistype i returns nothing
            set .data[GetUnitId(u)] = i //Just attaching a struct to the unit
endmethod //using the module's thistype array.

        static method operator [] takes unit u returns thistype
            return .data[GetUnitId(u)] //Just returning the attached struct.
endmethod
    endmodule

//library AutoIndex ends
//library Constants:
function GetGrenadeVector takes real ux, real uy, real tx, real ty returns vector
    local vector v = vector.create(tx - ux, ty - uy, 0)
    set v.z = v.getLength() * 2
    return v
endfunction
function GetGrenadeTrajectory takes real ux, real uy, real tx, real ty returns real
    local real d = SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2))
    local real v = SquareRoot(d*g/Sin(2*GRENADEDEG)) / 2.25
    return v
endfunction
function InitConstants takes nothing returns nothing
endfunction

//library Constants ends
//library Damage:
    //============================================================
    ////! external ObjectMerger w3a AIlz dprv anam "Life Bonus" ansf "(Damage System)" Ilif 1 500000 aite 0
    
    //============================================================
    
    function Damage_RegisterEvent takes trigger whichTrigger returns nothing
        call Damage___OnDamageEvent.register(whichTrigger)
    endfunction
    
    function Damage_EnableEvent takes boolean enable returns nothing
        set Damage___EventEnabled=enable
    endfunction
    
    //============================================================
    
    function Damage_GetType takes nothing returns damagetype
        return Damage___TypeStackValue[Damage___TypeStackLevel]
    endfunction
    
    function Damage_Block takes real amount returns nothing
        set Damage___ToBlock[Damage___TypeStackLevel]=Damage___ToBlock[Damage___TypeStackLevel]+amount
    endfunction
    
    function Damage_BlockAll takes nothing returns nothing
        set Damage___ToBlock[Damage___TypeStackLevel]=Damage___ToBlock[Damage___TypeStackLevel]+GetEventDamage()
    endfunction
    
    //============================================================
    
    //============================================================
    
    function Damage___RemoveBoostedTimerFunc takes nothing returns nothing
        loop
            exitwhen Damage___RemoveBoostedMax==0
            set Damage___BoostedLifeUnit=Damage___RemoveBoosted[Damage___RemoveBoostedMax]
            set Damage___BoostedLifeTemp=GetWidgetLife(Damage___BoostedLifeUnit)
            call UnitRemoveAbility(Damage___BoostedLifeUnit,Damage___LIFE_BONUS_ABIL)
            if Damage___BoostedLifeTemp>0.405 then
                call SetWidgetLife(Damage___BoostedLifeUnit,Damage___BoostedLifeTemp)
            endif
            set Damage___RemoveBoostedMax=Damage___RemoveBoostedMax-1
        endloop
    endfunction
    
    //============================================================
    function Damage___OnDamageActions takes nothing returns boolean
        if Damage___EventEnabled then
            call Damage___OnDamageEvent.fire()
        endif
        if Damage___ToBlock[Damage___TypeStackLevel]!=0. then
            //====================================================
            // Blocking
            set Damage___ForUnit=GetTriggerUnit()
            
            set Damage___NextHealth=GetEventDamage()
            if Damage___ToBlock[Damage___TypeStackLevel]>=Damage___NextHealth then
                set Damage___NextHealth=GetWidgetLife(Damage___ForUnit)+Damage___NextHealth
            else
                set Damage___NextHealth=GetWidgetLife(Damage___ForUnit)+Damage___ToBlock[Damage___TypeStackLevel]
            endif
            
            call SetWidgetLife(Damage___ForUnit,Damage___NextHealth)
            if GetWidgetLife(Damage___ForUnit)<Damage___NextHealth then
                // NextHealth is over max health.
                call UnitAddAbility(Damage___ForUnit,Damage___LIFE_BONUS_ABIL)
                call SetWidgetLife(Damage___ForUnit,Damage___NextHealth)
                
                set Damage___RemoveBoostedMax=Damage___RemoveBoostedMax+1
                set Damage___RemoveBoosted[Damage___RemoveBoostedMax]=Damage___ForUnit
                call ResumeTimer(Damage___RemoveBoostedTimer)
            endif
            //====================================================
            set Damage___ToBlock[Damage___TypeStackLevel]=0.
        endif
        return false
    endfunction
    
    //============================================================
    function UnitDamageTargetEx takes unit whichUnit, widget target, real amount, boolean attack, boolean ranged, attacktype attackType, damagetype damageType, weapontype weaponType returns boolean
        local boolean result
        set Damage___TypeStackLevel=Damage___TypeStackLevel+1
        set Damage___TypeStackValue[Damage___TypeStackLevel]=damageType
        set result=UnitDamageTarget(whichUnit,target,amount,attack,ranged,attackType,damageType,weaponType)
        set Damage___TypeStackLevel=Damage___TypeStackLevel-1
        return result
    endfunction
    
//textmacro instance: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
        function Damage_Pure takes unit source, unit target, real amount returns boolean
            return UnitDamageTargetEx(source,target,amount,false,false,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_UNIVERSAL,WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
//textmacro instance: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
        function Damage_Spell takes unit source, unit target, real amount returns boolean
            return UnitDamageTargetEx(source,target,amount,false,false,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
    
    // Uses different stuff, but works much the same way.
    function Damage_Physical takes unit source, unit target, real amount, attacktype whichType, boolean attack, boolean ranged returns boolean
        return UnitDamageTargetEx(source,target,amount,attack,ranged,whichType,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    //============================================================
    struct Damage___Detector extends array // Uses AIDS.
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()

        private static conditionfunc ACTIONS_COND
        
        private trigger t
        
        private method AIDS_onCreate takes nothing returns nothing
            set this.t=CreateTrigger()
            call TriggerAddCondition(this.t,thistype.ACTIONS_COND)
            call TriggerRegisterUnitEvent(this.t,this.unit,EVENT_UNIT_DAMAGED)
        endmethod
        
        private method AIDS_onDestroy takes nothing returns nothing
            call DestroyTrigger(this.t)
        endmethod
        
        private static method AIDS_onInit takes nothing returns nothing
            set thistype.ACTIONS_COND=Condition(function Damage___OnDamageActions)
        endmethod
    endstruct
    
    //============================================================
    function Damage___OnInit takes nothing returns nothing
        local unit abilpreload=CreateUnit(Player(15),'uloc',0,0,0)
        call UnitAddAbility(abilpreload,Damage___LIFE_BONUS_ABIL)
        call RemoveUnit(abilpreload)
        set abilpreload=null
        
        set Damage___OnDamageEvent=Event.create()
        set Damage___TypeStackValue[Damage___TypeStackLevel]=DAMAGE_TYPE_NORMAL
        call TimerStart(Damage___RemoveBoostedTimer,0.0,false,function Damage___RemoveBoostedTimerFunc)
    endfunction

//library Damage ends
//library Direction:
function getDir takes real sx,real sy,real tx,real ty returns real
    return Atan2(ty-sy,tx-sx)
endfunction
function getDeg takes real y, real x returns real
    return Rad2Deg(Atan2(y,x))
endfunction
function getFacing takes unit u returns real
    return Deg2Rad(GetUnitFacing(u))
endfunction
function getTargetDir takes unit source, unit target returns real
    local real sx = GetUnitX(source)
    local real sy = GetUnitY(source)
    local real tx = GetUnitX(target)
    local real ty = GetUnitY(target)
    return getDir(sx, sy, tx, ty)
endfunction
function getDirVector takes unit owner, unit target, real speed returns vector
    local real tx = GetUnitX(target)
    local real ty = GetUnitY(target)
    local real tz = getUnitHeight(target)
    local real ux = GetUnitX(owner)
    local real uy = GetUnitY(owner)
    local real uz = getUnitHeight(owner)
    local vector t = vector.create(tx - ux, ty - uy, tz - uz)
    call t.setLength(speed)
    return t
endfunction

//library Direction ends
//library DispatchTechLevel:
function DispatchTechAdd takes integer id, integer lv, integer pid returns nothing
    if id == tKMANA then
        set EquipmentData[heros[pid]].heroData.kill_mana_percent = EquipmentData[heros[pid]].heroData.kill_mana_percent + 0.5
    endif
    if id == tAIM_SHOOT then
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist + 0.3
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.3
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist - 0.1
    endif
    if id == tSAVE then
        set EquipmentData[heros[pid]].heroData.save = EquipmentData[heros[pid]].heroData.save + 0.4
    endif
    if id == tSTRONG then
        set EquipmentData[heros[pid]].heroData.strong = EquipmentData[heros[pid]].heroData.strong + 0.2
    endif
    if id == tANTRAD then
        set EquipmentData[heros[pid]].heroData.antrad = EquipmentData[heros[pid]].heroData.antrad + 0.3
    endif
    if id == tDOGE then
        set EquipmentData[heros[pid]].heroData.doge = EquipmentData[heros[pid]].heroData.doge + 0.2
    endif
    if id == tFREZZ then
        set EquipmentData[heros[pid]].heroData.frezz = EquipmentData[heros[pid]].heroData.frezz + 0.05
    endif
    if id == tMANA_BOOM then
        set EquipmentData[heros[pid]].heroData.mana_boom_percent = EquipmentData[heros[pid]].heroData.mana_boom_percent + 0.3
    endif
endfunction
function DispatchTechLevelUp takes integer id, integer lv, integer pid returns nothing
    if id == tKMANA then
        set EquipmentData[heros[pid]].heroData.kill_mana_percent = EquipmentData[heros[pid]].heroData.kill_mana_percent + 0.05
    endif
    if id == tAIM_SHOOT then
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist + 0.025
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.1
        set EquipmentData[heros[pid]].heroData.shoot_rist = EquipmentData[heros[pid]].heroData.shoot_rist - 0.05
    endif
    if id == tSAVE then
        set EquipmentData[heros[pid]].heroData.save = EquipmentData[heros[pid]].heroData.save + 0.05
    endif
    if id == tSTRONG then
        set EquipmentData[heros[pid]].heroData.strong = EquipmentData[heros[pid]].heroData.strong + 0.02
    endif
    if id == tANTRAD then
        set EquipmentData[heros[pid]].heroData.antrad = EquipmentData[heros[pid]].heroData.antrad + 0.05
    endif
    if id == tDOGE then
        set EquipmentData[heros[pid]].heroData.doge = EquipmentData[heros[pid]].heroData.doge + 0.01
    endif
    if id == tFREZZ then
        set EquipmentData[heros[pid]].heroData.frezz = EquipmentData[heros[pid]].heroData.frezz + 0.01
    endif
    if id == tMANA_BOOM then
        set EquipmentData[heros[pid]].heroData.mana_boom_percent = EquipmentData[heros[pid]].heroData.mana_boom_percent + 0.15
    endif
endfunction

//library DispatchTechLevel ends
//library DoublePacket:
function InitDoublePacket takes nothing returns nothing
    set kpacau=GetNewKey()
endfunction
//涓や釜鍗曚綅浜ゆ崲鐗╁搧
function ItemSwitch takes unit Ua,unit Ub returns nothing 
      local item array Ia 
      local item array Ib 
      local item array Ic 
      local integer i = 0 
      local integer n = 0 
      loop 
            exitwhen i >5 
            if UnitItemInSlot(Ua, i) != null then 
                  set Ia[i]= UnitItemInSlot(Ua, i) 
                  call UnitRemoveItemFromSlot(Ua,i) 
            endif 
            if UnitItemInSlot(Ub, i) != null then 
                  set Ib[i]= UnitItemInSlot(Ub, i) 
                  call UnitRemoveItemFromSlot(Ub,i) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >5 
            if Ia[i] == null then 
               call UnitAddItem(Ub,CreateItem('mort',GetUnitX(Ub),GetUnitY(Ub))) 
               set Ic[n] = UnitItemInSlot(Ub, i) 
               set n=n+1 
               else 
               call UnitAddItem(Ub,Ia[i]) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            set i = i+1 
            exitwhen i >n 
            call RemoveItem(Ic[i]) 
            set Ic[i]=null 
      endloop 
//缁橝鐨勭墿鍝?     
      set i = 0 
      loop 
            exitwhen i >5 
            if Ib[i] == null then 
               call UnitAddItem(Ua,CreateItem('mort',GetUnitX(Ua),GetUnitY(Ua))) 
               set Ic[n]=UnitItemInSlot(Ua, i) 
               set n=n+1 
               else 
               call UnitAddItem(Ua,Ib[i]) 
            endif 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >n 
            call RemoveItem(Ic[i]) 
            set Ic[i]=null 
            set i = i+1 
      endloop 
      set i = 0 
      loop 
            exitwhen i >5 
            set Ia[i]=null 
            set Ib[i]=null 
            set i = i+1 
      endloop 
endfunction
//瑕嗙洊A鐨勭墿鍝佺粰B
function ItemCopy takes unit ua, unit ub returns nothing
    local integer i
    set i=0
    loop
        exitwhen i>5
        call RemoveItem(UnitItemInSlot(ub,i))
        set i=i+1
    endloop
    set i=0
    loop
        exitwhen i>5
        call UnitAddItem(ub,CreateItem(GetItemTypeId(UnitItemInSlot(ua,i)),0,0))
        set i=i+1
    endloop
endfunction
//鍒囨崲鑳屽寘
function SwapPackageCA takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer dec=GetHandleId(u)
    if GetSpellAbilityId()==gpacspl then
        call ItemSwitch(u,LoadUnitHandle(ht,dec,kpacau))
    endif
    set u=null
endfunction
//涓鸿嫳闆勭殑褰撳墠鐗╁搧鏍忔敞鍐屽弻6鑳屽寘
function RegisterDouble6Package takes unit u returns nothing
    local integer dec=GetHandleId(u)
    local integer i
    local trigger trg
    local unit tu
    if LoadUnitHandle(ht,dec,kpacau) == null then
        set tu=CreateUnit(GetOwningPlayer(u),gpacauid,0,0,0)
        call SaveUnitHandle(ht,dec,kpacau,tu)
        set trg=CreateTrigger()
        call TriggerRegisterUnitEvent( trg, u, EVENT_UNIT_SPELL_EFFECT )
        call TriggerAddCondition(trg,function SwapPackageCA)
    endif
    set trg=null
    set tu=null
endfunction

//library DoublePacket ends
//library EquipmentData:
struct EquipmentData extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    
    implement T32xs
    
    IGun gun
    
    IHeroData heroData
    
    static method AIDS_filter takes unit u returns boolean
        if IsHero(u) or GetUnitTypeId(u) == EVIL_MARIN then
            return true
        endif
        return false
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        //set this.gun = IceMachineGun.create(.unit)
        set this.heroData = IHeroData.create()
        set this.heroData.bullets = gun.shooter.getClipSize()
        set this.heroData.shoot_energy_max = 100
        set this.heroData.shoot_energy = 100
        set this.heroData.shoot_energy_reg = 1
        set this.heroData.shoot_range_buff = 0
        //set this.heroData.shoot_speed_buff = 0.0
        //set this.heroData.last_shoot_tick = -999
        set this.heroData.reload = false
        set this.heroData.shoot_rist = 0.0
        set this.heroData.a_shoot_back = 0.0
        set this.heroData.a_shoot_back_log = 0.0
        set this.heroData.kill_mana_percent = 0.0
        set this.heroData.mana_boom_percent = 0.0
        set this.heroData.up_point = 10
        set this.heroData.bonus_point = 0
        set this.heroData.tech_counter = TechCounter.create()
        set this.heroData.tech_counter.cnt[TT_GENERAL] = 1
        set this.heroData.tech_counter.size = 1
        set this.heroData.save = 0.0
        set this.heroData.strong = 0.0
        set this.heroData.antrad = 0.0
        set this.heroData.doge = 0
        set this.heroData.frezz = 0.0
        set this.heroData.fire_charge = 1.0
        set this.heroData.machine_gun_buff = 1.0
        set this.heroData.vision = 2300
        call startPeriodic()
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
        
    endmethod
    
    method periodic takes nothing returns nothing
        local boolean reload = this.heroData.reload
        local real c = this.heroData.shoot_energy
        local real max = this.heroData.shoot_energy_max
        local real n = RMinBJ(max, c + this.heroData.shoot_energy_reg)
        if reload and c < max then
            set this.heroData.shoot_energy = n
            if n == max then
                if IsHero(.unit) then
                    set this.heroData.reload = false
                    call UnitRemoveAbility(.unit, 'Abun')
                    call SetPlayerState(GetOwningPlayer(.unit),PLAYER_STATE_RESOURCE_LUMBER, gun.shooter.getClipSize())
                    call DisplayFloatText(GetUnitX(.unit),GetUnitY(.unit),"R",1)
                else
                    set this.heroData.reload = false
                    call UnitRemoveAbility(.unit, 'Abun')
                    set this.heroData.bullets = gun.shooter.getClipSize()
                    call DisplayFloatText(GetUnitX(.unit),GetUnitY(.unit),"R",1)
                endif
            endif
        endif
    endmethod 
    
endstruct

//library EquipmentData ends
//library GroupUtils:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This library is a simple implementation of a stack for groups that need to
//* be in the user's control for greater than an instant of time. Additionally,
//* this library provides a single, global group variable for use with user-end
//* enumerations. It is important to note that users should not be calling
//* DestroyGroup() on the global group, since then it may not exist for when it
//* it is next needed.
//*
//* The group stack removes the need for destroying groups and replaces it with
//* a recycling method.
//*     function NewGroup takes nothing returns group
//*     function ReleaseGroup takes group g returns boolean
//*     function GroupRefresh takes group g returns nothing
//* 
//* NewGroup grabs a currently unused group from the stack or creates one if the
//* stack is empty. You can use this group however you'd like, but always
//* remember to call ReleaseGroup on it when you are done with it. If you don't
//* release it, it will 'leak' and your stack may eventually overflow if you
//* keep doing that.
//* 
//* GroupRefresh cleans a group of any shadow references which may be clogging
//* its hash table. If you remove a unit from the game who is a member of a unit
//* group, it will 'effectively' remove the unit from the group, but leave a
//* shadow in its place. Calling GroupRefresh on a group will clean up any
//* shadow references that may exist within it.
//******************************************************************************
    function GroupUtils___AddEx takes nothing returns nothing
        if GroupUtils___Flag then
            call GroupClear(GroupUtils___Refr)
            set GroupUtils___Flag = false
        endif
        call GroupAddUnit(GroupUtils___Refr, GetEnumUnit())
    endfunction
    
    function GroupRefresh takes group g returns nothing
        set GroupUtils___Flag = true
        set GroupUtils___Refr = g
        call ForGroup(GroupUtils___Refr, function GroupUtils___AddEx)
        if GroupUtils___Flag then
            call GroupClear(g)
        endif
    endfunction
    function NewGroup takes nothing returns group
        if GroupUtils___Count == 0 then
            set GroupUtils___Groups[0] = CreateGroup()
        else
            set GroupUtils___Count = GroupUtils___Count - 1
        endif
        set GroupUtils___Status[GetHandleId(GroupUtils___Groups[GroupUtils___Count])-GroupUtils___MIN_HANDLE_ID] = 1
        return GroupUtils___Groups[GroupUtils___Count]
    endfunction
    function ReleaseGroup takes group g returns boolean
        local integer stat = GroupUtils___Status[GetHandleId(g)-GroupUtils___MIN_HANDLE_ID]
        if g == null then
            return false
        elseif stat == 0 then
            return false
        elseif stat == 2 then
            return false
        elseif GroupUtils___Count == 8191 then
            call DestroyGroup(g)
            return false
        else
            call GroupClear(g)
            set GroupUtils___Groups[GroupUtils___Count] = g
            set GroupUtils___Count = GroupUtils___Count + 1
            set GroupUtils___Status[GetHandleId(g)-GroupUtils___MIN_HANDLE_ID] = 2
        endif
        return true
    endfunction
    

//library GroupUtils ends
//library Gun:
interface IGun
    IShooter shooter
    IMissleFactory factory
    ItemFeatureData ifd
    method fire takes nothing returns nothing
    method stopFire takes nothing returns nothing
    method getGunType takes nothing returns integer
    method setOwner takes unit owner returns nothing
endinterface
struct DefaultGun extends IGun
    method fire takes nothing returns nothing
        if shooter.owner != null then
            call shooter.shoot(vector.create(0,0,0))
        endif
    endmethod
    
    method setOwner takes unit owner returns nothing
        set shooter.owner = owner
    endmethod
    
    method stopFire takes nothing returns nothing
    endmethod
    
    method getGunType takes nothing returns integer
        return SHOOT_GUN
    endmethod
    
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local DefaultGun g=DefaultGun.allocate()
        set g.factory=DefaultMissleFactory.create()
        set g.shooter=ShootGunShooter.create(owner,g.factory)
        set g.ifd = ifd
        return g
    endmethod
    
    method onDestroy takes nothing returns nothing
        call shooter.destroy()
        call factory.destroy()
    endmethod
endstruct
//textmacro instance: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
struct FireShotgun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local FireShotgun g=FireShotgun.allocate(owner, ifd)
        set g.factory=FireMissleFactory.create()
        set g.shooter=ShootGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
//textmacro instance: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
struct HumanRifle extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local HumanRifle g=HumanRifle.allocate(owner, ifd)
        set g.factory=DefaultMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
struct SpearRifle extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local SpearRifle g=SpearRifle.allocate(owner, ifd)
        set g.factory=SpearMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
struct IceMachineGun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local IceMachineGun g=IceMachineGun.allocate(owner, ifd)
        set g.factory=IceMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")
struct FireMachineGun extends DefaultGun
    static method create takes unit owner, ItemFeatureData ifd returns thistype
        local FireMachineGun g=FireMachineGun.allocate(owner, ifd)
        set g.factory=FireMissleFactory.create()
        set g.shooter=MachineGunShooter.create(owner,g.factory)
        return g
    endmethod
endstruct
//end of: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")

//library Gun ends
//library Heal:
    
    native UnitAlive takes unit id returns boolean
    
    struct HealType extends array
        private static integer Counter = 0
        static method new takes nothing returns thistype
            set thistype.Counter = thistype.Counter + 1
            return thistype.Counter
        endmethod
    endstruct
    
    
    function Heal_RegisterEvent takes trigger trig returns EventReg
        return Heal___HealEvent.register(trig)
    endfunction
    
    function Heal_UnregisterEvent takes trigger trig returns nothing
        call Heal___HealEvent.unregister(trig)
    endfunction
    
    function Heal_EnableEvent takes boolean flag returns nothing
        set Heal___IsEventEnabled = flag
    endfunction
    
    function Heal_GetSource takes nothing returns unit
        return Heal___HealerStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetTarget takes nothing returns unit
        return Heal___TargetStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetAmount takes nothing returns real
        return Heal___HealAmountStack[Heal___StackLevel]
    endfunction
    
    function Heal_Block takes real amount returns nothing
        set Heal___HealBlockStack[Heal___StackLevel] = Heal___HealBlockStack[Heal___StackLevel] + amount
    endfunction
    
    function Heal_BlockAll takes nothing returns nothing
        set Heal___HealBlockStack[Heal___StackLevel] = Heal___HealBlockStack[Heal___StackLevel] + Heal___HealAmountStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetType takes nothing returns HealType
        return Heal___TypeStack[Heal___StackLevel]
    endfunction
    
    function HealUnit takes unit healer, unit target, real amount, HealType htype returns boolean
        local real life
        local real maxlife
        if UnitAlive(healer) == true and UnitAlive(target) == true and amount > 0. then
            set life = GetWidgetLife(target)
            set maxlife = GetUnitState(target,UNIT_STATE_MAX_LIFE)
            call DestroyEffect( AddSpecialEffect(HEAL_EFFECT, GetUnitX(target), GetUnitY(target)) )
            if life == maxlife then
                return false//If target has full hp, no healing is done.
            else
                if life + amount > maxlife then
                    set amount = maxlife - life //if current hp + amount > max hp, set amount to max hp - current hp.
endif
                call SetWidgetLife(target,life + amount)
            endif
            if Heal___IsEventEnabled == true then
                set Heal___StackLevel = Heal___StackLevel + 1
                set Heal___HealerStack[Heal___StackLevel] = healer
                set Heal___TargetStack[Heal___StackLevel] = target
                set Heal___HealAmountStack[Heal___StackLevel] = amount
                set Heal___TypeStack[Heal___StackLevel] = htype
                set Heal___HealBlockStack[Heal___StackLevel] = 0.
                call Heal___HealEvent.fire()
                if Heal___HealBlockStack[Heal___StackLevel] > amount then
                    set Heal___HealBlockStack[Heal___StackLevel] = amount
                endif
                call SetWidgetLife(target,GetWidgetLife(target) - Heal___HealBlockStack[Heal___StackLevel])
                set Heal___StackLevel = Heal___StackLevel - 1
            endif
            return true
        endif
        return false
    endfunction
    
    function Heal___Init takes nothing returns nothing
        set Heal___HealEvent = Event.create()
        
        set HEAL_TYPE_NORMAL = HealType.new()
    endfunction

//library Heal ends
//library ItemData:
struct ItemFeature
    string name
    real origin
    real step
    integer lv 
    integer maxlv
    integer gold
    integer wood
    static method create takes string name, real origin, real step, integer lv, integer maxlv, integer gold, integer wood returns ItemFeature
        local ItemFeature m=ItemFeature.allocate()
        set m.name = name
        set m.origin =origin
        set m.step = step
        set m.lv = lv
        set m.maxlv = maxlv
        set m.gold = gold
        set m.wood = wood
        return m
    endmethod
    method getValue takes nothing returns real
        return origin + step * lv
    endmethod
endstruct
struct IndividualItemData extends array
    ItemFeatureData featureData
    
    private method AII_onCreate takes nothing returns nothing
        local integer ii = GetItemTypeId(this.item)
        set featureData = ItemFeatureData.construct(ii)
    endmethod
    
    implement AII
endstruct
struct ItemFeatureData
    ItemFeature f1
    ItemFeature f2
    ItemFeature f3
    ItemFeature f4
    ItemFeature f5
    IGun gun
    
    static method create takes ItemFeature f1,ItemFeature f2,ItemFeature f3,ItemFeature f4,ItemFeature f5, IGun gun returns ItemFeatureData
        local ItemFeatureData m=ItemFeatureData.allocate()
        set m.f1 = f1
        set m.f2 = f2
        set m.f3 = f3
        set m.f4 = f4
        set m.f5 = f5
        set m.gun = gun
        return m
    endmethod
    static method construct takes integer did returns ItemFeatureData
        local ItemFeature f1
        local ItemFeature f2
        local ItemFeature f3
        local ItemFeature f4
        local ItemFeature f5
        local integer id = did - 'I000'
        local IGun gun = 0
        local ItemFeatureData ifd = 0
//textmacro instance: CreateItemFeature("1")
    set f1 = ItemFeature.create(LoadStr(ifht1, id, ifht_name),LoadReal(ifht1, id, ifht_origin),LoadReal(ifht1, id, ifht_step),LoadInteger(ifht1, id, ifht_lv),LoadInteger(ifht1, id, ifht_max_lv),LoadInteger(ifht1, id, ifht_gold),LoadInteger(ifht1, id, ifht_wood))
//end of: CreateItemFeature("1")
//textmacro instance: CreateItemFeature("2")
    set f2 = ItemFeature.create(LoadStr(ifht2, id, ifht_name),LoadReal(ifht2, id, ifht_origin),LoadReal(ifht2, id, ifht_step),LoadInteger(ifht2, id, ifht_lv),LoadInteger(ifht2, id, ifht_max_lv),LoadInteger(ifht2, id, ifht_gold),LoadInteger(ifht2, id, ifht_wood))
//end of: CreateItemFeature("2")
//textmacro instance: CreateItemFeature("3")
    set f3 = ItemFeature.create(LoadStr(ifht3, id, ifht_name),LoadReal(ifht3, id, ifht_origin),LoadReal(ifht3, id, ifht_step),LoadInteger(ifht3, id, ifht_lv),LoadInteger(ifht3, id, ifht_max_lv),LoadInteger(ifht3, id, ifht_gold),LoadInteger(ifht3, id, ifht_wood))
//end of: CreateItemFeature("3")
//textmacro instance: CreateItemFeature("4")
    set f4 = ItemFeature.create(LoadStr(ifht4, id, ifht_name),LoadReal(ifht4, id, ifht_origin),LoadReal(ifht4, id, ifht_step),LoadInteger(ifht4, id, ifht_lv),LoadInteger(ifht4, id, ifht_max_lv),LoadInteger(ifht4, id, ifht_gold),LoadInteger(ifht4, id, ifht_wood))
//end of: CreateItemFeature("4")
//textmacro instance: CreateItemFeature("5")
    set f5 = ItemFeature.create(LoadStr(ifht5, id, ifht_name),LoadReal(ifht5, id, ifht_origin),LoadReal(ifht5, id, ifht_step),LoadInteger(ifht5, id, ifht_lv),LoadInteger(ifht5, id, ifht_max_lv),LoadInteger(ifht5, id, ifht_gold),LoadInteger(ifht5, id, ifht_wood))
//end of: CreateItemFeature("5")
        set ifd = ItemFeatureData.create(f1,f2,f3,f4,f5,gun)
        if LoadInteger(idht, did-'I000', idht_item_type) == GUN then
            if did == 'I001' then
                set gun = HumanRifle.create(null, ifd)
//textmacro instance: BindGun("'I00R'", "SpearRifle")
            elseif did == 'I00R' then
                set gun = SpearRifle.create(null, ifd)
//end of: BindGun("'I00R'", "SpearRifle")
//textmacro instance: BindGun("'I00S'", "FireShotgun")
            elseif did == 'I00S' then
                set gun = FireShotgun.create(null, ifd)
//end of: BindGun("'I00S'", "FireShotgun")
            endif
        endif
        set ifd.gun = gun
        return ifd
    endmethod
endstruct
struct ItemTypeData
    string name
    integer spell
    integer s1
    integer s2
    integer s3
    integer itemType
    
    static method create takes string name, integer spell, integer s1, integer s2, integer s3, integer itemType returns ItemTypeData
        local ItemTypeData m=ItemTypeData.allocate()
        set m.name=name
        set m.spell=spell
        set m.s1=s1
        set m.s2=s2
        set m.s3=s3
        set m.itemType=itemType
        return m
    endmethod 
endstruct
function InitItemData takes nothing returns nothing
    call FlushParentHashtable( idht )
    set idht = InitHashtable()
//textmacro instance: DefineIfht("1")
    call FlushParentHashtable( ifht1 )
    set ifht1 = InitHashtable()
//end of: DefineIfht("1")
//textmacro instance: DefineIfht("2")
    call FlushParentHashtable( ifht2 )
    set ifht2 = InitHashtable()
//end of: DefineIfht("2")
//textmacro instance: DefineIfht("3")
    call FlushParentHashtable( ifht3 )
    set ifht3 = InitHashtable()
//end of: DefineIfht("3")
//textmacro instance: DefineIfht("4")
    call FlushParentHashtable( ifht4 )
    set ifht4 = InitHashtable()
//end of: DefineIfht("4")
//textmacro instance: DefineIfht("5")
    call FlushParentHashtable( ifht5 )
    set ifht5 = InitHashtable()
//end of: DefineIfht("5")
//textmacro instance: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
    call SaveStr(idht,iJUMP - 'I000',idht_name,"寮瑰皠闉?)
    call SaveInteger(idht,iJUMP - 'I000',idht_spell,'A00A')
    call SaveInteger(idht,iJUMP - 'I000',idht_s1,'A00B')
    call SaveInteger(idht,iJUMP - 'I000',idht_s2,0)
    call SaveInteger(idht,iJUMP - 'I000',idht_s3,0)
    call SaveInteger(idht,iJUMP - 'I000',idht_item_type,SHOE)
//end of: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
//textmacro instance: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€熷櫒", "'A00C'", "0","0","0","OTHER")
    call SaveStr(idht,iSPEED - 'I000',idht_name,"鍠峰皠鍔犻€熷櫒")
    call SaveInteger(idht,iSPEED - 'I000',idht_spell,'A00C')
    call SaveInteger(idht,iSPEED - 'I000',idht_s1,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_s2,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_s3,0)
    call SaveInteger(idht,iSPEED - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€熷櫒", "'A00C'", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
    call SaveStr(idht,iRETURN - 'I000',idht_name,"鍥炴棆闀?)
    call SaveInteger(idht,iRETURN - 'I000',idht_spell,aRETURN)
    call SaveInteger(idht,iRETURN - 'I000',idht_s1,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_s2,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_s3,0)
    call SaveInteger(idht,iRETURN - 'I000',idht_item_type,I_D)
//end of: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
    call SaveStr(idht,iREACT - 'I000',idht_name,"灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆")
    call SaveInteger(idht,iREACT - 'I000',idht_spell,aREACT)
    call SaveInteger(idht,iREACT - 'I000',idht_s1,0)
    call SaveInteger(idht,iREACT - 'I000',idht_s2,0)
    call SaveInteger(idht,iREACT - 'I000',idht_s3,0)
    call SaveInteger(idht,iREACT - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
    call SaveStr(idht,iELECTRIC - 'I000',idht_name,"鐢甸灜")
    call SaveInteger(idht,iELECTRIC - 'I000',idht_spell,aELECTRIC)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s1,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s2,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_s3,0)
    call SaveInteger(idht,iELECTRIC - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
    call SaveStr(idht,iBLINK - 'I000',idht_name,"闂儊鍖曢")
    call SaveInteger(idht,iBLINK - 'I000',idht_spell,aBLINK)
    call SaveInteger(idht,iBLINK - 'I000',idht_s1,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_s2,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_s3,0)
    call SaveInteger(idht,iBLINK - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
    call SaveStr(idht,iTRANSPORT - 'I000',idht_name,"瓒呰窛浼犻€佸櫒")
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_spell,aTRANSPORT)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s1,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s2,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_s3,0)
    call SaveInteger(idht,iTRANSPORT - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
    call SaveStr(idht,iAUTOAIM - 'I000',idht_name,"杈呭姪灏勫嚮瑁呯疆")
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_spell,aAUTOAIM)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s1,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s2,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_s3,0)
    call SaveInteger(idht,iAUTOAIM - 'I000',idht_item_type,OTHER)
//end of: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
    call SaveStr(idht,iLEAVE - 'I000',idht_name,"绂诲績闀?)
    call SaveInteger(idht,iLEAVE - 'I000',idht_spell,aLEAVE)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s1,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s2,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_s3,0)
    call SaveInteger(idht,iLEAVE - 'I000',idht_item_type,I_D)
//end of: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
    call SaveStr(idht,iBKGRENADE - 'I000',idht_name,"闇囪崱鎵嬮浄")
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_spell,aBKGRENADE)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s1,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s2,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_s3,0)
    call SaveInteger(idht,iBKGRENADE - 'I000',idht_item_type,I_T)
//end of: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
    call SaveStr(idht,iPSGRENADE - 'I000',idht_name,"鍐插嚮鎵嬮浄")
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_spell,aPSGRENADE)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s1,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s2,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_s3,0)
    call SaveInteger(idht,iPSGRENADE - 'I000',idht_item_type,I_T)
//end of: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
    call SaveStr(idht,iMINE - 'I000',idht_name,"鍙嶆鍏靛湴闆?)
    call SaveInteger(idht,iMINE - 'I000',idht_spell,aMINE)
    call SaveInteger(idht,iMINE - 'I000',idht_s1,0)
    call SaveInteger(idht,iMINE - 'I000',idht_s2,0)
    call SaveInteger(idht,iMINE - 'I000',idht_s3,0)
    call SaveInteger(idht,iMINE - 'I000',idht_item_type,I_N)
//end of: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
//textmacro instance: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
    call SaveStr(idht,'I00P' - 'I000',idht_name,"绛夌瀛愯偐鐐?)
    call SaveInteger(idht,'I00P' - 'I000',idht_spell,'A01N')
    call SaveInteger(idht,'I00P' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00P' - 'I000',idht_item_type,AB1)
//end of: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
    call SaveStr(idht,'I00Q' - 'I000',idht_name,"蹇垉椋炵")
    call SaveInteger(idht,'I00Q' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00Q' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00Q' - 'I000',idht_item_type,AB1)
//end of: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I001' - 'I000',idht_name,"鏅€氭鏋?)
    call SaveInteger(idht,'I001' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I001' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I001' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I001' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I001' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I00R' - 'I000',idht_name,"鐭涙灙")
    call SaveInteger(idht,'I00R' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00R' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00R' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht,'I00S' - 'I000',idht_name,"鐏劙鏁ｅ脊鏋?)
    call SaveInteger(idht,'I00S' - 'I000',idht_spell,'A01O')
    call SaveInteger(idht,'I00S' - 'I000',idht_s1,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_s2,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_s3,0)
    call SaveInteger(idht,'I00S' - 'I000',idht_item_type,GUN)
//end of: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitItemFeatureData("iSPEED", "1", "鎺ㄨ繘鍔?, "3","1","0","5","100","0")
    call SaveStr(ifht1,iSPEED - 'I000',ifht_name,"鎺ㄨ繘鍔?)
    call SaveReal(ifht1,iSPEED - 'I000',ifht_origin,3)
    call SaveReal(ifht1,iSPEED - 'I000',ifht_step,1)
    call SaveInteger(ifht1,iSPEED - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iSPEED - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iSPEED - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iSPEED - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iSPEED", "1", "鎺ㄨ繘鍔?, "3","1","0","5","100","0")
//textmacro instance: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
    call SaveStr(ifht1,iJUMP - 'I000',ifht_name,"璺宠穬楂樺害")
    call SaveReal(ifht1,iJUMP - 'I000',ifht_origin,35)
    call SaveReal(ifht1,iJUMP - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iJUMP - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
    call SaveStr(ifht2,iJUMP - 'I000',ifht_name,"璺宠穬璺濈")
    call SaveReal(ifht2,iJUMP - 'I000',ifht_origin,10)
    call SaveReal(ifht2,iJUMP - 'I000',ifht_step,3)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iJUMP - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
    call SaveStr(ifht1,iRETURN - 'I000',ifht_name,"鎶曟幏閫熷害")
    call SaveReal(ifht1,iRETURN - 'I000',ifht_origin,80)
    call SaveReal(ifht1,iRETURN - 'I000',ifht_step,10)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iRETURN - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2,iRETURN - 'I000',ifht_name,"棰濆浼ゅ")
    call SaveReal(ifht2,iRETURN - 'I000',ifht_origin,0)
    call SaveReal(ifht2,iRETURN - 'I000',ifht_step,20)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iRETURN - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
    call SaveStr(ifht1,iLEAVE - 'I000',ifht_name,"椋炶閫熷害")
    call SaveReal(ifht1,iLEAVE - 'I000',ifht_origin,3.5)
    call SaveReal(ifht1,iLEAVE - 'I000',ifht_step,0.5)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iLEAVE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2,iLEAVE - 'I000',ifht_name,"棰濆浼ゅ")
    call SaveReal(ifht2,iLEAVE - 'I000',ifht_origin,0)
    call SaveReal(ifht2,iLEAVE - 'I000',ifht_step,20)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iLEAVE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
    call SaveStr(ifht1,iREACT - 'I000',ifht_name,"灏勫嚮鍙嶄綔鐢ㄥ姏")
    call SaveReal(ifht1,iREACT - 'I000',ifht_origin,0.5)
    call SaveReal(ifht1,iREACT - 'I000',ifht_step,0.25)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_gold,50)
    call SaveInteger(ifht1,iREACT - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
    call SaveStr(ifht1,iELECTRIC - 'I000',ifht_name,"鎶曟幏閫熷害")
    call SaveReal(ifht1,iELECTRIC - 'I000',ifht_origin,30)
    call SaveReal(ifht1,iELECTRIC - 'I000',ifht_step,10)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iELECTRIC - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
    call SaveStr(ifht2,iELECTRIC - 'I000',ifht_name,"鎶曟幏璺濈")
    call SaveReal(ifht2,iELECTRIC - 'I000',ifht_origin,30)
    call SaveReal(ifht2,iELECTRIC - 'I000',ifht_step,5)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iELECTRIC - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
    call SaveStr(ifht1,iBLINK - 'I000',ifht_name,"闂儊璺濈")
    call SaveReal(ifht1,iBLINK - 'I000',ifht_origin,600)
    call SaveReal(ifht1,iBLINK - 'I000',ifht_step,200)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_max_lv,3)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_gold,50)
    call SaveInteger(ifht1,iBLINK - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
//textmacro instance: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
    call SaveStr(ifht1,iTRANSPORT - 'I000',ifht_name,"浼犻€佽窛绂?)
    call SaveReal(ifht1,iTRANSPORT - 'I000',ifht_origin,5000)
    call SaveReal(ifht1,iTRANSPORT - 'I000',ifht_step,2000)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_gold,150)
    call SaveInteger(ifht1,iTRANSPORT - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
//textmacro instance: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
    call SaveStr(ifht1,iAUTOAIM - 'I000',ifht_name,"鎸佺画鏃堕棿")
    call SaveReal(ifht1,iAUTOAIM - 'I000',ifht_origin,3)
    call SaveReal(ifht1,iAUTOAIM - 'I000',ifht_step,1)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iAUTOAIM - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1,iBKGRENADE - 'I000',ifht_name,"鎶曟幏鍔涢噺")
    call SaveReal(ifht1,iBKGRENADE - 'I000',ifht_origin,50)
    call SaveReal(ifht1,iBKGRENADE - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2,iBKGRENADE - 'I000',ifht_name,"鐖嗙偢鑼冨洿")
    call SaveReal(ifht2,iBKGRENADE - 'I000',ifht_origin,500)
    call SaveReal(ifht2,iBKGRENADE - 'I000',ifht_step,50)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
    call SaveStr(ifht3,iBKGRENADE - 'I000',ifht_name,"鐪╂檿")
    call SaveReal(ifht3,iBKGRENADE - 'I000',ifht_origin,1)
    call SaveReal(ifht3,iBKGRENADE - 'I000',ifht_step,1)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_max_lv,1)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_gold,300)
    call SaveInteger(ifht3,iBKGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1,iPSGRENADE - 'I000',ifht_name,"鎶曟幏鍔涢噺")
    call SaveReal(ifht1,iPSGRENADE - 'I000',ifht_origin,50)
    call SaveReal(ifht1,iPSGRENADE - 'I000',ifht_step,5)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht1,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2,iPSGRENADE - 'I000',ifht_name,"鐖嗙偢鑼冨洿")
    call SaveReal(ifht2,iPSGRENADE - 'I000',ifht_origin,500)
    call SaveReal(ifht2,iPSGRENADE - 'I000',ifht_step,50)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht2,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
    call SaveStr(ifht3,iPSGRENADE - 'I000',ifht_name,"鍑婚€€")
    call SaveReal(ifht3,iPSGRENADE - 'I000',ifht_origin,10)
    call SaveReal(ifht3,iPSGRENADE - 'I000',ifht_step,2)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_max_lv,5)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_gold,100)
    call SaveInteger(ifht3,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
    call SaveStr(ifht4,iPSGRENADE - 'I000',ifht_name,"鍑忛€?)
    call SaveReal(ifht4,iPSGRENADE - 'I000',ifht_origin,0)
    call SaveReal(ifht4,iPSGRENADE - 'I000',ifht_step,1)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_lv,0)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_max_lv,2)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_gold,200)
    call SaveInteger(ifht4,iPSGRENADE - 'I000',ifht_wood,0)
//end of: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
endfunction
function getItemTypeData takes integer idd returns ItemTypeData
    local integer id = idd - 'I000'
    if HaveSavedString(idht,id,idht_name) then
        return ItemTypeData.create(LoadStr(idht,id,idht_name),LoadInteger(idht,id,idht_spell),LoadInteger(idht,id,idht_s1),LoadInteger(idht,id,idht_s2),LoadInteger(idht,id,idht_s3),LoadInteger(idht,id,idht_item_type))
    endif
    return -1
endfunction
function hasItemTypeData takes integer idd returns boolean
    local integer id = idd - 'I000'
    if HaveSavedString(idht,id,idht_name) then
        return true
    endif
    return false
endfunction
function GetItemByTypeId takes unit u,integer id returns item
local integer i=0
local item ui
loop
    exitwhen i>5
    set ui=UnitItemInSlot(u,i)
    if GetItemTypeId(ui) == id then
        return ui
    endif
    set i=i+1
endloop
set ui = null
return null
endfunction
//textmacro instance: getfeaturevalue("1")
function getf1value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f1 = IndividualItemData[itm].featureData.f1
    set itm = null
    return f1.getValue()
endfunction
//end of: getfeaturevalue("1")
//textmacro instance: getfeaturevalue("2")
function getf2value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f2 = IndividualItemData[itm].featureData.f2
    set itm = null
    return f2.getValue()
endfunction
//end of: getfeaturevalue("2")
//textmacro instance: getfeaturevalue("3")
function getf3value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f3 = IndividualItemData[itm].featureData.f3
    set itm = null
    return f3.getValue()
endfunction
//end of: getfeaturevalue("3")
//textmacro instance: getfeaturevalue("4")
function getf4value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f4 = IndividualItemData[itm].featureData.f4
    set itm = null
    return f4.getValue()
endfunction
//end of: getfeaturevalue("4")
//textmacro instance: getfeaturevalue("5")
function getf5value takes unit u, integer id returns real
    local item itm = GetItemByTypeId(u, id)
    local ItemFeature f5 = IndividualItemData[itm].featureData.f5
    set itm = null
    return f5.getValue()
endfunction
//end of: getfeaturevalue("5")

//library ItemData ends
//library Job:
function InitMarinJob takes unit target, integer lv returns nothing
    local integer pid = GetPlayerId(GetOwningPlayer(target))
    if IsHero(target) then
        if lv == 1 then
            call IncShootSpeed(pid)
            call IncShootSpeed(pid)
            set EquipmentData[target].heroData.machine_gun_buff = EquipmentData[target].heroData.machine_gun_buff + 0.15
        endif
    endif
endfunction

//library Job ends
//library JumpFacingStore:
function storeJumpFacing takes nothing returns nothing
    local real sx = GetUnitX(GetTriggerUnit())
    local real sy = GetUnitY(GetTriggerUnit())
    local real tx = GetOrderPointX()
    local real ty = GetOrderPointY()
    local real dir = getDir(sx, sy, tx, ty)
    if IsHero(GetTriggerUnit()) and GetIssuedOrderId() == OI_RIGHT_CLICK_MOVE then
        set EquipmentData[GetTriggerUnit()].heroData.jump_direction = dir
    endif
endfunction
function InitJumpFacingStore takes nothing returns nothing
local trigger jumpPointFacing_t=CreateTrigger()
call TriggerAddCondition(jumpPointFacing_t,function storeJumpFacing)
call TriggerRegisterAnyUnitEventBJ( jumpPointFacing_t, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
set jumpPointFacing_t=null
endfunction

//library JumpFacingStore ends
//library MonsterBonus:
function MonsterBonus takes nothing returns nothing
local integer typeId=GetUnitTypeId(GetTriggerUnit())
local player p=GetOwningPlayer(GetKillingUnitBJ())
local IMonsterTypeData data=DefaultTypeData.findTypeData(typeId)
call AdjustPlayerStateBJ( data.getDeadGold(), p, PLAYER_STATE_RESOURCE_GOLD )
call AdjustPlayerStateBJ( data.getDeadWood(), p, PLAYER_STATE_RESOURCE_LUMBER )
endfunction
function InitMonsterBonus takes nothing returns nothing
call TriggerAddCondition(gtrgMonsterDead,function MonsterBonus)
endfunction

//library MonsterBonus ends
//library Move:
function UpdateBoard takes nothing returns nothing
    set lx = GetRectMinX(area)
    set rx = GetRectMaxX(area)
    set ly = GetRectMinY(area)
    set ry = GetRectMaxY(area)
    set lz = 0
    set rz = 3000
endfunction
function InitMove takes nothing returns nothing
    set area = GetPlayableMapRect()
    call UpdateBoard()
endfunction
function ChangeRect takes rect newrect returns nothing
    set area = newrect
    call UpdateBoard()
endfunction
function MoveUnit takes unit u, real tx, real ty, real tz returns nothing
    local real z = tz - getTerrianHeight(tx, ty)
    local real fz = GetUnitFlyHeight(u)
    if fz > 0 then
        set z = RMaxBJ(0,z)
    endif
    if tx >= rx or tx <= lx or ty >= ry or ty <= ly or tz > rz or z < 0 then
    else
        call SetUnitX(u, tx)
        call SetUnitY(u, ty)
        call SetUnitFlyHeight(u, z, 0)
        //if z == 0 then
            //call BJDebugMsg("set fly height zero")
        //endif
    endif
endfunction

//library Move ends
//library PUI:
    //===========================================================================
    //  Allowed PUI_PROPERTY TYPES are: unit, integer, real, boolean, string
    //  Do NOT put handles that need to be destroyed here (timer, trigger, ...)
    //  Instead put them in a struct and use PUI textmacro
    //===========================================================================
    //===========================================================================
    //  Never destroy PUI structs directly.
    //  Use .release() instead, will call .destroy()
    //===========================================================================

//library PUI ends
//library Save:
function BeforeSaveCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    if IsHero(u) then
        set EquipmentData[u].heroData.beforesave = GetUnitStateSwap(UNIT_STATE_MANA, u)
    endif
    set u = null
endfunction
function DoSaveCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local real mana
    local real save
    local real before
    if IsHero(u) then
        set before = EquipmentData[u].heroData.beforesave
        set mana = GetUnitStateSwap(UNIT_STATE_MANA, u)
        if before > mana then
            set save = EquipmentData[u].heroData.save
            call SetUnitManaBJ( u, mana + save * (before - mana))
        endif
    endif
    set u = null
endfunction
function InitSave takes nothing returns nothing
local trigger beforesave_t=CreateTrigger()
local trigger dosave_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( beforesave_t, EVENT_PLAYER_UNIT_SPELL_EFFECT )
call TriggerRegisterAnyUnitEventBJ( dosave_t, EVENT_PLAYER_UNIT_SPELL_FINISH )
call TriggerAddCondition(beforesave_t,function BeforeSaveCondition)
call TriggerAddCondition(dosave_t,function DoSaveCondition)
set beforesave_t=null
set dosave_t=null
endfunction

//library Save ends
//library SpellStruct:
    //===========================================================================
    // Configurables
    //
    
    //===========================================================================
    // Header Declarations
    //
    
    function interface SpellStruct___Method takes integer this returns nothing
    function interface SpellStruct___UnitMethodFilter takes integer this, unit u returns boolean
    function interface SpellStruct___UnitMethod takes integer this, unit u returns nothing
    function interface SpellStruct___Allocator takes nothing returns integer
    
    //===========================================================================
    // Recursion stack
    //
    module SpellStruct___Stack
        static thistype top=0 // thistype(0) throws a syntax error, does not compile
static method increment takes nothing returns nothing
            set thistype.top=thistype(thistype.top+1)
        endmethod
        static method decrement takes nothing returns nothing
            set thistype.top=thistype(thistype.top-1)
        endmethod
    endmodule
    
    //===========================================================================
    // Defaults
    //
    interface SpellStruct___DefaultsInterface
        // For methods that are not implemented.
        // In order of firing.
        method onCreate takes nothing returns nothing defaults nothing
        method onChannel takes nothing returns nothing defaults nothing
        method onStartCast takes nothing returns nothing defaults nothing
        method onEffect takes nothing returns nothing defaults nothing // May not always fire in casting a given spell.
method onFinish takes nothing returns nothing defaults nothing // May not fire in casting a spell, Blizzard's event response fails.
method onStopCast takes nothing returns nothing defaults nothing // Blizzard's event response sometimes fails.

        method cleanup takes nothing returns nothing defaults nothing
    endinterface
    
    //===========================================================================
    // Event Handlers
    //
    
    
//textmacro instance: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
        function SpellStruct___OnChannel takes nothing returns boolean
            set SpellStruct___CastingAbility=GetSpellAbilityId()
            static if true then
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR))
                if SpellStruct___ThisCastData==0 then
                    return false
                endif
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(SpellStruct___Allocator(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct___ThisCastData)
            else
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnChannel - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct___ThisCastData!=0 then
                call SpellStruct___ThisCastData.onChannel.execute()
                static if false then
                    call SpellStruct___ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
//textmacro instance: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
        function SpellStruct___OnStartCast takes nothing returns boolean
            set SpellStruct___CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR))
                if SpellStruct___ThisCastData==0 then
                    return false
                endif
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(SpellStruct___Allocator(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct___ThisCastData)
            else
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnStartCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct___ThisCastData!=0 then
                call SpellStruct___ThisCastData.onStartCast.execute()
                static if false then
                    call SpellStruct___ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
//textmacro instance: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
        function SpellStruct___OnEffect takes nothing returns boolean
            set SpellStruct___CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR))
                if SpellStruct___ThisCastData==0 then
                    return false
                endif
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(SpellStruct___Allocator(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct___ThisCastData)
            else
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnEffect - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct___ThisCastData!=0 then
                call SpellStruct___ThisCastData.onEffect.execute()
                static if false then
                    call SpellStruct___ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
//textmacro instance: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
        function SpellStruct___OnFinish takes nothing returns boolean
            set SpellStruct___CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR))
                if SpellStruct___ThisCastData==0 then
                    return false
                endif
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(SpellStruct___Allocator(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct___ThisCastData)
            else
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnFinish - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct___ThisCastData!=0 then
                call SpellStruct___ThisCastData.onFinish.execute()
                static if false then
                    call SpellStruct___ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
//textmacro instance: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
        function SpellStruct___OnStopCast takes nothing returns boolean
            set SpellStruct___CastingAbility=GetSpellAbilityId()
            static if false then
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR))
                if SpellStruct___ThisCastData==0 then
                    return false
                endif
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(SpellStruct___Allocator(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,SpellStruct___ALLOCATOR)).evaluate())
                call SaveInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit()),SpellStruct___ThisCastData)
            else
                set SpellStruct___ThisCastData=SpellStruct___DefaultsInterface(LoadInteger(SpellStruct___STORE,SpellStruct___CastingAbility,GetHandleId(GetTriggerUnit())))
            endif
            //call BJDebugMsg("OnStopCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct___ThisCastData!=0 then
                call SpellStruct___ThisCastData.onStopCast.execute()
                static if true then
                    call SpellStruct___ThisCastData.cleanup.evaluate()
                endif
            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
    
    //===========================================================================
    // Attachment.
    //
    struct SpellStruct___ChainAttach
        trigger trigger
        timer timer
        integer instance
        SpellStruct___Method callback
        thistype next
        thistype prev
    endstruct
    
    //===========================================================================
    // Timers (requires Attachment).
    //
    function SpellStruct___SetTimerStruct takes timer t, integer data returns nothing
        static if LIBRARY_TimerUtils then
            call SetTimerData(t,data)
        else
            call SaveInteger(SpellStruct___STORE,GetHandleId(t),SpellStruct___TIMER_DATA,data)
        endif
    endfunction
    function SpellStruct___GetTimerStruct takes timer t returns integer
        static if LIBRARY_TimerUtils then
            return GetTimerData(t)
        else
            return LoadInteger(SpellStruct___STORE,GetHandleId(t),SpellStruct___TIMER_DATA)
        endif
    endfunction
    
    //===========================================================================
    // Triggers (requires Attachment).
    //
    function SpellStruct___SetTriggerStruct takes trigger t, integer data returns nothing
        call SaveInteger(SpellStruct___STORE,GetHandleId(t),SpellStruct___TRIGGER_DATA,data)
    endfunction
    function SpellStruct___GetTriggerStruct takes trigger t returns integer
        return LoadInteger(SpellStruct___STORE,GetHandleId(t),SpellStruct___TRIGGER_DATA)
    endfunction
    
    //===========================================================================
    // AoE enumeration.
    //
    struct SpellStruct___EnumStack extends array
        implement SpellStruct___Stack
        integer instance
        real x
        real y
        real range
        integer callback
        group for
    endstruct
    function SpellStruct___InternalEnum takes nothing returns boolean // Could be recursive.
local unit u=GetFilterUnit() // can't be a global due to recursion.
if IsUnitInRangeXY(u,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range) then // Factors in collision sizes.
if SpellStruct___UnitMethodFilter(SpellStruct___EnumStack.top.callback).evaluate(SpellStruct___EnumStack.top.instance,u) then
                call GroupAddUnit(SpellStruct___EnumStack.top.for,u)
            endif
        endif
        set u=null
        return false
    endfunction
    function SpellStruct___InternalFor takes nothing returns boolean // Could be recursive.
local unit u=GetFilterUnit() // can't be a global due to recursion.
if IsUnitInRangeXY(u,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range) then // Factors in collision sizes.
call SpellStruct___UnitMethod(SpellStruct___EnumStack.top.callback).execute(SpellStruct___EnumStack.top.instance,u)
        endif
        set u=null
        return false
    endfunction
    
    //===========================================================================
    // Exposed Interface - SpellStruct
    //
    struct SpellStruct extends SpellStruct___DefaultsInterface
        //===========================================================================
        // Various Spell-based Methods.
        //
        method getDistanceToTargetWidget takes nothing returns real
            local real x=GetWidgetX(this.targetWidget)-this.casterX
            local real y=GetWidgetY(this.targetWidget)-this.casterY
            return SquareRoot(x*x+y*y)
        endmethod
        method getDistanceToTargetPoint takes nothing returns real
            local real x=this.targetX-this.casterX
            local real y=this.targetY-this.casterY
            return SquareRoot(x*x+y*y)
        endmethod
        method getAngleToTargetWidget takes nothing returns real // radians.
return Atan2(GetWidgetY(this.targetWidget)-this.casterY,GetWidgetX(this.targetWidget)-this.casterX)
        endmethod
        method getAngleToTargetPoint takes nothing returns real // radians.
return Atan2(this.targetY-this.casterY,this.targetX-this.casterX)
        endmethod
        
        //===========================================================================
        // ForGroup.
        //
        private static method forGroupCallback takes nothing returns nothing
            call SpellStruct___UnitMethod(SpellStruct___EnumStack.top.callback).execute(SpellStruct___EnumStack.top.instance,GetEnumUnit()) // bigger crimes have been committed, but not much bigger.
endmethod
        method forGroup takes group g, SpellStruct___UnitMethod callback returns nothing
            call SpellStruct___EnumStack.increment() // just borrowing that stack... would break if event reponses accessed the stack directly, but they don't.
set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.callback=callback
            call ForGroup(g,function thistype.forGroupCallback)
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        //===========================================================================
        // AoE enumeration.
        //
        real aoe
        
        method enumUnitsInAoE takes group whichGroup, SpellStruct___UnitMethodFilter filter returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=this.targetX
            set SpellStruct___EnumStack.top.y=this.targetY
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=filter
            set SpellStruct___EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalEnum))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method enumUnitsInAoETarget takes group whichGroup, SpellStruct___UnitMethodFilter filter returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=GetWidgetX(this.targetWidget)
            set SpellStruct___EnumStack.top.y=GetWidgetY(this.targetWidget)
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=filter
            set SpellStruct___EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalEnum))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method enumUnitsInAoECaster takes group whichGroup, SpellStruct___UnitMethodFilter filter returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=GetUnitX(this.caster)
            set SpellStruct___EnumStack.top.y=GetUnitY(this.caster)
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=filter
            set SpellStruct___EnumStack.top.for=whichGroup
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalEnum))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method forUnitsInAoE takes SpellStruct___UnitMethod callback returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=this.targetX
            set SpellStruct___EnumStack.top.y=this.targetY
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalFor))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method forUnitsInAoETarget takes SpellStruct___UnitMethod callback returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=GetWidgetX(this.targetWidget)
            set SpellStruct___EnumStack.top.y=GetWidgetY(this.targetWidget)
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalFor))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method forUnitsInAoECaster takes SpellStruct___UnitMethod callback returns nothing 
            call SpellStruct___EnumStack.increment()
            set SpellStruct___EnumStack.top.instance=this
            set SpellStruct___EnumStack.top.x=GetUnitX(this.caster)
            set SpellStruct___EnumStack.top.y=GetUnitY(this.caster)
            set SpellStruct___EnumStack.top.range=this.aoe
            set SpellStruct___EnumStack.top.callback=callback
            call GroupEnumUnitsInRange(SpellStruct___GROUP,SpellStruct___EnumStack.top.x,SpellStruct___EnumStack.top.y,SpellStruct___EnumStack.top.range+SpellStruct___MAX_UNIT_COLLISION_SIZE,Filter(function SpellStruct___InternalFor))
            call SpellStruct___EnumStack.decrement()
        endmethod
        
        method isUnitInAoE takes unit u returns boolean
            return IsUnitInRangeXY(u,this.targetX,this.targetY,this.aoe)
        endmethod
        method isUnitInAoETarget takes unit u returns boolean
            return IsUnitInRangeXY(u,GetWidgetX(this.targetWidget),GetWidgetY(this.targetWidget),this.aoe)
        endmethod
        method isUnitInAoECaster takes unit u returns boolean
            return IsUnitInRangeXY(u,GetUnitX(this.caster),GetUnitY(this.caster),this.aoe)
        endmethod
        
        //===========================================================================
        // Auto Cleanup.
        //
        private boolean doAutoDestroy // set in module's create method.
boolean hasStoppedCasting=false
        method operator autoDestroy= takes boolean flag returns nothing
            if flag then
                if this.hasStoppedCasting and this.isNotLocked then
                    set this.hasStoppedCasting=false // double free safety
call this.destroy()
                else
                    set this.doAutoDestroy=true
                endif
            else
                set this.doAutoDestroy=false
            endif
        endmethod
        method operator autoDestroy takes nothing returns boolean
            return this.doAutoDestroy
        endmethod
        
        //===========================================================================
        // Locking.
        //
        private integer lockLevel=0
        method operator isLocked takes nothing returns boolean
            return this.lockLevel>0
        endmethod
        method operator isNotLocked takes nothing returns boolean
            return this.lockLevel==0
        endmethod
        method addLock takes nothing returns nothing
            set this.lockLevel=this.lockLevel+1
        endmethod
        method removeLock takes nothing returns nothing
            set this.lockLevel=this.lockLevel-1
            if this.hasStoppedCasting and this.isNotLocked and this.doAutoDestroy then
                set this.hasStoppedCasting=false // double free safety
call this.destroy()
            endif
        endmethod
        
        //===========================================================================
        // Attachment.
        //
        private static SpellStruct___ChainAttach attachNode
        private static SpellStruct___ChainAttach attachHead
        
        
        
        
        //===========================================================================
        // Timers (requires Locking).
        //
        private SpellStruct___ChainAttach timerAttachments
        private static method timerCallback takes nothing returns nothing
            set thistype.attachNode=SpellStruct___GetTimerStruct(GetExpiredTimer()) // first time since h2i/gamecache I've needed this.
call thistype.attachNode.callback.execute(thistype.attachNode.instance) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
endmethod
        method startTimer takes SpellStruct___Method callback, real period returns nothing
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            // Create node.
            set thistype.attachNode=SpellStruct___ChainAttach.create()
            // Link node (at end of list).
            set thistype.attachHead=this.timerAttachments
            set thistype.attachHead.prev.next=thistype.attachNode
            set thistype.attachNode.prev=thistype.attachHead.prev
            set thistype.attachHead.prev=thistype.attachNode
            set thistype.attachNode.next=thistype.attachHead
//end of: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            set thistype.attachNode.instance=this
            set thistype.attachNode.callback=callback
            // Create timer and attach data.
//textmacro instance: SpellStruct__GetTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            set thistype.attachNode.timer=NewTimer()
        elseif LIBRARY_Recycle then
            set thistype.attachNode.timer=Timer.get()
        else
            set thistype.attachNode.timer=CreateTimer()
        endif
//end of: SpellStruct__GetTimer("thistype.attachNode.timer")
            call SpellStruct___SetTimerStruct(thistype.attachNode.timer,thistype.attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct___STORE,this,callback,thistype.attachNode)
            // Start timer.
            call TimerStart(thistype.attachNode.timer,period,true,function thistype.timerCallback)
            call this.addLock()
        endmethod
        method stopTimer takes SpellStruct___Method callback returns nothing
            set thistype.attachNode=SpellStruct___ChainAttach(LoadInteger(SpellStruct___STORE,this,callback))
            // Unchain attachment
            set thistype.attachNode.next.prev=thistype.attachNode.prev
            set thistype.attachNode.prev.next=thistype.attachNode.next
            // Release Timer.
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            call ReleaseTimer(thistype.attachNode.timer)
        elseif LIBRARY_Recycle then
            call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.timer),SpellStruct___TIMER_DATA)
            call Timer.release(thistype.attachNode.timer)
        else
            call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.timer),SpellStruct___TIMER_DATA)
            call PauseTimer(thistype.attachNode.timer)
            call DestroyTimer(thistype.attachNode.timer)
            //set thistype.attachNode.timer=null // using globals, unnecessary.
        endif
//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
            call RemoveSavedInteger(SpellStruct___STORE,this,callback)
            call this.removeLock()
        endmethod
        
        //===========================================================================
        // Triggers (requires Locking).
        //
        private SpellStruct___ChainAttach triggerAttachments
        private static method triggerCallback takes nothing returns boolean
            set thistype.attachNode=SpellStruct___GetTriggerStruct(GetTriggeringTrigger()) // first time since h2i/gamecache I've needed this.
call thistype.attachNode.callback.execute(thistype.attachNode.instance) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
return false
        endmethod
        method createTrigger takes SpellStruct___Method callback returns trigger
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            // Create node.
            set thistype.attachNode=SpellStruct___ChainAttach.create()
            // Link node (at end of list).
            set thistype.attachHead=this.triggerAttachments
            set thistype.attachHead.prev.next=thistype.attachNode
            set thistype.attachNode.prev=thistype.attachHead.prev
            set thistype.attachHead.prev=thistype.attachNode
            set thistype.attachNode.next=thistype.attachHead
//end of: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            set thistype.attachNode.instance=this
            set thistype.attachNode.callback=callback
            // Create timer and attach data.
            set thistype.attachNode.trigger=CreateTrigger()
            call SpellStruct___SetTriggerStruct(thistype.attachNode.trigger,thistype.attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct___STORE,this,callback,thistype.attachNode)
            // Init trigger.
            call TriggerAddCondition(thistype.attachNode.trigger,Filter(function thistype.triggerCallback))
            call this.addLock()
            return thistype.attachNode.trigger
        endmethod
        method destroyTrigger takes SpellStruct___Method callback returns nothing
            set thistype.attachNode=SpellStruct___ChainAttach(LoadInteger(SpellStruct___STORE,this,callback))
            // Unchain attachment
            set thistype.attachNode.next.prev=thistype.attachNode.prev
            set thistype.attachNode.prev.next=thistype.attachNode.next
            // Destroy trigger
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.trigger),SpellStruct___TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
            call DestroyTrigger(thistype.attachNode.trigger)
            call RemoveSavedInteger(SpellStruct___STORE,this,callback)
            call this.removeLock()
        endmethod
        
        //===========================================================================
        // Event responses.
        //
        readonly integer abilId
        readonly unit caster
        readonly integer level
        readonly integer order
        readonly unit targetUnit
        readonly widget targetWidget
        readonly destructable targetDest
        readonly item targetItem
        readonly location targetLoc
        readonly real targetX // for target point of AoE spells.
readonly real targetY // for target point of AoE spells.
readonly player owner
        
        method operator casterX takes nothing returns real
            return GetUnitX(this.caster)
        endmethod
        method operator casterY takes nothing returns real
            return GetUnitY(this.caster)
        endmethod
        
        private static location loc
        static method create takes nothing returns thistype
            local thistype this=thistype.allocate()
            
            //===========================================================================
            // Event responses.
            //
            set this.abilId=GetSpellAbilityId()
            set this.caster=GetTriggerUnit()
            set this.owner=GetOwningPlayer(this.caster)
            set this.level=GetUnitAbilityLevel(this.caster,this.abilId)
            set this.order=GetUnitCurrentOrder(this.caster)
            // Target stuff
            set this.targetUnit=GetSpellTargetUnit()
            if this.targetUnit==null then
                set this.targetDest=GetSpellTargetDestructable()
                if this.targetDest==null then
                    set this.targetItem=GetSpellTargetItem()
                    if this.targetItem==null then
                        set this.targetWidget=null
                        set thistype.loc=GetSpellTargetLoc()
                        if thistype.loc==null then
                            set this.targetX=GetUnitX(this.caster)
                            set this.targetY=GetUnitY(this.caster)
                        else
                            set this.targetX=GetLocationX(thistype.loc)
                            set this.targetY=GetLocationY(thistype.loc)
                            call RemoveLocation(thistype.loc)
                            set thistype.loc=null // worthwhile
endif
                    else
                        set this.targetWidget=this.targetItem
                        set this.targetX=GetItemX(this.targetItem)
                        set this.targetY=GetItemY(this.targetItem)
                    endif
                else
                    set this.targetWidget=this.targetDest
                    set this.targetItem=null
                    set this.targetX=GetWidgetX(this.targetDest) // shorter
set this.targetY=GetWidgetY(this.targetDest)
                endif
            else
                set this.targetWidget=this.targetUnit
                set this.targetDest=null
                set this.targetItem=null
                set this.targetX=GetUnitX(this.targetUnit)
                set this.targetY=GetUnitY(this.targetUnit)
            endif
            
            //===========================================================================
            // Attachment (timer & trigger).
            //
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set thistype.attachHead=SpellStruct___ChainAttach.create()
            set thistype.attachHead.next=thistype.attachHead
            set thistype.attachHead.prev=thistype.attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set this.timerAttachments=thistype.attachHead
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set thistype.attachHead=SpellStruct___ChainAttach.create()
            set thistype.attachHead.next=thistype.attachHead
            set thistype.attachHead.prev=thistype.attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set this.triggerAttachments=thistype.attachHead
            
            return this
        endmethod
        
        method destroy takes nothing returns nothing
            if this.hasStoppedCasting then
                set this.hasStoppedCasting=false // random double free protection on autoDestroy stuff.
else
                call RemoveSavedInteger(SpellStruct___STORE,this.abilId,GetHandleId(this.caster))
            endif
            
            //===========================================================================
            // Timers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.timerAttachments")
            set thistype.attachHead=this.timerAttachments
            set thistype.attachNode=thistype.attachHead.next
            loop
                exitwhen thistype.attachNode==thistype.attachHead
//end of: SpellStruct__AttachmentChainLoop("this.timerAttachments")
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
        static if LIBRARY_TimerUtils then
            call ReleaseTimer(thistype.attachNode.timer)
        elseif LIBRARY_Recycle then
            call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.timer),SpellStruct___TIMER_DATA)
            call Timer.release(thistype.attachNode.timer)
        else
            call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.timer),SpellStruct___TIMER_DATA)
            call PauseTimer(thistype.attachNode.timer)
            call DestroyTimer(thistype.attachNode.timer)
            //set thistype.attachNode.timer=null // using globals, unnecessary.
        endif
//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
                call RemoveSavedInteger(SpellStruct___STORE,this,thistype.attachNode.callback)
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set thistype.attachNode=thistype.attachNode.next
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call this.timerAttachments.destroy()
            
            //===========================================================================
            // Triggers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
            set thistype.attachHead=this.triggerAttachments
            set thistype.attachNode=thistype.attachHead.next
            loop
                exitwhen thistype.attachNode==thistype.attachHead
//end of: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct___STORE,GetHandleId(thistype.attachNode.trigger),SpellStruct___TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
                call DestroyTrigger(thistype.attachNode.trigger)
                call RemoveSavedInteger(SpellStruct___STORE,this,thistype.attachNode.callback)
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set thistype.attachNode=thistype.attachNode.next
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call this.triggerAttachments.destroy()
            
            call this.deallocate()
        endmethod
    endstruct
    
    //===========================================================================
    // Exposed Module - SpellStruct
    //
    module SpellStruct
        //===========================================================================
        // AoE enumeration.
        //
        static real defaultAoE=0.
        
        //===========================================================================
        // Setting up the struct.
        //
        private static integer currentAbil=0
        static method operator abil= takes integer abilId returns nothing
            if thistype.currentAbil!=0 then
                call RemoveSavedInteger(SpellStruct___STORE,thistype.currentAbil,SpellStruct___ALLOCATOR)
            endif
            set thistype.currentAbil=abilId
            if abilId!=0 then
                call SaveInteger(SpellStruct___STORE,abilId,SpellStruct___ALLOCATOR,thistype.create)
            endif
        endmethod
        static method operator abil takes nothing returns integer
            return thistype.currentAbil
        endmethod
        
        //===========================================================================
        // Auto Cleanup.
        //
        private static boolean doAutoDestroyDefault=true
        static method operator autoDestroyDefault= takes boolean flag returns nothing
            set thistype.doAutoDestroyDefault=flag
        endmethod
        static method operator autoDestroyDefault takes nothing returns boolean
            return thistype.doAutoDestroyDefault
        endmethod
        method cleanup takes nothing returns nothing // only runs if not destroyed
call RemoveSavedInteger(SpellStruct___STORE,this.abilId,GetHandleId(this.caster))
            set this.hasStoppedCasting=true // can't be readonly because of this.
if this.autoDestroy and this.isNotLocked then
                call SpellStruct(this).destroy() // Jasshelper bug? Had to typecast "this".
endif
        endmethod
        
        //===========================================================================
        // Struct Allocation.
        //
        private static method create takes nothing returns thistype
            local thistype this=thistype.allocate()
            // General stuff
            set this.autoDestroy=thistype.autoDestroyDefault
            set this.aoe=thistype.defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call this.onCreate.evaluate() // in case of thread terminate
//endif
return this
        endmethod
    endmodule
    
    //===========================================================================
    // Init
    //
    struct SpellStruct___Init extends array
        private static method onInit takes nothing returns nothing
            //===========================================================================
            // Event Responses
            //
            local trigger t
            
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_CHANNEL)
                call TriggerAddCondition(t,Filter(function SpellStruct___OnChannel))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_CAST)
                call TriggerAddCondition(t,Filter(function SpellStruct___OnStartCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_EFFECT)
                call TriggerAddCondition(t,Filter(function SpellStruct___OnEffect))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_FINISH)
                call TriggerAddCondition(t,Filter(function SpellStruct___OnFinish))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
                call TriggerAddCondition(t,Filter(function SpellStruct___OnStopCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
            
            set t=null
        endmethod
    endstruct

//library SpellStruct ends
//library Status:
    
    native UnitAlive takes unit id returns boolean
    
    module Status___PreloadModule
        private static method onInit takes nothing returns nothing
            local unit u=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            local integer abil
            call UnitAddAbility(u,Status___ABIL_INVISIBLE)
            call UnitAddAbility(u,Status___ABIL_GHOST)
            call UnitAddAbility(u,Status___ABIL_IMMUNITY)
            call UnitAddAbility(u,Status___ABIL_UNLOCUST)
            call UnitAddAbility(u,Status___ABIL_NEVER_MISS)
            call UnitAddAbility(u,Status___ABIL_ALWAYS_MISS)
            call UnitAddAbility(u,Status___ABIL_UNTOUCHABLE)
            call UnitAddAbility(u,Status___ABIL_PHASE)
            call UnitAddAbility(u,ABIL_DOUBLE_ATTACK)
            call UnitAddAbility(u,Status___ABIL_RESISTANT_SKIN)
            call UnitAddAbility(u,Status___ABIL_REFLECT_PIERCING)
//textmacro instance: Status__PreloadBonus("ARMOR")
                set abil=Status___ABIL_ARMOR+Status___LEVELS_ARMOR
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_ARMOR
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("ARMOR")
//textmacro instance: Status__PreloadBonus("DAMAGE")
                set abil=Status___ABIL_DAMAGE+Status___LEVELS_DAMAGE
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_DAMAGE
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("DAMAGE")
//textmacro instance: Status__PreloadBonus("STR")
                set abil=Status___ABIL_STR+Status___LEVELS_STR
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_STR
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("STR")
//textmacro instance: Status__PreloadBonus("AGI")
                set abil=Status___ABIL_AGI+Status___LEVELS_AGI
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_AGI
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("AGI")
//textmacro instance: Status__PreloadBonus("INT")
                set abil=Status___ABIL_INT+Status___LEVELS_INT
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_INT
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("INT")
//textmacro instance: Status__PreloadBonus("ATTACK_SPEED")
                set abil=Status___ABIL_ATTACK_SPEED+Status___LEVELS_ATTACK_SPEED
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_ATTACK_SPEED
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("ATTACK_SPEED")
//textmacro instance: Status__PreloadBonus("HEALTH")
                set abil=Status___ABIL_HEALTH+Status___LEVELS_HEALTH
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_HEALTH
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("HEALTH")
//textmacro instance: Status__PreloadBonus("MANA")
                set abil=Status___ABIL_MANA+Status___LEVELS_MANA
                loop
                    call UnitAddAbility(u,abil)
                    exitwhen abil==Status___ABIL_MANA
                    set abil=abil-1
                endloop
//end of: Status__PreloadBonus("MANA")
            call KillUnit(u)
            call RemoveUnit(u)
            set u=null
        endmethod
    endmodule
    
    module Status___StaticPeriodic
        private static method onInit takes nothing returns nothing
            call TimerStart(CreateTimer(),Status___PERIOD,true,function thistype.periodicLink)
        endmethod
    endmodule
    
    module Status___StatusInit
        private static method onInit takes nothing returns nothing
            local integer i
            set thistype.dummyCaster=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            set thistype.dummyCaster2=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            set thistype.dummyCaster3=CreateUnit(Status___DUMMY_CASTER_OWNER,DUMMY_TYPE,0,0,0)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_STUN)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_DISABLE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_SILENCE)
            set Status___CASTER_DISARM_BOTH=thistype.dummyCaster
            set Status___CASTER_DISARM_MELEE=thistype.dummyCaster2
            set Status___CASTER_DISARM_RANGE=thistype.dummyCaster3
            call UnitAddAbility(Status___CASTER_DISARM_BOTH,Status___ABIL_DISARM_BOTH)
            call UnitAddAbility(Status___CASTER_DISARM_MELEE,Status___ABIL_DISARM_MELEE)
            call UnitAddAbility(Status___CASTER_DISARM_RANGE,Status___ABIL_DISARM_RANGE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_IMMOBOLISE)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_DOOM)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_HEX)
            call UnitAddAbility(thistype.dummyCaster,Status___ABIL_BANISH)
            set i=bj_MAX_PLAYERS
            loop
                set i=i-1
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_IMMUNITY,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_NEVER_MISS,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_ALWAYS_MISS,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_UNTOUCHABLE,false)
                //call SetPlayerAbilityAvailable(Player(i),ABIL_DOUBLE_ATTACK,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_RESISTANT_SKIN,false)
                call SetPlayerAbilityAvailable(Player(i),Status___ABIL_REFLECT_PIERCING,false)
                exitwhen i==0
            endloop
        endmethod
    endmodule
    
    module Status___TwoPowArray
        readonly static integer array twoPow
        private static method onInit takes nothing returns nothing
            local integer i=0
            local integer val=1
            loop
                set thistype.twoPow[i]=val // thistype.twoPow[0]=1
exitwhen i==30
                set i=i+1
                set val=val*2
            endloop
        endmethod
    endmodule
    
    struct Status extends array
        private method AIDS_onCreate takes nothing returns nothing
            static if Status___PERMENANTLY_REVEAL then
                call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
            endif
            
            set this.disableLevel=0
            set this.stunLevel=0
            set this.silenceLevel=0
            set this.doomLevel=0
            set this.disarmMeleeLevel=0
            set this.disarmRangeLevel=0
            set this.immoboliseLevel=0
            set this.invisibleLevel=0
            set this.ghostLevel=0
            set this.invulnerableLevel=0
            set this.immunityLevel=0
            set this.pauseLevel=0
            set this.hideLevel=0
            set this.unpathLevel=0
            set this.hexLevel=0
            set this.locustLevel=0
            set this.neverMissLevel=0
            set this.alwaysMissLevel=0
            set this.untouchableLevel=0
            set this.banishLevel=0
            set this.phaseLevel=0
            set this.resistantSkinLevel=0
            set this.reflectPiercingLevel=0
            
            set this.armorBonus=0
            set this.damageBonus=0
            set this.strBonus=0
            set this.agiBonus=0
            set this.intBonus=0
            set this.attackSpeedBonus=0
            set this.healthBonus=0
            set this.manaBonus=0
            set this.healthRegenBonus=0
            set this.manaRegenBonus=0
            set this.healthRegenPercentBonus=0
            set this.manaRegenPercentBonus=0
            
            set this.moveSpeedBonus=0.0
            set this.moveSpeedPercentBonus=0.0
            call this.stopPeriodic()
        endmethod
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
        private static unit dummyCaster=null
        private static unit dummyCaster2=null
        private static unit dummyCaster3=null
        
        implement Status___StatusInit
        implement Status___TwoPowArray
        
        ////////////////////
        // Status Effects //
        ////////////////////
        
        // Stun
        private integer stunLevel
        method addStun takes nothing returns nothing
            set this.stunLevel=this.stunLevel+1
            if this.stunLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_STUN,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeStun takes nothing returns nothing
            set this.stunLevel=this.stunLevel-1
            if this.stunLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_STUN)
            endif
        endmethod
        method isStunned takes nothing returns boolean
            return this.stunLevel>0
        endmethod
        
        // Disable
        private integer disableLevel
        method addDisable takes nothing returns nothing
            set this.disableLevel=this.disableLevel+1
            if this.disableLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_DISABLE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeDisable takes nothing returns nothing
            set this.disableLevel=this.disableLevel-1
            if this.disableLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISABLE)
            endif
        endmethod
        method isDisabled takes nothing returns boolean
            return this.disableLevel>0
        endmethod
        
        // Silence
        private integer silenceLevel
        method addSilence takes nothing returns nothing
            set this.silenceLevel=this.silenceLevel+1
            if this.silenceLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_SILENCE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeSilence takes nothing returns nothing
            set this.silenceLevel=this.silenceLevel-1
            if this.silenceLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_SILENCE)
            endif
        endmethod
        method isSilenced takes nothing returns boolean
            return this.silenceLevel>0
        endmethod
        
        private integer doomLevel
        method addDoom takes nothing returns nothing
            set this.doomLevel=this.doomLevel+1
            if this.doomLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_DOOM,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeDoom takes nothing returns nothing
            set this.doomLevel=this.doomLevel-1
            if this.doomLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DOOM)
            endif
        endmethod
        method isDoomed takes nothing returns boolean
            return this.doomLevel>0
        endmethod
        
        // Disarm (Melee)
        private integer disarmMeleeLevel
        private integer disarmRangeLevel
        method addDisarmMelee takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel+1
            if this.disarmMeleeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method addDisarmRange takes nothing returns nothing
            set this.disarmRangeLevel=this.disarmRangeLevel+1
            if this.disarmRangeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmMeleeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method addDisarm takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel+1
            set this.disarmRangeLevel=this.disarmRangeLevel+1
            if this.disarmMeleeLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH,Status___OID_DISARM,this.unit)
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                endif
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            else
                if this.disarmRangeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            endif
        endmethod
        method removeDisarmMelee takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel-1
            if this.disarmMeleeLevel==0 then
                if this.disarmRangeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                else
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                endif
            endif
        endmethod
        method removeDisarmRange takes nothing returns nothing
            set this.disarmRangeLevel=this.disarmRangeLevel-1
            if this.disarmRangeLevel==0 then
                if this.disarmMeleeLevel>0 then
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                else
                    call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                endif
            endif
        endmethod
        method removeDisarm takes nothing returns nothing
            set this.disarmMeleeLevel=this.disarmMeleeLevel-1
            set this.disarmRangeLevel=this.disarmRangeLevel-1
            if this.disarmMeleeLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_MELEE)
                if this.disarmRangeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            elseif this.disarmRangeLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(this.unit,Status___BUFF_DISARM_RANGE)
                if this.disarmMeleeLevel>0 then
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                    endif
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE,Status___OID_DISARM,this.unit)
                    static if not Status___PERMENANTLY_REVEAL then
                        call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                    endif
                endif
            endif
        endmethod
        method isDisarmedMelee takes nothing returns boolean
            return this.disarmMeleeLevel>0
        endmethod
        method isDisarmedRange takes nothing returns boolean
            return this.disarmRangeLevel>0
        endmethod
        method isDisarmed takes nothing returns boolean
            return this.disarmMeleeLevel>0 and this.disarmRangeLevel>0
        endmethod
        
        // Immobolise
        private integer immoboliseLevel
        method addImmobolise takes nothing returns nothing
            set this.immoboliseLevel=this.immoboliseLevel+1
            if this.immoboliseLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_IMMOBOLISE,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeImmobolise takes nothing returns nothing
            set this.immoboliseLevel=this.immoboliseLevel-1
            if this.immoboliseLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_IMMOBOLISE_GROUND)
                call UnitRemoveAbility(this.unit,Status___BUFF_IMMOBOLISE_AIR)
            endif
        endmethod
        method isImmobolised takes nothing returns boolean
            return this.immoboliseLevel>0
        endmethod
        
        // Invisibility
        private integer invisibleLevel
        method addInvisible takes nothing returns nothing
            set this.invisibleLevel=this.invisibleLevel+1
            if this.invisibleLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_INVISIBLE)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_INVISIBLE)
            endif
        endmethod
        method removeInvisible takes nothing returns nothing
            set this.invisibleLevel=this.invisibleLevel-1
            if this.invisibleLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_INVISIBLE)
                call UnitRemoveAbility(this.unit,Status___ABIL_INVISIBLE)
            endif
        endmethod
        method isInvisible takes nothing returns boolean
            return this.invisibleLevel>0
        endmethod
        
        // Ghost
        private integer ghostLevel
        method addGhost takes nothing returns nothing
            set this.ghostLevel=this.ghostLevel+1
            if this.ghostLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_GHOST)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_GHOST)
            endif
        endmethod
        method removeGhost takes nothing returns nothing
            set this.ghostLevel=this.ghostLevel-1
            if this.ghostLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_GHOST)
                call UnitRemoveAbility(this.unit,Status___ABIL_GHOST)
            endif
        endmethod
        method isGhost takes nothing returns boolean
            return this.ghostLevel>0
        endmethod
        
        // Invulnerability
        private integer invulnerableLevel
        method addInvulnerable takes nothing returns nothing
            set this.invulnerableLevel=this.invulnerableLevel+1
            if this.invulnerableLevel>0 then
                call SetUnitInvulnerable(this.unit,true)
            endif
        endmethod
        method removeInvulnerable takes nothing returns nothing
            set this.invulnerableLevel=this.invulnerableLevel-1
            if this.invulnerableLevel==0 then
                call SetUnitInvulnerable(this.unit,false)
            endif
        endmethod
        method isInvulnerable takes nothing returns boolean
            return this.invulnerableLevel>0
        endmethod
        
        // Spell Immunity
        private integer immunityLevel
        method addImmunity takes nothing returns nothing
            set this.immunityLevel=this.immunityLevel+1
            if this.immunityLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_IMMUNITY)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_IMMUNITY)
            endif
        endmethod
        method removeImmunity takes nothing returns nothing
            set this.immunityLevel=this.immunityLevel-1
            if this.immunityLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_IMMUNITY)
                call UnitRemoveAbility(this.unit,Status___ABIL_IMMUNITY)
            endif
        endmethod
        method isImmune takes nothing returns boolean
            return this.immunityLevel>0
        endmethod
        
        // Pause
        private integer pauseLevel
        method addPause takes nothing returns nothing
            set this.pauseLevel=this.pauseLevel+1
            if this.pauseLevel>0 then
                call PauseUnit(this.unit,true)
            endif
        endmethod
        method removePause takes nothing returns nothing
            set this.pauseLevel=this.pauseLevel-1
            if this.pauseLevel==0 then
                call PauseUnit(this.unit,false)
            endif
        endmethod
        method isPaused takes nothing returns boolean
            return this.pauseLevel>0
        endmethod
        
        // Hide
        private integer hideLevel
        method addHide takes nothing returns nothing
            set this.hideLevel=this.hideLevel+1
            if this.hideLevel>0 then
                call ShowUnit(this.unit,false)
            endif
        endmethod
        method removeHide takes nothing returns nothing
            set this.hideLevel=this.hideLevel-1
            if this.hideLevel==0 then
                call ShowUnit(this.unit,true)
            endif
        endmethod
        method isHidden takes nothing returns boolean
            return this.hideLevel>0
        endmethod
        
        // Unpath
        private integer unpathLevel
        method addUnpath takes nothing returns nothing
            set this.unpathLevel=this.unpathLevel+1
            if this.unpathLevel>0 then
                call SetUnitPathing(this.unit,false)
            endif
        endmethod
        method removeUnpath takes nothing returns nothing
            set this.unpathLevel=this.unpathLevel-1
            if this.unpathLevel==0 then
                call SetUnitPathing(this.unit,true)
            endif
        endmethod
        method isUnpathed takes nothing returns boolean
            return this.unpathLevel>0
        endmethod
        
        // Hex
        private integer hexLevel
        method addHex takes nothing returns nothing
            set this.hexLevel=this.hexLevel+1
            if this.hexLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_HEX,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeHex takes nothing returns nothing
            set this.hexLevel=this.hexLevel-1
            if this.hexLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_HEX)
            endif
        endmethod
        method isHexed takes nothing returns boolean
            return this.hexLevel>0
        endmethod
        
        // Locust
        private integer locustLevel
        method addLocust takes nothing returns nothing
            set this.locustLevel=this.locustLevel+1
            if this.locustLevel>0 then
                call UnitAddAbility(this.unit,'Aloc')
                call UnitMakeAbilityPermanent(this.unit,true,'Aloc')
            endif
        endmethod
        method removeLocust takes nothing returns nothing
            set this.locustLevel=this.locustLevel-1
            if this.locustLevel==0 then
                call ShowUnit(this.unit,false)
                call UnitMakeAbilityPermanent(this.unit,false,'Aloc')
                call UnitRemoveAbility(this.unit,'Aloc')
                call ShowUnit(this.unit,true)
                call UnitAddAbility(this.unit,Status___ABIL_UNLOCUST)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_UNLOCUST)
                call IssueImmediateOrderById(this.unit,Status___OID_UNLOCUST)
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_UNLOCUST)
                call UnitRemoveAbility(this.unit,Status___ABIL_UNLOCUST)
            endif
        endmethod
        method isLocust takes nothing returns boolean
            return this.locustLevel>0
        endmethod
        
        // Never Miss
        private integer neverMissLevel
        method addNeverMiss takes nothing returns nothing
            set this.neverMissLevel=this.neverMissLevel+1
            if this.neverMissLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_NEVER_MISS)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_NEVER_MISS)
            endif
        endmethod
        method removeNeverMiss takes nothing returns nothing
            set this.neverMissLevel=this.neverMissLevel-1
            if this.neverMissLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_NEVER_MISS)
                call UnitRemoveAbility(this.unit,Status___ABIL_NEVER_MISS)
            endif
        endmethod
        method isNeverMiss takes nothing returns boolean
            return this.neverMissLevel>0
        endmethod
        
        // Always Miss
        private integer alwaysMissLevel
        method addAlwaysMiss takes nothing returns nothing
            set this.alwaysMissLevel=this.alwaysMissLevel+1
            if this.alwaysMissLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_ALWAYS_MISS)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_ALWAYS_MISS)
            endif
        endmethod
        method alwaysNeverMiss takes nothing returns nothing
            set this.alwaysMissLevel=this.alwaysMissLevel-1
            if this.alwaysMissLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_ALWAYS_MISS)
                call UnitRemoveAbility(this.unit,Status___ABIL_ALWAYS_MISS)
            endif
        endmethod
        method isAlwaysMiss takes nothing returns boolean
            return this.alwaysMissLevel>0
        endmethod
        
        // Untouchable
        private integer untouchableLevel
        method addUntouchable takes nothing returns nothing
            set this.untouchableLevel=this.untouchableLevel+1
            if this.untouchableLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_UNTOUCHABLE)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_UNTOUCHABLE)
            endif
        endmethod
        method removeUntouchable takes nothing returns nothing
            set this.untouchableLevel=this.untouchableLevel-1
            if this.untouchableLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_UNTOUCHABLE)
                call UnitRemoveAbility(this.unit,Status___ABIL_UNTOUCHABLE)
            endif
        endmethod
        method isUntouchable takes nothing returns boolean
            return this.untouchableLevel>0
        endmethod
        
        // Banish
        private integer banishLevel
        method addBanish takes nothing returns nothing
            set this.banishLevel=this.banishLevel+1
            if this.banishLevel>0 then
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,true)
                endif
                call IssueTargetOrderById(thistype.dummyCaster,Status___OID_BANISH,this.unit)
                static if not Status___PERMENANTLY_REVEAL then
                    call UnitShareVision(this.unit,Status___DUMMY_CASTER_OWNER,false)
                endif
            endif
        endmethod
        method removeBanish takes nothing returns nothing
            set this.banishLevel=this.banishLevel-1
            if this.banishLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_BANISH)
            endif
        endmethod
        method isBanished takes nothing returns boolean
            return this.banishLevel>0
        endmethod
        
        // Phase
        private integer phaseLevel
        method addPhase takes nothing returns nothing
            set this.phaseLevel=this.phaseLevel+1
            if this.phaseLevel>0 then
                call SetPlayerAbilityAvailable(GetOwningPlayer(this.unit),Status___ABIL_PHASE,true)
                if UnitAddAbility(this.unit,Status___ABIL_PHASE) then
                    call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_PHASE)
                endif
                call IssueImmediateOrderById(this.unit,Status___OID_PHASE)
                call SetPlayerAbilityAvailable(GetOwningPlayer(this.unit),Status___ABIL_PHASE,false)
            endif
        endmethod
        method removePhase takes nothing returns nothing
            set this.phaseLevel=this.phaseLevel-1
            if this.phaseLevel==0 then
                call UnitRemoveAbility(this.unit,Status___BUFF_PHASE)
            endif
        endmethod
        method isPhased takes nothing returns boolean
            return this.phaseLevel>0
        endmethod
        
        // Resistant Skin
        private integer resistantSkinLevel
        method addResistantSkin takes nothing returns nothing
            set this.resistantSkinLevel=this.resistantSkinLevel+1
            if this.resistantSkinLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_RESISTANT_SKIN)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_RESISTANT_SKIN)
            endif
        endmethod
        method removeResistantSkin takes nothing returns nothing
            set this.resistantSkinLevel=this.resistantSkinLevel-1
            if this.resistantSkinLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_RESISTANT_SKIN)
                call UnitRemoveAbility(this.unit,Status___ABIL_RESISTANT_SKIN)
            endif
        endmethod
        method isResistantSkin takes nothing returns boolean
            return this.resistantSkinLevel>0
        endmethod
        
        // Reflect Piercing
        private integer reflectPiercingLevel
        method addReflectPiercing takes nothing returns nothing
            set this.reflectPiercingLevel=this.reflectPiercingLevel+1
            if this.reflectPiercingLevel>0 then
                call UnitAddAbility(this.unit,Status___ABIL_REFLECT_PIERCING)
                call UnitMakeAbilityPermanent(this.unit,true,Status___ABIL_REFLECT_PIERCING)
            endif
        endmethod
        method removeReflectPiercing takes nothing returns nothing
            set this.reflectPiercingLevel=this.reflectPiercingLevel-1
            if this.reflectPiercingLevel==0 then
                call UnitMakeAbilityPermanent(this.unit,false,Status___ABIL_REFLECT_PIERCING)
                call UnitRemoveAbility(this.unit,Status___ABIL_REFLECT_PIERCING)
            endif
        endmethod
        method isReflectPiercing takes nothing returns boolean
            return this.reflectPiercingLevel>0
        endmethod
        
        
        ////////////////////
        // Status Bonuses //
        ////////////////////
        private static method setBonus takes unit u, integer abil, integer levels, integer amount returns nothing
            local boolean addNeg=false
            if amount<0 then
                set addNeg=true
                set amount=amount+thistype.twoPow[levels]
            else
                call UnitMakeAbilityPermanent(u,false,abil)
                call UnitRemoveAbility(u,abil)
            endif
            
            set abil=abil+levels
            set levels=thistype.twoPow[levels]
            loop
                set levels=levels/2
                
                if amount>=levels then
                    call UnitAddAbility(u,abil)
                    call UnitMakeAbilityPermanent(u,true,abil)
                    set amount=amount-levels
                else
                    call UnitMakeAbilityPermanent(u,false,abil)
                    call UnitRemoveAbility(u,abil)
                endif
                
                set abil=abil-1
                exitwhen levels==1
            endloop
            
            if addNeg then
                call UnitAddAbility(u,abil)
                call UnitMakeAbilityPermanent(u,true,abil)
            endif
        endmethod
        
        private integer armorBonus
        method modArmorBonus takes integer amount returns nothing
            set this.armorBonus=this.armorBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_ARMOR,Status___LEVELS_ARMOR,this.armorBonus)
        endmethod
        method getArmorBonus takes nothing returns integer
            return this.armorBonus
        endmethod
        
        private integer damageBonus
        method modDamageBonus takes integer amount returns nothing
            set this.damageBonus=this.damageBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_DAMAGE,Status___LEVELS_DAMAGE,this.damageBonus)
        endmethod
        method getDamageBonus takes nothing returns integer
            return this.damageBonus
        endmethod
        
        private integer strBonus
        method modStrBonus takes integer amount returns nothing
            set this.strBonus=this.strBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_STR,Status___LEVELS_STR,this.strBonus)
        endmethod
        method getStrBonus takes nothing returns integer
            return this.strBonus
        endmethod
        
        private integer agiBonus
        method modAgiBonus takes integer amount returns nothing
            set this.agiBonus=this.agiBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_AGI,Status___LEVELS_AGI,this.agiBonus)
        endmethod
        method getAgiBonus takes nothing returns integer
            return this.agiBonus
        endmethod
        
        private integer intBonus
        method modIntBonus takes integer amount returns nothing
            set this.intBonus=this.intBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_INT,Status___LEVELS_INT,this.intBonus)
        endmethod
        method getIntBonus takes nothing returns integer
            return this.intBonus
        endmethod
        
        private integer attackSpeedBonus
        method modAttackSpeedBonus takes integer amount returns nothing
            set this.attackSpeedBonus=this.attackSpeedBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_ATTACK_SPEED,Status___LEVELS_ATTACK_SPEED,this.attackSpeedBonus)
        endmethod
        method getAttackSpeedBonus takes nothing returns integer
            return this.attackSpeedBonus
        endmethod
        
        private integer healthBonus
        method modHealthBonus takes integer amount returns nothing
            set this.healthBonus=this.healthBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_HEALTH,Status___LEVELS_HEALTH,this.healthBonus)
        endmethod
        method getHealthBonus takes nothing returns integer
            return this.healthBonus
        endmethod
        
        private integer manaBonus
        method modManaBonus takes integer amount returns nothing
            set this.manaBonus=this.manaBonus+amount
            call thistype.setBonus(this.unit,Status___ABIL_MANA,Status___LEVELS_MANA,this.manaBonus)
        endmethod
        method getManaBonus takes nothing returns integer
            return this.manaBonus
        endmethod
        
        // Periodic bonuses
        private static unit updateUnit
        
        private static group healthRegenGroup=CreateGroup()
        private static method healthRegenPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetWidgetLife(thistype.updateUnit,GetWidgetLife(thistype.updateUnit)+thistype[thistype.updateUnit].healthRegenBonus)
            endif
        endmethod
        private real healthRegenBonus
        method modHealthRegenBonus takes real amount returns nothing
            set this.healthRegenBonus=this.healthRegenBonus+amount*Status___PERIOD
            if this.healthRegenBonus==0 then
                call GroupRemoveUnit(thistype.healthRegenGroup,this.unit)
            else
                call GroupAddUnit(thistype.healthRegenGroup,this.unit)
            endif
        endmethod
        method getHealthRegenBonus takes nothing returns real
            return this.healthRegenBonus/Status___PERIOD
        endmethod
        
        private static group manaRegenGroup=CreateGroup()
        private static method manaRegenPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetUnitState(thistype.updateUnit,UNIT_STATE_MANA,GetUnitState(thistype.updateUnit,UNIT_STATE_MANA)+thistype[thistype.updateUnit].manaRegenBonus)
            endif
        endmethod
        private real manaRegenBonus
        method modManaRegenBonus takes real amount returns nothing
            set this.manaRegenBonus=this.manaRegenBonus+amount*Status___PERIOD
            if this.manaRegenBonus==0 then
                call GroupRemoveUnit(thistype.manaRegenGroup,this.unit)
            else
                call GroupAddUnit(thistype.manaRegenGroup,this.unit)
            endif
        endmethod
        method getManaRegenBonus takes nothing returns real
            return this.manaRegenBonus/Status___PERIOD
        endmethod
        
        private static group healthRegenPercentGroup=CreateGroup()
        private static method healthRegenPercentPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetWidgetLife(thistype.updateUnit,GetWidgetLife(thistype.updateUnit)+GetUnitState(thistype.updateUnit,UNIT_STATE_MAX_LIFE)*thistype[thistype.updateUnit].healthRegenPercentBonus)
            endif
        endmethod
        private real healthRegenPercentBonus
        method modHealthRegenPercentBonus takes real amount returns nothing
            set this.healthRegenPercentBonus=this.healthRegenPercentBonus+amount*Status___PERIOD*0.01
            if this.healthRegenPercentBonus==0 then
                call GroupRemoveUnit(thistype.healthRegenPercentGroup,this.unit)
            else
                call GroupAddUnit(thistype.healthRegenPercentGroup,this.unit)
            endif
        endmethod
        method getHealthRegenPercentBonus takes nothing returns real
            return this.healthRegenPercentBonus/Status___PERIOD/0.01
        endmethod
        
        private static group manaRegenPercentGroup=CreateGroup()
        private static method manaRegenPercentPeriodic takes nothing returns nothing
            set thistype.updateUnit=GetEnumUnit()
            if UnitAlive(thistype.updateUnit) then
                call SetUnitState(thistype.updateUnit,UNIT_STATE_MANA,GetUnitState(thistype.updateUnit,UNIT_STATE_MANA)+GetUnitState(thistype.updateUnit,UNIT_STATE_MAX_MANA)*thistype[thistype.updateUnit].manaRegenPercentBonus)
            endif
        endmethod
        private real manaRegenPercentBonus
        method modManaRegenPercentBonus takes real amount returns nothing
            set this.manaRegenPercentBonus=this.manaRegenPercentBonus+amount*Status___PERIOD*0.01
            if this.manaRegenPercentBonus==0 then
                call GroupRemoveUnit(thistype.manaRegenPercentGroup,this.unit)
            else
                call GroupAddUnit(thistype.manaRegenPercentGroup,this.unit)
            endif
        endmethod
        method getManaRegenPercentBonus takes nothing returns real
            return this.manaRegenPercentBonus/Status___PERIOD/0.01
        endmethod
        
        // Links periodic effects.
        private static method periodicLink takes nothing returns nothing
            call ForGroup(thistype.healthRegenGroup,function thistype.healthRegenPeriodic)
            call ForGroup(thistype.manaRegenGroup,function thistype.manaRegenPeriodic)
            call ForGroup(thistype.healthRegenPercentGroup,function thistype.healthRegenPercentPeriodic)
            call ForGroup(thistype.manaRegenPercentGroup,function thistype.manaRegenPercentPeriodic)
        endmethod
        implement Status___StaticPeriodic
        
        ////////////////////
        // Movement Speed //
        ////////////////////
        
        private real moveSpeedBonus
        private real moveSpeedPercentBonus
        private real x
        private real y
        private static real updateUnitX
        private static real updateUnitY
        private static real xInc
        private static real yInc
        private static real updateDist
        private method periodic takes nothing returns nothing
            set thistype.updateUnit=this.unit
            set thistype.updateUnitX=GetUnitX(thistype.updateUnit)
            set thistype.updateUnitY=GetUnitY(thistype.updateUnit)
            set thistype.xInc=thistype.updateUnitX-this.x
            set thistype.yInc=thistype.updateUnitY-this.y
            set thistype.updateDist=SquareRoot(thistype.xInc*thistype.xInc+thistype.yInc*thistype.yInc)
            if thistype.updateDist>0 then
                if UnitAlive(thistype.updateUnit) and this.disableLevel<=0 and this.stunLevel<=0 and this.pauseLevel<=0 and this.immoboliseLevel<=0 and GetUnitMoveSpeed(thistype.updateUnit)>0 then
                    if this.moveSpeedPercentBonus!=0.0 then
                        set thistype.updateUnitX=thistype.updateUnitX+thistype.xInc*this.moveSpeedPercentBonus
                        set thistype.updateUnitY=thistype.updateUnitY+thistype.yInc*this.moveSpeedPercentBonus
                    endif
                    if this.moveSpeedBonus!=0.0 then
                        set thistype.updateDist=this.moveSpeedBonus/thistype.updateDist
                        set thistype.updateUnitX=thistype.updateUnitX+thistype.xInc*thistype.updateDist
                        set thistype.updateUnitY=thistype.updateUnitY+thistype.yInc*thistype.updateDist
                    endif
                    call SetUnitX(thistype.updateUnit,thistype.updateUnitX)
                    call SetUnitY(thistype.updateUnit,thistype.updateUnitY)
                endif
            endif
            set this.x=thistype.updateUnitX
            set this.y=thistype.updateUnitY
        endmethod
        implement T32xs
        method modMoveSpeedBonus takes real amount returns nothing
            set this.moveSpeedBonus=this.moveSpeedBonus+amount*T32_PERIOD
            if this.moveSpeedBonus==0 and this.moveSpeedPercentBonus==0 then
                call this.stopPeriodic()
            else
                set this.x=GetUnitX(this.unit)
                set this.y=GetUnitY(this.unit)
                call this.startPeriodic()
            endif
        endmethod
        method getMoveSpeedBonus takes nothing returns real
            return this.moveSpeedBonus/T32_PERIOD
        endmethod
        method modMoveSpeedPercentBonus takes real amount returns nothing
            set this.moveSpeedPercentBonus=this.moveSpeedPercentBonus+amount*0.01
            if this.moveSpeedBonus==0 and this.moveSpeedPercentBonus==0 then
                call this.stopPeriodic()
            else
                set this.x=GetUnitX(this.unit)
                set this.y=GetUnitY(this.unit)
                call this.startPeriodic()
            endif
        endmethod
        method getMoveSpeedPercentBonus takes nothing returns real
            return this.moveSpeedPercentBonus/0.01
        endmethod
    endstruct

//library Status ends
//library VectorLib:

//library VectorLib ends
//library CameraLock:
function TrackCamera takes real x, real y, integer i returns nothing
    if (GetLocalPlayer() == Player(i)) then
        call PanCameraToTimed(x, y, 1)
    endif
endfunction
function CameraLockAction takes nothing returns nothing
    local integer i = 0
    local real dir = 0
    local real x
    local real y
    local real d = 500
    if g_camera_lock then
        if heros[i] != null and IsUnitAliveBJ(heros[i]) then
            set dir = getFacing(heros[i])
            set x = GetUnitX(heros[i]) + Cos(dir) * d
            set y = GetUnitY(heros[i]) + Sin(dir) * d
            call TrackCamera(x, y, i)
        endif
    endif
endfunction
    
function CameraLockInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer,0.1,true,function CameraLockAction)
endfunction

//library CameraLock ends
//library FakeMan:
function FakeManInit takes nothing returns nothing
endfunction
struct RealMan
    unit man
    implement List
    static method create takes unit man returns RealMan
        local RealMan ys = .allocate()
            set ys.man = man
            call ys.addList()
        return ys
    endmethod
    method onDestroy takes nothing returns nothing
        call .removeList()
    endmethod
    static method CheckLevel takes real x, real y, string lv returns string
        local real distance = 1000000
        local real temp
        local RealMan ys = .getFirst()
        loop
            exitwhen ys == 0
            set temp = DistanceUnitAndXY(ys.man, x, y)
            if temp < distance then
                set distance = temp
            endif
            set ys = ys.getNext()
        endloop
        if distance >= LV_FREEZ_DISTANCE then
            return lv
        endif
        return LV_ACTIVE
    endmethod
endstruct
function AddRealMan takes unit man returns nothing
    call RealMan.create(man)
endfunction

//library FakeMan ends
//library FogControl:
function FogControlAction takes nothing returns nothing
    local integer i = 0
    local real x
    local real y
    local location l
    if g_fog then
        if heros[i] != null and IsUnitAliveBJ(heros[i]) then
            if fogms[i] != null then
                call FogModifierStop(fogms[i])
                call DestroyFogModifier(fogms[i])
            endif
            set x = GetUnitX(heros[i])
            set y = GetUnitY(heros[i])
            set l = Location(x, y)
            set fogms[i] = CreateFogModifierRadiusLocBJ( true, Player(i), FOG_OF_WAR_VISIBLE, l, EquipmentData[heros[i]].heroData.vision)
            set l = null
        endif
    endif
endfunction
    
function FogControlInit takes nothing returns nothing
    set fctimer=CreateTimer()
    call TimerStart(fctimer,1,true,function FogControlAction)
endfunction

//library FogControl ends
//library ItemEquip:
function HasConflictItemType takes unit u,item itm returns boolean
local integer i=0
local integer t
local integer typeid=GetItemTypeId(itm)
local item ui
if HaveSavedInteger(ht,typeid,kit)==false then
    return false
endif
set t=LoadInteger(ht,typeid,kit)
loop
    exitwhen i>5
    set ui=UnitItemInSlot(u,i)
    if ui!=itm and LoadInteger(ht,GetItemTypeId(ui),kit)==t then
        return true
    endif
    set i=i+1
endloop
return false
endfunction
function UnequipGun takes unit u,item i returns nothing
endfunction
function EquipGun takes unit u,item i returns nothing
    local integer t = GetItemTypeId(i)
    local IGun gun = IndividualItemData[i].featureData.gun
    call gun.setOwner(u)
    set EquipmentData[u].gun = gun
    set EquipmentData[u].heroData.equips[GUN] = t
endfunction
function AddItemSpell takes unit u , integer itemType returns nothing
    local ItemTypeData data= getItemTypeData(itemType)
    local integer spell = data.spell
    local integer lv = GetUnitAbilityLevel(GetTriggerUnit(), spell)
    if lv == 0 then
        call UnitAddAbility(u, spell)
    endif
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, true )
    call data.destroy()
endfunction
function RemoveItemSpell takes unit u , integer itemType returns nothing
    local ItemTypeData data= getItemTypeData(itemType)
    local integer spell = data.spell
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, false )
    call data.destroy()
endfunction
function AddItemStaticAbility takes unit u, integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local ItemTypeData data = getItemTypeData(itemType)
//textmacro instance: AddStaticAbility("s1")
    set s1 = data.s1
    if s1 != 0 then
        call UnitAddAbility(u, s1)
    endif
//end of: AddStaticAbility("s1")
//textmacro instance: AddStaticAbility("s2")
    set s2 = data.s2
    if s2 != 0 then
        call UnitAddAbility(u, s2)
    endif
//end of: AddStaticAbility("s2")
//textmacro instance: AddStaticAbility("s3")
    set s3 = data.s3
    if s3 != 0 then
        call UnitAddAbility(u, s3)
    endif
//end of: AddStaticAbility("s3")
call data.destroy()
endfunction
function RemoveItemStaticAbility takes unit u, integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local ItemTypeData data = getItemTypeData(itemType)
//textmacro instance: RemoveStaticAbility("s1")
    set s1 = getItemTypeData(itemType).s1
    if s1 != 0 then
        call UnitRemoveAbility(u, s1)
    endif
//end of: RemoveStaticAbility("s1")
//textmacro instance: RemoveStaticAbility("s2")
    set s2 = getItemTypeData(itemType).s2
    if s2 != 0 then
        call UnitRemoveAbility(u, s2)
    endif
//end of: RemoveStaticAbility("s2")
//textmacro instance: RemoveStaticAbility("s3")
    set s3 = getItemTypeData(itemType).s3
    if s3 != 0 then
        call UnitRemoveAbility(u, s3)
    endif
//end of: RemoveStaticAbility("s3")
call data.destroy()
endfunction
function ItemEquip takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType = GetItemTypeId(i)
    local integer t
    local ItemTypeData itd
    local IDialog d
    local string s
    if GetUnitTypeId(u)== HERO then
        if hasItemTypeData(itemType) then
            set itd = getItemTypeData(itemType)
            set t = itd.itemType
            if t == AB1 or t == AB2 then
                if EquipmentData[u].heroData.equips[t] > 0 then
                    if t == AB1 then
                        set s = MAJOR_AB
                    else
                        set s = MINOR_AB
                    endif
                    set d = ChangeAbDialog.create("鏄惁鍒囨崲"+s+"锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥?, GetOwningPlayer(u), t, EquipmentData[u].heroData.equips[t], itemType)
                    call d.display()
                else
                    call AddItemSpell(u, itemType)
                    call AddItemStaticAbility(u, itemType)
                    set EquipmentData[u].heroData.equips[t] = itemType
                endif
            elseif t == GUN then
                if EquipmentData[u].heroData.equips[t] > 0 then
                    set d = ChangeGunDialog.create("鏄惁鍒囨崲鏋锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥?, GetOwningPlayer(u), t, EquipmentData[u].heroData.equips[t], itemType, i)
                    call d.display()
                else
                    call EquipGun(u, i)
                endif
            endif
            call itd.destroy()
        endif
    endif
    set u=null
endfunction
function DropItem takes unit u, integer t returns nothing
    local integer i = 0
    local item itm
    loop
        exitwhen i > 5
        set itm = UnitItemInSlot(u, i)
        if GetItemTypeId(itm) == t then
            call UnitRemoveItemSwapped(itm, u)
        endif
        set i = i + 1
    endloop
    set itm = null
endfunction
function UnEquipItem takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType=GetItemTypeId(i)
    if GetUnitTypeId(u)== HERO then
        if hasItemTypeData(itemType) then
            call RemoveItemSpell(u, itemType)
            call RemoveItemStaticAbility(u, itemType)
        endif 
    endif
    set u=null
endfunction
function InitItemEquip takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_PICKUP_ITEM )
call TriggerAddCondition(t,function ItemEquip)
call TriggerRegisterAnyUnitEventBJ( t2, EVENT_PLAYER_UNIT_DROP_ITEM )
call TriggerAddCondition(t2,function UnEquipItem)
set t=null
set t2=null
endfunction

//library ItemEquip ends
//library MonsterTargetGroup:
function InitMonsterTargetGroup takes nothing returns nothing
    set MonsterTargetGroup=NewGroup()
endfunction
function BeMonsterTarget takes unit u returns nothing
    call GroupAddUnit(MonsterTargetGroup,u)
endfunction
function NotMonsterTarget takes unit u returns nothing
    call GroupRemoveUnit(MonsterTargetGroup,u)
    call GroupRefresh(MonsterTargetGroup)
endfunction

//library MonsterTargetGroup ends
//library ShootTarget:
function ShootEnergy takes nothing returns nothing
//local damagetype dt = Damage_GetType()
//local unit ds = GetEventDamageSource()
local unit ds = GetAttacker()
//if dt == DAMAGE_TYPE_NORMAL and GetUnitTypeId(ds) == 'h000' then
if GetUnitTypeId(ds) == HERO or GetUnitTypeId(ds) == EVIL_MARIN then
    set EquipmentData[ds].heroData.shoot_target = GetTriggerUnit()
    //call BJDebugMsg(R2S( GetTimeOfDay()))
    if EquipmentData[ds].gun != null then
        call EquipmentData[ds].gun.fire()
    endif
endif
set ds = null
endfunction
function InitShootTarget takes nothing returns nothing
set gtrgShootTarget=CreateTrigger()
//all Damage_RegisterEvent( gtrgShootTarget)
call TriggerRegisterAnyUnitEventBJ( gtrgShootTarget, EVENT_PLAYER_UNIT_ATTACKED )
call TriggerAddCondition(gtrgShootTarget,function ShootEnergy)
endfunction

//library ShootTarget ends
//library StartRoom:
function GamePlay_GaveGuns takes nothing returns nothing
    call TriggerSleepAction(1)
    call MovieStart()
    call MoveCamera(1221, -1785)
    call TriggerSleepAction(2)
    call CreateEffect(E_GUN_SHOW,1214,-1470)
    call CreateEffect(E_GUN_SHOW,1214,-1784)
    call CreateEffect(E_GUN_SHOW,1214,-2109)
    call TriggerSleepAction(5)
    call MovieSay(act1, "鍗фЫ锛屼粈涔堢帺鎰忓効锛?)
    call MovieSay(act1, "鐩磋鍛婅瘔鎴戜笉瑕佺瀹冧滑")
    call MovieEnd()
endfunction
function GamePlay_StartRoom_Open_Gate takes nothing returns nothing
    if not gateOpened then
        call TriggerSleepAction(1)
        call MovieStart()
        call StartShake()
        call TriggerSleepAction(2)
        call MovieSay(act1, "浠€涔堟儏鍐碉紒锛熴€傘€傘€?)
        call MoveCamera(3498.00, -1767.00)
        call TriggerSleepAction(5)
        call RemoveUnit( gg_unit_h006_0185 )
        call RemoveUnit( gg_unit_h006_0184 )
        call RemoveUnit( gg_unit_h006_0048 )
        call RemoveUnit( gg_unit_h006_0049 )
        call RemoveUnit( gg_unit_h006_0065 )
        call RemoveUnit( gg_unit_h006_0186 )
        call RemoveUnit( gg_unit_h006_0187 )
        call RemoveUnit( gg_unit_h006_0188 )
        set gateOpened = true
        call StopShake()
        call MovieSay(act1, "鐭冲鎵撳紑浜嗐€傘€傘€?)
        call MovieEnd()
        call LockAgain()
        call Seen(gg_rct_start_road_1)
    endif
endfunction
function GamePlay_StartRoom_Action takes nothing returns nothing
    local real x
    local real y
    local real tx = 0
    local real ty = 0
    local unit u = GetTriggerUnit()
    local integer i = 0
    local integer j = 0
    if not IsHero(u) then
        return
    endif
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    loop
        exitwhen i >= 4
        set j = 0
        loop
            exitwhen j >= 60
            if ModuloInteger(j, 4) == 0 then
                set ty = y
                set tx = x + j * 100
            elseif ModuloInteger(j, 4) == 1 then
                set tx = x - j * 100
                set ty = y
            elseif ModuloInteger(j, 4) == 2 then
                set ty = y + j * 100
                set tx = x
            else
                set ty = y - j * 100
                set tx = x
            endif
            if IsPointInRegion(GetTriggeringRegion(), tx, ty) then
                call SetUnitX(u, tx)
                call SetUnitY(u, ty)
                set i = 100
                set j = 1000
            endif
            set j = j + 1
        endloop
        set i = i + 1
    endloop
    set u = null
endfunction
function GamePlay_StartRoom takes nothing returns nothing
    local trigger trg = CreateTrigger()
    local trigger trg2 = CreateTrigger()
    local trigger trg3 = CreateTrigger()
    local region r = CreateRegion()
    local integer i = 0
    call RegionAddRect(r, gg_rct_start_road_1)
    call RegionAddRect(r, gg_rct_start_road_2)
    call TriggerRegisterLeaveRegionSimple( trg, r )
    call TriggerAddAction(trg, function GamePlay_StartRoom_Action)
    call YDWETriggerRegisterEnterRectSimpleNull( trg2, gg_rct_start_road_gate )
    call TriggerAddAction(trg2, function GamePlay_StartRoom_Open_Gate)
    call YDWETriggerRegisterEnterRectSimpleNull( trg3, gg_rct_gave_guns)
    call TriggerAddAction(trg3, function GamePlay_GaveGuns)
    loop
        exitwhen i >= 3
        if heros[i] != null then
            set cur_player = cur_player + 1
        endif
        set i = i + 1
    endloop
endfunction

//library StartRoom ends
//library Strong:
function DoStrongCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local real strong
    local real dam = GetEventDamage()
    local real doge
    if dam > 0.1 and IsHero(u) then
        set doge = EquipmentData[u].heroData.doge
        if GetRandomReal(0, 1) <= doge then
            call Damage_BlockAll()
            call DestroyEffect( AddSpecialEffect(E_DOGE, GetUnitX(u), GetUnitY(u)) )
        else
            set strong = EquipmentData[u].heroData.strong
            call Damage_Block(dam * strong)
        endif
    endif
    set u = null
endfunction
function InitStrong takes nothing returns nothing
local trigger doStrong_t=CreateTrigger()
call TriggerAddCondition(doStrong_t,function DoStrongCondition)
call Damage_RegisterEvent(doStrong_t)
set doStrong_t=null
endfunction

//library Strong ends
//library Stun:
function AddStun takes unit whichUnit returns nothing
        call Status[whichUnit].addStun()
    endfunction
    function RemoveStun takes unit whichUnit returns nothing
        call Status[whichUnit].removeStun()
    endfunction
    function Stun_IsUnitStunned takes unit whichUnit returns boolean
        return Status[whichUnit].isStunned()
    endfunction

//library Stun ends
//library TargetFilter:
    function IsLiveEnemy takes unit s,unit u returns boolean
        return s!= u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u))
    endfunction
    function IsLiveAlly takes unit s,unit u returns boolean
        return s!= u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u))
    endfunction
    
    function IsLiveEnemyUnit takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u)) and (Material[u].clazz == MC_UNIT)
    endfunction 
    
    function IsLiveAllyUnit takes unit s,unit u returns boolean
        return s!=u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u)) and (Material[u].clazz == MC_UNIT)
    endfunction 
    
    function IsLiveUnit takes unit s, unit u returns boolean
        return IsUnitAliveBJ(u) and Material[u].clazz == MC_UNIT
    endfunction
    function IsLiveUnitOrWall takes unit s, unit u returns boolean
        return IsUnitAliveBJ(u) and (Material[u].clazz == MC_UNIT or Material[u].clazz == MC_WALL)
    endfunction
    
//textmacro instance: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
    function HasLiveEnemyUnitInRange takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveEnemyUnit(s, ydl_unit) then
                set result = ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return result
    endfunction
//end of: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
//textmacro instance: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
    function HasLiveUnitInRange takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnit(s, ydl_unit) then
                set result = ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return result
    endfunction
//end of: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
    function GetNearestLiveUnit takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnit(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
    function GetNearestLiveUnitOrWall takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveUnitOrWall(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
//textmacro instance: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    function GetNearestEnemy takes unit s, real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru = null
        set ydl_group = CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r,null)
        loop
            set ydl_unit = FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s,ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= (r*2) and IsLiveEnemyUnit(s, ydl_unit) and d<mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group = null
        set ydl_unit = null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    
    function GetNearestEnemyInGroup takes unit u,group g returns unit
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        local group tg=NewGroup()
        call GroupAddGroup(g,tg)
        set ru=null
        loop
            set ydl_unit = FirstOfGroup(tg)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(tg, ydl_unit)
            set d=DistanceTwoUnits(u,ydl_unit)
            if d<mind and IsLiveEnemy(u,ydl_unit)then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        set ydl_unit = null
        call ReleaseGroup(tg)
        return ru
    endfunction
    

//library TargetFilter ends
//library AIApproach:
struct ApproachGroup
implement T32x
    group tg
    static method create takes nothing returns ApproachGroup
        local ApproachGroup g=ApproachGroup.allocate()
        set g.tg=NewGroup()
        call GroupAddGroup(appgro,g.tg)
        call g.startPeriodic()
        call BJDebugMsg("create approach group")
        return g
    endmethod
    
    method periodic takes nothing returns nothing
        local unit u
    local unit tu
    local real dir
    local real r
    local real d
    local real x
    local real y
    local real tx
    local real ty
        if ModuloInteger(Tick,15)==0 then
            set u=FirstOfGroup(tg)
        if u==null then
            call stopPeriodic()
            call BJDebugMsg("null create")
            call ApproachGroup.create()
            call destroy()
        else
        call GroupRemoveUnit(tg,u)
        set tu=GetNearestEnemyInGroup(u,MonsterTargetGroup)
    if IsUnitDeadBJ(u) then
       call GroupRemoveUnit(appgro,u)
       call GroupRefresh(appgro)
    endif
        set d=DistanceTwoUnits(u,tu)
        set dir=GetRandomReal(0,3.1416)
        set r=GetRandomReal(0,d)
        set x=GetUnitX(tu)+r*Cos(dir)
        set y=GetUnitY(tu)+r*Sin(dir)
        call IssuePointOrderById( u, 851983, x, y )
        set cur=cur+1
        call BJDebugMsg("cur issued "+I2S(cur))
        //call IssuePointOrderById( u, 851988, x, y )
        //call IssuePointOrder( u, "move", x, y )
        //call IssuePointOrder( u, "move", GetUnitX(u)+2000, GetRandomReal(-10000,10000) )
        //call PolledWait(0.05)
    endif
    endif
    endmethod
endstruct
function ApproacthTest takes nothing returns nothing
    local unit u
    local unit tu
    local real d
    local real dir
    local real r
    local real x
    local real y
    local group tg
    set tg=NewGroup()
    call GroupAddGroup(appgro,tg)
    loop
        set u=FirstOfGroup(tg)
        exitwhen u==null
        call GroupRemoveUnit(tg,u)
        set tu=GetNearestEnemyInGroup(u,MonsterTargetGroup)
        set d=DistanceTwoUnits(u,tu)
    if IsUnitDeadBJ(u) then
       call GroupRemoveUnit(appgro,u)
       call GroupRefresh(appgro)
    endif
    if d<1000 then
        call GroupRemoveUnit(appgro,u)
        call GroupAddUnit(attgro,u)
    else
        set dir=GetRandomReal(0,3.1416)
        set r=GetRandomReal(0,d)
        set x=GetUnitX(tu)+r*Cos(dir)
        set y=GetUnitY(tu)+r*Sin(dir)
        call IssuePointOrderById( u, 851986, x, y )
        //call IssuePointOrderById( u, 851988, x, y )
        //call IssuePointOrder( u, "move", x, y )
        //call IssuePointOrder( u, "move", GetUnitX(u)+2000, GetRandomReal(-10000,10000) )
        //call PolledWait(0.05)
    endif
    endloop
    call ReleaseGroup(tg)
    set u=null
    set tu=null
endfunction
function ApproachGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local unit tu=GetNearestEnemyInGroup(u,MonsterTargetGroup)
    local real d=DistanceTwoUnits(u,tu)
    local real dir
    local real r
    local real x
    local real y
    if IsUnitDeadBJ(u) then
        call GroupRemoveUnit(appgro,u)
        call GroupRefresh(appgro)
    endif
    if d<1000 then
        call GroupRemoveUnit(appgro,u)
        call GroupAddUnit(attgro,u)
    else
        set dir=GetRandomReal(0,3.1416)
        set r=GetRandomReal(0,d/2)
        set x=GetUnitX(tu)+r*Cos(dir)
        set y=GetUnitY(tu)+r*Sin(dir)
        call IssuePointOrderById( u, 851986, x, y )
    endif
    set u=null
    set tu=null
endfunction
function AIApproach takes nothing returns nothing 
    call ApproachGroup.create()
endfunction
function AIDispatch takes nothing returns nothing
    local unit u=GetTriggerUnit()
    if IsUnitOwnedByPlayer(u, Player(11)) then
        if IsUnitInGroup(u,appgro)==false then
            //call GroupAddUnit(appgro,u)
            //set sum=sum+1
            //call BJDebugMsg(I2S(sum))
        endif
    endif
    set u=null
endfunction
function AIAttackGA takes nothing returns nothing
    local unit u=GetEnumUnit()
    local unit tu=GetNearestEnemyInGroup(u,MonsterTargetGroup)
    local real r=DistanceTwoUnits(u,tu)
    if IsUnitDeadBJ(u) then
        call GroupRemoveUnit(attgro,u)
        call GroupRefresh(attgro)
    endif
    if r>1000 then
        call GroupRemoveUnit(attgro,u)
        call GroupAddUnit(appgro,u)
    else
        //call IssueTargetOrderById( u, 851983,tu )
        call IssuePointOrderById( u, 851983, GetUnitX(tu), GetUnitY(tu) )
    endif
    set u=null
    set tu=null
endfunction
function AIAttack takes nothing returns nothing
    call ForGroupBJ( attgro, function AIAttackGA)
endfunction
function InitAIApproach takes nothing returns nothing
    set appt=CreateTimer()
    set attt=CreateTimer()
    set appgro=NewGroup()
    set attgro=NewGroup()
    set aitrg=CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( aitrg, GetPlayableMapRect() )
    //call TimerStart(appt,80,true,function AIApproach)
    //call TimerStart(attt,5,true,function AIAttack)
    call TriggerAddCondition(aitrg,function AIDispatch)
endfunction

//library AIApproach ends
//library AIData:
struct AIData extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
IAIGroup currentAIGroup
unit targetUnit
static method AIDS_filter takes unit u returns boolean
    if GetOwningPlayer(u)==Player(11) then
        return true
    endif
    return false
endmethod
private method AIDS_onCreate takes nothing returns nothing
set targetUnit=GetNearestEnemyInGroup(.unit,MonsterTargetGroup)
call GetInMap(.unit)
endmethod
private method AIDS_onDestroy takes nothing returns nothing
set currentAIGroup=0
set targetUnit=null
endmethod
endstruct

//library AIData ends
//library AIGroup:
function InitAIGroup takes nothing returns nothing
    set gDefaultAIGroup=DefaultAIGroup.create()
endfunction
interface IAIGroup
group g
group tg
method getInterval takes nothing returns integer
method ailoop takes unit u returns nothing
method addUnit takes unit u returns nothing
method removeUnit takes unit u returns nothing
endinterface
struct DefaultAIGroup extends IAIGroup
implement T32x
static method create takes nothing returns DefaultAIGroup
    local DefaultAIGroup dag=DefaultAIGroup.allocate()
    set dag.g=NewGroup()
    set dag.tg=NewGroup()
    call GroupAddGroup(dag.g,dag.tg)
    call dag.startPeriodic()
    return dag
endmethod
method getInterval takes nothing returns integer
    return 15
endmethod
method ailoop takes unit u returns nothing
    local unit tu
    local real dir
    local real r
    local real d
    local real x
    local real y
    set tu=AIData[u].targetUnit
    set d=DistanceTwoUnits(u,tu)/2
    set dir=GetRandomReal(0,3.1416)
    set r=GetRandomReal(0,d)
    set x=GetUnitX(tu)+r*Cos(dir)
    set y=GetUnitY(tu)+r*Sin(dir)
    call IssuePointOrderById( u, 851983, x, y )
    set tu=null
endmethod
method onDestroy takes nothing returns nothing
    call stopPeriodic()
    call ReleaseGroup(g)
    call ReleaseGroup(tg)
endmethod
method periodic takes nothing returns nothing
    local unit u
    if ModuloInteger(Tick,getInterval())==0 then
    set u=FirstOfGroup(tg)
    if u==null then
        call GroupRefresh(tg)
        call GroupAddGroup(g,tg)
    else
        call GroupRemoveUnit(tg,u)
        if IsUnitInGroup(u,g) then
            if IsUnitAliveBJ(u) then
                call ailoop(u)
            else
                call removeUnit(u)
            endif
        endif
        set u=null
    endif
    endif
endmethod
method addUnit takes unit u returns nothing
    local IAIGroup cg=AIData[u].currentAIGroup
    if cg!=0 then
        call cg.removeUnit(u)
        call BJDebugMsg("group change")
    endif
    set AIData[u].currentAIGroup=this
    call GroupAddUnit(g,u)
    call GroupAddUnit(tg,u)
endmethod
method removeUnit takes unit u returns nothing
    set AIData[u].currentAIGroup=0
    call GroupRemoveUnit(g,u)
    call GroupRefresh(g)
endmethod
endstruct

//library AIGroup ends
//library CustomDamage:
function NormalDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
endfunction
function rangeOneTimeSpellDamageToUnit takes unit source ,real x ,real y ,real radius, real damage, string efs,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group = CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsLiveEnemy(source,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) and Material[ydl_unit].clazz == MC_UNIT then
            call Damage_Spell(source,ydl_unit,damage)
            call GroupAddUnit(gro,ydl_unit )
        endif
        endloop
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    call DestroyGroup(ydl_group)
    set ydl_group = null
    set ydl_unit = null
endfunction
function BulletDamage takes unit source, unit target, real damage, string efs returns nothing
    local real finalDamage = damage
    if IsHero(source) then
        if EquipmentData[source].gun.getGunType() == MACHINE_GUN then
            set finalDamage = finalDamage * EquipmentData[source].heroData.machine_gun_buff
        endif
    endif
    call Damage_Spell(source,target,finalDamage)
    call DestroyEffect( AddSpecialEffect(efs, GetUnitX(target), GetUnitY(target)) )
endfunction
function ExplodeDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
endfunction
function rangeExplodeDamage takes unit source ,real x ,real y ,real radius, real damage returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemyUnit(source,ydl_unit) then
            call ExplodeDamage(source,ydl_unit,damage)
        endif
        endloop
    set ydl_unit = null
endfunction
function RadiationDamage takes unit target returns nothing
    local real finalDamage = 1
    local real antrad
    if IsHero(target) then
        set finalDamage = finalDamage * (1 - EquipmentData[target].heroData.antrad)
        set finalDamage = RMaxBJ(0, finalDamage)
    endif
    call SetUnitLifeBJ(target, GetUnitStateSwap(UNIT_STATE_LIFE, target) - finalDamage)
endfunction
function KillMana takes unit source, unit target, real damage returns nothing
    local real mana = GetUnitState(target, UNIT_STATE_MANA)
    local real mb
    if IsHero(source) then
        set mb = EquipmentData[source].heroData.mana_boom_percent
        call BJDebugMsg(R2S(damage))
        call BJDebugMsg(R2S(damage*mb))
        call NormalDamage(source, target, damage*mb)
        call DestroyEffect(AddSpecialEffectZ(E_MANA_BOOM,GetUnitX(target),GetUnitY(target),100))
    endif
    call SetUnitState(target,UNIT_STATE_MANA, mana - damage)
    call DestroyEffect(AddSpecialEffectZ(E_KILL_MANA,GetUnitX(target),GetUnitY(target),100))
endfunction
function IceDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    local real frezz
    if IsHero(source) then
        set frezz = EquipmentData[source].heroData.frezz
        if GetRandomReal(0,1) <= frezz then
            call Frezz(source,target,1)
        endif
    endif
    call Damage_Spell(source,target,finalDamage)
endfunction
function FireDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
endfunction
function EnergyDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
endfunction
function LightningDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
endfunction
function BladeDamage takes unit source, unit target, real damage returns nothing
    local real finalDamage = damage
    local real kill_mana = damage * EquipmentData[source].heroData.kill_mana_percent
    call Damage_Spell(source,target,finalDamage)
endfunction
function CollisionDamage takes unit source, unit target, real damage, real dir, boolean efs returns nothing
    local real finalDamage = damage
    call Damage_Spell(source,target,finalDamage)
    if efs then
        call KillUnit( CreateUnit(GetOwningPlayer(source),euCOLLISION,GetUnitX(target),GetUnitY(target),dir-(pi/2) ))
    endif
endfunction
function rangeSpellDamage takes unit source ,real x ,real y ,real radius, real damage, string efs returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemy(source,ydl_unit) then
            call Damage_Spell(source,ydl_unit,damage)
        endif
        endloop
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    set ydl_unit = null
endfunction
function rangeSpellDamageOneUnit takes unit source ,real x ,real y ,real radius, real damage, string efs returns nothing
    local unit t=GetNearestEnemy(source,radius)
    call Damage_Spell(source,t,damage)
    call DestroyEffect( AddSpecialEffect(efs, x, y) )
    set t=null
endfunction

//library CustomDamage ends
//library DialogSystem:
function CancelDialog takes nothing returns nothing
    local dialog d=GetClickedDialogBJ()
    local button b=GetClickedButton()
    local IDialog data = GetDialogStructA(d)
    call data.button_clicked(b)
    call DialogDisplay(data.p, d, false)
    call data.destroy()
    call ClearDialogStructA(d)
endfunction
interface IDialog
    dialog d
    trigger dtr
    player p
    string name
    button cancel_button
    button array choses[20]
    integer choses_size
    method init takes nothing returns nothing
    method display takes nothing returns nothing
    method button_clicked takes button b returns nothing
endinterface
struct DefaultDialog extends IDialog
    static method create takes string name, player p returns DefaultDialog
        local DefaultDialog g=DefaultDialog.allocate()
        set g.d=DialogCreate()
        set g.dtr=CreateTrigger()
        set g.p = p
        set g.name = name
        set g.choses_size = 0
        call DialogSetMessage(g.d,name)
        call SetDialogStructA(g.d, g)
        call TriggerRegisterDialogEvent(g.dtr, g.d)
        call TriggerAddCondition(g.dtr, Condition(function CancelDialog))
        return g
    endmethod
    method button_clicked takes button b returns nothing
    endmethod
    method init takes nothing returns nothing
    endmethod
    method onDestroy takes nothing returns nothing
        local integer i = 0
        loop
            exitwhen i >= choses_size
            if GetButtonStructA(choses[i]) != 0 then
                call ClearButtonStructA(choses[i])
                set choses[i] = null
                set i = i+1
            endif
        endloop
        call DialogClear(d)
        call DialogDestroy(d)
        call TriggerClearConditions(dtr)
        call DestroyTrigger(dtr)
        set cancel_button = null
        set d = null
        set dtr = null
        set p = null
    endmethod
    method display takes nothing returns nothing
        call init()
        set cancel_button = DialogAddButton(d,"鍙栨秷",0)
        call DialogDisplay(p,d,true)
    endmethod
endstruct
struct ChangeAbDialog extends DefaultDialog
    integer oi
    integer ni
    integer t
    static method create takes string name, player p, integer t, integer oi, integer ni returns ChangeAbDialog
        local ChangeAbDialog g=ChangeAbDialog.allocate(name,p)
        set g.oi = oi
        set g.ni = ni
        set g.t = t
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit u
        if b != cancel_button then
            set u = heros[GetPlayerId(p)]
            call DropItem(u, oi)
            call AddItemSpell(u, ni)
            call AddItemStaticAbility(u, ni)
            set EquipmentData[u].heroData.equips[t] = ni
        else
            set u = heros[GetPlayerId(p)]
            call DropItem(u, ni)
        endif
        set u = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s = "鍒囨崲"
        set b = DialogAddButton(d, s ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
endstruct
struct ChangeGunDialog extends DefaultDialog
    integer oi
    integer ni
    integer t
    item itm
    static method create takes string name, player p, integer t, integer oi, integer ni, item itm returns ChangeGunDialog
        local ChangeGunDialog g=ChangeGunDialog.allocate(name,p)
        set g.oi = oi
        set g.ni = ni
        set g.t = t
        set g.itm = itm
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit u
        if b != cancel_button then
            set u = heros[GetPlayerId(p)]
            call DropItem(u, oi)
            call EquipGun(u, itm)
            set EquipmentData[u].heroData.equips[t] = ni
        else
            set u = heros[GetPlayerId(p)]
            call DropItem(u, ni)
        endif
        set u = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s = "鍒囨崲"
        set b = DialogAddButton(d, s ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
endstruct
struct TransformDialog extends DefaultDialog
    ItemFeatureData fd
    static method create takes string name, player p, ItemFeatureData fd returns TransformDialog
        local TransformDialog g=TransformDialog.allocate(name,p)
        set g.fd = fd
        return g
    endmethod
    method button_clicked takes button b returns nothing
        local unit hero
        local ItemFeature f
        set f = GetButtonStructA(b)
        if b != cancel_button then
            if GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) >= (f.lv+1)*f.gold then
                if GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) >= (f.lv+1)*f.wood then
                    set f.lv = f.lv + 1
                    call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) - f.lv*f.gold )
                    call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) - f.lv*f.wood )
                else
                    call DisplayText(p, "杩涘寲鐐逛笉澶燂紝闇€瑕?" +I2S((f.lv+1)*f.wood))
                endif
            else
                call DisplayText(p, "榛勯噾涓嶅锛岄渶瑕?" +I2S((f.lv+1)*f.gold))
            endif
        else
            set hero = heros[GetPlayerId(p)]
            //call CreateItem(iUPGADE,GetUnitX(hero),GetUnitY(hero))
        endif
        set hero = null
    endmethod
    method init takes nothing returns nothing
        local button b
        local string s
//textmacro instance: AddFeatureButton("1")
        if fd.f1.maxlv > 0 and fd.f1.lv < fd.f1.maxlv then
            set s = fd.f1.name + " " + "(" + I2S(fd.f1.lv) + "/" + I2S(fd.f1.maxlv) + ")" + " "
            if fd.f1.step > 0 then
                set s = s + "+" + " " + R2S(fd.f1.step)
            else
                set s = s + "-" + " " + R2S(-fd.f1.step)
            endif
            set s = s + " " + I2S(fd.f1.gold * (fd.f1.lv+1)) + "G"
            if fd.f1.wood > 0 then
                set s = s + " " + I2S(fd.f1.wood * (fd.f1.lv+1)) + "P"
            endif
            set b = DialogAddButton(d, s ,1)
            call SetButtonStructA(b ,fd.f1)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("1")
//textmacro instance: AddFeatureButton("2")
        if fd.f2.maxlv > 0 and fd.f2.lv < fd.f2.maxlv then
            set s = fd.f2.name + " " + "(" + I2S(fd.f2.lv) + "/" + I2S(fd.f2.maxlv) + ")" + " "
            if fd.f2.step > 0 then
                set s = s + "+" + " " + R2S(fd.f2.step)
            else
                set s = s + "-" + " " + R2S(-fd.f2.step)
            endif
            set s = s + " " + I2S(fd.f2.gold * (fd.f2.lv+1)) + "G"
            if fd.f2.wood > 0 then
                set s = s + " " + I2S(fd.f2.wood * (fd.f2.lv+1)) + "P"
            endif
            set b = DialogAddButton(d, s ,2)
            call SetButtonStructA(b ,fd.f2)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("2")
//textmacro instance: AddFeatureButton("3")
        if fd.f3.maxlv > 0 and fd.f3.lv < fd.f3.maxlv then
            set s = fd.f3.name + " " + "(" + I2S(fd.f3.lv) + "/" + I2S(fd.f3.maxlv) + ")" + " "
            if fd.f3.step > 0 then
                set s = s + "+" + " " + R2S(fd.f3.step)
            else
                set s = s + "-" + " " + R2S(-fd.f3.step)
            endif
            set s = s + " " + I2S(fd.f3.gold * (fd.f3.lv+1)) + "G"
            if fd.f3.wood > 0 then
                set s = s + " " + I2S(fd.f3.wood * (fd.f3.lv+1)) + "P"
            endif
            set b = DialogAddButton(d, s ,3)
            call SetButtonStructA(b ,fd.f3)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("3")
//textmacro instance: AddFeatureButton("4")
        if fd.f4.maxlv > 0 and fd.f4.lv < fd.f4.maxlv then
            set s = fd.f4.name + " " + "(" + I2S(fd.f4.lv) + "/" + I2S(fd.f4.maxlv) + ")" + " "
            if fd.f4.step > 0 then
                set s = s + "+" + " " + R2S(fd.f4.step)
            else
                set s = s + "-" + " " + R2S(-fd.f4.step)
            endif
            set s = s + " " + I2S(fd.f4.gold * (fd.f4.lv+1)) + "G"
            if fd.f4.wood > 0 then
                set s = s + " " + I2S(fd.f4.wood * (fd.f4.lv+1)) + "P"
            endif
            set b = DialogAddButton(d, s ,4)
            call SetButtonStructA(b ,fd.f4)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("4")
//textmacro instance: AddFeatureButton("5")
        if fd.f5.maxlv > 0 and fd.f5.lv < fd.f5.maxlv then
            set s = fd.f5.name + " " + "(" + I2S(fd.f5.lv) + "/" + I2S(fd.f5.maxlv) + ")" + " "
            if fd.f5.step > 0 then
                set s = s + "+" + " " + R2S(fd.f5.step)
            else
                set s = s + "-" + " " + R2S(-fd.f5.step)
            endif
            set s = s + " " + I2S(fd.f5.gold * (fd.f5.lv+1)) + "G"
            if fd.f5.wood > 0 then
                set s = s + " " + I2S(fd.f5.wood * (fd.f5.lv+1)) + "P"
            endif
            set b = DialogAddButton(d, s ,5)
            call SetButtonStructA(b ,fd.f5)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
        endif
//end of: AddFeatureButton("5")
        set b = null
    endmethod
endstruct
struct FreeTransformDialog extends TransformDialog
    method button_clicked takes button b returns nothing
        local unit hero
        local ItemFeature f
        set f = GetButtonStructA(b)
        if b != cancel_button then
            set f.lv = f.lv + 1
        else
            set hero = heros[GetPlayerId(p)]
            call CreateItem(iFREEUP,GetUnitX(hero),GetUnitY(hero))
        endif
        set hero = null
    endmethod
endstruct
struct ButtonTech
    integer id
    static method create takes integer id returns ButtonTech
        local ButtonTech g=ButtonTech.allocate()
        set g.id = id
        return g
    endmethod
endstruct
struct ChooseTechDialog extends DefaultDialog
    
    private method heroHasTech takes unit hero, integer tech returns boolean
        return false
    endmethod
    method getHotestTech takes unit hero, integer selectId1, integer selectId2, integer selectId3, integer selectId4 returns integer
        local integer array prob
        local integer size = EquipmentData[hero].heroData.tech_counter.size
        local string s = ""
        local integer i = 0
        local integer id = -1
        local integer r = 0
        local integer j = 0
        local integer k = 0
        local integer c = 0
        local integer t = 0
        local integer l = 0 
        local integer array randtree
        local integer array randtech
        //call BJDebugMsg("-------------------------")
        //calculate proberity
        loop
            exitwhen i >= TT_COUNT
            set prob[i] = EquipmentData[hero].heroData.tech_counter.cnt[i]
            //call BJDebugMsg("prob " + I2S(i) + " " + I2S(prob[i]))
            set i = i + 1
        endloop
        
        //rand seq tech tree chose
        set k = 0
        loop
            exitwhen k > TT_COUNT - 1
            set randtree[k] = k
            set k = k + 1
        endloop
        
        set j = 0
        loop
            exitwhen j >= TT_COUNT
            set k = GetRandomInt(0, TT_COUNT - 1)
            set r = GetRandomInt(0, TT_COUNT - 1)
            if (GetRandomReal(0,1) > 0.9) or (prob[r] <= prob[k] and r < k) then
                set t = randtree[r]
                set randtree[r] = randtree[k]
                set randtree[k] = t
            endif
            set j = j + 1
        endloop
            
        //main loop tech tree
        loop
            exitwhen id > 0 or l >= TT_COUNT
            set c = randtree[l]
            //call BJDebugMsg("tech tree " + I2S(c))
            //rand seq tech chose
            set k = 0
            loop
                exitwhen k >= TECH_TREE_COUNT[c]
                set randtech[k] = k
                set k = k + 1
            endloop
            
            set j = 0
            loop
                exitwhen j >= TECH_TREE_COUNT[c]
                set k = GetRandomInt(0, TECH_TREE_COUNT[c] - 1)
                //call BJDebugMsg("rand chose " + I2S(k))
                set t = randtech[0]
                set randtech[0] = randtech[k]
                set randtech[k] = t
                set j = j + 1
            endloop
            //loop chose tech
            set i = 0
            loop
                exitwhen id > 0 or i >= TECH_TREE_COUNT[c]
                set r= randtech[i]
                //call BJDebugMsg("tech nth " + I2S(r))
                //call BJDebugMsg("tech " + I2S(TECH_TREES[c].itms[r]))
                if TECH_TREES[c].itms[r] != selectId1 and TECH_TREES[c].itms[r] != selectId2 and TECH_TREES[c].itms[r] != selectId3 and TECH_TREES[c].itms[r] != selectId4 then
                    if not heroHasTech(hero, TECH_TREES[c].itms[r]) then
                        set id = TECH_TREES[c].itms[r]
                    endif
                endif
                set i = i + 1
            endloop 
            set l = l + 1
        endloop
        return id
    endmethod
    method button_clicked takes button b returns nothing
        local ButtonTech bt
        local integer pid
        local integer id
        local string name
        if b == choses[3] then
            call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
            call DisplayInfo(p, "鑾峰緱涓ょ偣绉戞妧鐐?)
        else
            set bt = GetButtonStructA(b)
            set pid = GetPlayerId(p)
            set id = bt.id
            set name = LoadStr(tdht,id,tdht_name)
            call DisplayInfo(p, "浣犲浼氫簡 " + name)
            set EquipmentData[heros[GetPlayerId(p)]].heroData.up_point = EquipmentData[heros[GetPlayerId(p)]].heroData.up_point - 1
            call UnitAddAbility(techs[pid], id)
            call DispatchTechAdd(id, GetUnitAbilityLevel(techs[pid], id), pid)
        endif
    endmethod
    
    method init takes nothing returns nothing
        local button b
        local unit hero = heros[GetPlayerId(p)]
        local integer tech1 = getHotestTech(hero,-1,-1,-1,-1)
        local integer tech2 = getHotestTech(hero,tech1,-1,-1,-1)
        local integer tech3 = getHotestTech(hero,tech1,tech2,-1,-1)
        local string s1
        local string s2
        local string s3
        local string s4
        local string s5
        //local integer tech2 = getHotestTech(hero,tech1,-1,-1,-1)
//textmacro instance: AddTechButton("1")
        if tech1 > 0 then
            //call BJDebugMsg(I2S(tech1))
            set s1 = LoadStr(tdht,tech1,tdht_name)
            set b = DialogAddButton(d, s1 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech1))
            set b = null
        endif
//end of: AddTechButton("1")
//textmacro instance: AddTechButton("2")
        if tech2 > 0 then
            //call BJDebugMsg(I2S(tech2))
            set s2 = LoadStr(tdht,tech2,tdht_name)
            set b = DialogAddButton(d, s2 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech2))
            set b = null
        endif
//end of: AddTechButton("2")
//textmacro instance: AddTechButton("3")
        if tech3 > 0 then
            //call BJDebugMsg(I2S(tech3))
            set s3 = LoadStr(tdht,tech3,tdht_name)
            set b = DialogAddButton(d, s3 ,0)
            set choses[choses_size] = b
            set choses_size = choses_size + 1
            call SetButtonStructA(b, ButtonTech.create(tech3))
            set b = null
        endif
//end of: AddTechButton("3")
        set choses[3] = DialogAddButton(d, "涓ょ偣绉戞妧鐐? ,0)
    endmethod
    
    method display takes nothing returns nothing
        call init()
        call DialogDisplay(p,d,true)
    endmethod
    
endstruct
struct ChooseBonusDialog extends DefaultDialog
    method button_clicked takes button b returns nothing
        call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) + 100)
    endmethod
    
    method init takes nothing returns nothing
        local button b
        local unit hero = heros[GetPlayerId(p)]
        set b = DialogAddButton(d, "閲戝竵+100" ,0)
        set choses[choses_size] = b
        set choses_size = choses_size + 1
        set b = null
    endmethod
    
    method display takes nothing returns nothing
        call init()
        call DialogDisplay(p,d,true)
    endmethod
    
endstruct

//library DialogSystem ends
//library HorrorOrder:
    function HorrorMove takes unit u returns nothing
        local unit ne
        local real tx
        local real ty
        local real dir
        set ne = GetNearestEnemy(u, 800)
        if ne != null then
            set dir = getTargetDir(ne, u) + GetRandomReal(-1.5,1.5)
        else
            set dir = GetRandomReal(0, 2 * pi)
        endif
        set tx = GetUnitX(u) + 1200 * Cos(dir)
        set ty = GetUnitY(u) + 1200 * Sin(dir)
        call IssuePointOrderById( u, OI_MOVE, tx, ty )
        set ne = null
    endfunction

//library HorrorOrder ends
//library Buffer:
function MoveBufferStruct takes nothing returns nothing
    call DefaultBufferStruct.loopMoveAll()
endfunction
    
function BufferStructInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer,0.02,true,function MoveBufferStruct)
endfunction
interface IBufferStruct
    unit u
    
    integer count
    
    boolean flag
    
    method condition takes nothing returns boolean
    method addBuffer takes nothing returns nothing
    
    method removeBuffer takes nothing returns nothing
    
    method finish takes nothing returns nothing
    
    method init takes unit u, integer count returns nothing
    method action takes nothing returns nothing
endinterface
struct DefaultBufferStruct extends IBufferStruct
    implement List
    
    method condition takes nothing returns boolean
        set count = count - 1
        call action()
        return count >= 0 and IsUnitAliveBJ(u)
    endmethod
    
    method action takes nothing returns nothing
    endmethod
    
    method addBuffer takes nothing returns nothing
    endmethod
    
    method removeBuffer takes nothing returns nothing
    endmethod
    
    method init takes unit u, integer count returns nothing
    endmethod
    
    method start takes nothing returns nothing
        set flag =true
        call addBuffer()
    endmethod
       
    static method create takes unit u, integer count returns DefaultBufferStruct
        local DefaultBufferStruct m=DefaultBufferStruct.allocate()
        set m.u=u
        set m.count=count
        set m.flag=false
        call m.addList()
        call m.init(u, count)
        return m
    endmethod
    
    method onDestroy takes nothing returns nothing
        if flag then
            call removeBuffer()
        endif
        set u=null
        call removeList()
        call finish()
    endmethod
    
    method finish takes nothing returns nothing
    endmethod
    
    static method loopMoveAll takes nothing returns nothing
         local boolean r
         local DefaultBufferStruct m = getFirst() 
             loop
                 exitwhen m == 0
                 if m.flag then
                     set r = m.condition()
                     if r then
                     else
                        call m.destroy()
                     endif
                     set m = m.getNext()
                 endif
             endloop
    endmethod
    
endstruct
struct BoundUnitEffectStruct extends DefaultBufferStruct
    unit eu
    
    integer uid
    
    real bais
    
    string animate
    
    real z
    
    method addBuffer takes nothing returns nothing
        set eu = CreateUnit(GetOwningPlayer(u), uid, GetUnitX(u), GetUnitY(u), GetUnitFacing(u) + bais)
        call SetUnitFlyHeight(eu,GetUnitFlyHeight(u) + z,0)
        call SetUnitAnimation( eu, animate )
    endmethod
    
    method action takes nothing returns nothing
        call SetUnitX(eu, GetUnitX(u))
        call SetUnitY(eu, GetUnitY(u))
        call SetUnitFlyHeight(eu,GetUnitFlyHeight(u) + z,0)
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call KillUnit(eu)
    endmethod
    
    static method create takes unit u, integer count, integer uid, real bais, string animate, real z returns BoundUnitEffectStruct
        local BoundUnitEffectStruct m=BoundUnitEffectStruct.allocate(u, count)
        set m.uid = uid
        set m.bais = bais
        set m.animate = animate
        set m.z = z
        return m
    endmethod
    
    method finish takes nothing returns nothing
        set eu=null
    endmethod
    
endstruct
struct ElectricWhipBufferStruct extends DefaultBufferStruct
    unit source
       
    real dam
    
    vector pref
    
    private lightning l
    method condition takes nothing returns boolean
        local real dis = DistanceTwoUnits(source, u)
        set count = count - 1
        call action()
        return count >= 0 and dis > 200 and IsUnitAliveBJ(source) and IsUnitAliveBJ(u)
    endmethod
    
    private method removef takes vector v returns nothing
        call Velocity[u].a.subtract(v)
    endmethod
    
    private method addf takes vector v returns nothing
        call Velocity[u].a.add(v)
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.5
        local vector v = Velocity[u].v
        local real len = v.getLength()
        local vector dir = getDirVector(u, source, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method addBuffer takes nothing returns nothing
        set l = AddLightningEx( "CLPB", false, GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u) )
    endmethod
    
    method action takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call removef( pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call addf( pref)
        call LightningDamage(source, u, dam/50)
        call MoveLightningEx( l, false, GetUnitX(source),GetUnitY(source),getUnitHeight(source), GetUnitX(u), GetUnitY(u),getUnitHeight(u))
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call DestroyLightning(l)
        call removef(pref)
        call pref.destroy()
        set l = null
        set source = null
        set u = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns ElectricWhipBufferStruct
        local ElectricWhipBufferStruct m = ElectricWhipBufferStruct.allocate(u, count)
        set m.source = source
        set m.dam = dam
        set m.pref = vector.create(0,0,0)
        return m
    endmethod
    
    method finish takes nothing returns nothing
    endmethod
    
endstruct

//library Buffer ends
//library ChooseBonus:
function ChooseBonusCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    set EquipmentData[u].heroData.bonus_point = EquipmentData[u].heroData.bonus_point + 1
    set u = null
endfunction
function UseBonusCondition takes nothing returns nothing
    local player p = GetTriggerPlayer()
    local unit hero = heros[GetPlayerId(p)]
    if EquipmentData[hero].heroData.bonus_point > 0 then
        call ChooseBonusDialog.create("閫夋嫨涓€涓崌绾у鍔?, p).display()
    endif
    set p = null
    set hero = null
endfunction
function InitChooseBonus takes nothing returns nothing
local trigger choosebonus_t=CreateTrigger()
local trigger usebonus_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( choosebonus_t, EVENT_PLAYER_HERO_LEVEL )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(1), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(2), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(3), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(4), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(5), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerRegisterPlayerKeyEventBJ( usebonus_t, Player(0), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT )
call TriggerAddCondition(choosebonus_t,function ChooseBonusCondition)
call TriggerAddCondition(usebonus_t,function UseBonusCondition)
set choosebonus_t=null
set usebonus_t=null
endfunction

//library ChooseBonus ends
//library ChooseTech:
function ChooseTechCondition takes nothing returns nothing
    local unit u = GetTriggerUnit()
    local integer lv = GetHeroLevel(u)
    if ModuloInteger(lv, 3) == 0 then
        set EquipmentData[u].heroData.up_point = EquipmentData[u].heroData.up_point + 1
        call BJDebugMsg("uppoint")
    endif
    set u = null
endfunction
function UseTechCondition takes nothing returns nothing
    local player p = GetTriggerPlayer()
    local unit hero = heros[GetPlayerId(p)]
    if EquipmentData[hero].heroData.up_point > 0 then
        call ChooseTechDialog.create("閫夋嫨涓€涓鎶€", p).display()
    endif
    set p = null
    set hero = null
endfunction
function InitChooseTech takes nothing returns nothing
local trigger choosetech_t=CreateTrigger()
local trigger usetech_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( choosetech_t, EVENT_PLAYER_HERO_LEVEL )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(1), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(2), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(3), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(4), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(5), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerRegisterPlayerKeyEventBJ( usetech_t, Player(0), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP )
call TriggerAddCondition(choosetech_t,function ChooseTechCondition)
call TriggerAddCondition(usetech_t,function UseTechCondition)
set choosetech_t=null
set usetech_t=null
endfunction

//library ChooseTech ends
//library Radiation:
function DoRadiationCondition takes nothing returns nothing
    local integer i = 0
    loop
        exitwhen i > 4 
        if heros[i] != null and IsUnitAliveBJ(heros[i]) and UnitHasBuffBJ(heros[i], 'B004') then
            call RadiationDamage(heros[i])
        endif
        set i = i + 1
    endloop
endfunction
function InitRadiation takes nothing returns nothing
local trigger doRadiation_t=CreateTrigger()
call TriggerAddCondition(doRadiation_t,function DoRadiationCondition)
call TriggerRegisterTimerEventPeriodic( doRadiation_t, 1.00 )
set doRadiation_t=null
endfunction

//library Radiation ends
//library Transform:
function TransformCondition takes nothing returns nothing
    local unit tu = GetTriggerUnit()
    local player owner = GetOwningPlayer(tu)
    local item ti = GetManipulatedItem()
    local integer tii = GetItemTypeId(ti)
    local item target_item
    local ItemFeatureData fd
    local ItemTypeData data
    local IDialog d
    local string s = " 閫夋嫨涓€涓己鍖?
    if GetUnitTypeId(tu)== HERO and tii == iUPGADE then
        set target_item = UnitItemInSlot(tu, 0)
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = TransformDialog.create(data.name +s,owner,fd)
            call d.display()
            call data.destroy()
        endif
    elseif GetUnitTypeId(tu)== HERO and tii == iFREEUP then
        set target_item = UnitItemInSlot(tu, 0)
        if target_item != null then
            set data = getItemTypeData(GetItemTypeId(target_item))
            set fd = IndividualItemData[target_item].featureData
            set d = FreeTransformDialog.create(data.name +" 鍏嶈垂寮哄寲",owner,fd)
            call d.display()
            call data.destroy()
        else
            call CreateItem(iFREEUP,GetUnitX(heros[GetPlayerId(owner)]),GetUnitY(heros[GetPlayerId(owner)]))
        endif
    endif
    set tu = null
    set owner = null
    set ti = null
    set target_item = null
endfunction
function InitTransform takes nothing returns nothing
local trigger transform_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ( transform_t, EVENT_PLAYER_UNIT_PICKUP_ITEM )
call TriggerAddCondition(transform_t,function TransformCondition)
set transform_t=null
endfunction

//library Transform ends
//library PhysicsSystem:
function AddVelocity takes unit u, vector n returns nothing
    call Velocity[u].v.add(n)
endfunction
function AddForce takes unit u, vector a returns nothing
    call Velocity[u].a.add(a)
endfunction
function RemoveForce takes unit u, vector a returns nothing
    call Velocity[u].a.subtract(a)
endfunction
function Push takes unit u, real dir, real d, real h, integer s returns nothing
    local vector a = vector.create(d*Cos(dir),d*Sin(dir), h)
    local PushForceStruct pfs = PushForceStruct.create(u, s, a)
    call pfs.start()
endfunction
struct PushForceStruct extends DefaultBufferStruct
    vector fc
    
    method addBuffer takes nothing returns nothing
        call AddForce(u, fc)
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call RemoveForce(u, fc)
    endmethod
    
    static method create takes unit u, integer count, vector fc returns PushForceStruct
        local PushForceStruct m=PushForceStruct.allocate(u, count)
        set m.fc=fc
        return m
    endmethod
    
    method finish takes nothing returns nothing
        call fc.destroy()
    endmethod
    
endstruct

//library PhysicsSystem ends
//library Missle:
function missleRangeOneTimeActionToUnit takes IMissle source ,real x ,real y ,real radius,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    //set ydl_group = NewGroup()
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius,null) 
        loop
        set ydl_unit = FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        //if DistanceUnitAndXY(ydl_unit,x,y) <= Material[ydl_unit].volume + radius then
        
            if IsLiveEnemyUnit(source.owner,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) then
                call source.debuffEnemy(ydl_unit)
                call source.damageEnemy(ydl_unit)
                call GroupAddUnit(gro,ydl_unit )
            elseif IsLiveAllyUnit(source.owner,ydl_unit) and (not IsUnitInGroup(ydl_unit,gro)) then
            //call BJDebugMsg("fdsa")
                call source.healAlly(ydl_unit)
                call GroupAddUnit(gro,ydl_unit)
            elseif IsUnitAliveBJ(ydl_unit) and ydl_unit == source.owner and source.origin_life - source.life > LEAVE_COUNT then
                call source.hitSelf(ydl_unit)
                call GroupAddUnit(gro,ydl_unit )
            endif
        //endif
        endloop
    //call ReleaseGroup(ydl_group)
    //set ydl_group = null
    set ydl_unit = null
endfunction
interface IMissle
    
    unit missle
    unit owner
    integer life
    integer origin_life
    group damaged
    boolean started
    method doDamage takes real radius returns nothing
    method getFinalDamage takes nothing returns real
    method fireMissle takes vector vi returns nothing
    method onFire takes nothing returns nothing
    method getOriginalDamage takes nothing returns real
    method getMissleId takes nothing returns integer
    method step takes nothing returns nothing
    method getLife takes nothing returns integer
    method substep takes nothing returns nothing
    method explode takes nothing returns nothing
    method damageEnemy takes unit target returns nothing
    method debuffEnemy takes unit target returns nothing
    method healAlly takes unit target returns nothing
    method hitSelf takes unit self returns nothing
    method refreshDamagedGroup takes nothing returns nothing
    method troughDamage takes unit target returns nothing
    
endinterface
struct Missle extends IMissle
    method getMissleId takes nothing returns integer
        return 'e000'
    endmethod
    
    method refreshDamagedGroup takes nothing returns nothing
        local group newGroup
        local unit ydl_unit
        if not IsUnitGroupEmptyBJ(damaged) then
            set newGroup = CreateGroup()
            loop
            set ydl_unit = FirstOfGroup(damaged)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(damaged, ydl_unit)
            if DistanceTwoUnits(missle, ydl_unit) <= REDAMAGE_DISTANCE then
                call GroupAddUnit(newGroup, ydl_unit)
            endif
            endloop
            set damaged = newGroup
        endif
        set newGroup = null
        set ydl_unit = null
    endmethod
    method troughDamage takes unit target returns nothing
    endmethod
    
    method doDamage takes real radius returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
    endmethod
    
    method damageEnemy takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
        call destroy()
    endmethod
    
    method debuffEnemy takes unit target returns nothing
    endmethod
    
    method healAlly takes unit target returns nothing
        //call HealUnit(owner, target, 50, HEAL_TYPE_NORMAL)
        //call destroy()
    endmethod
    
    method hitSelf takes unit self returns nothing
    endmethod
    
    
    method fireMissle takes vector vi returns nothing
        set missle = CreateUnit(GetOwningPlayer(owner), getMissleId(), GetUnitX(owner), GetUnitY(owner), getDeg(vi.y, vi.x))
        if GetUnitFlyHeight(owner) > g_sd_th then
            call SetUnitFlyHeight(missle, GetUnitFlyHeight(owner), 0)
        endif
        set life = getLife()
        set origin_life = life
        call onFire()
        set started = true
        set Velocity[missle].v = vi
        set Velocity[missle].missleStruct = this
    endmethod
    
    method onFire takes nothing returns nothing
    endmethod
    
    method substep takes nothing returns nothing
    endmethod
    
    method getLife takes nothing returns integer
        return 30
    endmethod
    
    static method create takes unit owner returns Missle
        local Missle m=Missle.allocate()
        //set m.damaged=NewGroup()
        set m.damaged=CreateGroup()
        set m.owner=owner
        set m.started=false
        return m
    endmethod
    
    method step takes nothing returns nothing
        set life = life - 1
        call substep()
        if life <= 0 then
            call destroy()
        endif
    endmethod
    
    method getFinalDamage takes nothing returns real
        local real od = getOriginalDamage()
        return od
    endmethod
    
    method getOriginalDamage takes nothing returns real
        return 50.0
    endmethod
    
    method hitGround takes nothing returns nothing
        call destroy()
    endmethod
    
    method explode takes nothing returns nothing
        //call BJDebugMsg("explode")
    endmethod
    
    method onDestroy takes nothing returns nothing
        call explode()
        set owner=null
        call KillUnit(missle)
        call GroupClear(damaged)
        call DestroyGroup(damaged)
        //call GroupRefresh(damaged)
        //call ReleaseGroup(damaged)
        set damaged = null
        set missle=null
    endmethod
    
endstruct
struct TroughMissle extends Missle
    
    method damageEnemy takes unit target returns nothing
        local real consume
        call troughDamage(target)
        set consume = ( Material[target].hardness * Material[target].volume ) / 100
        if life <= consume then
            call destroy()
        else
            set life = life - R2I(consume)
        endif
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
    endmethod
    
endstruct
struct ShootGunMissle extends Missle
    method getLife takes nothing returns integer
        return 15
    endmethod
endstruct
struct IceMissle extends Missle
    method getMissleId takes nothing returns integer
        return bICE_MISSLE
    endmethod
    
    method damageEnemy takes unit target returns nothing
        call IceDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        local unit dummy
        set dummy = CreateUnit(GetOwningPlayer(owner),MAGIC,GetUnitX(target),GetUnitY(target),0)
        call IssueTargetOrderById( dummy, 852226,target )
        set dummy = null
    endmethod
    
endstruct
struct FireMissle extends Missle
    method damageEnemy takes unit target returns nothing
        call FireDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
    
    method getMissleId takes nothing returns integer
        return bFIRE_MISSLE
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        call ApplyBurn(owner, target, 1, 3)
    endmethod
endstruct
struct SmallDarts extends Missle
    method getMissleId takes nothing returns integer
        return 'e002'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method damageEnemy takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
        call destroy()
    endmethod
endstruct
struct ElectricWhip extends Missle
    private lightning l
    
    method getMissleId takes nothing returns integer
        return bELECTRIC
    endmethod 
    
    method getOriginalDamage takes nothing returns real
        return 0.0
    endmethod
    
    method getLife takes nothing returns integer
        return R2I(getf2value(owner, iELECTRIC))
    endmethod
    
    method debuffEnemy takes unit target returns nothing
        call ElectricBlow(owner, target)
        call ElectricWhipBufferStruct.create(target, 150, owner, 5).start()
    endmethod
    
    method onFire takes nothing returns nothing
        set l = AddLightningEx( "CLPB", false, GetUnitX(missle),GetUnitY(missle),getUnitHeight(missle), GetUnitX(owner), GetUnitY(owner),getUnitHeight(owner) )
    endmethod
    
    method substep takes nothing returns nothing
        call MoveLightningEx( l, false, GetUnitX(missle),GetUnitY(missle),getUnitHeight(missle), GetUnitX(owner), GetUnitY(owner),getUnitHeight(owner) )
    endmethod
    
    method explode takes nothing returns nothing
        call DestroyLightning(l)
    endmethod
    
endstruct
struct ReturnDarts extends TroughMissle
    vector pref
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 130.0
    endmethod
    method getLife takes nothing returns integer
        return 10000
    endmethod
    method debuffEnemy takes unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endmethod
    method hitSelf takes unit self returns nothing
        call destroy()
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real daminc = f2.getValue()
        local real od = getOriginalDamage()
        set itm = null
        return od + daminc
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.7
        local vector v = Velocity[missle].v
        local real len = v.getLength()
        local vector dir = getDirVector(missle, owner, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call RemoveForce(missle, pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call AddForce(missle, pref)
    endmethod
endstruct
struct LeaveDarts extends TroughMissle
    vector pref
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method getLife takes nothing returns integer
        return 1000
    endmethod
    method debuffEnemy takes unit target returns nothing
        call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        call ApplyBleed(owner, target, 1, 10)
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real daminc = f2.getValue()
        local real od = getOriginalDamage()
        set itm = null
        return od + daminc
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local vector dir = getDirVector(missle, owner, 6)
        set itm = null
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call RemoveForce(missle, pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call AddForce(missle, pref)
    endmethod
endstruct
struct BackGrenade extends Missle
    method getMissleId takes nothing returns integer
        return 'e009'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method debuffEnemy takes unit target returns nothing
        local integer lv = R2I(IndividualItemData[GetItemByTypeId(owner, iBKGRENADE)].featureData.f3.getValue())
        if lv > 0 then
            call Stun(owner, target, lv)
        endif
    endmethod
    method damageEnemy takes unit target returns nothing
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        local item itm = GetItemByTypeId(owner, iBKGRENADE)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real radius = f2.getValue()
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
        call DestroyEffect( AddSpecialEffect(E_TUNDER_CLAP, x, y) )
        set itm = null
    endmethod
    method getLife takes nothing returns integer
        return 300
    endmethod
endstruct
struct PushGrenade extends Missle
    method getMissleId takes nothing returns integer
        return 'e00A'
    endmethod 
    method getOriginalDamage takes nothing returns real
        return 100.0
    endmethod
    method debuffEnemy takes unit target returns nothing
        local item itm = GetItemByTypeId(owner, iPSGRENADE)
        local ItemFeature f3 = IndividualItemData[itm].featureData.f3
        local real speed = f3.getValue()
        local real lv = IndividualItemData[GetItemByTypeId(owner, iPSGRENADE)].featureData.f4.getValue()
        local real facing = getTargetDir(missle, target)
        if lv > 0 then
            call Clap(owner, target, R2I(lv))
        endif
        call Push(target, facing, speed, 0, 5)
        set itm = null
    endmethod
    method damageEnemy takes unit target returns nothing
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        local item itm = GetItemByTypeId(owner, iPSGRENADE)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real radius = f2.getValue()
        call missleRangeOneTimeActionToUnit(this,x,y,radius,damaged)
        call DestroyEffect( AddSpecialEffect(E_CLAP, x, y) )
        set itm = null
    endmethod
    method getLife takes nothing returns integer
        return 300
    endmethod
endstruct
struct Mine extends Missle
    
    boolean active
    
    integer count
    
    method getMissleId takes nothing returns integer
        return 'e00B'
    endmethod 
    method substep takes nothing returns nothing
        if active == false then
            if life < getLife() - getDeployTime() and HasLiveEnemyUnitInRange(missle, 200) != null then
                set active = true
            endif
        else
            if count > 0 then
                set count = count - 1
            else
                call destroy()
            endif
        endif
    endmethod
    method explode takes nothing returns nothing
        local real x = GetUnitX(missle)
        local real y = GetUnitY(missle)
        call DestroyEffect( AddSpecialEffect(E_MINE_EXPLODE, x, y) )
        call rangeExplodeDamage(owner, x, y, 200, 300)
    endmethod
    method getLife takes nothing returns integer
        return 3000
    endmethod
    method getDeployTime takes nothing returns integer
        return 122
    endmethod
    static method create takes unit owner returns Mine
        local Mine m=Mine.allocate(owner)
        set m.active=false
        set m.count=20
        return m
    endmethod
endstruct
struct ShoulderCannonMissle extends Missle
    method damageEnemy takes unit target returns nothing
        call BulletDamage(owner, target, getFinalDamage(), SMALL_BLOOD)
        call destroy()
    endmethod
    
    method getLife takes nothing returns integer
        return 30
    endmethod
    method getOriginalDamage takes nothing returns real
        return 400.0
    endmethod
    
    method getMissleId takes nothing returns integer
        return 'e00E'
    endmethod
endstruct
struct SpearMissle extends Missle
    method getLife takes nothing returns integer
        return 30
    endmethod
    method getOriginalDamage takes nothing returns real
        return g_missle_damage + 20
    endmethod
    method getMissleId takes nothing returns integer
        return 'e00F'
    endmethod
endstruct
struct SmartDarts extends TroughMissle
    vector pref
    
    unit t
    
    integer count
    
    integer swift
    
    method getMissleId takes nothing returns integer
        set pref = vector.create(0,0,0)
        return 'e003'
    endmethod
    
    method getOriginalDamage takes nothing returns real
        return 130.0
    endmethod
    method getLife takes nothing returns integer
        return 10000
    endmethod
    method debuffEnemy takes unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endmethod
    
    static method create takes unit owner, unit target returns thistype
        local thistype m=thistype.allocate(owner)
        set m.t = target
        set m.count = 3
        set m.swift = 0
        return m
    endmethod
    method hitSelf takes unit self returns nothing
    endmethod
    method getFinalDamage takes nothing returns real
        local item itm = GetItemByTypeId(owner, iRETURN)
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real daminc = f2.getValue()
        local real od = getOriginalDamage()
        set itm = null
        return od + daminc
    endmethod
    
    method troughDamage takes unit target returns nothing
        call BladeDamage(owner, target, getFinalDamage())
        if target == t then
            set count = count - 1
            set swift = 10
            if count == 0 then
                set t = null
                call destroy()
            endif
        endif
    endmethod
    
    private method getReturnForce takes nothing returns vector
        local real fl = 0.7
        local vector v = Velocity[missle].v
        local real len = v.getLength()
        local vector dir = getDirVector(missle, t, fl*5)
        local real angle = vector.getAngle(v, dir)
        local real a = Sin(angle) * len
        local real sd
        local vector r
        local real dl
        if swift > 0 then
            set swift = swift - 1
            return vector.create(0,0,0)
        endif
        if angle >= (pi / 2) then
            set sd = len
        else
            set sd = a
        endif
        if sd > fl then
            set r = vector.create(-v.x,-v.y,-v.z)
            call r.setLength(RMinBJ(len, fl))
            call r.add(dir)
            call dir.destroy()
            return r
        else
            if angle >= (pi / 2) then
                set dl = SquareRoot(fl*fl - a*a) - SquareRoot(len*len - a*a)
            else
                set dl = SquareRoot(fl*fl - a*a) + SquareRoot(len*len - a*a)
            endif
            set r = vector.create(dir.x,dir.y,dir.z)
            call r.setLength(dl)
            call r.subtract(v)
            call r.add(dir)
            call dir.destroy()
            return r
        endif
        return dir
    endmethod
    method explode takes nothing returns nothing
        call pref.destroy()
    endmethod
    
    method substep takes nothing returns nothing
        local vector returnForce
        set returnForce = getReturnForce()
        call RemoveForce(missle, pref)
        set pref.x = returnForce.x
        set pref.y = returnForce.y
        set pref.z = returnForce.z
        call returnForce.destroy()
        call AddForce(missle, pref)
    endmethod
endstruct

//library Missle ends
//library Shooter:
interface IShooter
    unit owner
    IMissleFactory factory
    
    method shoot takes vector dir returns nothing
    method getEnergyConsume takes nothing returns integer
    method subshoot takes vector dir returns nothing
    method getRist takes nothing returns real
    method shootCount takes nothing returns integer
    method getOriginSpeed takes nothing returns real
    method getClipSize takes nothing returns integer
    method shoothz takes nothing returns integer
    method tick takes nothing returns nothing
endinterface
struct AbstractShooter extends IShooter
    implement T32xs
    
    method tick takes nothing returns nothing
    endmethod
    
    method periodic takes nothing returns nothing
        call tick()
    endmethod
        
    static method create takes unit owner ,IMissleFactory factory returns thistype
        local thistype s=thistype.allocate()
        set s.owner=owner
        set s.factory=factory
        call s.startPeriodic()
        return s
    endmethod
    
    method shoothz takes nothing returns integer
        return 10
    endmethod
    
    method getClipSize takes nothing returns integer
        return 10
    endmethod
    
    method shootCount takes nothing returns integer
        return 1
    endmethod
    method getRist takes nothing returns real
        return 100.0
    endmethod
    method getOriginSpeed takes nothing returns real
        return 60.0
    endmethod
    
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
    
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    method subshoot takes vector dir returns nothing
    endmethod
    
    method onDestroy takes nothing returns nothing
        call stopPeriodic()
        set owner=null
    endmethod
    
endstruct
struct SingleShooter extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct ShoulderCannonShooter extends AbstractShooter
    
    integer c
    
    vector d
    
    integer t
    static method create takes unit owner ,IMissleFactory factory returns thistype
        local thistype s=thistype.allocate(owner, factory)
        set s.c = 2
        return s
    endmethod
    method tick takes nothing returns nothing
        local vector v
        if ModuloInteger(Tick - this.t, 4) == 0 then
            if this.c > 0 then
                set v = vector.create(d.x, d.y, d.z)
                call v.rotate(vector.create(0, 0, 1), 0.1 * (3 - this.c))
                call factory.createMissle(owner).fireMissle(v)
                set this.c = this.c - 1
            else
                call destroy()
            endif
        endif
    endmethod
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call dir.rotate(vector.create(0, 0, 1), -0.1)
        set this.d = dir
        call m.fireMissle(dir)
        set this.t = Tick
    endmethod
endstruct
struct GrenadeThrower extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct MineThrower extends AbstractShooter
    method shoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
endstruct
struct DefaultShooter extends AbstractShooter
    method shoot takes vector dir returns nothing
        local integer ec = getEnergyConsume()
        local vector vdir
        local integer i = 1
        local integer n = 0
        set n = (Material[owner].shot_tick + shoothz() + Material[owner].shot_fast_buff) / SHOTHZ
        set Material[owner].shot_tick = ModuloInteger(Material[owner].shot_tick + shoothz() + Material[owner].shot_fast_buff, SHOTHZ)
        if n == 0 then
            if ((GetTimeOfDay() - Material[owner].last_shoot)/0.005) * (shoothz() + Material[owner].shot_fast_buff) > 100 then
                set n = 1
                set Material[owner].shot_tick = 0
            endif
        endif
        loop
            exitwhen i > n * shootCount()
            set i = i + 1
            set vdir = getShootVector()
            if IsHero(owner) then
                if not EquipmentData[owner].heroData.reload and GetPlayerState(GetOwningPlayer(owner), PLAYER_STATE_RESOURCE_LUMBER) >= ec then
                    call energyConsume(ec)
                    call backForce(getShootDir())
                    call subshoot(vdir)
                    set Material[owner].last_shoot = GetTimeOfDay()
                else
                    if not EquipmentData[owner].heroData.reload then
                        set EquipmentData[this.owner].heroData.shoot_energy = 0
                        call SetPlayerState(GetOwningPlayer(owner),PLAYER_STATE_RESOURCE_LUMBER, 0)
                        call UnitAddAbility(owner, 'Abun')
                        set EquipmentData[owner].heroData.reload = true
                    endif
                    call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"!",1)
                endif
            else
                if not EquipmentData[owner].heroData.reload and EquipmentData[owner].heroData.bullets >= ec then
                    call energyConsume(ec)
                    call backForce(getShootDir())
                    call subshoot(vdir)
                    set Material[owner].last_shoot = GetTimeOfDay()
                else
                    if not EquipmentData[owner].heroData.reload then
                        set EquipmentData[this.owner].heroData.shoot_energy = 0
                        set EquipmentData[this.owner].heroData.bullets = 0
                        call UnitAddAbility(owner, 'Abun')
                        set EquipmentData[owner].heroData.reload = true
                    endif
                    call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"!",1)
                endif 
            endif
        endloop
    endmethod
    
    method getSpeed takes nothing returns real
        return getOriginSpeed()
    endmethod
    
    method getShootDir takes nothing returns real
        local unit target = EquipmentData[this.owner].heroData.shoot_target
        local real ux = GetUnitX(owner)
        local real uy = GetUnitY(owner)
        local real tx = GetUnitX(target)
        local real ty = GetUnitY(target)
        local real dir = getDir(ux,uy,tx,ty)
        set target = null
        return dir
    endmethod
    
    method getShootVector takes nothing returns vector
        local unit target = EquipmentData[this.owner].heroData.shoot_target
        local real ux = GetUnitX(owner)
        local real uy = GetUnitY(owner)
        local real uz = getUnitHeight(owner)
        local real tx = GetUnitX(target)
        local real ty = GetUnitY(target)
        local real tz = getUnitHeight(target)
        local real rr = GetRandomReal(0, 2 * pi)
        local real hr = EquipmentData[owner].heroData.shoot_rist
        local real rist = getRist() * RMaxBJ(0,(1 - hr)) * SquareRoot(Pow(ty-uy,2)+Pow(tx-ux,2)) / 900
        local real tx2 = GetUnitX(target) + Cos(rr) * rist
        local real ty2 = GetUnitY(target) + Sin(rr) * rist
        local vector t = vector.create(tx2 - ux, ty2 - uy, tz - uz)
        call t.setLength(getSpeed())
        return t
    endmethod
    
    method subshoot takes vector dir returns nothing
        local IMissle m=factory.createMissle(owner)
        call m.fireMissle(dir)
    endmethod
    
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    
    method energyConsume takes integer consume returns nothing
        local integer l
        if IsHero(owner) then
            set l = GetPlayerState(GetOwningPlayer(owner), PLAYER_STATE_RESOURCE_LUMBER)
            call SetPlayerState(GetOwningPlayer(owner),PLAYER_STATE_RESOURCE_LUMBER, l - consume)
        else
            set l = EquipmentData[owner].heroData.bullets
            set EquipmentData[owner].heroData.bullets = l - consume
        endif
    endmethod
    
    method backForce takes real vdir returns nothing
        local real facing = vdir + pi
        call Push(owner, facing, EquipmentData[owner].heroData.a_shoot_back_log, 0, 5)
    endmethod
    
endstruct
struct ShootGunShooter extends DefaultShooter
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    
    method shootCount takes nothing returns integer
        return 12
    endmethod
    method getRist takes nothing returns real
        return 200.0
    endmethod
    method getOriginSpeed takes nothing returns real
        return 80.0
    endmethod
endstruct
struct MachineGunShooter extends DefaultShooter
    method shoothz takes nothing returns integer
        return 100
    endmethod
    method getEnergyConsume takes nothing returns integer
        return 1
    endmethod
    method getClipSize takes nothing returns integer
        return 100
    endmethod
endstruct

//library Shooter ends
//library Velocity:
function LoopCollisionGroupUnit takes nothing returns nothing
    local unit u = GetEnumUnit()
    local group tempGroup = NewGroup()
    call GroupEnumUnitsInRange(tempGroup, GetUnitX(u), GetUnitY(u), Material[u].volume,null)
    if CountUnitsInGroup(tempGroup) == 1 then
        call GroupRemoveUnit(COLLISION_GROUP, u)
    endif
    call ReleaseGroup(tempGroup)
    set tempGroup = null
endfunction
function LoopCollisionGroup takes nothing returns nothing
    call ForGroup(COLLISION_GROUP, function LoopCollisionGroupUnit)
    call GroupRefresh(COLLISION_GROUP)
endfunction
function MoveMissles takes nothing returns nothing
    call VelocityUnit.loopMoveAllMissles()
endfunction
    
function MissleInit takes nothing returns nothing
    set missleMoveTimer=CreateTimer()
    set collisionGroupTimer = CreateTimer()
    set COLLISION_GROUP = NewGroup()
    call TimerStart(missleMoveTimer,0.03125,true,function MoveMissles)
    call TimerStart(collisionGroupTimer,1,true,function LoopCollisionGroup)
endfunction
function BulletCollision takes unit b, unit u, real r returns nothing
    local Missle missle = Velocity[b].missleStruct
    call missle.doDamage(r)
endfunction
function UnitHitWall takes unit s, unit u, real v, real dir, boolean efs returns nothing
    call CollisionDamage(s, u, v, dir, efs)
endfunction
function UnitCollision takes unit u1, unit u2 returns nothing
    local real x1 = GetUnitX(u1)
    local real y1 = GetUnitY(u1)
    local real x2 = GetUnitX(u2)
    local real y2 = GetUnitY(u2)
    local vector vn = vector.create(x1 - x2, y1 - y2,0)
    local vector v_un = vector.unitVector(vn)
    local vector v_ut = vector.create(-v_un.y, v_un.x,0)
    local vector v1 = Velocity[u1].v
    local vector v2 = Velocity[u2].v
    
    local vector dv1 = vector.create(x2-x1,y2-y1,0)
    local vector dv2 = vector.create(x1-x2,y1-y2,0)
    local real pv1 = vector.projectionVector(v1,dv1).getLength()
    local real pv2 = vector.projectionVector(v2,dv2).getLength()
    local real pvd = (pv1 + pv2)/2
    
    local real m1 = Material[u1].weight
    local real m2 = Material[u2].weight
    local real v1n = vector.dotProduct(v_un, v1)
    local real v1t = vector.dotProduct(v_ut, v1)
    local real v2n = vector.dotProduct(v_un, v2)
    local real v2t = vector.dotProduct(v_ut, v2)
    local real v1tPrime = v1t
    local real v2tPrime = v2t
    local real v1nPrime = (v1n * (m1 - m2)) + 2 * m2 * v2n / (m1 + m2)
    local real v2nPrime = (v2n * (m2 - m1)) + 2 * m1 * v1n / (m1 + m2)
    local vector v_v1nPrime = vector.scale2(v_un,v1nPrime)
    local vector v_v1tPrime = vector.scale2(v_ut,v1tPrime)
    local vector v_v2nPrime = vector.scale2(v_un,v2nPrime)
    local vector v_v2tPrime = vector.scale2(v_ut,v2tPrime)
    set v1.x = v_v1nPrime.x + v_v1tPrime.x
    set v1.y = v_v1nPrime.y + v_v1tPrime.y
    set v2.x = v_v2nPrime.x + v_v2tPrime.x
    set v2.y = v_v2nPrime.y + v_v2tPrime.y
    
    if Material[u1].clazz == MC_WALL then
        call v1.setLength(0)
    elseif Material[u2].clazz == MC_WALL then
        call v2.setLength(0)
    endif
    if pvd > DAMAGE_SPEED then
        call UnitHitWall(u1,u2,pvd,getTargetDir(u1,u2),true)
        call UnitHitWall(u2,u1,pvd,getTargetDir(u2,u1),false)
    endif
endfunction
struct VelocityUnit
    implement List
    
    unit target
    
    static method create takes unit target returns VelocityUnit
        local VelocityUnit m=VelocityUnit.allocate()
        set m.target=target
        call m.addList()
        return m
    endmethod
    
    method onDestroy takes nothing returns nothing
        set target=null
        call removeList()
    endmethod
    
    static method loopMoveAllMissles takes nothing returns nothing
         local string fakeManLv
         local VelocityUnit m = getFirst() 
             loop
                 exitwhen m == 0
                 set fakeManLv = RealMan.CheckLevel(GetUnitX(m.target), GetUnitY(m.target), Material[m.target].fakelv)
                 if fakeManLv == LV_ACTIVE then
                    call Velocity[m.target].periodic()
                 elseif fakeManLv == LV_DESTORY then
                    call KillUnit(m.target)
                 endif
                 set m = m.getNext()
             endloop
    endmethod
endstruct
struct Velocity extends array
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        private static delegate AIDS_DEFAULT AIDS_DELEGATE=0
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        private boolean AIDS_instanciated
        
        //-----------------------------------------------------------------------
        static method operator[] takes unit whichUnit returns thistype
            return GetUnitId(whichUnit)
        endmethod
        
        method operator unit takes nothing returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endmethod
        
        //-----------------------------------------------------------------------
        method AIDS_addLock takes nothing returns nothing
            call AIDS_AddLock(this)
        endmethod
        method AIDS_removeLock takes nothing returns nothing
            call AIDS_RemoveLock(this)
        endmethod
        
        //-----------------------------------------------------------------------
        private static method AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set thistype(AIDS_GetIndexOfEnteringUnit()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if thistype.AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_instanciated=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call thistype(AIDS_GetIndexOfEnteringUnitAllocated()).AIDS_onCreate()
            endif
            
            return false
        endmethod
        
        private static method AIDS_onDeallocate takes nothing returns boolean
            if thistype(AIDS_GetDecayingIndex()).AIDS_instanciated then
                call thistype(AIDS_GetDecayingIndex()).AIDS_onDestroy()
                // Unflag destruction on deallocation.
                set thistype(AIDS_GetDecayingIndex()).AIDS_instanciated=false
            endif
            
            return false
        endmethod
        
        //-----------------------------------------------------------------------
        private static method onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function thistype.AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function thistype.AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function thistype.AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call thistype.AIDS_onInit()
        endmethod
//end of: AIDS()
    vector v
    
    vector a
    
    VelocityUnit vu
    
    Missle missleStruct
    
    static method AIDS_filter takes unit u returns boolean
        local string materialType = Material[u].clazz
        if GetUnitTypeId(u)== HERO or GetUnitTypeId(u) == 'ewsp' then
            return true
        endif
        if materialType == MC_BULLET or materialType == MC_UNIT or materialType == MC_ARROW or materialType == MC_STONE or materialType == MC_MINE then
            return true
        endif
        return false
    endmethod
    
    private method AIDS_onCreate takes nothing returns nothing
        if GetUnitTypeId(.unit)==HERO then
            set this.v = vector.create(0,0,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            set this.a = vector.create(0,0,0)
            set this.vu = VelocityUnit.create(.unit)
        else
            set this.v = vector.create(0,0,0)
            set this.a = vector.create(0,0,0)
            set this.vu = VelocityUnit.create(.unit)
        endif
    endmethod
        
    private method AIDS_onDestroy takes nothing returns nothing
        call v.destroy()
        call a.destroy()
        call missleStruct.destroy()
        call this.vu.destroy()
    endmethod
    
    method periodic takes nothing returns nothing
        local real x = GetUnitX(.unit)
        local real y = GetUnitY(.unit)
        local real z = getUnitHeight(.unit)
        local real v
        local real a = this.a.getLength()
        local real fz
        local real tx
        local real ty
        local real tz
        local real f1
        local real f2 
        local real af
        local real fs
        local real as
        local unit tu = null
        local string clazz = Material[.unit].clazz
        local vector gravity
        local boolean unitHitWall = false
        local real addon = 0
        if IsUnitAliveBJ(.unit) then
            set fz = GetUnitFlyHeight(.unit)
            if fz > 0.1 then
                if clazz == MC_UNIT or clazz == MC_STONE or clazz == MC_MINE then
                    set gravity = vector.create(0,0,-2)
                    call this.v.add(gravity)
                endif
            endif
            if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                call missleStruct.step()
            endif
            set v = this.v.getLength()
            if v > 0 then
                //call BJDebugMsg("velocity "+R2S(v) + R2S(this.v.x)+ " " + R2S(this.v.y)+ " " + R2S(this.v.z))
                //call BJDebugMsg("v " + R2S(v))
                //call BJDebugMsg("f1 " + R2S(f1))
                //call BJDebugMsg("f2 " + R2S(f2))
                //call BJDebugMsg("af " + R2S(af))
                set tz = z + this.v.z
                set tx = x + this.v.x
                set ty = y + this.v.y
                //call BJDebugMsg(R2S(fz) + " " + R2S(this.v.z))
                call MoveUnit(.unit, tx, ty, tz)
                //hit ground
                if fz < 0.1 and this.v.z < 0 then
                    if Material[.unit].ground_action == GROUND_DESTROY then
                        call missleStruct.destroy()
                    elseif Material[.unit].ground_action == GROUND_STICK then
                        call this.v.setLength(0)
                    endif 
                endif
                //F
                if clazz == MC_UNIT or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                    set f2 = Material[.unit].airk * v * v / 10
                    if fz > 0.1 or clazz == MC_ARROW then
                        set af = f2 / Material[.unit].weight
                    else
                        set f1 = Material[.unit].weight * g * u / 20
                        set af = (f1 + f2) / Material[.unit].weight
                    endif
                    if af >= v then
                        call this.v.setLength(0)
                    else
                        call this.v.setLength(v - af)
                    endif
                endif
                //hit wall
                if getTerrianHeight(tx,ty) > z + 5 then
                    //call BJDebugMsg("prepare hit wall")
                    if clazz == MC_BULLET or clazz == MC_STONE then
                        call missleStruct.destroy()
                    elseif clazz == MC_ARROW then
                    elseif clazz == MC_UNIT then
                        if v > DAMAGE_SPEED then
                            call UnitHitWall(.unit, .unit,v,getDir(x,y,tx,ty),true)
                        endif
                        set unitHitWall = true
                    elseif clazz == MC_MINE then
                        set unitHitWall = true
                    endif
                endif 
                //CollisionRefresh
                if clazz == MC_BULLET or clazz == MC_ARROW then
                    call missleStruct.refreshDamagedGroup()
                endif
                //Collision
                if IsUnitAliveBJ(.unit) then
                    //handle boss big collision
                    if GetPlayerId(GetOwningPlayer(.unit)) < 3 then
                        if IsBoss(EquipmentData[heros[GetPlayerId(GetOwningPlayer(.unit))]].heroData.shoot_target) then
                            set addon = Material[EquipmentData[heros[GetPlayerId(GetOwningPlayer(.unit))]].heroData.shoot_target].volume
                        endif
                    endif
                    if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                        set tu = HasLiveUnitInRange(.unit, addon + RMaxBJ( Material[.unit].volume,v + BULLET_RANGE_ADDON))
                    elseif clazz == MC_UNIT then
                        set tu = GetNearestLiveUnitOrWall(.unit, Material[.unit].volume)
                    endif
                    if tu != null then
                        if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                            call BulletCollision(.unit, tu, addon + RMaxBJ( Material[.unit].volume,v + BULLET_RANGE_ADDON))
                        elseif clazz == MC_UNIT then
                            if IsUnitInGroup(.unit, COLLISION_GROUP) and IsUnitInGroup(tu, COLLISION_GROUP) then
                            else
                                call UnitCollision(.unit, tu)
                                call GroupAddUnit(COLLISION_GROUP, .unit)
                                call GroupAddUnit(COLLISION_GROUP, tu)
                            endif
                        endif
                    endif 
                endif
            endif
            if a > 0 then
                //call BJDebugMsg("as " + R2S(as))
                //call BJDebugMsg("a " + R2S(a))
                if v == 0 and clazz == MC_UNIT then
                    //set fs = Material[.unit].weight * g * us / 30
                    //set as = fs / Material[.unit].weight
                    set as = g * us /30
                    if a > as then
                        call this.v.add(this.a)
                    endif
                else
                    call this.v.add(this.a)
                endif
            endif
            
            if unitHitWall then
                call this.v.setLength(0)
            endif
        else
            call this.vu.destroy()
        endif
        set tu = null
    endmethod 
    
endstruct

//library Velocity ends
//===========================================================================
// 
// 鍙槸鍙﹀涓€寮犻瓟鍏戒簤闇哥殑鍦板浘
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat Feb 29 21:32:32 2020
//   Map Author: 鏈煡
// 
//===========================================================================
//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************
function InitGlobals takes nothing returns nothing
    set udg_r = 0
endfunction
//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************
//===========================================================================
function CreateBuildingsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'h006', 3200.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3072.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2944.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3328.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3456.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3584.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3712.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3840.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3968.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4096.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4224.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4352.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4480.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4608.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4736.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4864.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4992.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5120.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5248.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5376.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2816.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2688.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2560.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -1088.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -960.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -832.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -704.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2304.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2176.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2048.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1920.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1792.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1664.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1536.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1408.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1280.0, -576.0, 270.000 )
    set gg_unit_h006_0048 = CreateUnit( p, 'h006', 3520.0, -1600.0, 270.000 )
    set gg_unit_h006_0049 = CreateUnit( p, 'h006', 3520.0, -1728.0, 270.000 )
    set u = CreateUnit( p, 'h006', 896.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 768.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 640.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 512.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 384.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 256.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -704.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -832.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -960.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1088.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1344.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1472.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1600.0, 270.000 )
    set gg_unit_h006_0065 = CreateUnit( p, 'h006', 3520.0, -1856.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6400.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1984.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2112.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2240.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2496.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2624.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2752.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -2880.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 256.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 384.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 512.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 640.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 768.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 896.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1024.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1152.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1280.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1408.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1536.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1664.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1792.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1920.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2048.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2176.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2304.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -3008.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -2880.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -2752.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -2624.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -2496.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2560.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2688.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2816.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2944.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3072.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3200.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3328.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3456.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3584.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3712.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3840.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 3968.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4096.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4224.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4352.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4480.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4608.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4736.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4864.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 4992.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5120.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5248.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5376.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5504.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5632.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5760.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5888.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6016.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6144.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6272.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6400.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6528.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6656.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6784.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6912.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7040.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7168.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7296.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7424.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7552.0, -2368.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3328.0, -1408.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6528.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h007', -3328.0, -1536.0, 270.000 )
    set u = CreateUnit( p, 'h007', -3328.0, -1664.0, 270.000 )
    set u = CreateUnit( p, 'h007', -3328.0, -1792.0, 270.000 )
    set u = CreateUnit( p, 'h007', -3328.0, -1920.0, 270.000 )
    set u = CreateUnit( p, 'h007', -3328.0, -2048.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6656.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', -3328.0, -2176.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5504.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5632.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5760.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 5888.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6016.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6144.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6272.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6784.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 6912.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7040.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7168.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7296.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7424.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 7552.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 2432.0, -1216.0, 270.000 )
    set u = CreateUnit( p, 'h006', 896.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1024.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1152.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1024.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1280.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1408.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1152.0, -576.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1728.0, 270.000 )
    set u = CreateUnit( p, 'h006', 128.0, -1856.0, 270.000 )
    set gg_unit_h006_0184 = CreateUnit( p, 'h006', 3520.0, -1472.0, 270.000 )
    set gg_unit_h006_0185 = CreateUnit( p, 'h006', 3520.0, -1344.0, 270.000 )
    set gg_unit_h006_0186 = CreateUnit( p, 'h006', 3520.0, -1984.0, 270.000 )
    set gg_unit_h006_0187 = CreateUnit( p, 'h006', 3520.0, -2112.0, 270.000 )
    set gg_unit_h006_0188 = CreateUnit( p, 'h006', 3520.0, -2240.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1536.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1664.0, 2816.0, 270.000 )
    set u = CreateUnit( p, 'h006', 896.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1024.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1152.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1280.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1408.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1536.0, -6400.0, 270.000 )
    set u = CreateUnit( p, 'h006', 1664.0, -6400.0, 270.000 )
endfunction
//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p = Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'u000', -444.0, 2772.8, 309.637 )
    set gg_unit_u002_0161 = CreateUnit( p, 'u002', 2153.1, 1808.0, 356.640 )
    set u = CreateUnit( p, 'u000', -835.6, 2737.5, 137.992 )
    set u = CreateUnit( p, 'u000', -1011.2, 2538.0, 289.466 )
    set u = CreateUnit( p, 'u000', -945.6, 2366.5, 104.033 )
    set u = CreateUnit( p, 'u000', -842.7, 2331.8, 349.057 )
    set u = CreateUnit( p, 'u000', -641.8, 2324.2, 97.001 )
    set u = CreateUnit( p, 'u000', -453.3, 2389.8, 95.441 )
    set u = CreateUnit( p, 'u000', -489.3, 2505.3, 316.284 )
    set u = CreateUnit( p, 'u000', -712.7, 2600.3, 201.462 )
    set u = CreateUnit( p, 'u000', -812.4, 2529.8, 244.640 )
    set u = CreateUnit( p, 'u000', -802.4, 2425.2, 333.863 )
    set u = CreateUnit( p, 'u000', -728.2, 2437.1, 253.693 )
    set u = CreateUnit( p, 'u000', -567.5, 2542.1, 313.570 )
    set u = CreateUnit( p, 'u000', -539.5, 2621.3, 164.998 )
    set u = CreateUnit( p, 'u000', -703.3, 2604.5, 256.956 )
    set u = CreateUnit( p, 'u000', -764.6, 2566.9, 201.440 )
    set u = CreateUnit( p, 'u000', -657.3, 2546.2, 290.806 )
    set u = CreateUnit( p, 'u000', -411.8, 2689.7, 309.967 )
    set u = CreateUnit( p, 'u000', -333.7, 2724.4, 218.371 )
    set u = CreateUnit( p, 'u000', -228.4, 2685.3, 169.821 )
    set u = CreateUnit( p, 'u000', -209.5, 2562.8, 247.431 )
    set u = CreateUnit( p, 'u000', -316.8, 2429.1, 235.851 )
    set u = CreateUnit( p, 'u000', -525.0, 2389.8, 220.722 )
    set u = CreateUnit( p, 'u000', -664.2, 2378.1, 280.347 )
    set u = CreateUnit( p, 'u000', -800.7, 2343.3, 171.524 )
    set u = CreateUnit( p, 'u000', -951.8, 2316.6, 204.033 )
    set u = CreateUnit( p, 'u000', -961.0, 2316.6, 210.548 )
    set u = CreateUnit( p, 'u000', -934.8, 2179.1, 187.740 )
    set u = CreateUnit( p, 'u000', -882.6, 2143.1, 148.188 )
    set u = CreateUnit( p, 'u000', -718.2, 2208.2, 188.498 )
    set u = CreateUnit( p, 'u000', -551.9, 2312.8, 192.563 )
    set u = CreateUnit( p, 'u000', -408.3, 2339.5, 178.588 )
    set u = CreateUnit( p, 'u000', -359.2, 2351.0, 191.970 )
    set u = CreateUnit( p, 'u000', -361.6, 2553.1, 328.479 )
endfunction
//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p = Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u = CreateUnit( p, 'ncop', 1216.0, -1792.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1216.0, -1472.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1216.0, -2112.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1280.0, 3776.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 960.0, 3776.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1600.0, 3776.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1280.0, -7360.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 960.0, -7360.0, 270.000 )
    set u = CreateUnit( p, 'ncop', 1600.0, -7360.0, 270.000 )
    set u = CreateUnit( p, 'ncop', -4288.0, -2112.0, 270.000 )
    set u = CreateUnit( p, 'ncop', -4288.0, -1792.0, 270.000 )
    set u = CreateUnit( p, 'ncop', -4288.0, -1472.0, 270.000 )
    set u = CreateUnit( p, 'ncp3', 2048.0, -1792.0, 270.000 )
endfunction
//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer11( )
endfunction
//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer11( )
endfunction
//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings( )
    call CreatePlayerBuildings( )
    call CreatePlayerUnits( )
endfunction
//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************
function CreateRegions takes nothing returns nothing
    local weathereffect we
    set gg_rct_lock_1 = Rect( 6912.0, 8512.0, 7616.0, 9120.0 )
    set gg_rct_lock_2 = Rect( 7680.0, 8512.0, 8384.0, 9120.0 )
    set gg_rct_lock_3 = Rect( 8448.0, 8512.0, 9152.0, 9120.0 )
    set gg_rct_lock_11 = Rect( 6912.0, 7840.0, 7616.0, 8448.0 )
    set gg_rct_start = Rect( 6592.0, -2208.0, 7648.0, -1312.0 )
    set gg_rct_start_road_1 = Rect( -32.0, -3072.0, 2560.0, -512.0 )
    set gg_rct_start_road_2 = Rect( 2400.0, -2432.0, 7680.0, -1152.0 )
    set gg_rct_start_road_gate = Rect( 4160.0, -1856.0, 4288.0, -1728.0 )
    set gg_rct_gave_guns = Rect( 1952.0, -1888.0, 2144.0, -1696.0 )
endfunction
//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//TESH.scrollpos=0
//TESH.alwaysfold=0
//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************
//===========================================================================
// Trigger: StartRoom
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: level1
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: InitJobData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Save
//
// call SetUnitManaBJ( GetTriggerUnit(), GetUnitStateSwap(UNIT_STATE_MANA, GetTriggerUnit()) )
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Strong
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemJump
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ItemJump extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00A'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getFacing(caster)
        local item itm = GetItemByTypeId(caster, iJUMP)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        local ItemFeature f2 = IndividualItemData[itm].featureData.f2
        local real d = f2.getValue()
        local real h = f1.getValue()
        local vector v = vector.create(d*Cos(facing),d*Sin(facing),h)
        call AddVelocity(caster, v)
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: GunSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Jump
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Jump extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01K'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = EquipmentData[caster].heroData.jump_direction
        local real d = 13
        local real h = 35
        local vector v = vector.create(d*Cos(facing),d*Sin(facing),h)
        call IssueImmediateOrder( caster, "stop" )
        call AddVelocity(caster, v)
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: JumpFacingStore
//
// function Trig_fd________4_______uConditions takes nothing returns boolean
//     return ((GetIssuedOrderIdBJ() == String2OrderIdBJ("move")) and (GetUnitTypeId(GetTriggerUnit()) == 'hfoo'))
// endfunction
// function Trig_fd________4_______uActions takes nothing returns nothing
//     call CreateTextTagLocBJ( "TRIGSTR_1340", GetRectCenter(GetPlayableMapRect()), GetOrderPointX(), GetOrderPointY(), 100, 100, 100, 0 )
// endfunction
// IsHero(GetOrderTargetUnit()) and 
// //===========================================================================
// function InitTrig_fd________4_______u takes nothing returns nothing
//     set gg_trg_fd________4_______u = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_fd________4_______u, "fd 澶嶅埗 4 澶嶅埗")
// #endif
//     call TriggerRegisterAnyUnitEventBJ( gg_trg_fd________4_______u, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
//     call TriggerAddCondition(gg_trg_fd________4_______u, Condition(function Trig_fd________4_______uConditions))
//     call TriggerAddAction(gg_trg_fd________4_______u, function Trig_fd________4_______uActions)
// endfunction
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: InjectionSpeedUp
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct InjectionSpeedUp extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00C'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getFacing(caster)
        local item itm = GetItemByTypeId(caster, iSPEED)
        local ItemFeature f = IndividualItemData[itm].featureData.f1
        local real speed = f.origin + f.lv * f.step
        call Push(caster, facing, speed, 0, 30)
        call BoundUnitEffectStruct.create(caster, 30, 'e001', -90, "stand", 70).start()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: RegisterSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Darts
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct Darts extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00D'
    endmethod
    
    private method getSpeed takes nothing returns real
        return 60.0
    endmethod
    
    method onChannel takes nothing returns nothing
        local unit tu = GetNearestEnemy(caster, 1000)
        local real speed = getSpeed()
        local real dd
        local IShooter shooter = SingleShooter.create(caster, SmallDartsFactory.create())
        local vector dir
        if (tu == null) then
            set dd = getFacing(caster)
            set dir = vector.create(speed * Cos(dd), speed * Sin(dd), 0)
        else
            set dir = getDirVector(caster, tu, speed)
        endif
        call shooter.shoot(dir)
        set tu =null
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
//===========================================================================
// Trigger: RetrunDarts
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
struct ReturnDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01L'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 100
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ReturnDartsFactory factory = ReturnDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: SmartDarts
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
struct SmartDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01O'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 60
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local SmartDartsFactory factory = SmartDartsFactory.create(targetUnit)
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call BJDebugMsg("fire")
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: ShoulderCannon
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ShoulderCannonSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A01N'
    endmethod
    
    private method getSpeed takes nothing returns real
        local real speed = 75
        return speed
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ShoulderCannonFactory factory = ShoulderCannonFactory.create()
        local IShooter shooter = ShoulderCannonShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: ItemRetrunDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ItemReturnDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A002'
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iRETURN)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local ReturnDartsFactory factory = ReturnDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: LeaveDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct LeaveDartsSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aLEAVE
    endmethod
    
    private method getSpeed takes nothing returns real
        return 80.0
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local LeaveDartsFactory factory = LeaveDartsFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local vector dir = vector.create(targetX - casterX, targetY - casterY, 0)
        call dir.setLength(getSpeed())
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: BackGrenade
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
struct BackGrenadeSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aBKGRENADE
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iBKGRENADE)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local BackGrenadeFactory factory = BackGrenadeFactory.create()
        local IShooter shooter = GrenadeThrower.create(caster, factory)
        local vector dir = GetGrenadeVector(casterX, casterY, targetX, targetY)
        local real v = GetGrenadeTrajectory(casterX, casterY, targetX, targetY)
        call dir.setLength(RMinBJ(v,speed))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: Mine
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct MineSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aMINE
    endmethod
       
    method onChannel takes nothing returns nothing
        local MineFactory factory = MineFactory.create()
        local IShooter shooter = MineThrower.create(caster, factory)
        local vector dir = vector.create(0,0,0)
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: PushGrenade
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
struct PushGrenadeSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aPSGRENADE
    endmethod
    
    private method getSpeed takes nothing returns real
        local item itm = GetItemByTypeId(caster, iPSGRENADE)
        local ItemFeature f1 = IndividualItemData[itm].featureData.f1
        set itm = null
        return f1.getValue()
    endmethod
    
    method onChannel takes nothing returns nothing
        local real speed = getSpeed()
        local PushGrenadeFactory factory = PushGrenadeFactory.create()
        local IShooter shooter = GrenadeThrower.create(caster, factory)
        local vector dir = GetGrenadeVector(casterX, casterY, targetX, targetY)
        local real v = GetGrenadeTrajectory(casterX, casterY, targetX, targetY)
        call dir.setLength(RMinBJ(v,speed))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: Blink
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Blink extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aBLINK
    endmethod
    
    method onChannel takes nothing returns nothing
        local real dis = DistanceTwo(casterX,casterY,targetX,targetY)
        local real max = getf1value(caster,iBLINK)
        local real r = RMinBJ(max,dis)
        local real ang = getDir(casterX,casterY,targetX,targetY)
        local real tx = casterX + r * Cos(ang)
        local real ty = casterY + r * Sin(ang)
        call DestroyEffect( AddSpecialEffect(E_BLINK_CASTER, casterX, casterY) )
        call SetUnitX(caster, tx)
        call SetUnitY(caster, ty)
        call DestroyEffect( AddSpecialEffect(E_BLINK_TARGET, tx, ty) )
    endmethod
    
endstruct//===========================================================================
// Trigger: Transport
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct Transport extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aTRANSPORT
    endmethod
    
    method onFinish takes nothing returns nothing
        local real dis = DistanceTwo(casterX,casterY,targetX,targetY)
        local real max = getf1value(caster,iTRANSPORT)
        local real r = RMinBJ(max,dis)
        local real ang = getDir(casterX,casterY,targetX,targetY)
        local real tx = casterX + r * Cos(ang)
        local real ty = casterY + r * Sin(ang)
        call DestroyEffect( AddSpecialEffect(E_TRANSPORT_CASTER, casterX, casterY) )
        call SetUnitX(caster, tx)
        call SetUnitY(caster, ty)
        call DestroyEffect( AddSpecialEffect(E_TRANSPORT_TARGET, tx, ty) )
    endmethod
    
endstruct
//===========================================================================
// Trigger: ElectricWhip
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
struct ElectricWhipSpell extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00G'
    endmethod
    
    
    method onChannel takes nothing returns nothing
        local ElectricWhipFactory factory = ElectricWhipFactory.create()
        local IShooter shooter = SingleShooter.create(caster, factory)
        local real uz = getUnitHeight(caster)
        local real tz
        local vector dir
        if targetUnit == null then
            set tz = getTerrianHeight(targetX, targetY)
            set dir = vector.create(targetX - casterX, targetY - casterY, tz - uz)
        else
            set tz = getUnitHeight(targetUnit)
            set dir = vector.create(targetX - casterX, targetY - casterY, tz - uz)
        endif
        call dir.setLength(getf1value(caster, iELECTRIC))
        call shooter.shoot(dir)
        call shooter.destroy()
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct//===========================================================================
// Trigger: AutoAim
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct AutoAim extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil=aAUTOAIM
    endmethod
    
    method onChannel takes nothing returns nothing
        local real time = getf1value(caster, iAUTOAIM)
        call AutoAimBuffer.create(caster,R2I(time*50)).start()
    endmethod
    
endstruct
//===========================================================================
// Trigger: ShootBack
//
//         local real facing = getFacing(caster) + pi
//         local item itm = GetItemByTypeId(caster, iREACT)
//         local ItemFeature f = IndividualItemData[itm].featureData.f1
//         local real speed = f.getValue()
//         call Push(caster, facing, speed, 0, 5)
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct ShootBack extends SpellStruct
    implement SpellStruct
    
    private static method onInit takes nothing returns nothing
        set thistype.abil='A00F'
    endmethod
    
    method onChannel takes nothing returns nothing
        local real facing = getFacing(caster) + pi
        local item itm = GetItemByTypeId(caster, iREACT)
        local ItemFeature f = IndividualItemData[itm].featureData.f1
        local real speed = f.getValue()
        set EquipmentData[caster].heroData.a_shoot_back = EquipmentData[caster].heroData.a_shoot_back + speed
        set EquipmentData[caster].heroData.a_shoot_back_log = speed
    endmethod
    
    method onStopCast takes nothing returns nothing
    endmethod
endstruct
// Trigger: TeckLock
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TeckLockActions takes nothing returns nothing
    local integer i = 10
    set gg_rct_lock[0] = gg_rct_lock_1
    set gg_rct_lock[1] = gg_rct_lock_2
    set gg_rct_lock[2] = gg_rct_lock_3
    loop
        exitwhen i >= PLAYER_COUNT
        call EnableAbiLock(i)
        set i = i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_TeckLock takes nothing returns nothing
    set gg_trg_TeckLock = CreateTrigger()
    call TriggerAddAction(gg_trg_TeckLock, function Trig_TeckLockActions)
endfunction
//===========================================================================
// Trigger: Register
//===========================================================================
function Trig_RegisterConditions takes nothing returns boolean
    return ((GetUnitTypeId(GetTriggerUnit()) == 'H002'))
endfunction
function Trig_RegisterActions takes nothing returns nothing
    call RegisterDouble6Package(GetTriggerUnit())
    call AddRealMan(GetTriggerUnit())
    call UnitAddAbility( GetTriggerUnit(), 'A00B' )
    call UnitRemoveAbility( GetTriggerUnit(), 'A00B' )
endfunction
//===========================================================================
function InitTrig_Register takes nothing returns nothing
    set gg_trg_Register = CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_Register, GetPlayableMapRect() )
    call TriggerAddCondition(gg_trg_Register, Condition(function Trig_RegisterConditions))
    call TriggerAddAction(gg_trg_Register, function Trig_RegisterActions)
endfunction
//===========================================================================
// Trigger: RegisterFly
//===========================================================================
function Trig_RegisterFlyActions takes nothing returns nothing
    call YDWEFlyEnable( GetTriggerUnit() )
endfunction
//===========================================================================
function InitTrig_RegisterFly takes nothing returns nothing
    set gg_trg_RegisterFly = CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull( gg_trg_RegisterFly, GetPlayableMapRect() )
    call TriggerAddAction(gg_trg_RegisterFly, function Trig_RegisterFlyActions)
endfunction
//===========================================================================
// Trigger: FogControl
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
// Trigger: CameraLock
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Movie
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//===========================================================================
// Trigger: GV
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: LearnAbility
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_LearnAbilityConditions takes nothing returns boolean
    if GetLearnedSkill() == 'A00O' then
        set Material[GetTriggerUnit()].kill_hp = Material[GetTriggerUnit()].kill_hp + 1
        set Material[GetTriggerUnit()].anti_horro = Material[GetTriggerUnit()].anti_horro + 0.1
    endif
    return false
endfunction
//===========================================================================
function InitTrig_LearnAbility takes nothing returns nothing
    set gg_trg_LearnAbility = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_LearnAbility, EVENT_PLAYER_HERO_SKILL )
    call TriggerAddCondition(gg_trg_LearnAbility, Condition(function Trig_LearnAbilityConditions))
endfunction
//===========================================================================
// Trigger: TriggerKillHpBuff
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerKillHpBuffActions takes nothing returns nothing
    call SetUnitState( GetKillingUnitBJ(), UNIT_STATE_LIFE, GetUnitState(GetKillingUnitBJ(),UNIT_STATE_LIFE) + Material[GetKillingUnitBJ()].kill_hp )
endfunction
//===========================================================================
function InitTrig_TriggerKillHpBuff takes nothing returns nothing
    set gg_trg_TriggerKillHpBuff = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_TriggerKillHpBuff, EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddAction(gg_trg_TriggerKillHpBuff, function Trig_TriggerKillHpBuffActions)
endfunction
//===========================================================================
// Trigger: TriggerHorro
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerHorroConditions takes nothing returns boolean
    if GetEventDamage() > 1 and GetRandomReal(0,1) <= RMaxBJ(Material[GetEventDamageSource()].horro_dmg - Material[GetTriggerUnit()].anti_horro, 0) then
        call ApplyHorro(GetTriggerUnit(), GetEventDamageSource(), 5)
    endif
    return false
endfunction
//===========================================================================
function InitTrig_TriggerHorro takes nothing returns nothing
    set gg_trg_TriggerHorro = CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger( gg_trg_TriggerHorro )
    call TriggerAddCondition(gg_trg_TriggerHorro, Condition(function Trig_TriggerHorroConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrderFilter
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_HorrorOrderFilterConditions takes nothing returns boolean
    if Material[GetTriggerUnit()].horro and GetIssuedOrderId() != OI_MOVE then
        call HorrorMove(GetTriggerUnit())
    endif
    return false
endfunction
//===========================================================================
function InitTrig_HorrorOrderFilter takes nothing returns nothing
    set gg_trg_HorrorOrderFilter = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER )
    call TriggerAddCondition(gg_trg_HorrorOrderFilter, Condition(function Trig_HorrorOrderFilterConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrder
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: OrderId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootSpeed
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Radiation
//
// UnitHasBuffBJ(GetTriggerUnit(), 'Bcor')
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ArrayList
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ChooseTech
//
// I2S(GetHeroLevel(GetTriggerUnit()))
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ChooseBonus
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TechLevelUp
//
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
// //! runtextmacro InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TechLevelUpConditions takes nothing returns boolean
    local integer ai = GetSpellAbilityId()
    local integer bp = 0
    local unit u
    local integer lv
    local integer p
    local player owner
    local integer pid
    if (ai >= 'A00Q' and ai <= 'A013') or ai == 'A004' then
        set owner = GetOwningPlayer(GetTriggerUnit())
        set pid = GetPlayerId(owner)
        set u = techs[pid]
        set lv = GetUnitAbilityLevel(u, ai)
        set bp = LoadInteger(tdht,ai,tdht_base_point)
        if lv >= 1 and lv <= 2 then
            set bp = bp + 1
        elseif lv >= 3 and lv <= 4 then
            set bp = bp + 2
        elseif lv >= 5 and lv <= 6 then
            set bp = bp + 3
        else
            return true
        endif
        set p = GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED)
        if p >= bp then
            call DisplayInfo(owner, "鎶€鑳藉崌绾ф垚鍔?)
            call SetPlayerStateBJ( owner, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED) - bp)
            call IncUnitAbilityLevel( techs[pid], ai )
            call DispatchTechLevelUp(ai, lv + 1, pid)
        else
            call DisplayInfo(owner, "绉戞妧鐐逛笉瓒筹紝闇€瑕?" + I2S(bp))
        endif
    endif
    set u = null
    return true
endfunction
//===========================================================================
function InitTrig_TechLevelUp takes nothing returns nothing
    set gg_trg_TechLevelUp = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_TechLevelUp, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition(gg_trg_TechLevelUp, Condition(function Trig_TechLevelUpConditions))
endfunction
//===========================================================================
// Trigger: TechData
//
// struct TechTree
//     integer size
//     integer array ids[64]
//     
//     static method create takes nothing returns TechTree
//         local TechTree m=TechTree.allocate()
//         set m.size = 0
//         return m
//     endmethod
//     
//     method addTech takes integer id returns nothing
//         set ids[size] = id
//         set size = size + 1
//     endmethod
// endstruct
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Transform
//
// function TransformAction takes nothing returns nothing
//     local button b=GetClickedButtonBJ()
//     local dialog d=GetClickedDialogBJ()
//     local integer i
// globals
// endglobals
// function Trig_TransformConditions takes nothing returns boolean
//     call BJDebugMsg("jjj")
//     return ((GetItemTypeId(GetManipulatedItem()) == 'I004'))
// endfunction
// function Trig_TransformActions takes nothing returns nothing
//     local unit tu = GetTriggerUnit()
//     local player owner = GetOwningPlayer(tu)
//     local integer i = GetPlayerId(owner)
//     if GetUnitTypeId(tu)== HERO then
//         call DefaultDialog.create("閫夋嫨涓€涓己鍖?,owner)
//     endif
// endfunction
// //===========================================================================
// function InitTrig_Transform takes nothing returns nothing
//     local integer i = 0
//     set gg_trg_Transform = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_Transform, "Transform")
// #endif
//     call TriggerRegisterAnyUnitEventBJ( gg_trg_Transform, EVENT_PLAYER_UNIT_USE_ITEM )
//     call TriggerAddCondition(gg_trg_Transform, Condition(function Trig_TransformConditions))
//     call TriggerAddAction(gg_trg_Transform, function Trig_TransformActions)
// endfunction
//     loop
//         exitwhen td[i]==d or i>PLAYER_COUNT - 1
//         set i=i+1
//     endloop
// endfunction
//     loop
//         exitwhen i > PLAYER_COUNT - 1
//         set td[i] = DialogCreate()
//         set i_trg[i] = CreateTrigger()
//     endloop
//     dialog array td
//     trigger array i_trg
//     unit array i_tu
//     ItemFeatureData fd
//     static method create takes string name, player p, ItemFeatureData fd returns TransformDialog
//         local TransformDialog g=TransformDialog.allocate(name,p)
//         set g.fd = fd
//         return g
//     endmethod
//     method button_clicked takes button b returns nothing
//         local unit hero
//         local ItemFeature f
//         set f  = GetButtonStructA(b)
//         if b != cancel_button then
//             if GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) >= (f.lv
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DialogSystem
//
//             exitwhen id > 0 or i <= 0
//             set i = i - 1
//             set r = GetRandomInt(1, size)
//             
//             //rand tech tree choose
//             set j = 0
//             loop
//                 exitwhen EquipmentData[hero].heroData.tech_counter.cnt[j] >= r or j >= TT_COUNT
//                 set r = r - EquipmentData[hero].heroData.tech_counter.cnt[j]
//                 set j = j + 1
//             endloop
//     method button_clicked takes button b returns nothing
//         call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
//         call DisplayText(p, "鑾峰緱涓ょ偣绉戞妧鐐?)
//         set EquipmentData[heros[GetPlayerId(p)]].heroData.up_point = EquipmentData[heros[GetPlayerId(p)]].heroData.up_point - 1
//     endmethod
//     
//     method init takes nothing returns nothing
//         local button b
//         local string s
//         set s = "绉戞妧鐐?+ 2"
//         set b = DialogAddButton(d, s ,0)
//         set b = null
//     endmethod
// //! textmacro InitTechData takes ID, NAME, CAT, TECH_NEED, GAME_LV_NEED
//     call SaveStr(tdht,$ID$,tdht_name,"$NAME$")
//     call SaveInteger(tdht,$ID$,tdht_cat,$CAT$)
//     call SaveInteger(tdht,$ID$,tdht_tech_need,$TECH_NEED$)
//     call SaveInteger(tdht,$ID$,tdht_game_lv_need,$GAME_LV_NEED$)
//     call TECH_TREES[$CAT$].addItem($ID$)
//     set TECH_TREE_COUNT[$CAT$] = TECH_TREE_COUNT[$CAT$] + 1
//     set TECH_COUNT = TECH_COUNT + 1
// //! endtextmacro
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_BLADE", "0","1")
//         
//         set k = 0
//         loop
//             exitwhen k > TT_COUNT - 1
//             set s = s + I2S(randtree[k])
//             set k = k + 1
//         endloop
//         //call BJDebugMsg("rand tree " + s)
//===========================================================================
//TESH.scrollpos=97
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Buffer
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: BurnBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct BurnBuffer extends DefaultBufferStruct
    
    private real dam
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        local integer burnlv = Material[u].burnlv
        set Material[u].burnlv = burnlv + 1
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.u,"origin")
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 25) == 0 then
            call FireDamage(this.source, u, this.dam)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].burnlv = Material[u].burnlv - 1
        set source = null
        call DestroyEffect(e)
        set e = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns BurnBuffer
        local BurnBuffer m = BurnBuffer.allocate(u, count)
        set m.source = source
        set m.dam = dam
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: HorroBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct HorroBuffer extends DefaultBufferStruct
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        set Material[u].horro = true
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl",this.u,"origin")
        call HorrorMove(this.u)
        call UnitAddAbility(u, aBAN_ATTACK)
        call DisableAllAbi(u
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 100) == 0 then
            call HorrorMove(this.u)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].horro = false
        set source = null
        call DestroyEffect(e)
        call UnitRemoveAbility(u, aBAN_ATTACK)
        call EnableAllAbi(u)
        set e = null
    endmethod
    
    static method create takes unit u, unit source, integer count returns HorroBuffer
        local HorroBuffer m = HorroBuffer.allocate(u, count)
        set m.source = source
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: BleedBuffer
//
// //! runtextmacro BuffType("Bleed")
//     //! runtextmacro SetBuffName("娴佽")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒版祦琛€鐨勬寔缁激瀹?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNGhoulFrenzy.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         if ModuloInteger(Tick, 10) == 0 then
//             call NormalDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer bleedlv = Material[this.unit].bleedlv
//         set this.e = AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl",this.unit,"chest")
//         set Material[this.unit].bleedlv = bleedlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].bleedlv = Material[this.unit].bleedlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
struct BleedBuffer extends DefaultBufferStruct
    
    private real dam
    
    private unit source
    
    private effect e
    method addBuffer takes nothing returns nothing
        local integer bleedlv = Material[u].bleedlv 
        set Material[u].bleedlv = bleedlv + 1
        set e = AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl",this.u,"chest")
    endmethod
    
    method action takes nothing returns nothing
        if ModuloInteger(count, 25) == 0 then
            call NormalDamage(this.source, u, this.dam)
        endif
    endmethod
    
    method removeBuffer takes nothing returns nothing
        set Material[u].bleedlv = Material[u].bleedlv - 1
        set source = null
        call DestroyEffect(e)
        set e = null
    endmethod
    
    static method create takes unit u, integer count, unit source, real dam returns BleedBuffer
        local BleedBuffer m = BleedBuffer.allocate(u, count)
        set m.source = source
        set m.dam = dam
        return m
    endmethod
    
endstruct
//===========================================================================
// Trigger: IceSlowBuffer
//
// //! runtextmacro BuffType("IceSlow")
//     //! runtextmacro SetBuffName("瀵掑啺")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("鐩爣鐨勭Щ鍔ㄩ€熷害鍜屾敾鍑婚€熷害閮介檷浣庝簡")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     method onApply takes nothing returns nothing
//         call Status[this.unit].addStun()
//         //set this.e=AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl",this.unit,"body")
//     endmethod
//     method onRemove takes nothing returns nothing
//         call Status[this.unit].removeStun()
//         call DestroyEffect(this.e)
//     endmethod
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct IceSlowBuffer extends DefaultBufferStruct
    private effect e
    method addBuffer takes nothing returns nothing
        call Status[this.u].addStun()
        set e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl",this.u,"origin")
    endmethod
    
    method removeBuffer takes nothing returns nothing
        call Status[this.u].removeStun()
        call DestroyEffect(e)
        set e = null
    endmethod
endstruct//===========================================================================
// Trigger: AutoAimBuffer
//
// //! runtextmacro BuffType("AutoAimBuff")
//     //! runtextmacro SetBuffName("杈呭姪灏勫嚮")
//     //! runtextmacro SetBuffAlignment("POSITIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶈兘澶熻繘琛岀簿纭皠鍑?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNScout.blp")
// //! runtextmacro BuffStruct()
//     method onApply takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r + 1
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r - 1
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
struct AutoAimBuffer extends DefaultBufferStruct
    method addBuffer takes nothing returns nothing
        local real r = EquipmentData[.u].heroData.shoot_rist
        set EquipmentData[.u].heroData.shoot_rist = r + 1
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\TrueshotAura\\TrueshotAura.mdl",this.u,"origin"))
    endmethod
    
    method removeBuffer takes nothing returns nothing
        local real r = EquipmentData[.u].heroData.shoot_rist
        set EquipmentData[.u].heroData.shoot_rist = r - 1
    endmethod
endstruct//===========================================================================
// Trigger: Debuff
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
//===========================================================================
// Trigger: BufferFunction
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Constants
//===========================================================================
//TESH.scrollpos=45
//TESH.alwaysfold=0
//===========================================================================
// Trigger: PlayerHero
//
// function PlayerHeroCondition takes nothing returns nothing
//     local unit tu = GetTriggerUnit()
//     local player owner = GetOwningPlayer(tu)
//     local integer pid = GetPlayerId(owner)
//     call BJDebugMsg("HERO EnTER")
//     if GetUnitTypeId(tu) == HERO then
//         
//         set heros[pid] = tu
//     endif
//     set tu = null
//     set owner = null
// endfunction
// function InitPlayerHero takes nothing returns nothing
// local trigger playerhero_t=CreateTrigger()
// local integer i = 0
// loop
//     exitwhen i >=4
//     set heros[i] = null
// endloop
// call TriggerRegisterEnterRectSimple( playerhero_t, GetPlayableMapRect() )
// call TriggerAddCondition(playerhero_t,function PlayerHeroCondition)
// set playerhero_t=null
// endfunction
// endlibrary
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function CreateHero takes integer pid, real x, real y returns unit
    local unit hero = CreateUnit(Player(pid),HERO,x,y,0)
    local unit tech = CreateUnit(Player(pid),TECH_UNIT,x,y,0)
    call UnitAddAbility(hero, SHOOT_SPEED)
    call SetUnitAbilityLevel(hero, SHOOT_SPEED, 1)
    set heros[pid] = hero
    set techs[pid] = tech
    set tech = null
    return hero
endfunction
//===========================================================================
// Trigger: FocuseHero
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_FocuseHeroConditions takes nothing returns boolean
    return ((GetUnitTypeId(GetTriggerUnit()) == 'H004'))
endfunction
function Trig_FocuseHeroActions takes nothing returns nothing
    local player p = GetTriggerPlayer()
    local integer id = GetPlayerId(p)
    local location l = Location(GetUnitX(heros[id]),GetUnitY(heros[id]))
    call PanCameraToTimedLocForPlayer( p, l, 1 )
    call RemoveLocation(l)
    set l = null
    set p = null
endfunction
//===========================================================================
function InitTrig_FocuseHero takes nothing returns nothing
    set gg_trg_FocuseHero = CreateTrigger()
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(0), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(1), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(2), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(3), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(4), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(5), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(6), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(7), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(8), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(9), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(10), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(11), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(12), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(13), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(14), true )
        call TriggerRegisterPlayerSelectionEventBJ( gg_trg_FocuseHero, Player(15), true )
    call TriggerAddCondition(gg_trg_FocuseHero, Condition(function Trig_FocuseHeroConditions))
    call TriggerAddAction(gg_trg_FocuseHero, function Trig_FocuseHeroActions)
endfunction
//===========================================================================
// Trigger: ItemData
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemEquip
//===========================================================================
//TESH.scrollpos=16
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemType
//
//     integer GUN=4
//     integer HAND=1
//     integer ARMOR=2
//     integer SHOE=3
//     integer OTHER=5
//     integer LONGTERM=7
//     integer STATIC=6
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: UnitId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: FakeMan
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterDead
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootTarget
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTypeData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterBonus
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTargetGroup
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DeathEffect
//===========================================================================
function Trig_DeathEffectActions takes nothing returns nothing
    call DestroyEffect( AddSpecialEffect("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())) )
endfunction
//===========================================================================
function InitTrig_DeathEffect takes nothing returns nothing
    set gg_trg_DeathEffect = CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple( gg_trg_DeathEffect, Player(11), EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddAction(gg_trg_DeathEffect, function Trig_DeathEffectActions)
endfunction
//===========================================================================
// Trigger: Difficulty
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: EffectString
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SkillLearn
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DoublePacket
//===========================================================================
//TESH.scrollpos=93
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Missle
//
//             if HasLiveEnemyUnitInRange(owner, 300) then
//                 //set this.active = true
//                 call BJDebugMsg("active")
//             endif
// function rangeExplodeDamage takes unit source ,real x ,real y ,real radius, real damage returns nothing
//===========================================================================
//TESH.scrollpos=102
//TESH.alwaysfold=0
// Trigger: MissleFactory
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Gun
//===========================================================================
//TESH.scrollpos=33
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: Shooter
//
//     method shoot takes vector dir returns nothing
//         local real ec = getEnergyConsume()
//         local vector vdir
//         local integer lst = EquipmentData[owner].heroData.last_shoot_tick
//         local integer i = 1
//         local integer interval = R2I(I2R(getModuleTick()) * (1 - EquipmentData[owner].heroData.shoot_speed_buff))
//         if  Tick - lst >= interval then
//             loop
//                 exitwhen i > shootCount()
//                 set i = i + 1
//                 set vdir = getShootVector()
//                 if not EquipmentData[owner].heroData.reload and EquipmentData[owner].heroData.shoot_energy >= ec then
//                     set EquipmentData[owner].heroData.last_shoot_tick = Tick
//                     call energyConsume()
//                     call backForce(getShootDir())
//                     call subshoot(vdir)
//                 else
//                     if not EquipmentData[owner].heroData.reload then
//                         set EquipmentData[owner].heroData.reload = true
//                     endif
//                     call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"!",0.1)
//                 endif
//             endloop
//         endif
//     endmethod
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: HeroData
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: EquipmentData
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: HeroStatus
//
// function Trig_HeroStatusActions takes nothing returns nothing
//     call SetHeroStr( GetAttacker(), ( GetHeroAgi(null, false) + 1 ), true )
// endfunction
// //===========================================================================
// function InitTrig_HeroStatus takes nothing returns nothing
//     set gg_trg_HeroStatus = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_HeroStatus, "HeroStatus")
// #endif
//     call TriggerRegisterUnitEvent( gg_trg_HeroStatus, null, EVENT_UNIT_HERO_SKILL )
//     call TriggerAddAction(gg_trg_HeroStatus, function Trig_HeroStatusActions)
// endfunction
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Velocity
//===========================================================================
//TESH.scrollpos=258
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: Material
//
// //! textmacro RegisterMaterial takes ID,CLAZZ,HARDNESS,BOUNCE,VOLUME,WEIGHT,AIRK,FKL,GOUND_ACTION
//===========================================================================
//TESH.scrollpos=60
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: PhysicsSystem
//===========================================================================
//TESH.scrollpos=10
//TESH.alwaysfold=0
    //===========================================================================
// Trigger: bordercontrol
//===========================================================================
function Trig_bordercontrolActions takes nothing returns nothing
    call RemoveUnit( GetTriggerUnit() )
endfunction
//===========================================================================
function InitTrig_bordercontrol takes nothing returns nothing
    set gg_trg_bordercontrol = CreateTrigger()
    call YDWETriggerRegisterLeaveRectSimpleNull( gg_trg_bordercontrol, GetPlayableMapRect() )
    call TriggerAddAction(gg_trg_bordercontrol, function Trig_bordercontrolActions)
endfunction
//===========================================================================
// Trigger: TargetFilter
//===========================================================================
//TESH.scrollpos=63
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemInfo
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_fConditions takes nothing returns boolean
    return ((GetItemType(GetManipulatedItem()) == ITEM_TYPE_PERMANENT))
endfunction
function Trig_fActions takes nothing returns nothing
    local item itm = GetManipulatedItem()
    local unit tu = GetTriggerUnit()
    local ItemFeatureData fd = IndividualItemData[itm].featureData
    local ItemTypeData data = getItemTypeData(GetItemTypeId(itm))
    local string msg = data.name + "\n"
//textmacro instance: AddFeatureData("1")
        if fd.f1.maxlv > 0 then
            set msg = msg + fd.f1.name + " " + "(" + I2S(fd.f1.lv) + "/" + I2S(fd.f1.maxlv) + ")" + " " + R2S(fd.f1.origin + fd.f1.lv * fd.f1.step) + "\n"
        endif
//end of: AddFeatureData("1")
//textmacro instance: AddFeatureData("2")
        if fd.f2.maxlv > 0 then
            set msg = msg + fd.f2.name + " " + "(" + I2S(fd.f2.lv) + "/" + I2S(fd.f2.maxlv) + ")" + " " + R2S(fd.f2.origin + fd.f2.lv * fd.f2.step) + "\n"
        endif
//end of: AddFeatureData("2")
//textmacro instance: AddFeatureData("3")
        if fd.f3.maxlv > 0 then
            set msg = msg + fd.f3.name + " " + "(" + I2S(fd.f3.lv) + "/" + I2S(fd.f3.maxlv) + ")" + " " + R2S(fd.f3.origin + fd.f3.lv * fd.f3.step) + "\n"
        endif
//end of: AddFeatureData("3")
//textmacro instance: AddFeatureData("4")
        if fd.f4.maxlv > 0 then
            set msg = msg + fd.f4.name + " " + "(" + I2S(fd.f4.lv) + "/" + I2S(fd.f4.maxlv) + ")" + " " + R2S(fd.f4.origin + fd.f4.lv * fd.f4.step) + "\n"
        endif
//end of: AddFeatureData("4")
//textmacro instance: AddFeatureData("5")
        if fd.f5.maxlv > 0 then
            set msg = msg + fd.f5.name + " " + "(" + I2S(fd.f5.lv) + "/" + I2S(fd.f5.maxlv) + ")" + " " + R2S(fd.f5.origin + fd.f5.lv * fd.f5.step) + "\n"
        endif
//end of: AddFeatureData("5")
    call DisplayText(GetOwningPlayer(tu),msg)
    set itm = null
    set tu = null
    call data.destroy()
endfunction
//===========================================================================
function InitTrig_ItemInfo takes nothing returns nothing
    set gg_trg_ItemInfo = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_ItemInfo, EVENT_PLAYER_UNIT_USE_ITEM )
    call TriggerAddCondition(gg_trg_ItemInfo, Condition(function Trig_fConditions))
    call TriggerAddAction(gg_trg_ItemInfo, function Trig_fActions)
endfunction
//===========================================================================
// Trigger: AIStrategy
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIGroup
//===========================================================================
//TESH.scrollpos=18
//TESH.alwaysfold=0
    
    
//===========================================================================
// Trigger: AIData
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDriver
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIHurted
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AIHurtedConditions takes nothing returns boolean
    if ((GetOwningPlayer(GetTriggerUnit()) == Player(11))) then
        //call BeHurted(GetTriggerUnit())
    endif
    return false
endfunction
//===========================================================================
function InitTrig_AIHurted takes nothing returns nothing
    set gg_trg_AIHurted = CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger( gg_trg_AIHurted )
    call TriggerAddCondition(gg_trg_AIHurted, Condition(function Trig_AIHurtedConditions))
endfunction
//===========================================================================
// Trigger: DummyCaster
//===========================================================================
//TESH.scrollpos=67
//TESH.alwaysfold=0
//
//      ___  _   _  __  __  __  __ __  __
//     |   \| | | |/  |/  |/  |/  |\ \/ /
//     | |) | |_| | / | / | / | / | \  /
//     |___/\____/_/|__/|_|/|__/|_|_|_|__
//         /  _/ /_\ / __\_   _|  __|  _ //        |  |_ / _ \\__ \ | | |  __|  _ /
//         \___\_/ \_\___/ |_| |____|_|\_\         By Jesus4Lyf
//
//      What is DummyCaster?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          DummyCaster is designed to be the perfect dummy caster for dummy abilities.
//          There has been a lot of thought put into this unit type, and dummy casting
//          has evolved over the years of WC3 mapping. These days, best practise is that
//          damage is triggered, and the effects of an ability such as slow or stun
//          are applied through a global dummy caster (which is owned by Neutral Hostile).
//
//          A lot of thought has been put into this unit. It has no mana, because if
//          it had mana then it could potentially run out and suddenly fail without
//          an apparent reason. It has no movement speed or casting time, allowing it
//          to instantly cast. Hence, this library only exposes one thing. A "DUMMY"
//          unit constant (global variable).
//
//          You may provide this unit with a model by having a model imported into the
//          path "Dummy.mdx". The purpose of this is allowing the same unit type
//          to be created dynamically for special effect attachment.
//
//          The rawcode of the "Dummy Caster" type is 'dumy'.
//
//          Upon issueing the order to cast a spell using the DUMMY global, as long as
//          the spell is instant, the casting will occur before the next line of
//          JASS code is executed, meaning you can cast in a loop or a ForGroup, etc
//          without bugging or dynamically creating (or recycling) dummies.
//
//          The initialiser is in a struct because struct onInit methods are called
//          before library "initializers". This allows abilities to be added on the
//          constant DUMMY unit on map initialisation.
//
//          Spells that this dummy casts should have no mana cost, no cooldown, no
//          cast time and infinite range. They also must be able to be cast from a
//          Neutral Hostile unit to your target, meaning they must be castable on
//          enemies (if you must, you can change the owner of the dummy for the cast,
//          and then change it back if you need to have it target allied units and such).
//
//          Be sure to add your spell to the dummy before trying to cast it! :)
//          Beware of permenantly adding spells with conflicting order ids/strings.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called DummyCaster, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next line (so "external" will line up with this line):
//          external ObjectMerger w3u ushd dumy unam "Dummy Caster" uabi Aloc ucbs 0 ucpt 0 umvs 0 ushu "" umvh 0 umdl "Dummy.mdl" umpi 100000 umpm 100000 umpr 1000 ufoo 0
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Viikuna for demonstrating how to make dummy casters cast instantaneously.
//
//===========================================================================
// Trigger: Status
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=821
//TESH.alwaysfold=0
//
//      ___ _____ _ _____ _   _ ___ 
//     / __|_   _/_\_   _| | | / __|
//     \__ \ | |/ _ \| | | |_| \__ \    By Jesus4Lyf.
//     |___/ |_/_/ \_\_| \____/|___/          v 1.2.8
//
//      What is Status?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Status allows you to apply stuns, silences, disable attacks and much
//          more. Status effects based off dummy casted spells are applied 0.0
//          seconds after the "add" method is called. Status aims to commoditise
//          unit effects in WC3.
//
//      Restrictions
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Disarming spell immune units is not possible. Some status effects will
//          not apply to invulnerable units, namely those which are dummy casted.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Status, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "runtextmacro" will line up with this line):
//          runtextmacro Status__CreateAbilities()
//
//          Go to the object editor, and select abilities. Go to Special > Heroes,
//          and select Disarm (Both). Change Data - Attacks Prevented to Melee, Ranged.
//          For Disarm (Melee), change Attacks Prevented to Melee. For Disarm (Range),
//          change Attacks Prevented to Ranged. Object merger has a bug that does not
//          allow setting this field automatically.
//
//      Methods:
//     藟藟藟藟藟藟藟藟藟藟
//          Statuses (short list):
//              - Disable (addDisable, removeDisable, isDisabled)
//              - Stun (addStun, removeStun, isStunned)
//              - Silence (addSilence, removeSilence, isSilenced)
//              - Doom (addDoom, removeDoom, isDoomed)
//              - DisarmMelee (addDisarmMelee, removeDisarmMelee, isDisarmedMelee)
//              - DisarmRange (addDisarmRange, removeDisarmRange, isDisarmedRange)
//              - Disarm (addDisarm, removeDisarm, isDisarmed) // this is both Melee AND Ranged.
//              - Immobolise (addImmobolise, removeImmobolise, isImmobolised)
//              - Invisible (addInvisible, removeInvisible, isInvisible)
//              - Ghost (addGhost, removeGhost, isGhost)
//              - Invulnerable (addInvulnerable, removeInvulnerable, isInvulnerable)
//              - Immunity (addImmunity, removeImmunity, isImmune)
//              - Pause (addPause, removePause, isPaused)
//              - Hide (addHide, removeHide, isHidden)
//              - Unpath (addUnpath, removeUnpath, isUnpathed)
//              - Hex (addHex, removeHex, isHexed)
//              - Locust (addLocust, removeLocust, isLocust) // does not remove correctly for flying units, use with caution.
//              - NeverMiss (addNeverMiss, removeNeverMiss, isNeverMiss)
//              - AlwaysMiss (addAlwaysMiss, removeAlwaysMiss, isAlwaysMiss)
//              - Untouchable (addUntouchable, removeUntouchable, isUntouchable) // 100% evasion
//              - Banish (addBanish, removeBanish, isBanished)
//              - Phase (addPhase, removePhase, isPhased) // clashes with windwalk, interrupts current order
//              - ResistantSkin (addResistantSkin, removeResistantSkin, isResistantSkin)
//              - ReflectPiercing (addReflectPiercing, removeReflectPiercing, isReflectPiercing)
//
//          Bonuses (short list):
//              - ArmorBonus (modArmorBonus, getArmorBonus)
//              - DamageBonus (modDamageBonus, getDamageBonus)
//              - StrBonus (modStrBonus, getStrBonus)
//              - AgiBonus (modAgiBonus, getAgiBonus)
//              - IntBonus (modIntBonus, getIntBonus)
//              - AttackSpeedBonus (modAttackSpeedBonus, getAttackSpeedBonus)
//              - Health (modHealthBonus, getHealthBonus)
//              - Mana (modManaBonus, getManaBonus)'
//              - HealthRegen (modHealthRegenBonus, getHealthRegenBonus)
//              - HealthRegenPercent (modHealthRegenPercentBonus, getHealthRegenPercentBonus) // percent of max
//              - ManaRegen (modManaRegenBonus, getManaRegenBonus)
//              - ManaRegenPercent (modManaRegenPercentBonus, getManaRegenPercentBonus) // percent of max
//              - MoveSpeed (modMoveSpeedBonus, getMoveSpeedBonus)
//              - MoveSpeedPercent (modMoveSpeedPercentBonus, getMoveSpeedPercentBonus) // percent of current move speed (after normal bonuses).
//
//      How to Use:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Statuses:
//              Status[unit].add?()
//                  - Adds the status effect to the unit.
//                  - This does not add any animation.
//              Status[unit].remove?()
//                  - Removes the status effect added with .add?().
//                  - Will not actually remove it until all added instances are removed.
//              Status[unit].is?() --> boolean
//                  - Checks to see whether or not a unit has a status effect applied.
//
//          Bonuses:
//              Status[unit].mod?(amount)
//                  - Modifies the bonus by the amount given.
//                  - Use a negative value to reverse a bonus.
//                  - Supports giving negative of a bonus.
//              Status[unit].get?()
//                  - Gets the curret total amount for a given bonus.
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Weep: for suggesting that making the ability an ultimate hero ability
//            would allow it to stun magic immune units, and suggesting a simpler
//            target allowance for the ability.
//
//===========================================================================
// Trigger: Heal
//===========================================================================
//TESH.scrollpos=101
//TESH.alwaysfold=0
//////////////////////////////////////////////////////////////
//
//      @@   @@   @@@@@@    @@@    @    
//      @@   @@   @@       @   @   @
//      @@@@@@@   @@@@@   @ @@@ @  @
//      @@   @@   @@      @     @  @
//      @@   @@   @@@@@@  @     @  @@@@@@@@
//
//                by kingking
//
//           This version : v1.0.6
//
//  This library is used to simulate heal events.
//  
//  Functions provided :
//  Heal_RegisterEvent(trig)

//  Heal_UnregisterEvent(trig)

//  Heal_Block(real)

//  Heal_BlockAll()

//  Heal_EnableEvent(boolean)

//  Heal_GetSource() -> unit

//  Heal_GetTarget() -> unit

//  Heal_GetAmount() -> real

//  Heal_GetType() -> HealType

//  HealUnit(healer, target, amount, healtype)

//  
//  Default heal type :

//
//  Heal type creation :

//
//  Requires :


/////////////////////////////////////////////////////////////
// Trigger: ABC
//===========================================================================
//TESH.scrollpos=105
//TESH.alwaysfold=0
//==============================================================================
//  ABC -- STRUCT ATTACHMENT SYSTEM BY COHADAR -- v6.1
//==============================================================================
//==============================================================================
//  Quick function index:
//==============================================================================
//
//    ----------------------------------------------------------------------
//      Set Functions - these functions attach struct to a handle
//    ----------------------------------------------------------------------
//    SetTimerStructA(timer, struct)
//    SetTimerStructB(timer, struct)
//    SetTimerStructC(timer, struct)
//
//    SetTriggerStructA(trigger, struct)
//    SetTriggerStructB(trigger, struct)
//    SetTriggerStructC(trigger, struct)
//
//    SetDialogStructA(dialog, struct)
//    SetDialogStructB(dialog, struct)
//    SetDialogStructC(dialog, struct)
//
//    SetRegionStructA(region, struct)
//    SetRegionStructB(region, struct)
//    SetRegionStructC(region, struct)
//
//    ----------------------------------------------------------------------
//      Get Functions - these functions retrieve attached structs
//    ----------------------------------------------------------------------
//    GetTimerStructA(timer) -> struct
//    GetTimerStructB(timer) -> struct
//    GetTimerStructC(timer) -> struct
//
//    GetTriggerStructA(trigger) -> struct
//    GetTriggerStructB(trigger) -> struct
//    GetTriggerStructC(trigger) -> struct
//
//    GetDialogStructA(dialog) -> struct
//    GetDialogStructB(dialog) -> struct
//    GetDialogStructC(dialog) -> struct
//
//    GetRegionStructA(region) -> struct
//    GetRegionStructB(region) -> struct
//    GetRegionStructC(region) -> struct
//
//    ----------------------------------------------------------------------
//      Clear Functions - these functions clear and return attached value
//    ----------------------------------------------------------------------
//    ClearTimerStructA(timer) -> struct
//    ClearTimerStructB(timer) -> struct
//    ClearTimerStructC(timer) -> struct
//
//    ClearTriggerStructA(trigger) -> struct
//    ClearTriggerStructB(trigger) -> struct
//    ClearTriggerStructC(trigger) -> struct
//
//    ClearDialogStructA(dialog) -> struct
//    ClearDialogStructB(dialog) -> struct
//    ClearDialogStructC(dialog) -> struct
//
//    ClearRegionStructA(region) -> struct
//    ClearRegionStructB(region) -> struct
//    ClearRegionStructC(region) -> struct
//
//==============================================================================
//==============================================================================
//  DOCUMENTATION:
//==============================================================================
//
//  PURPOUSE OF ABC:
//       * Type safe handle attaching.
//      
//       * Currently supported handle types are timer, trigger, dialog and region
//
//  PROS: 
//       * ABC is faster than gamecache based systems.
//
//       * You can attach up to 3 structs on the same handle
//         
//       * System reports collision, and clearing of non-existent value.
//
//       * This system will work even if your map leaks
//         and will NOT slow down because of it.
//
//  CONS:
//       * you must manually clear the stored value - REMEMBER THIS RULE!!!
//         Don't forget to use Clear functions
//
//  DETAILS:
//       * You can use Get to check if struct is attached to handle
//         It will return 0 if it is not.
//
//       * ABC will not interfere with other attachment systems
//         You can freely use any other system alongside ABC
//
//       * For unit attaching I recommend using PUI
//
//  SPECIAL THANKS TO: 
//       * NagelBagel - for finding errors in versions 4.3 and 4.4
//       * Here-b-Trollz - for testing ABC and for making cool spells with it.
//       * Toadcop - for being pain in the ass and for pushing me to improve ABC.
//       * emjlr3 - for pointing out the need for non-generic trigger attachments
//       * PandaMine - I found a bug in ABC by examining his HSAS vs ABC test
//       * All those people out there who use and support my systems
//         Thank you guys.
//
//  HOW TO IMPORT:
//       * Just create a trigger named ABC
//       * convert it to text and replace the whole trigger text with this one
//
//==============================================================================
//==============================================================================
//  Macro function cores
//==============================================================================
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//==============================================================================
//==============================================================================
//  END OF ABC STRUCT ATTACHMENT SYSTEM
//==============================================================================//===========================================================================
// Trigger: AII
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: Table
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Height
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AddEffectZ
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
// Trigger: Move
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: Vector
//===========================================================================
//TESH.scrollpos=69
//TESH.alwaysfold=0
// Trigger: FloatText
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Text
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Direction
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SpellStruck
//===========================================================================
//TESH.scrollpos=40
//TESH.alwaysfold=0
//
//
//      Spell Struct
//          By Jesus4Lyf.
//       Version 1.0.7.
//
//      What is SpellStruct?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          SpellStruct is a system designed for the sake of rapid spell development.
//          It grants features which can be entirely encapsulated in a struct type per
//          ability. It handles event response creation, timer attachment, trigger
//          attachment, area of effect (AoE) enumeration, unit attachment, and all
//          spells made using it should be automatically MUI/leakless and rather efficient.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called SpellStruct, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//    _______________________
//    ||                   ||
//    || SpellStruct Usage ||
//    ||                   ||
//    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//      Writing a Simple SpellStruct:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - To use SpellStruct, write SpellStructs. These are structs which extend
//            SpellStruct, and implement SpellStruct.
//
//          - Everything is optional to implement/use, except setting thistype.abil='Axxx'
//            in static method onInit.
//
//          - Example:
//

//      Event Responses:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - The following is a list of event responses that come with SpellStructs.
//
//          - Event responses are stored on your struct as members.

//          - The above event response list may be used anywhere in your SpellStruct,
//            and at any time.
//
//          - You may implement methods which are called when the normal Warcraft III
//            spell events would fire. Some of the Warcraft III event responses are
//            broken for certain events, sometimes intermittently, but these are fixed
//            when using SpellStruct.
//            Also, usually in Warcraft III, these are implemented in a way that cycles
//            through all triggered abilities to see if the spell cast is the spell the
//            trigger is for. In SpellStruct, this is changed so that Warcraft III will
//            jump straight to the method for the spell that was cast.
//
//          - These methods, which are called when events fire, are non-static. This means
//            any members you add in your SpellStruct can be accessed from within the method.
//            This is achieved with unit attachment (internally).
//
//          - Example:
//

//      Disabling Auto-Destruction:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - SpellStructs are created just before the .onChannel event method is
//            called.
//
//          - By default, SpellStructs are automatically destroyed, and this occurs
//            just after the method .onStopCast is called.
//
//          - You may extend this lifetime in two ways. If you wish to manually
//            manage the lifetime of a SpellStruct, you may do either of the following:

//          - Setting thistype.autoDestroyDefault to false causes .autoDestroy to
//            be set to false just before onCreate is called, for all new instances.
//
//          - Setting this.autoDestroy to false stops just the current instance
//            from auto destruction. Setting it back to true will cause the struct
//            to be destroyed if it usually would have been by then, else continue
//            to monitor it for auto destruction.
//
//      Locking:
//     藟藟藟藟藟藟藟藟藟藟
//          - You may also add locks to an instance. This is done using this.addLock(),
//            and this.removeLock(). Calling this.addLock increments a counter, and
//            calling this.removeLock() decrements it. While it is greater than 0,
//            a SpellStruct will not be autodestroyed. Decrementing it back to 0
//            after the .onStopCast method has fired while .autoDestroy is true will
//            destroy the struct automatically. This is a garbage collection mechanism.
//
//          - You may check if a struct has no locks on it by using .isNotLocked.
//
//          - Example:
//

//      Timers:
//     藟藟藟藟藟藟藟藟藟
//          - If you have TimerUtils in your map, SpellStruct will operate using
//            TimerUtils data attachment for timers.
//          - If you don't have TimerUtils, but have Recycle, SpellStruct will
//            attach to Recycled timers using GetHandleId and a hashtable.
//          - If you have neither, SpellStruct will create timers dynamically,
//            and pause and destroy them when they are done with. Attachment
//            will be done with GetHandleId and a hashtable.
//
//          - .startTimer(method, period) will start a timer for the given method,
//            for the current spell instance. This means all spell event responses
//            will be available from within the callback. This timer will keep
//            firing until you stop it using .stopTimer(method).
//
//          - Starting a timer in this way automatically adds a lock to the struct,
//            and stopping a timer removes a lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will stop all timers for
//            that struct automatically.
//
//          - Because it attaches both the method to call and the struct instance
//            to the timer, and then fires the method with .execute(), it is
//            recommended that you use this only for timers that are reasonably
//            infrequent. Using T32x with SpellStruct is recommended for high
//            frequency (low period) timers.
//
//          - Example:
//

//      Triggers:
//     藟藟藟藟藟藟藟藟藟藟藟
//          - Trigger attaching works using GetHandleId and a hashtable.
//
//          - .createTrigger(method) will create a trigger with the method as it's
//            action. Do not use DestroyTrigger to remove this trigger, you must
//            use .destroyTrigger(method) to destroy it instead. This saves having
//            to store the trigger in any sort of variable, generally. Destroying
//            a trigger using SpellStruct has protection against the double free
//            bug in Warcraft III, even if you use TriggerSleepAction.
//
//          - Creating a trigger in this way automatically adds a lock to the struct,
//            and destroying it removes this lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will destroy all triggers
//            for that struct automatically.
//
//          - Example:
//

//      AoE (Area of Effect) enumeration:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - You may set the AoE of a spell instance using set this.aoe = x, or you
//            may set the default value for the aoe of a spell using set
//            thistype.defaultAoE = x. This will set the value of .aoe to the value
//            specified before onCreate is called.
//
//          - You may enumerate the units in AoE of the target point, the current
//            position of the targetted object, or the caster. This requires a unit
//            filter to be applied.
//
//          - This enum does not clear the group before hand, like native enums.
//            Actually, it should even be safe to use with dynamic groups.
//

//          - You may also skip groups altogether and do actions for all units within
//            aoe of the target point/target/caster.
//

//          - You may also check, for a single unit, to see if it is within the AoE
//            of the target point, target or caster, using the following:
//            - this.isUnitInAoE(myUnit) // within aoe of target point.
//            - this.isUnitInAoETarget(myUnit) // within aoe of target.
//            - this.isUnitInAoECaster(myUnit) // within aoe of caster.
//          - The above return booleans.
//
//          - All AoE functionality takes into account the collision size of the
//            enumerated units. This matches better with Warcraft III AoE detection,
//            which highlights units the spell will hit in green for AoE abilities.
//
//      Miscellaneous:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - call this.forGroup(g, callback method takes unit)
//            Example:
//

//          - real this.getDistanceToTargetWidget() // The distance between the caster and the target widget.
//          - real this.getDistanceToTargetPoint()  // The distance between the caster and the original point targetted.
//          - real this.getAngleToTargetWidget()    // The angle from the caster to the target object (in radians).
//          - real this.getAngleToTargetPoint()    // The angle from the caster to the target location (in radians).
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me with the interface hint to make the methods
//            optional.
//
//===========================================================================
// Trigger: Timer Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: HashKeyManager
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: T32
//===========================================================================
//TESH.scrollpos=15
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ Timer32 ~~ By Jesus4Lyf ~~ Version 1.06 ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Timer32?
//         - Timer32 implements a fully optimised timer loop for a struct.
//         - Instances can be added to the loop, which will call .periodic every
//           PERIOD until .stopPeriodic() is called.
//
//    =Pros=
//         - Efficient.
//         - Simple.
//
//    =Cons=
//         - Only allows one period.
//         - The called method must be named ".periodic".
//
//    Methods:
//         - struct.startPeriodic()
//         - struct.stopPeriodic()
//
//         - private method periodic takes nothing returns nothing
//
//           This must be defined in structs that implement Periodic Module.
//           It will be executed by the module every PERIOD until .stopPeriodic() is called.
//           Put "implement T32x" BELOW this method.
//
//    Modules:
//         - T32x
//           Has no safety on .stopPeriodic or .startPeriodic (except debug messages
//           to warn).
//
//         - T32xs
//           Has safety on .stopPeriodic and .startPeriodic so if they are called
//           multiple times, or while otherwise are already stopped/started respectively,
//           no error will occur, the call will be ignored.
//
//         - T32
//           The original, old version of the T32 module. This remains for backwards
//           compatability, and is deprecated. The periodic method must return a boolean,
//           false to continue running or true to stop.
//
//  Details:
//         - Uses one timer.
//
//         - Do not, within a .periodic method, follow a .stopPeriodic call with a
//           .startPeriodic call.
//
//  How to import:
//         - Create a trigger named T32.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Infinitegde for finding a bug in the debug message that actually altered
//           system operation (when in debug mode).
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: HashTable
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Distance
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDS
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=78
//TESH.alwaysfold=0
//  
//        _   ___ ___  ___    _______________________________________________
//       /_\ |_ _|   \/ __|   ||     A D V A N C E D   I N D E X I N G     ||
//      / _ \ | || |) \__ \   ||                  A N D                    ||
//     /_/ \_\___|___/|___/   ||         D A T A   S T O R A G E           ||
//            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.1.0
//      What is AIDS?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          AIDS assigns unique integers between 1 and 8191 to units which enter
//          the map. These can be used for arrays and data attaching.
//          
//          AIDS also allows you to define structs which are created automatically
//          when units enter the map, and filtering which units should be indexed
//          as well as for which units these structs should be created.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called AIDS, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "external" will line up with this line):
//          external ObjectMerger w3a Adef AIDS anam "State Detection" ansf "(AIDS)" aart "" arac 0
//
//          At the top of the script, there is a 'UnitIndexingFilter' constant
//          function. If the function returns true for the unit, then that unit
//          will be automatically indexed. Setting this to true will automatically
//          index all units. Setting it to false will disable automatic indexing.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function GetUnitId takes unit u returns integer
//              - This returns the index of an indexed unit. This will return 0
//                if the unit has not been indexed.
//              - This function inlines. It does not check if the unit needs an
//                index. This function is for the speed freaks.
//              - Always use this if 'UnitIndexingFilter' simply returns true.
//
//          function GetUnitIndex takes unit u returns integer
//              - This will return the index of a unit if it has one, or assign
//                an index if the unit doesn't have one (and return the new index).
//              - Use this if 'UnitIndexingFilter' doesn't return true.
//
//          function GetIndexUnit takes integer index returns unit
//              - This returns the unit which has been assigned the 'index'.
//
//      AIDS Structs:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - Insert: //! runtextmacro AIDS() at the top of a struct to make it
//            an AIDS struct.
//          - AIDS structs cannot be created or destroyed manually. Instead, they
//            are automatically created when an appropriate unit enters the map.
//          - You cannot give members default values in their declaration.
//            (eg: private integer i=5 is not allowed)
//          - You cannot use array members.
//          - AIDS structs must "extend array". This will remove some unused
//            functions and enforce the above so there will be no mistakes.
//          - There are four optional methods you can use in AIDS structs:
//              - AIDS_onCreate takes nothing returns nothing
//                  - This is called when the struct is 'created' for the unit.
//                  - In here you can assign members their default values, which
//                    you would usually assign in their declarations.
//                    (eg: set this.i=5)
//              - AIDS_onDestroy takes nothing returns nothing
//                  - This is called when the struct is 'destroyed' for the unit.
//                  - This is your substitute to the normal onDestroy method.
//              - AIDS_filter takes unit u returns boolean
//                  - This is similar to the constant filter in the main system.
//                  - Each unit that enters the map will be tested by each AIDS
//                    struct filter. If it returns true for that unit, that unit
//                    will be indexed if it was not already, the AIDS struct will
//                    have its AIDS_onCreate method called, and later have its
//                    AIDS_onDestroy method called when the index is recycled.
//                  - Not declaring this will use the default AIDS filter instead.
//              - AIDS_onInit takes nothing returns nothing
//                  - This is because I stole your onInit function with my textmacro.
//          - You can use '.unit' from any AIDS struct to get the unit for which
//            the struct is for.
//          - The structs id will be the units index, so getting the struct for
//            a unit inlines to a single native call, and you can typecast between
//            different AIDS structs. This is the premise of AIDS.
//          - Never create or destroy AIDS structs directly.
//          - You can call .AIDS_addLock() and AIDS_removeLock() to increase or
//            decrease the lock level on the struct. If a struct's lock level is
//            not 0, it will not be destroyed until it is reduced to 0. Locks just
//            put off AIDS struct destruction in case you wish to attach to a timer
//            or something which must expire before the struct data disappears.
//            Hence, not freeing all locks will leak the struct (and index).
//
//      PUI and AutoIndex:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - AIDS includes the PUI textmacros and the AutoIndex module, because
//            these systems are not compatible with AIDS but have valid and distinct
//            uses.
//          - The PUI textmacros are better to use for spells than AIDS structs,
//            because they are not created for all units, just those targetted by
//            the spell (or whatever else is necessary).
//          - The AutoData module is good for very simple array syntax for data
//            attachment (although I don't recommend that people actually use it,
//            it's here mostly for compatability). Note that unlike the PUI textmacros,
//            units must pass the AIDS filter in order for this module to work with
//            them. This is exactly as the same as in AutoIndex itself (AutoIndex
//            has a filter too).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for writing 90% of this user documentation, challenging my
//            interface, doing some testing, suggesting improvements and inspiring
//            me to re-do my code to include GetUnitIndex as non-inlining.
//          - grim001, for writing the AutoData module, and AutoIndex. I used the
//            on-enter-map method that he used. Full credits for the AutoData module.
//          - Cohadar, for writing his PUI textmacros. Full credits to him for these,
//            except for my slight optimisations for this system.
//            Also, I have used an optimised version of his PeriodicRecycler from
//            PUI in this system to avoid needing a RemoveUnitEx function.
//          - Vexorian, for helping Cohadar on the PUI textmacro.
//          - Larcenist, for suggesting the AIDS acronym. Originally he suggested
//            'Alternative Index Detection System', but obviously I came up with
//            something better. In fact, I'd say it looks like the acronym was
//            an accident. Kinda neat, don't you think? :P
//
//      Final Notes:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - With most systems, I wouldn't usually add substitutes for alternative
//            systems. However, UnitData systems are an exception, because they
//            are incompatible with eachother. Since using this system forbids
//            people from using the real PUI or AutoIndex, and a lot of resources
//            use either of these, it made sense not to break them all.
//
//          - If this documentation confused you as to how to use the system, just
//            leave everything as default and use GetUnitId everywhere.
//
//          - To use this like PUI (if you don't like spamming indices) simply
//            make the AIDS filter return false, and use GetUnitIndex.
//
// Trigger: AIDSCleaner
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AIDSCleanerActions takes nothing returns nothing
    local unit tu = GetTriggerUnit()
    call EquipmentData[tu].stopPeriodic()
endfunction
//===========================================================================
function InitTrig_AIDSCleaner takes nothing returns nothing
    set gg_trg_AIDSCleaner = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ( gg_trg_AIDSCleaner, EVENT_PLAYER_UNIT_DEATH )
    call YDWETriggerRegisterLeaveRectSimpleNull( gg_trg_AIDSCleaner, GetPlayableMapRect() )
    call TriggerAddCondition(gg_trg_AIDSCleaner, function Trig_AIDSCleanerActions)
endfunction
//===========================================================================
// Trigger: Event
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  ~~    Event     ~~    By Jesus4Lyf    ~~    Version 1.04    ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Event?
//         - Event simulates Warcraft III events. They can be created,
//           registered for, fired and also destroyed.
//         - Event, therefore, can also be used like a trigger "group".
//         - This was created when there was an influx of event style systems 
//           emerging that could really benefit from a standardised custom
//           events snippet. Many users were trying to achieve the same thing
//           and making the same kind of errors. This snippet aims to solve that.
//
//  Functions:
//         - Event.create()       --> Creates a new Event.
//         - .destroy()           --> Destroys an Event.
//         - .fire()              --> Fires all triggers which have been
//                                    registered on this Event.
//         - .register(trigger)   --> Registers another trigger on this Event.
//         - .unregister(trigger) --> Unregisters a trigger from this Event.
//
//  Details:
//         - Event is extremely efficient and lightweight.
//         - It is safe to use with dynamic triggers.
//         - Internally, it is just a linked list. Very simple.
//
//  How to import:
//         - Create a trigger named Event.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Builder Bob for the trigger destroy detection method.
//         - Azlier for inspiring this by ripping off my dodgier code.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: Damage
//===========================================================================
//TESH.scrollpos=63
//TESH.alwaysfold=0
//  
//      ___   _     __  __   _   ___  ____    _______________________________
//     |   \ /_\   /  |/  | /_\ /  _\|  __|   ||      D E A L   I T ,      ||
//     | |) / _ \ / / | / |/ _ \| |/||  __|   ||    D E T E C T   I T ,    ||
//     |___/_/ \_/_/|__/|_|_/ \_\___/|____|   ||     B L O C K   I T .     ||
//                            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.0.1
//      What is Damage?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Damage is a damage dealing, detection and blocking system. It implements
//          all such functionality. It also provides a means to detect what type
//          of damage was dealt, so long as all damage in your map is dealt using
//          this system's deal damage functions (except for basic attacks).
//
//          It is completely recursively defined, meaning if you deal damage on
//          taking damage, the type detection and other features like blocking
//          will not malfunction.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Damage, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          At the top of the script, there is a '//! external ObjectMerger' line.
//          Save your map, close your map, reopen your map, and then comment out this
//          line. Damage is now implemented. This line creates a dummy ability used
//          in the system in some circumstances with damage blocking.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function Damage_RegisterEvent takes trigger whichTrigger returns nothing
//              - This registers a special "any unit takes damage" event.
//              - This event supports dynamic trigger use.
//              - Only triggers registered on this event may block damage.
//
//          function Damage_GetType takes nothing returns damagetype
//              - This will get the type of damage dealt, like an event response,
//                for when using a unit takes damage event (or the special event above).
//
//          function Damage_Block takes real amount returns nothing
//          function Damage_BlockAll takes nothing returns nothing
//              - For use only with Damage_RegisterEvent.
//              - Blocks 'amount' of the damage dealt.
//              - Multiple blocks at once work correctly.
//              - Blocking more than 100% of the damage will block 100% instead.
//              - Damage_BlockAll blocks 100% of the damage being dealt.
//
//          function Damage_EnableEvent takes boolean enable returns nothing
//              - For disabling and re-enabling the special event.
//              - Use it to deal damage which you do not want to be detected by
//                the special event.
//
//          function UnitDamageTargetEx takes lots of things returns boolean
//              - Replaces UnitDamageTarget in your map, with the same arguments.
//
//          function Damage_Physical takes unit source, unit target, real amount,
//            attacktype whichType, boolean attack, boolean ranged returns boolean
//              - A clean wrapper for physical damage.
//              - 'attack' determines if this is to be treated as a real physical
//                attack or just physical type damage.
//              - 'ranged' determines if this is to be treated as a ranged or melee
//                attack.
//
//          function Damage_Spell takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for spell damage.
//
//          function Damage_Pure takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for pure type damage (universal type, 100% damage).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me find a better way to think about damage blocking.
//
//===========================================================================
// Trigger: CustomDamage
//===========================================================================
//TESH.scrollpos=99
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Custom Congregation
//===========================================================================
//TESH.scrollpos=10
//TESH.alwaysfold=0
// Trigger: List Module
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Group Utils
//===========================================================================
//TESH.scrollpos=18
//TESH.alwaysfold=0
// Trigger: CreateItem
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
function Trig_CreateItemActions takes nothing returns nothing
    local integer i = 0
    call YDWEPolledWaitNull(1.00)
    //call CreateItemEx('I003',0,0)
    //call CreateItemEx('I002',0,0)
    //call CreateItemEx(iRETURN,0,0)
    //call CreateItemEx(iREACT,0,0)
    //call CreateItemEx(iELECTRIC,0,0)
    //call CreateItemEx(iBLINK,0,0)
    //call CreateItemEx(iTRANSPORT,0,0)
    //call CreateItemEx(iAUTOAIM,0,0)
    //call CreateItemEx(iLEAVE,0,0)
    //call CreateItemEx(iBKGRENADE,0,0)
    //call CreateItemEx(iPSGRENADE,0,0)
    //call CreateItemEx(iMINE,0,0)
    call CreateItemEx('I00P',0,0)
    call CreateItemEx('I00Q',0,0)
    call CreateItemEx('I00S',0,0)
    call CreateItemEx('I00R',0,0)
    call CreateItemEx('I001',0,0)
    loop
        exitwhen i > 0
        //call CreateItemEx(i100G,-300,0)
        set i = i + 1
    endloop
    set i = 0
    loop
        exitwhen i > 0
        //call CreateItemEx(iFREEUP,-300,-100)
        set i = i + 1
    endloop
    set i =0
    loop
        exitwhen i > 0
        //call CreateItemEx(iEXP,-300,-200)
        set i = i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_CreateItem takes nothing returns nothing
    set gg_trg_CreateItem = CreateTrigger()
    call TriggerAddAction(gg_trg_CreateItem, function Trig_CreateItemActions)
endfunction
//===========================================================================
// Trigger: 12 澶嶅埗 2 澶嶅埗
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_12________2_______uActions takes nothing returns nothing
    call TriggerSleepAction(100.00)
    call BJDebugMsg("fff")
    call UnitAddAbility( gg_unit_u002_0161, 'A01Q' )
    call UnitRemoveAbility( gg_unit_u002_0161, 'A01Q' )
    call UnitAddAbility( gg_unit_u002_0161, 'A01Q' )
    call UnitRemoveAbility( gg_unit_u002_0161, 'A01Q' )
endfunction
//===========================================================================
function InitTrig_12________2_______u takes nothing returns nothing
    set gg_trg_12________2_______u = CreateTrigger()
    call TriggerAddAction(gg_trg_12________2_______u, function Trig_12________2_______uActions)
endfunction
//===========================================================================
// Trigger: 12 澶嶅埗 2 澶嶅埗 2
//===========================================================================
function Trig_12________2________2Actions takes nothing returns nothing
    call KillUnit( gg_unit_u002_0161 )
endfunction
//===========================================================================
function InitTrig_12________2________2 takes nothing returns nothing
    set gg_trg_12________2________2 = CreateTrigger()
    call TriggerAddAction(gg_trg_12________2________2, function Trig_12________2________2Actions)
endfunction
//===========================================================================
// Trigger: 12 澶嶅埗 2 澶嶅埗 3
//===========================================================================
function Trig_12________2________3Actions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_12________2________3 takes nothing returns nothing
    set gg_trg_12________2________3 = CreateTrigger()
    call TriggerAddAction(gg_trg_12________2________3, function Trig_12________2________3Actions)
endfunction
//===========================================================================
// Trigger: AIApproach
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: camera
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_cameraActions takes nothing returns nothing
    call SetCameraFieldForPlayer( Player(0), CAMERA_FIELD_TARGET_DISTANCE, 2500.00, 0.50 )
endfunction
//===========================================================================
function InitTrig_camera takes nothing returns nothing
    set gg_trg_camera = CreateTrigger()
    call TriggerAddAction(gg_trg_camera, function Trig_cameraActions)
endfunction
//===========================================================================
// Trigger: inittest
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_inittestActions takes nothing returns nothing
    local unit u
    local unit hero
    local unit ally
    local real x = GetRandomReal(GetRectMinX(gg_rct_start), GetRectMaxX(gg_rct_start))
    local real y = GetRandomReal(GetRectMinY(gg_rct_start), GetRectMaxY(gg_rct_start))
    local integer i = 0
    //call CreateFogModifierRectBJ( true, Player(0), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
    //call CreateFogModifierRectBJ( true, Player(11), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
    //set hero = CreateHero(0,x, y )
    set hero = CreateHero(0,0, 0 )
    //set g_camera_lock = true
    set g_fog = true
    //call LockAgain()
    //set ally = CreateUnit(Player(11),'h003',0,-700,0)
    //set ally = CreateUnit(Player(0),EVIL_MARIN,0,-100,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-500,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-600,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-700,0)
    //call SetUnitLifeBJ( ally, 1000.00 )
    call BeMonsterTarget(hero)
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = 0
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call CreateUnit( Player(11), 'u000', GetRandomReal(-10000.00, 10000.00), GetRandomReal(-10000.00, 10000.00), bj_UNIT_FACING )
        call CreateUnit( Player(11), 'z000', GetRandomReal(-10000.00, 10000.00), GetRandomReal(-10000.00, 10000.00), bj_UNIT_FACING )
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
    set u = null
    set hero = null
    
    loop
        exitwhen i >= 3
        if heros[i] != null then
            //call SetCameraTargetControllerNoZForPlayer( Player(i), heros[i], 0, 0, false )
        endif
        set i = i + 1
    endloop
    //call GamePlay_StartRoom()
endfunction
//===========================================================================
function InitTrig_inittest takes nothing returns nothing
    set gg_trg_inittest = CreateTrigger()
    call TriggerAddAction(gg_trg_inittest, function Trig_inittestActions)
endfunction
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_StartRoom( )
    call InitTrig_level1( )
    call InitTrig_InitJobData( )
    call InitTrig_Save( )
    call InitTrig_Strong( )
    call InitTrig_ItemJump( )
    call InitTrig_GunSpell( )
    call InitTrig_Jump( )
    call InitTrig_JumpFacingStore( )
    call InitTrig_InjectionSpeedUp( )
    call InitTrig_RegisterSpell( )
    call InitTrig_Darts( )
    call InitTrig_RetrunDarts( )
    call InitTrig_SmartDarts( )
    call InitTrig_ShoulderCannon( )
    call InitTrig_ItemRetrunDarts( )
    call InitTrig_LeaveDarts( )
    call InitTrig_BackGrenade( )
    call InitTrig_Mine( )
    call InitTrig_PushGrenade( )
    call InitTrig_Blink( )
    call InitTrig_Transport( )
    call InitTrig_ElectricWhip( )
    call InitTrig_AutoAim( )
    call InitTrig_ShootBack( )
    call InitTrig_TeckLock( )
    call InitTrig_Register( )
    call InitTrig_RegisterFly( )
    call InitTrig_FogControl( )
    call InitTrig_CameraLock( )
    call InitTrig_Movie( )
    call InitTrig_GV( )
    call InitTrig_LearnAbility( )
    call InitTrig_TriggerKillHpBuff( )
    call InitTrig_TriggerHorro( )
    call InitTrig_HorrorOrderFilter( )
    call InitTrig_HorrorOrder( )
    call InitTrig_OrderId( )
    call InitTrig_ShootSpeed( )
    call InitTrig_Radiation( )
    call InitTrig_ArrayList( )
    call InitTrig_ChooseTech( )
    call InitTrig_ChooseBonus( )
    call InitTrig_TechLevelUp( )
    call InitTrig_TechData( )
    call InitTrig_Transform( )
    call InitTrig_DialogSystem( )
    call InitTrig_Buffer( )
    call InitTrig_BurnBuffer( )
    call InitTrig_HorroBuffer( )
    call InitTrig_BleedBuffer( )
    call InitTrig_IceSlowBuffer( )
    call InitTrig_AutoAimBuffer( )
    call InitTrig_Debuff( )
    call InitTrig_BufferFunction( )
    call InitTrig_Constants( )
    call InitTrig_PlayerHero( )
    call InitTrig_FocuseHero( )
    call InitTrig_ItemData( )
    call InitTrig_ItemEquip( )
    call InitTrig_ItemType( )
    call InitTrig_UnitId( )
    call InitTrig_FakeMan( )
    call InitTrig_MonsterDead( )
    call InitTrig_ShootTarget( )
    call InitTrig_MonsterTypeData( )
    call InitTrig_MonsterBonus( )
    call InitTrig_MonsterTargetGroup( )
    call InitTrig_DeathEffect( )
    call InitTrig_Difficulty( )
    call InitTrig_EffectString( )
    call InitTrig_SkillLearn( )
    call InitTrig_DoublePacket( )
    call InitTrig_Missle( )
    call InitTrig_MissleFactory( )
    call InitTrig_Gun( )
    call InitTrig_Shooter( )
    call InitTrig_HeroData( )
    call InitTrig_EquipmentData( )
    call InitTrig_HeroStatus( )
    call InitTrig_Velocity( )
    call InitTrig_Material( )
    call InitTrig_PhysicsSystem( )
    call InitTrig_bordercontrol( )
    call InitTrig_TargetFilter( )
    call InitTrig_ItemInfo( )
    call InitTrig_AIStrategy( )
    call InitTrig_AIGroup( )
    call InitTrig_AIData( )
    call InitTrig_AIDriver( )
    call InitTrig_AIHurted( )
    call InitTrig_DummyCaster( )
    call InitTrig_Status( )
    call InitTrig_Heal( )
    call InitTrig_ABC( )
    call InitTrig_AII( )
    call InitTrig_Table( )
    call InitTrig_Height( )
    call InitTrig_AddEffectZ( )
    call InitTrig_Move( )
    call InitTrig_Vector( )
    call InitTrig_FloatText( )
    call InitTrig_Text( )
    call InitTrig_Direction( )
    call InitTrig_SpellStruck( )
    call InitTrig_Timer_Utils( )
    call InitTrig_HashKeyManager( )
    call InitTrig_T32( )
    call InitTrig_HashTable( )
    call InitTrig_Distance( )
    call InitTrig_AIDS( )
    call InitTrig_AIDSCleaner( )
    call InitTrig_Event( )
    call InitTrig_Damage( )
    call InitTrig_CustomDamage( )
    call InitTrig_Custom_Congregation( )
    call InitTrig_List_Module( )
    call InitTrig_Group_Utils( )
    call InitTrig_CreateItem( )
    call InitTrig_12________2_______u( )
    call InitTrig_12________2________2( )
    call InitTrig_12________2________3( )
    call InitTrig_AIApproach( )
    call InitTrig_camera( )
    call InitTrig_inittest( )
endfunction
//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute( gg_trg_TeckLock )
    call ConditionalTriggerExecute( gg_trg_Status )
    call ConditionalTriggerExecute( gg_trg_ABC )
    call ConditionalTriggerExecute( gg_trg_CreateItem )
    call ConditionalTriggerExecute( gg_trg_12________2_______u )
    call ConditionalTriggerExecute( gg_trg_camera )
    call ConditionalTriggerExecute( gg_trg_inittest )
endfunction
//***************************************************************************
//*
//*  Players
//*
//***************************************************************************
function InitCustomPlayerSlots takes nothing returns nothing
    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call ForcePlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), true )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )
    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call ForcePlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(1), true )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )
    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call ForcePlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(2), true )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )
    // Player 11
    call SetPlayerStartLocation( Player(11), 3 )
    call ForcePlayerStartLocation( Player(11), 3 )
    call SetPlayerColor( Player(11), ConvertPlayerColor(11) )
    call SetPlayerRacePreference( Player(11), RACE_PREF_UNDEAD )
    call SetPlayerRaceSelectable( Player(11), true )
    call SetPlayerController( Player(11), MAP_CONTROL_COMPUTER )
endfunction
function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerTeam( Player(2), 0 )
    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(1), true )
    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(2), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(0), true )
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(1), true )
    // Force: TRIGSTR_149
    call SetPlayerTeam( Player(11), 1 )
endfunction
function InitAllyPriorities takes nothing returns nothing
    call SetStartLocPrioCount( 0, 2 )
    call SetStartLocPrio( 0, 0, 1, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 0, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 1, 2 )
    call SetStartLocPrio( 1, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 1, 1, 2, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrioCount( 2, 2 )
    call SetStartLocPrio( 2, 0, 0, MAP_LOC_PRIO_HIGH )
    call SetStartLocPrio( 2, 1, 1, MAP_LOC_PRIO_HIGH )
endfunction
//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************
//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -9472.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -9472.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCDalaran\\DNCDalaranTerrain\\DNCDalaranTerrain.mdl", "Environment\\DNC\\DNCDalaran\\DNCDalaranUnit\\DNCDalaranUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "DalaranDay" )
    call SetAmbientNightSound( "DalaranNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateRegions( )
    call CreateAllUnits( )
    call InitBlizzard( )

//! initstructs
call ExecuteFunc("ABC___Init")
call ExecuteFunc("AIDS___InitAIDS")
call ExecuteFunc("InitHashTable")
call ExecuteFunc("InitHeroStatus")
call ExecuteFunc("InitLevel1")
call ExecuteFunc("InitMonsterDead")
call ExecuteFunc("InitMonsterTypeData")
call ExecuteFunc("InitRegisterSpell")
call ExecuteFunc("ShootBackInitializer")
call ExecuteFunc("InitSkillLearn")
call ExecuteFunc("T32___OnInit")
call ExecuteFunc("InitTechData")
call ExecuteFunc("Init")
call ExecuteFunc("InitializeYD")
call ExecuteFunc("InitAIStrategy")
call ExecuteFunc("InitConstants")
call ExecuteFunc("Damage___OnInit")
call ExecuteFunc("InitDoublePacket")
call ExecuteFunc("Heal___Init")
call ExecuteFunc("InitItemData")
call ExecuteFunc("InitJumpFacingStore")
call ExecuteFunc("InitMonsterBonus")
call ExecuteFunc("InitMove")
call ExecuteFunc("InitSave")
call ExecuteFunc("CameraLockInit")
call ExecuteFunc("FakeManInit")
call ExecuteFunc("FogControlInit")
call ExecuteFunc("InitItemEquip")
call ExecuteFunc("InitMonsterTargetGroup")
call ExecuteFunc("InitShootTarget")
call ExecuteFunc("InitStrong")
call ExecuteFunc("InitAIApproach")
call ExecuteFunc("InitAIGroup")
call ExecuteFunc("BufferStructInit")
call ExecuteFunc("InitChooseBonus")
call ExecuteFunc("InitChooseTech")
call ExecuteFunc("InitRadiation")
call ExecuteFunc("InitTransform")
call ExecuteFunc("MissleInit")

//! initdatastructs
    call InitGlobals( )
    call InitCustomTriggers( )
    call RunInitializationTriggers( )
endfunction
//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************
function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_138" )
    call SetMapDescription( "TRIGSTR_140" )
    call SetPlayers( 4 )
    call SetTeams( 4 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )
    call DefineStartLocation( 0, 7296.0, -1792.0 )
    call DefineStartLocation( 1, 7296.0, -1792.0 )
    call DefineStartLocation( 2, 7296.0, -1792.0 )
    call DefineStartLocation( 3, 6400.0, -3136.0 )
    // Player setup
    call InitCustomPlayerSlots( )
    call InitCustomTeams( )
    call InitAllyPriorities( )
endfunction
//===========================================================================  
//===========================================================================  
//自定义事件 
//===========================================================================
//===========================================================================   

