globals
//globals from ABC:
constant boolean LIBRARY_ABC=true
constant integer ABC___HASH= 8191
timer array ABC___TimerKeyA
timer array ABC___TimerKeyB
timer array ABC___TimerKeyC
trigger array ABC___TriggerKeyA
trigger array ABC___TriggerKeyB
trigger array ABC___TriggerKeyC
dialog array ABC___DialogKeyA
dialog array ABC___DialogKeyB
dialog array ABC___DialogKeyC
region array ABC___RegionKeyA
region array ABC___RegionKeyB
region array ABC___RegionKeyC
button array ABC___ButtonKeyA
button array ABC___ButtonKeyB
button array ABC___ButtonKeyC
    
integer array ABC___TimerValueA
integer array ABC___TimerValueB
integer array ABC___TimerValueC
integer array ABC___TriggerValueA
integer array ABC___TriggerValueB
integer array ABC___TriggerValueC
integer array ABC___DialogValueA
integer array ABC___DialogValueB
integer array ABC___DialogValueC
integer array ABC___RegionValueA
integer array ABC___RegionValueB
integer array ABC___RegionValueC
integer array ABC___ButtonValueA
integer array ABC___ButtonValueB
integer array ABC___ButtonValueC
integer array ABC___TimerCollisionA
integer array ABC___TimerCollisionB
integer array ABC___TimerCollisionC
integer array ABC___TriggerCollisionA
integer array ABC___TriggerCollisionB
integer array ABC___TriggerCollisionC
integer array ABC___DialogCollisionA
integer array ABC___DialogCollisionB
integer array ABC___DialogCollisionC
integer array ABC___RegionCollisionA
integer array ABC___RegionCollisionB
integer array ABC___RegionCollisionC
integer array ABC___ButtonCollisionA
integer array ABC___ButtonCollisionB
integer array ABC___ButtonCollisionC
    
integer ABC___TimerMaxCollisionA= 0
integer ABC___TimerMaxCollisionB= 0
integer ABC___TimerMaxCollisionC= 0
integer ABC___TriggerMaxCollisionA= 0
integer ABC___TriggerMaxCollisionB= 0
integer ABC___TriggerMaxCollisionC= 0
integer ABC___DialogMaxCollisionA= 0
integer ABC___DialogMaxCollisionB= 0
integer ABC___DialogMaxCollisionC= 0
integer ABC___RegionMaxCollisionA= 0
integer ABC___RegionMaxCollisionB= 0
integer ABC___RegionMaxCollisionC= 0
integer ABC___ButtonMaxCollisionA= 0
integer ABC___ButtonMaxCollisionB= 0
integer ABC___ButtonMaxCollisionC= 0
    
hashtable ABC___TimerHash
hashtable ABC___TriggerHash
hashtable ABC___DialogHash
hashtable ABC___RegionHash
hashtable ABC___ButtonHash
//endglobals from ABC
//globals from AIAttack:
constant boolean LIBRARY_AIAttack=true
trigger gtrgAIAttack
//endglobals from AIAttack
//globals from AIDS:
constant boolean LIBRARY_AIDS=true
constant boolean AIDS__USE_PERIODIC_RECYCLER= false
constant real AIDS__PERIOD= 0.03125
// Lower to be able to recycle faster.
// Only used if USE_PERIODIC_RECYCLER
// is set to true.

constant integer AIDS__LEAVE_DETECTION_ABILITY= 'AIDS'
        // The unit stored at an index.
unit array AIDS__IndexUnit
integer array AIDS__LockLevel
        // Recycle stack
integer array AIDS__RecycledIndex
integer AIDS__MaxRecycledIndex= 0
        
        // Previous highest index
integer AIDS__MaxIndex= 0
integer array AIDS__DecayingIndex
integer AIDS__MaxDecayingIndex=0
integer AIDS__DecayChecker=0
timer AIDS__UndefendTimer=CreateTimer()
integer array AIDS__UndefendIndex
integer AIDS__UndefendStackIndex=0
integer array AIDS__UndefendExpiringIndex
integer AIDS__UndefendExpiringIndexLevel=0
        // The Add/Remove stack (or assign/recycle stack).
        // 
        // Indexing can become recusive since units can be created on index
        // assignment or deallocation.
        // To support this, a stack is used to store the event response results.
integer AIDS__ARStackLevel=0
integer array AIDS__ARStackIndex
unit array AIDS__ARStackUnit
        
        // A later discovery revealed that the Add/Remove stack did not need to be
        // used for deallocation. The alternative used works fine...
        // For structs and such which need to do things on unit index assignment.
trigger AIDS__OnEnter=CreateTrigger()
        // The same, but for when units pass the initial filter anyway.
trigger AIDS__OnEnterAllocated=CreateTrigger()
        // For structs and such which need to do things on unit index deallocation.
trigger AIDS__OnDeallocate=CreateTrigger()
integer AIDS__getindex
integer AIDS__UndefendFilterIndex
//endglobals from AIDS
//globals from AIDriver:
constant boolean LIBRARY_AIDriver=true
//endglobals from AIDriver
//globals from AII:
constant boolean LIBRARY_AII=true
constant integer AII___MAX_THRASH=100
        //Max threshold for leaked event for death detection trigger.
trigger AII___alloItem=CreateTrigger()
trigger AII___dealloItem=CreateTrigger()
trigger AII___pickUpItem=CreateTrigger()
trigger AII___sellItem=CreateTrigger()
trigger AII___pawnItem=CreateTrigger()
integer AII___EventStruct=0
item array AII___HashedItem
boolean AII___IsInited=false
trigger AII___dropItem=CreateTrigger()
constant integer AII___HASH_NEXT=53
constant integer AII___MAX_HASH_VALUE=8191
integer array AII___HashedInt
//endglobals from AII
//globals from BOSS1:
constant boolean LIBRARY_BOSS1=true
//endglobals from BOSS1
//globals from BufferFunction:
constant boolean LIBRARY_BufferFunction=true
//endglobals from BufferFunction
//globals from Debuff:
constant boolean LIBRARY_Debuff=true
//endglobals from Debuff
//globals from Difficulty:
constant boolean LIBRARY_Difficulty=true
integer D_HARD=1
integer D_CRAZY=2
integer D_HELL=3
integer Difficulty=D_HARD
integer GAME_LV= 1
integer MAX_GAME_LV= 7
real HORRO_DMG= 0.05
//endglobals from Difficulty
//globals from Distance:
constant boolean LIBRARY_Distance=true
//endglobals from Distance
//globals from DummyCaster:
constant boolean LIBRARY_DummyCaster=true
        // If this is changed, the object merger line must also be changed
        // before the second implementation step is followed.
constant integer DUMMY_TYPE='dumy'
        
        // This shouldn't be changed, but in some maps perhaps it is necessary.
constant player DUMMY_OWNER=Player(PLAYER_NEUTRAL_AGGRESSIVE)
        
        // Just because these belong here:
constant real DummyCaster___CREATED_AT_X=0.0
constant real DummyCaster___CREATED_AT_Y=0.0
//=====================================================================================
unit DUMMY=null
//endglobals from DummyCaster
//globals from EffectString:
constant boolean LIBRARY_EffectString=true
//endglobals from EffectString
//globals from EffectZ:
constant boolean LIBRARY_EffectZ=true
destructable EffectZ__D
effect EffectZ__E
//endglobals from EffectZ
//globals from Event:
constant boolean LIBRARY_Event=true
//endglobals from Event
//globals from FloatText:
constant boolean LIBRARY_FloatText=true
//endglobals from FloatText
//globals from HashKeyManager:
constant boolean LIBRARY_HashKeyManager=true
integer currentKey=- 1
//endglobals from HashKeyManager
//globals from HashTable:
constant boolean LIBRARY_HashTable=true
hashtable ht= null
//endglobals from HashTable
//globals from Height:
constant boolean LIBRARY_Height=true
//endglobals from Height
//globals from HeroData:
constant boolean LIBRARY_HeroData=true
//endglobals from HeroData
//globals from HeroStatus:
constant boolean LIBRARY_HeroStatus=true
trigger herostatus_t
//endglobals from HeroStatus
//globals from Level1:
constant boolean LIBRARY_Level1=true
//endglobals from Level1
//globals from ListModule:
constant boolean LIBRARY_ListModule=true
//endglobals from ListModule
//globals from Lock:
constant boolean LIBRARY_Lock=true
//endglobals from Lock
//globals from Material:
constant boolean LIBRARY_Material=true
string MC_BULLET= "mc_bullet"
string MC_UNIT= "mc_unit"
string MC_ARROW= "mc_arrow"
string MC_EFFECT= "mc_effect"
string MC_BUILDING= "mc_building"
string MC_STONE= "mc_stone"
string MC_MINE= "mc_mine"
string MC_WALL= "mc_wall"
string MC_RING= "mc_ring"
string GROUND_SMOOTH= "GROUND_SMOOTH"
string GROUND_DESTROY= "ground_destroy"
string GROUND_BOUNCE= "ground_bounce"
string GROUND_STICK= "ground_stick"
//endglobals from Material
//globals from MissleFactory:
constant boolean LIBRARY_MissleFactory=true
//endglobals from MissleFactory
//globals from MonsterDead:
constant boolean LIBRARY_MonsterDead=true
trigger gtrgMonsterDead
//endglobals from MonsterDead
//globals from MonsterTypeData:
constant boolean LIBRARY_MonsterTypeData=true
//endglobals from MonsterTypeData
//globals from Movie:
constant boolean LIBRARY_Movie=true
//endglobals from Movie
//globals from OrderId:
constant boolean LIBRARY_OrderId=true
integer OI_RIGHT_CLICK_MOVE= 851971
integer OI_MOVE= 851983
integer OI_STOP= 851972
//endglobals from OrderId
//globals from RegisterSpell:
constant boolean LIBRARY_RegisterSpell=true
integer kRegistedSpell
//endglobals from RegisterSpell
//globals from ShootBack:
constant boolean LIBRARY_ShootBack=true
trigger shoot_back_trg
//endglobals from ShootBack
//globals from ShootSpeed:
constant boolean LIBRARY_ShootSpeed=true
//endglobals from ShootSpeed
//globals from SkillLearn:
constant boolean LIBRARY_SkillLearn=true
//endglobals from SkillLearn
//globals from T32:
constant boolean LIBRARY_T32=true
constant real T32_PERIOD=0.03125
constant integer T32_FPS=R2I(1 / T32_PERIOD)
integer Tick=0

//==============================================================================
trigger T32__Trig=CreateTrigger()
//endglobals from T32
//globals from Table:
constant boolean LIBRARY_Table=true
hashtable Table___ht= InitHashtable()
integer Table___grow= 2
integer Table___keys= 0
integer array Table___list
integer Table___lpos= 0
//endglobals from Table
//globals from TechData:
constant boolean LIBRARY_TechData=true
hashtable tdht= null
integer tdht_cat= 1
integer tdht_name= 2
integer tdht_tech_need= 3
integer tdht_game_lv_need= 4
integer tdht_base_point= 5
constant integer tKMANA= 'A004'
constant integer tSTRONG= 'A010'
constant integer tANTRAD= 'A01J'
constant integer tDOGE= 'A00U'
constant integer tFIRE_CHARGE= 'A00V'
constant integer tSPEED_SHOOT= 'A00R'
constant integer tAIM_SHOOT= 'A00Q'
constant integer tFIRE= 'A00V'
constant integer tFREZZ= 'A00W'
constant integer tSAVE= 'A011'
constant integer tMANA_BOOM= 'A013'
constant integer TT_GENERAL= 0
constant integer TT_BLADE= 1
constant integer TT_MAGIC_HUNTER= 2
constant integer TT_ICE= 3
constant integer TT_COUNT= 4
// processed:     string array TECH_TREE_NAME[TT_COUNT]
// processed:     integer array TECH_TREE_COUNT[TT_COUNT]
// processed:     TechTree array TECH_TREES[TT_COUNT]
integer TECH_COUNT= 0
//endglobals from TechData
//globals from Text:
constant boolean LIBRARY_Text=true
//endglobals from Text
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
constant integer TimerUtils__MAX_HANDLE_ID_COUNT= 408000
        // values lower than 8191: very fast, but very unsafe.
        // values bigger than 8191: not that fast, the bigger the number is the slower the function gets
        // Most maps don't really need a value bigger than 50000 here, but if you are unsure, leave it
        // as the rather inflated value of 408000
// processed:         integer array TimerUtils__data[TimerUtils__MAX_HANDLE_ID_COUNT]
constant integer TimerUtils__MIN_HANDLE_ID=0x100000
        //use a totally random number here, the more improbable someone uses it, the better.
constant integer TimerUtils__HELD=0x28829022
timer array TimerUtils__tT
integer TimerUtils__tN= 0
//endglobals from TimerUtils
//globals from Union:
constant boolean LIBRARY_Union=true
filterfunc Union__FilterLeisure
//endglobals from Union
//globals from UnitId:
constant boolean LIBRARY_UnitId=true
integer HERO= 'H002'
integer ABI_LOCK= 'h005'
integer ONE_WALL= 'h006'
integer ONE_WALL_BREAKABLE= 'h007'
//endglobals from UnitId
//globals from Vector:
constant boolean LIBRARY_Vector=true
//endglobals from Vector
//globals from YDWEBase:
constant boolean LIBRARY_YDWEBase=true
//全局哈希表 
hashtable YDHT= null
string bj_AllString=".................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................"
//鍏ㄥ眬绯荤粺鍙橀噺
unit bj_lastAbilityCastingUnit=null
unit bj_lastAbilityTargetUnit=null
unit bj_lastPoolAbstractedUnit=null
unitpool bj_lastCreatedUnitPool=null
item bj_lastPoolAbstractedItem=null
itempool bj_lastCreatedItemPool=null
attacktype bj_lastSetAttackType= ATTACK_TYPE_NORMAL
damagetype bj_lastSetDamageType= DAMAGE_TYPE_NORMAL
weapontype bj_lastSetWeaponType= WEAPON_TYPE_WHOKNOWS
real yd_MapMaxX= 0
real yd_MapMinX= 0
real yd_MapMaxY= 0
real yd_MapMinY= 0
string array YDWEBase__yd_PlayerColor
trigger array YDWEBase__AbilityCastingOverEventQueue
integer array YDWEBase__AbilityCastingOverEventType
integer YDWEBase__AbilityCastingOverEventNumber= 0
//endglobals from YDWEBase
//globals from YDWEPolledWaitNull:
constant boolean LIBRARY_YDWEPolledWaitNull=true
//endglobals from YDWEPolledWaitNull
//globals from YDWETriggerEvent:
constant boolean LIBRARY_YDWETriggerEvent=true
trigger yd_DamageEventTrigger= null
trigger array YDWETriggerEvent__DamageEventQueue
integer YDWETriggerEvent__DamageEventNumber= 0
	
item bj_lastMovedItemInItemSlot= null
	
trigger YDWETriggerEvent__MoveItemEventTrigger= null
trigger array YDWETriggerEvent__MoveItemEventQueue
integer YDWETriggerEvent__MoveItemEventNumber= 0
//endglobals from YDWETriggerEvent
//globals from YDWETriggerRegisterEnterRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterEnterRectSimpleNull=true
//endglobals from YDWETriggerRegisterEnterRectSimpleNull
//globals from YDWETriggerRegisterLeaveRectSimpleNull:
constant boolean LIBRARY_YDWETriggerRegisterLeaveRectSimpleNull=true
region yd_NullTempRegion
//endglobals from YDWETriggerRegisterLeaveRectSimpleNull
//globals from AIStrategy:
constant boolean LIBRARY_AIStrategy=true
integer gDefaultAIGroup
//endglobals from AIStrategy
//globals from AutoIndex:
constant boolean LIBRARY_AutoIndex=true
//endglobals from AutoIndex
//globals from Constants:
constant boolean LIBRARY_Constants=true
//endglobals from Constants
//globals from Damage:
constant boolean LIBRARY_Damage=true
constant integer Damage__LIFE_BONUS_ABIL='A000'
integer Damage__OnDamageEvent
boolean Damage__EventEnabled=true
integer Damage__TypeStackLevel=0
damagetype array Damage__TypeStackValue
real array Damage__ToBlock
integer Damage__BlockNum=0
unit array Damage__BlockUnit
real array Damage__BlockUnitLife
real array Damage__BlockRedamage
unit array Damage__BlockDamageSource
        
timer Damage__BlockTimer=CreateTimer()
unit array Damage__RemoveBoosted
integer Damage__RemoveBoostedMax=0
        
timer Damage__RemoveBoostedTimer=CreateTimer()
real Damage__BoostedLifeTemp
unit Damage__BoostedLifeUnit
unit Damage__ForUnit
real Damage__NextHealth
//endglobals from Damage
//globals from Direction:
constant boolean LIBRARY_Direction=true
//endglobals from Direction
//globals from DispatchTechLevel:
constant boolean LIBRARY_DispatchTechLevel=true
//endglobals from DispatchTechLevel
//globals from DoublePacket:
constant boolean LIBRARY_DoublePacket=true
integer gpacauid='h001'
integer gpacspl='A001'
integer kpacau
integer kRegedPac
//endglobals from DoublePacket
//globals from EquipmentData:
constant boolean LIBRARY_EquipmentData=true
//endglobals from EquipmentData
//globals from GroupUtils:
constant boolean LIBRARY_GroupUtils=true
        //* Group for use with all instant enumerations
group ENUM_GROUP= CreateGroup()
        //* Temporary references for GroupRefresh
boolean GroupUtils__Flag= false
group GroupUtils__Refr= null
        //* Assorted constants
constant integer GroupUtils__MAX_HANDLE_COUNT= 408000
constant integer GroupUtils__MIN_HANDLE_ID= 0x100000
        //* Arrays and counter for the group stack
group array GroupUtils__Groups
// processed:         integer array GroupUtils__Status[GroupUtils__MAX_HANDLE_COUNT]
integer GroupUtils__Count= 0
//endglobals from GroupUtils
//globals from Gun:
constant boolean LIBRARY_Gun=true
//endglobals from Gun
//globals from Heal:
constant boolean LIBRARY_Heal=true
integer HEAL_TYPE_NORMAL
boolean Heal___IsEventEnabled= true
integer Heal___HealEvent
unit array Heal___HealerStack
unit array Heal___TargetStack
real array Heal___HealAmountStack
real array Heal___HealBlockStack
integer array Heal___TypeStack
integer Heal___StackLevel= 0
//endglobals from Heal
//globals from ItemData:
constant boolean LIBRARY_ItemData=true
hashtable idht= null
hashtable ifht1= null
hashtable ifht2= null
hashtable ifht3= null
hashtable ifht4= null
hashtable ifht5= null
integer idht_name= 1
integer idht_spell= 2
integer idht_item_type= 3
integer idht_s1= 4
integer idht_s2= 5
integer idht_s3= 6
integer ifht_name= 1
integer ifht_origin= 2
integer ifht_step= 3
integer ifht_lv= 4
integer ifht_max_lv= 5
integer ifht_gold= 6
integer ifht_wood= 7
//endglobals from ItemData
//globals from Job:
constant boolean LIBRARY_Job=true
//endglobals from Job
//globals from JumpFacingStore:
constant boolean LIBRARY_JumpFacingStore=true
trigger jumpPointFacing_t
//endglobals from JumpFacingStore
//globals from MonsterBonus:
constant boolean LIBRARY_MonsterBonus=true
//endglobals from MonsterBonus
//globals from Move:
constant boolean LIBRARY_Move=true
rect area
real lx
real ry
real ly
real rx
real lz
real rz
//endglobals from Move
//globals from PUI:
constant boolean LIBRARY_PUI=true
//endglobals from PUI
//globals from Save:
constant boolean LIBRARY_Save=true
trigger beforesave_t
trigger dosave_t
//endglobals from Save
//globals from SpellStruct:
constant boolean LIBRARY_SpellStruct=true
constant real SpellStruct__MAX_UNIT_COLLISION_SIZE=256.0
group SpellStruct__GROUP=CreateGroup()
hashtable SpellStruct__STORE=InitHashtable()
// abilid, methodkey
// abilid, unit
// timer, key
// trigger, key
// spellstruct, method (timer)
// spellstruct, method (trigger)
constant integer SpellStruct__ALLOCATOR=11
integer SpellStruct__ThisCastData
integer SpellStruct__CastingAbility
constant integer SpellStruct__TIMER_DATA=13
constant integer SpellStruct__TRIGGER_DATA=15
//endglobals from SpellStruct
//globals from Status:
constant boolean LIBRARY_Status=true
constant real Status___PERIOD=0.1
constant player Status___DUMMY_CASTER_OWNER=Player(PLAYER_NEUTRAL_PASSIVE)
constant boolean Status___PERMENANTLY_REVEAL=true

        // To change these, change them also in the externalblock before executing it.
constant integer Status___ABIL_STUN='A500'
constant integer Status___ABIL_SILENCE='A501'
constant integer Status___ABIL_DISARM_BOTH='A502'
constant integer Status___ABIL_DISARM_MELEE='A503'
constant integer Status___ABIL_DISARM_RANGE='A504'
constant integer Status___ABIL_IMMOBOLISE='A505'
constant integer Status___ABIL_INVISIBLE='A507'
constant integer Status___ABIL_GHOST='A508'
constant integer Status___ABIL_DOOM='A509'
constant integer Status___ABIL_IMMUNITY='A50B'
constant integer Status___ABIL_HEX='A50C'
constant integer Status___ABIL_UNLOCUST='A50D'
constant integer Status___ABIL_NEVER_MISS='A50F'
constant integer Status___ABIL_ALWAYS_MISS='A50H'
constant integer Status___ABIL_UNTOUCHABLE='A50J'
constant integer Status___ABIL_BANISH='A50K'
constant integer Status___ABIL_PHASE='A50L'
        //private constant integer ABIL_DOUBLE_ATTACK='A50O'
constant integer Status___ABIL_RESISTANT_SKIN='A50Q'
constant integer Status___ABIL_REFLECT_PIERCING='A50S'
constant integer Status___ABIL_DISABLE='A50T'
        
constant integer Status___ABIL_ARMOR='A5A@'
constant integer Status___ABIL_DAMAGE='A5B@'
constant integer Status___ABIL_STR='A5C@'
constant integer Status___ABIL_AGI='A5D@'
constant integer Status___ABIL_INT='A5E@'
constant integer Status___ABIL_ATTACK_SPEED='A5F@'
constant integer Status___ABIL_HEALTH='A5G@'
constant integer Status___ABIL_MANA='A5H@'
        
constant integer Status___LEVELS_ARMOR=10
constant integer Status___LEVELS_DAMAGE=15
constant integer Status___LEVELS_STR=10
constant integer Status___LEVELS_AGI=10
constant integer Status___LEVELS_INT=10
constant integer Status___LEVELS_ATTACK_SPEED=9
constant integer Status___LEVELS_HEALTH=20
constant integer Status___LEVELS_MANA=20
        
        // To change these, change them also in the externalblock before executing it.
constant integer Status___BUFF_STUN='B500'
constant integer Status___BUFF_SILENCE='B501'
constant integer Status___BUFF_DOOM='B509'
constant integer Status___BUFF_DISARM_MELEE='B503'
constant integer Status___BUFF_DISARM_RANGE='B504'
constant integer Status___BUFF_DISARM_BOTH='B502'
constant integer Status___BUFF_IMMOBOLISE_GROUND='B505'
constant integer Status___BUFF_IMMOBOLISE_AIR='B506'
constant integer Status___BUFF_HEX='B50C'
constant integer Status___BUFF_BANISH='B50K'
constant integer Status___BUFF_PHASE='B50L'
constant integer Status___BUFF_DISABLE='B50T'
        
constant integer Status___OID_STOP=851972
constant integer Status___OID_STUN=852231
constant integer Status___OID_SILENCE=852668
constant integer Status___OID_DISARM=852585
constant integer Status___OID_IMMOBOLISE=852106
constant integer Status___OID_DOOM=852583
constant integer Status___OID_HEX=852502
constant integer Status___OID_UNLOCUST=852155
constant integer Status___OID_BANISH=852486
constant integer Status___OID_PHASE=852129
constant integer Status___OID_DISABLE=852252

unit Status___CASTER_DISARM_BOTH=null
unit Status___CASTER_DISARM_MELEE=null
unit Status___CASTER_DISARM_RANGE=null
//endglobals from Status
//globals from VectorLib:
constant boolean LIBRARY_VectorLib=true
//endglobals from VectorLib
//globals from CameraLock:
constant boolean LIBRARY_CameraLock=true
timer cltimer
//endglobals from CameraLock
//globals from FakeMan:
constant boolean LIBRARY_FakeMan=true
string LV_FREEZ= "LV_FREEZ"
string LV_ACTIVE= "LV_ACTIVE"
string LV_DESTORY= "LV_DESTORY"
real LV_FREEZ_DISTANCE= 300000000000000
//endglobals from FakeMan
//globals from FogControl:
constant boolean LIBRARY_FogControl=true
timer fctimer
fogmodifier array fogms
//endglobals from FogControl
//globals from ItemEquip:
constant boolean LIBRARY_ItemEquip=true
integer kit
trigger t
trigger t2
//endglobals from ItemEquip
//globals from ShootTarget:
constant boolean LIBRARY_ShootTarget=true
trigger gtrgShootTarget
real lastshoot= 0
//endglobals from ShootTarget
//globals from StartRoom:
constant boolean LIBRARY_StartRoom=true
boolean gateOpened= false
//endglobals from StartRoom
//globals from Strong:
constant boolean LIBRARY_Strong=true
trigger doStrong_t
//endglobals from Strong
//globals from Stun:
constant boolean LIBRARY_Stun=true
//endglobals from Stun
//globals from TargetFilter:
constant boolean LIBRARY_TargetFilter=true
//endglobals from TargetFilter
//globals from AIData:
constant boolean LIBRARY_AIData=true
//endglobals from AIData
//globals from AIGroup:
constant boolean LIBRARY_AIGroup=true
//endglobals from AIGroup
//globals from CustomDamage:
constant boolean LIBRARY_CustomDamage=true
//endglobals from CustomDamage
//globals from DialogSystem:
constant boolean LIBRARY_DialogSystem=true
//endglobals from DialogSystem
//globals from HorrorOrder:
constant boolean LIBRARY_HorrorOrder=true
//endglobals from HorrorOrder
//globals from Buffer:
constant boolean LIBRARY_Buffer=true
timer moveTimer
//endglobals from Buffer
//globals from ChooseBonus:
constant boolean LIBRARY_ChooseBonus=true
trigger choosebonus_t
trigger usebonus_t
//endglobals from ChooseBonus
//globals from ChooseTech:
constant boolean LIBRARY_ChooseTech=true
trigger choosetech_t
trigger usetech_t
//endglobals from ChooseTech
//globals from MonsterTargetGroup:
constant boolean LIBRARY_MonsterTargetGroup=true
group MonsterTargetGroup
integer mtm
group MeleeGroup
//endglobals from MonsterTargetGroup
//globals from Radiation:
constant boolean LIBRARY_Radiation=true
trigger doRadiation_t
//endglobals from Radiation
//globals from Transform:
constant boolean LIBRARY_Transform=true
trigger transform_t
//endglobals from Transform
//globals from PhysicsSystem:
constant boolean LIBRARY_PhysicsSystem=true
//endglobals from PhysicsSystem
//globals from Missle:
constant boolean LIBRARY_Missle=true
//endglobals from Missle
//globals from Shooter:
constant boolean LIBRARY_Shooter=true
//endglobals from Shooter
//globals from Velocity:
constant boolean LIBRARY_Velocity=true
real u= 1.5
real us= 3
real g= 9.8
group COLLISION_GROUP
timer missleMoveTimer
timer collisionGroupTimer
//endglobals from Velocity
    // User-defined
real udg_r= 0
    // Generated
rect gg_rct_lock_1= null
rect gg_rct_lock_2= null
rect gg_rct_lock_3= null
rect gg_rct_lock_11= null
rect gg_rct_start= null
rect gg_rct_start_road_1= null
rect gg_rct_start_road_2= null
rect gg_rct_start_road_gate= null
rect gg_rct_gave_guns= null
trigger gg_trg_StartRoom= null
trigger gg_trg_level1= null
trigger gg_trg_InitJobData= null
trigger gg_trg_Save= null
trigger gg_trg_Strong= null
trigger gg_trg_ItemJump= null
trigger gg_trg_GunSpell= null
trigger gg_trg_Jump= null
trigger gg_trg_JumpFacingStore= null
trigger gg_trg_InjectionSpeedUp= null
trigger gg_trg_RegisterSpell= null
trigger gg_trg_Darts= null
trigger gg_trg_RetrunDarts= null
trigger gg_trg_SmartDarts= null
trigger gg_trg_ShoulderCannon= null
trigger gg_trg_ItemRetrunDarts= null
trigger gg_trg_LeaveDarts= null
trigger gg_trg_BackGrenade= null
trigger gg_trg_Mine= null
trigger gg_trg_PushGrenade= null
trigger gg_trg_Blink= null
trigger gg_trg_Transport= null
trigger gg_trg_ElectricWhip= null
trigger gg_trg_AutoAim= null
trigger gg_trg_ShootBack= null
trigger gg_trg_TeckLock= null
trigger gg_trg_Register= null
trigger gg_trg_RegisterFly= null
trigger gg_trg_FogControl= null
trigger gg_trg_CameraLock= null
trigger gg_trg_Movie= null
trigger gg_trg_GV= null
trigger gg_trg_LearnAbility= null
trigger gg_trg_TriggerKillHpBuff= null
trigger gg_trg_TriggerHorro= null
trigger gg_trg_HorrorOrderFilter= null
trigger gg_trg_HorrorOrder= null
trigger gg_trg_OrderId= null
trigger gg_trg_ShootSpeed= null
trigger gg_trg_Radiation= null
trigger gg_trg_ArrayList= null
trigger gg_trg_ChooseTech= null
trigger gg_trg_ChooseBonus= null
trigger gg_trg_TechLevelUp= null
trigger gg_trg_TechData= null
trigger gg_trg_Transform= null
trigger gg_trg_ChangeAbility= null
trigger gg_trg_DialogSystem= null
trigger gg_trg_Buffer= null
trigger gg_trg_BurnBuffer= null
trigger gg_trg_HorroBuffer= null
trigger gg_trg_BleedBuffer= null
trigger gg_trg_IceSlowBuffer= null
trigger gg_trg_AutoAimBuffer= null
trigger gg_trg_Debuff= null
trigger gg_trg_BufferFunction= null
trigger gg_trg_Constants= null
trigger gg_trg_PlayerHero= null
trigger gg_trg_FocuseHero= null
trigger gg_trg_ItemData= null
trigger gg_trg_ItemEquip= null
trigger gg_trg_ItemType= null
trigger gg_trg_UnitId= null
trigger gg_trg_FakeMan= null
trigger gg_trg_MonsterDead= null
trigger gg_trg_ShootTarget= null
trigger gg_trg_MonsterTypeData= null
trigger gg_trg_MonsterBonus= null
trigger gg_trg_MonsterTargetGroup= null
trigger gg_trg_DeathEffect= null
trigger gg_trg_Difficulty= null
trigger gg_trg_EffectString= null
trigger gg_trg_SkillLearn= null
trigger gg_trg_DoublePacket= null
trigger gg_trg_Missle= null
trigger gg_trg_MissleFactory= null
trigger gg_trg_Gun= null
trigger gg_trg_Shooter= null
trigger gg_trg_HeroData= null
trigger gg_trg_EquipmentData= null
trigger gg_trg_EMData= null
trigger gg_trg_EvilMarinData= null
trigger gg_trg_HeroStatus= null
trigger gg_trg_Velocity= null
trigger gg_trg_Material= null
trigger gg_trg_PhysicsSystem= null
trigger gg_trg_bordercontrol= null
trigger gg_trg_TargetFilter= null
trigger gg_trg_ItemInfo= null
trigger gg_trg_BOSS1= null
trigger gg_trg_AIStrategy= null
trigger gg_trg_AIGroup= null
trigger gg_trg_AIData= null
trigger gg_trg_AIDriver= null
trigger gg_trg_AIHurted= null
trigger gg_trg_DummyCaster= null
trigger gg_trg_Status= null
trigger gg_trg_Heal= null
trigger gg_trg_ABC= null
trigger gg_trg_AII= null
trigger gg_trg_Table= null
trigger gg_trg_Height= null
trigger gg_trg_AddEffectZ= null
trigger gg_trg_Move= null
trigger gg_trg_Vector= null
trigger gg_trg_FloatText= null
trigger gg_trg_Text= null
trigger gg_trg_Direction= null
trigger gg_trg_SpellStruck= null
trigger gg_trg_Timer_Utils= null
trigger gg_trg_HashKeyManager= null
trigger gg_trg_T32= null
trigger gg_trg_HashTable= null
trigger gg_trg_Distance= null
trigger gg_trg_AIDS= null
trigger gg_trg_AIDSCleaner= null
trigger gg_trg_Event= null
trigger gg_trg_Damage= null
trigger gg_trg_CustomDamage= null
trigger gg_trg_Custom_Congregation= null
trigger gg_trg_List_Module= null
trigger gg_trg_Group_Utils= null
trigger gg_trg_CreateItem= null
trigger gg_trg_Demo_Usage= null
trigger gg_trg_eventtest= null
trigger gg_trg_AIListRunner= null
trigger gg_trg_AIList= null
trigger gg_trg_ListTEst= null
trigger gg_trg_EnemyBugSystem2= null
trigger gg_trg_12________2________3= null
trigger gg_trg_AIApproach= null
trigger gg_trg____________________002= null
trigger gg_trg_TestGun= null
trigger gg_trg____________________003= null
trigger gg_trg_camera= null
trigger gg_trg_inittest= null
trigger gg_trg____________________001_______u= null
trigger gg_trg_Zero_Damage_All= null
unit gg_unit_h006_0185= null
unit gg_unit_h006_0048= null
unit gg_unit_h006_0065= null
unit gg_unit_h006_0049= null
unit gg_unit_h006_0186= null
unit gg_unit_h006_0184= null
unit gg_unit_h006_0188= null
unit gg_unit_h006_0187= null
trigger gg_trg_AIAttack= null
trigger gg_trg_12________2________3_______u= null
trigger gg_trg_12________2________3________2= null
region g_cur_region
integer cur_player= 0
integer act1= 0
integer act2= 1
integer act3= 2
boolean g_camera_lock= false
boolean g_fog= false
real g_sd_th= 70
real g_missle_damage= 50
unit boss1= null
constant integer ARRAY_SIZE= 1000
constant real pi= Deg2Rad(180.0)
    
constant integer iEXP= 'I00E'
    
constant integer PLAYER_COUNT= 3
constant integer iUPGADE= 'I004'
constant integer iFREEUP= 'I00D'
constant integer iSPEED= 'I003'
constant integer iJUMP= 'I002'
constant integer iRETURN= 'I006'
constant integer iREACT= 'I007'
constant integer iELECTRIC= 'I008'
constant integer iBLINK= 'I009'
constant integer iTRANSPORT= 'I00A'
constant integer iAUTOAIM= 'I00B'
constant integer i100G= 'I00C'
constant integer iLEAVE= 'I00F'
constant integer iBKGRENADE= 'I00G'
constant integer iPSGRENADE= 'I00M'
constant integer iMINE= 'I00J'
constant integer bICE_MISSLE= 'e005'
constant integer bFIRE_MISSLE= 'e006'
constant integer bELECTRIC= 'e008'
constant integer aRETURN= 'A002'
constant integer aREACT= 'A00F'
constant integer aELECTRIC= 'A00G'
constant integer aBLINK= 'A00I'
constant integer aTRANSPORT= 'A00J'
constant integer aAUTOAIM= 'A00K'
constant integer aLEAVE= 'A016'
constant integer aBKGRENADE= 'A017'
constant integer aPSGRENADE= 'A019'
constant integer aMINE= 'A01B'
constant integer aBAN_ATTACK= 'A01M'
constant integer euCOLLISION= 'e004'
    //constant integer BULLET_MAX_SPEED = 180
constant integer BULLET_RANGE_ADDON= 10
constant integer LEAVE_COUNT= 10
constant integer REDAMAGE_DISTANCE= 200
constant integer WHO_PLAYER_ID= 7
constant player WHO_PLAYER= Player(7)
constant real DAMAGE_SPEED= 5
constant integer MAGIC= 'u001'
constant integer MAX_BURN_LV= 5000
constant integer MAX_BLEED_LV= 5000
constant integer TECH_UNIT= 'H004'
constant integer sALL= 'A00M'
constant integer sSTR= 'A00N'
constant integer sAGI= 'A00O'
constant integer sINT= 'A00P'
constant integer SHOOT_SPEED= 'A015'
constant real GRENADEDEG= Atan2(2, 1)
constant integer DEFAULT_ARRAYLIST_SIZE= 64
constant player MONSTER_PLAYER= Player(11)
constant integer MONSTER_PLAYER_ID= 11
constant integer EVIL_MARIN= 'h000'
rect array gg_rct_lock
constant integer SHOTHZ= 100
constant string MAJOR_AB= "涓绘鍣?
constant string MINOR_AB= "鍓鍣?
unit array heros
unit array techs
integer SHOOT_GUN=5
integer SNAKE_GUN=1
integer MACHINE_GUN=2
integer ASSASSINATE_GUN=3
integer ROCKET_GUN=4
integer GUN=4
integer HAND=1
integer ARMOR=2
integer SHOE=3
integer OTHER=5
integer LONGTERM=7
integer STATIC=6
integer I_D= 8
integer I_T= 9
integer I_N= 10
integer AB1= 11
integer AB2= 12
constant string SMALL_BLOOD="Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl"
constant string HEAL_EFFECT= "Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
constant string BLADE_BLOOD= "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
constant string E_BLINK_CASTER= "Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl"
constant string E_BLINK_TARGET= "Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl"
constant string E_TRANSPORT_TARGET= "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"
constant string E_TRANSPORT_CASTER= "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl"
constant string E_KILL_MANA= "Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
constant string E_ELF_BLOOD= "Objects\\Spawnmodels\\Human\\HumanBlood\\HeroBloodElfBlood.mdl"
constant string E_DOGE= "Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"
constant string E_TUNDER_CLAP= "Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
constant string E_CLAP= "Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
constant string E_MINE_EXPLODE= "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
constant string E_MANA_BOOM= "Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
constant string E_GUN_SHOW= "Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"

trigger l__library_init

//JASSHelper struct globals:
constant integer si__AIDS_DEFAULT=1
constant integer si__AII___ItemStruct=2
integer si__AII___ItemStruct_F=0
integer si__AII___ItemStruct_I=0
integer array si__AII___ItemStruct_V
trigger s__AII___ItemStruct_trig=CreateTrigger()
integer s__AII___ItemStruct_thrashCount=0
item array s__AII___ItemStruct_it
integer array s__AII___ItemStruct_hid
integer array s__AII___ItemStruct_lockLevel
integer array s__AII___ItemStruct_prevA
integer array s__AII___ItemStruct_nextA
integer array s__AII___ItemStruct_toFireDeallocate
integer s__AII___ItemStruct_tFDCount=0
constant integer si__AII___Initializer=3
constant integer si__DummyCaster___Initializer=4
constant integer si__EventReg=5
integer array s__EventReg_data
constant integer si__Event__EventStack=6
integer s__Event__EventStack_top=0
integer array s__Event__EventStack_current
constant integer si__Event=7
integer si__Event_F=0
integer si__Event_I=0
integer array si__Event_V
trigger array s__Event_trig
integer array s__Event_next
integer array s__Event_prev
trigger s__Event_currentTrigger
constant integer si__TechRecord=8
integer si__TechRecord_F=0
integer si__TechRecord_I=0
integer array si__TechRecord_V
integer array s__TechRecord_size
integer array s___TechRecord_itms
constant integer s___TechRecord_itms_size=64
integer array s__TechRecord_itms
constant integer si__TechCounter=10
integer si__TechCounter_F=0
integer si__TechCounter_I=0
integer array si__TechCounter_V
integer array s___TechCounter_cnt
constant integer s___TechCounter_cnt_size=4
integer array s__TechCounter_cnt
integer array s__TechCounter_size
constant integer si__IHeroData=12
integer si__IHeroData_F=0
integer si__IHeroData_I=0
integer array si__IHeroData_V
real array s__IHeroData_shoot_energy_max
real array s__IHeroData_shoot_energy_reg
real array s__IHeroData_shoot_energy
unit array s__IHeroData_shoot_target
real array s__IHeroData_shoot_range_buff
real array s__IHeroData_shoot_rist
real array s__IHeroData_a_shoot_back
real array s__IHeroData_a_shoot_back_log
boolean array s__IHeroData_reload
real array s__IHeroData_kill_mana_percent
real array s__IHeroData_mana_boom_percent
integer array s__IHeroData_tech_record
integer array s__IHeroData_tech_counter
integer array s__IHeroData_up_point
integer array s__IHeroData_bonus_point
integer array s__IHeroData_bullets
real array s__IHeroData_shoot_split
real array s__IHeroData_save
real array s__IHeroData_beforesave
real array s__IHeroData_strong
real array s__IHeroData_antrad
real array s__IHeroData_doge
real array s__IHeroData_frezz
real array s__IHeroData_fire_charge
real array s__IHeroData_machine_gun_buff
real array s__IHeroData_jump_direction
unit array s__IHeroData_abi_lock
real array s__IHeroData_vision
integer array s___IHeroData_equips
constant integer s___IHeroData_equips_size=20
integer array s__IHeroData_equips
constant integer si__Material=14
integer s__Material_AIDS_DELEGATE=0
boolean array s__Material_AIDS_instanciated
string array s__Material_clazz
real array s__Material_hardness
real array s__Material_bounce
real array s__Material_volume
real array s__Material_weight
real array s__Material_airk
string array s__Material_fakelv
string array s__Material_ground_action
integer array s__Material_burnlv
integer array s__Material_bleedlv
boolean array s__Material_horro
real array s__Material_horro_dmg
real array s__Material_anti_horro
real array s__Material_kill_hp
integer array s__Material_shot_tick
integer array s__Material_shot_fast_buff
real array s__Material_last_shoot
integer array s__Material_last_issue
constant integer si__IMissleFactory=15
integer si__IMissleFactory_F=0
integer si__IMissleFactory_I=0
integer array si__IMissleFactory_V
integer array si__IMissleFactory_type
trigger array st__IMissleFactory_onDestroy
trigger array st__IMissleFactory_createMissle
constant integer si__SmartDartsFactory=16
unit array s__SmartDartsFactory_t
constant integer si__DefaultMissleFactory=17
constant integer si__ShootGunMissleFactory=18
constant integer si__SmallDartsFactory=19
constant integer si__ReturnDartsFactory=20
constant integer si__LeaveDartsFactory=21
constant integer si__IceMissleFactory=22
constant integer si__FireMissleFactory=23
constant integer si__ElectricWhipFactory=24
constant integer si__BackGrenadeFactory=25
constant integer si__PushGrenadeFactory=26
constant integer si__MineFactory=27
constant integer si__ShoulderCannonFactory=28
constant integer si__SpearMissleFactory=29
constant integer si__IMonsterTypeData=30
integer si__IMonsterTypeData_F=0
integer si__IMonsterTypeData_I=0
integer array si__IMonsterTypeData_V
integer array si__IMonsterTypeData_type
trigger array st__IMonsterTypeData_onDestroy
trigger array st__IMonsterTypeData_getDeadGold
trigger array st__IMonsterTypeData_getDeadWood
trigger array st__IMonsterTypeData_getTypeId
constant integer si__DefaultTypeData=31
boolean s__DefaultTypeData_List___destroyinglist= false
integer s__DefaultTypeData_List___length= 0
integer s__DefaultTypeData_List___first= 0
integer s__DefaultTypeData_List___last= 0
integer array s__DefaultTypeData_List___prev
integer array s__DefaultTypeData_List___next
boolean array s__DefaultTypeData_List___inlist
constant integer si__Table___reals=32
constant integer si__Table___booleans=33
constant integer si__Table___strings=34
constant integer si__Table___players=35
constant integer si__Table___widgets=36
constant integer si__Table___destructables=37
constant integer si__Table___items=38
constant integer si__Table___units=39
constant integer si__Table___abilitys=40
constant integer si__Table___timers=41
constant integer si__Table___triggers=42
constant integer si__Table___triggerconditions=43
constant integer si__Table___triggeractions=44
constant integer si__Table___events=45
constant integer si__Table___forces=46
constant integer si__Table___groups=47
constant integer si__Table___locations=48
constant integer si__Table___rects=49
constant integer si__Table___boolexprs=50
constant integer si__Table___sounds=51
constant integer si__Table___effects=52
constant integer si__Table___unitpools=53
constant integer si__Table___itempools=54
constant integer si__Table___quests=55
constant integer si__Table___questitems=56
constant integer si__Table___defeatconditions=57
constant integer si__Table___timerdialogs=58
constant integer si__Table___leaderboards=59
constant integer si__Table___multiboards=60
constant integer si__Table___multiboarditems=61
constant integer si__Table___trackables=62
constant integer si__Table___dialogs=63
constant integer si__Table___buttons=64
constant integer si__Table___texttags=65
constant integer si__Table___lightnings=66
constant integer si__Table___images=67
constant integer si__Table___ubersplats=68
constant integer si__Table___regions=69
constant integer si__Table___fogstates=70
constant integer si__Table___fogmodifiers=71
constant integer si__Table___agents=72
constant integer si__Table___hashtables=73
constant integer si__Table=74
constant integer si__TableArray=75
constant integer si__TechData=76
integer si__TechData_F=0
integer si__TechData_I=0
integer array si__TechData_V
string array s__TechData_name
integer array s__TechData_cat
constant integer si__TechTree=77
integer si__TechTree_F=0
integer si__TechTree_I=0
integer array si__TechTree_V
integer array s__TechTree_size
integer array s___TechTree_itms
constant integer s___TechTree_itms_size=64
integer array s__TechTree_itms
constant integer si__vector=79
integer si__vector_F=0
integer si__vector_I=0
integer array si__vector_V
real array s__vector_x
real array s__vector_y
real array s__vector_z
location s__vector_loc= Location(0.0, 0.0)
constant integer si__IAIStrategy=80
integer si__IAIStrategy_F=0
integer si__IAIStrategy_I=0
integer array si__IAIStrategy_V
integer array si__IAIStrategy_type
trigger array st__IAIStrategy_onDestroy
trigger array st__IAIStrategy_targetInRange
trigger array st__IAIStrategy_targetOutRange
trigger array st__IAIStrategy_beHurted
trigger array st__IAIStrategy_getInMap
trigger array st__IAIStrategy_support
constant integer si__DefaultAIStrategy=81
boolean s__DefaultAIStrategy_List___destroyinglist= false
integer s__DefaultAIStrategy_List___length= 0
integer s__DefaultAIStrategy_List___first= 0
integer s__DefaultAIStrategy_List___last= 0
integer array s__DefaultAIStrategy_List___prev
integer array s__DefaultAIStrategy_List___next
boolean array s__DefaultAIStrategy_List___inlist
constant integer si__Boss1AIStrategy=82
constant integer si__Damage__Detector=83
integer s__Damage__Detector_AIDS_DELEGATE=0
boolean array s__Damage__Detector_AIDS_instanciated
conditionfunc s__Damage__Detector_ACTIONS_COND
trigger array s__Damage__Detector_t
constant integer si__EquipmentData=84
integer s__EquipmentData_AIDS_DELEGATE=0
boolean array s__EquipmentData_AIDS_instanciated
integer array s__EquipmentData_T32xs___next
integer array s__EquipmentData_T32xs___prev
boolean array s__EquipmentData_T32xs___runningPeriodic
integer array s__EquipmentData_gun
integer array s__EquipmentData_heroData
constant integer si__IGun=85
integer si__IGun_F=0
integer si__IGun_I=0
integer array si__IGun_V
integer array si__IGun_type
trigger array st__IGun_onDestroy
integer array s__IGun_shooter
integer array s__IGun_factory
integer array s__IGun_ifd
trigger array st__IGun_fire
trigger array st__IGun_stopFire
trigger array st__IGun_getGunType
trigger array st__IGun_setOwner
constant integer si__DefaultGun=86
constant integer si__FireShotgun=87
constant integer si__HumanRifle=88
constant integer si__SpearRifle=89
constant integer si__IceMachineGun=90
constant integer si__FireMachineGun=91
constant integer si__HealType=92
integer s__HealType_Counter= 0
constant integer si__ItemFeature=93
integer si__ItemFeature_F=0
integer si__ItemFeature_I=0
integer array si__ItemFeature_V
string array s__ItemFeature_name
real array s__ItemFeature_origin
real array s__ItemFeature_step
integer array s__ItemFeature_lv
integer array s__ItemFeature_maxlv
integer array s__ItemFeature_gold
integer array s__ItemFeature_wood
constant integer si__IndividualItemData=94
integer array s__IndividualItemData_featureData
boolean array s__IndividualItemData_flag
constant integer si__ItemFeatureData=95
integer si__ItemFeatureData_F=0
integer si__ItemFeatureData_I=0
integer array si__ItemFeatureData_V
integer array s__ItemFeatureData_f1
integer array s__ItemFeatureData_f2
integer array s__ItemFeatureData_f3
integer array s__ItemFeatureData_f4
integer array s__ItemFeatureData_f5
integer array s__ItemFeatureData_gun
constant integer si__ItemTypeData=96
integer si__ItemTypeData_F=0
integer si__ItemTypeData_I=0
integer array si__ItemTypeData_V
string array s__ItemTypeData_name
integer array s__ItemTypeData_spell
integer array s__ItemTypeData_s1
integer array s__ItemTypeData_s2
integer array s__ItemTypeData_s3
integer array s__ItemTypeData_itemType
constant integer si__SpellStruct__DefaultsInterface=97
integer si__SpellStruct__DefaultsInterface_F=0
integer si__SpellStruct__DefaultsInterface_I=0
integer array si__SpellStruct__DefaultsInterface_V
integer array si__SpellStruct__DefaultsInterface_type
trigger array st__SpellStruct__DefaultsInterface_onDestroy
trigger array st__SpellStruct__DefaultsInterface_onCreate
trigger array st__SpellStruct__DefaultsInterface_onChannel
trigger array st__SpellStruct__DefaultsInterface_onStartCast
trigger array st__SpellStruct__DefaultsInterface_onEffect
trigger array st__SpellStruct__DefaultsInterface_onFinish
trigger array st__SpellStruct__DefaultsInterface_onStopCast
trigger array st__SpellStruct__DefaultsInterface_cleanup
constant integer si__SpellStruct__ChainAttach=98
integer si__SpellStruct__ChainAttach_F=0
integer si__SpellStruct__ChainAttach_I=0
integer array si__SpellStruct__ChainAttach_V
trigger array s__SpellStruct__ChainAttach_trigger
timer array s__SpellStruct__ChainAttach_timer
integer array s__SpellStruct__ChainAttach_instance
integer array s__SpellStruct__ChainAttach_callback
integer array s__SpellStruct__ChainAttach_next
integer array s__SpellStruct__ChainAttach_prev
constant integer si__SpellStruct__EnumStack=99
integer s__SpellStruct__EnumStack_top=0
integer array s__SpellStruct__EnumStack_instance
real array s__SpellStruct__EnumStack_x
real array s__SpellStruct__EnumStack_y
real array s__SpellStruct__EnumStack_range
integer array s__SpellStruct__EnumStack_callback
group array s__SpellStruct__EnumStack_for
constant integer si__SpellStruct=100
real array s__SpellStruct_aoe
boolean array s__SpellStruct_doAutoDestroy
boolean array s__SpellStruct_hasStoppedCasting
integer array s__SpellStruct_lockLevel
integer s__SpellStruct_attachNode
integer s__SpellStruct_attachHead
integer array s__SpellStruct_timerAttachments
integer array s__SpellStruct_triggerAttachments
integer array s__SpellStruct_abilId
unit array s__SpellStruct_caster
integer array s__SpellStruct_level
integer array s__SpellStruct_order
unit array s__SpellStruct_targetUnit
widget array s__SpellStruct_targetWidget
destructable array s__SpellStruct_targetDest
item array s__SpellStruct_targetItem
location array s__SpellStruct_targetLoc
real array s__SpellStruct_targetX
real array s__SpellStruct_targetY
player array s__SpellStruct_owner
location s__SpellStruct_loc
constant integer si__SpellStruct__Init=101
constant integer si__Status=102
integer s__Status_AIDS_DELEGATE=0
boolean array s__Status_AIDS_instanciated
unit s__Status_dummyCaster=null
unit s__Status_dummyCaster2=null
unit s__Status_dummyCaster3=null
integer array s__Status_twoPow
integer array s__Status_stunLevel
integer array s__Status_disableLevel
integer array s__Status_silenceLevel
integer array s__Status_doomLevel
integer array s__Status_disarmMeleeLevel
integer array s__Status_disarmRangeLevel
integer array s__Status_immoboliseLevel
integer array s__Status_invisibleLevel
integer array s__Status_ghostLevel
integer array s__Status_invulnerableLevel
integer array s__Status_immunityLevel
integer array s__Status_pauseLevel
integer array s__Status_hideLevel
integer array s__Status_unpathLevel
integer array s__Status_hexLevel
integer array s__Status_locustLevel
integer array s__Status_neverMissLevel
integer array s__Status_alwaysMissLevel
integer array s__Status_untouchableLevel
integer array s__Status_banishLevel
integer array s__Status_phaseLevel
integer array s__Status_resistantSkinLevel
integer array s__Status_reflectPiercingLevel
integer array s__Status_armorBonus
integer array s__Status_damageBonus
integer array s__Status_strBonus
integer array s__Status_agiBonus
integer array s__Status_intBonus
integer array s__Status_attackSpeedBonus
integer array s__Status_healthBonus
integer array s__Status_manaBonus
unit s__Status_updateUnit
group s__Status_healthRegenGroup=CreateGroup()
real array s__Status_healthRegenBonus
group s__Status_manaRegenGroup=CreateGroup()
real array s__Status_manaRegenBonus
group s__Status_healthRegenPercentGroup=CreateGroup()
real array s__Status_healthRegenPercentBonus
group s__Status_manaRegenPercentGroup=CreateGroup()
real array s__Status_manaRegenPercentBonus
real array s__Status_moveSpeedBonus
real array s__Status_moveSpeedPercentBonus
real array s__Status_x
real array s__Status_y
real s__Status_updateUnitX
real s__Status_updateUnitY
real s__Status_xInc
real s__Status_yInc
real s__Status_updateDist
integer array s__Status_T32xs___next
integer array s__Status_T32xs___prev
boolean array s__Status_T32xs___runningPeriodic
constant integer si__RealMan=103
integer si__RealMan_F=0
integer si__RealMan_I=0
integer array si__RealMan_V
unit array s__RealMan_man
boolean s__RealMan_List___destroyinglist= false
integer s__RealMan_List___length= 0
integer s__RealMan_List___first= 0
integer s__RealMan_List___last= 0
integer array s__RealMan_List___prev
integer array s__RealMan_List___next
boolean array s__RealMan_List___inlist
constant integer si__AIData=104
integer s__AIData_AIDS_DELEGATE=0
boolean array s__AIData_AIDS_instanciated
integer array s__AIData_currentAIGroup
integer array s__AIData_strategy
integer array s__AIData_last_change
unit array s__AIData_targetUnit
constant integer si__IAIGroup=105
integer si__IAIGroup_F=0
integer si__IAIGroup_I=0
integer array si__IAIGroup_V
integer array si__IAIGroup_type
trigger array st__IAIGroup_onDestroy
group array s__IAIGroup_g
group array s__IAIGroup_tg
trigger array st__IAIGroup_getInterval
trigger array st__IAIGroup_shouldLoop
trigger array st__IAIGroup_afterLoop
trigger array st__IAIGroup_ailoop
trigger array st__IAIGroup_addUnit
trigger array st__IAIGroup_removeUnit
constant integer si__DefaultAIGroup=106
integer array s__DefaultAIGroup_T32x___next
integer array s__DefaultAIGroup_T32x___prev
constant integer si__IDialog=107
integer si__IDialog_F=0
integer si__IDialog_I=0
integer array si__IDialog_V
integer array si__IDialog_type
trigger array st__IDialog_onDestroy
dialog array s__IDialog_d
trigger array s__IDialog_dtr
player array s__IDialog_p
string array s__IDialog_name
button array s__IDialog_cancel_button
button array s___IDialog_choses
constant integer s___IDialog_choses_size=20
integer array s__IDialog_choses
integer array s__IDialog_choses_size
trigger array st__IDialog_init
trigger array st__IDialog_display
trigger array st__IDialog_button_clicked
constant integer si__DefaultDialog=109
constant integer si__ChangeAbDialog=110
integer array s__ChangeAbDialog_oi
integer array s__ChangeAbDialog_ni
integer array s__ChangeAbDialog_t
constant integer si__ChangeGunDialog=111
integer array s__ChangeGunDialog_oi
integer array s__ChangeGunDialog_ni
integer array s__ChangeGunDialog_t
item array s__ChangeGunDialog_itm
constant integer si__TransformDialog=112
integer array s__TransformDialog_fd
constant integer si__FreeTransformDialog=113
constant integer si__ButtonTech=114
integer si__ButtonTech_F=0
integer si__ButtonTech_I=0
integer array si__ButtonTech_V
integer array s__ButtonTech_id
constant integer si__ChooseTechDialog=115
constant integer si__ChooseBonusDialog=116
constant integer si__IBufferStruct=117
integer si__IBufferStruct_F=0
integer si__IBufferStruct_I=0
integer array si__IBufferStruct_V
integer array si__IBufferStruct_type
trigger array st__IBufferStruct_onDestroy
unit array s__IBufferStruct_u
integer array s__IBufferStruct_count
boolean array s__IBufferStruct_flag
trigger array st__IBufferStruct_condition
trigger array st__IBufferStruct_addBuffer
trigger array st__IBufferStruct_removeBuffer
trigger array st__IBufferStruct_finish
trigger array st__IBufferStruct_init
trigger array st__IBufferStruct_action
constant integer si__DefaultBufferStruct=118
boolean s__DefaultBufferStruct_List___destroyinglist= false
integer s__DefaultBufferStruct_List___length= 0
integer s__DefaultBufferStruct_List___first= 0
integer s__DefaultBufferStruct_List___last= 0
integer array s__DefaultBufferStruct_List___prev
integer array s__DefaultBufferStruct_List___next
boolean array s__DefaultBufferStruct_List___inlist
constant integer si__BoundUnitEffectStruct=119
unit array s__BoundUnitEffectStruct_eu
integer array s__BoundUnitEffectStruct_uid
real array s__BoundUnitEffectStruct_bais
string array s__BoundUnitEffectStruct_animate
real array s__BoundUnitEffectStruct_z
constant integer si__ElectricWhipBufferStruct=120
unit array s__ElectricWhipBufferStruct_source
real array s__ElectricWhipBufferStruct_dam
integer array s__ElectricWhipBufferStruct_pref
lightning array s__ElectricWhipBufferStruct_l
constant integer si__MonsterTargetGroupManager=121
integer si__MonsterTargetGroupManager_F=0
integer si__MonsterTargetGroupManager_I=0
integer array si__MonsterTargetGroupManager_V
integer array s__MonsterTargetGroupManager_T32x___next
integer array s__MonsterTargetGroupManager_T32x___prev
constant integer si__PushForceStruct=122
integer array s__PushForceStruct_fc
constant integer si__IMissle=123
integer si__IMissle_F=0
integer si__IMissle_I=0
integer array si__IMissle_V
integer array si__IMissle_type
trigger array st__IMissle_onDestroy
unit array s__IMissle_missle
unit array s__IMissle_owner
integer array s__IMissle_life
integer array s__IMissle_origin_life
group array s__IMissle_damaged
boolean array s__IMissle_started
trigger array st__IMissle_doDamage
trigger array st__IMissle_getFinalDamage
trigger array st__IMissle_fireMissle
trigger array st__IMissle_onFire
trigger array st__IMissle_getOriginalDamage
trigger array st__IMissle_getMissleId
trigger array st__IMissle_step
trigger array st__IMissle_getLife
trigger array st__IMissle_substep
trigger array st__IMissle_explode
trigger array st__IMissle_damageEnemy
trigger array st__IMissle_debuffEnemy
trigger array st__IMissle_healAlly
trigger array st__IMissle_hitSelf
trigger array st__IMissle_refreshDamagedGroup
trigger array st__IMissle_troughDamage
constant integer si__Missle=124
constant integer si__TroughMissle=125
constant integer si__ShootGunMissle=126
constant integer si__IceMissle=127
constant integer si__FireMissle=128
constant integer si__SmallDarts=129
constant integer si__ElectricWhip=130
lightning array s__ElectricWhip_l
constant integer si__ReturnDarts=131
integer array s__ReturnDarts_pref
constant integer si__LeaveDarts=132
integer array s__LeaveDarts_pref
constant integer si__BackGrenade=133
constant integer si__PushGrenade=134
constant integer si__Mine=135
boolean array s__Mine_active
integer array s__Mine_count
constant integer si__ShoulderCannonMissle=136
constant integer si__SpearMissle=137
constant integer si__SmartDarts=138
integer array s__SmartDarts_pref
unit array s__SmartDarts_t
integer array s__SmartDarts_count
integer array s__SmartDarts_swift
constant integer si__IShooter=139
integer si__IShooter_F=0
integer si__IShooter_I=0
integer array si__IShooter_V
integer array si__IShooter_type
trigger array st__IShooter_onDestroy
unit array s__IShooter_owner
integer array s__IShooter_factory
trigger array st__IShooter_shoot
trigger array st__IShooter_getEnergyConsume
trigger array st__IShooter_subshoot
trigger array st__IShooter_getRist
trigger array st__IShooter_shootCount
trigger array st__IShooter_getOriginSpeed
trigger array st__IShooter_getClipSize
trigger array st__IShooter_shoothz
trigger array st__IShooter_tick
constant integer si__AbstractShooter=140
integer array s__AbstractShooter_T32xs___next
integer array s__AbstractShooter_T32xs___prev
boolean array s__AbstractShooter_T32xs___runningPeriodic
constant integer si__SingleShooter=141
constant integer si__ShoulderCannonShooter=142
integer array s__ShoulderCannonShooter_c
integer array s__ShoulderCannonShooter_d
integer array s__ShoulderCannonShooter_t
constant integer si__GrenadeThrower=143
constant integer si__MineThrower=144
constant integer si__DefaultShooter=145
constant integer si__ShootGunShooter=146
constant integer si__MachineGunShooter=147
constant integer si__VelocityUnit=148
integer si__VelocityUnit_F=0
integer si__VelocityUnit_I=0
integer array si__VelocityUnit_V
boolean s__VelocityUnit_List___destroyinglist= false
integer s__VelocityUnit_List___length= 0
integer s__VelocityUnit_List___first= 0
integer s__VelocityUnit_List___last= 0
integer array s__VelocityUnit_List___prev
integer array s__VelocityUnit_List___next
boolean array s__VelocityUnit_List___inlist
unit array s__VelocityUnit_target
constant integer si__Velocity=149
integer s__Velocity_AIDS_DELEGATE=0
boolean array s__Velocity_AIDS_instanciated
integer array s__Velocity_v
integer array s__Velocity_a
integer array s__Velocity_vu
integer array s__Velocity_missleStruct
constant integer si__ItemJump=150
real s__ItemJump_defaultAoE=0.
integer s__ItemJump_SpellStruct___currentAbil=0
boolean s__ItemJump_SpellStruct___doAutoDestroyDefault=true
constant integer si__Jump=151
real s__Jump_defaultAoE=0.
integer s__Jump_SpellStruct___currentAbil=0
boolean s__Jump_SpellStruct___doAutoDestroyDefault=true
constant integer si__InjectionSpeedUp=152
real s__InjectionSpeedUp_defaultAoE=0.
integer s__InjectionSpeedUp_SpellStruct___currentAbil=0
boolean s__InjectionSpeedUp_SpellStruct___doAutoDestroyDefault=true
constant integer si__Darts=153
real s__Darts_defaultAoE=0.
integer s__Darts_SpellStruct___currentAbil=0
boolean s__Darts_SpellStruct___doAutoDestroyDefault=true
constant integer si__ReturnDartsSpell=154
real s__ReturnDartsSpell_defaultAoE=0.
integer s__ReturnDartsSpell_SpellStruct___currentAbil=0
boolean s__ReturnDartsSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__SmartDartsSpell=155
real s__SmartDartsSpell_defaultAoE=0.
integer s__SmartDartsSpell_SpellStruct___currentAbil=0
boolean s__SmartDartsSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__ShoulderCannonSpell=156
real s__ShoulderCannonSpell_defaultAoE=0.
integer s__ShoulderCannonSpell_SpellStruct___currentAbil=0
boolean s__ShoulderCannonSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__ItemReturnDartsSpell=157
real s__ItemReturnDartsSpell_defaultAoE=0.
integer s__ItemReturnDartsSpell_SpellStruct___currentAbil=0
boolean s__ItemReturnDartsSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__LeaveDartsSpell=158
real s__LeaveDartsSpell_defaultAoE=0.
integer s__LeaveDartsSpell_SpellStruct___currentAbil=0
boolean s__LeaveDartsSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__BackGrenadeSpell=159
real s__BackGrenadeSpell_defaultAoE=0.
integer s__BackGrenadeSpell_SpellStruct___currentAbil=0
boolean s__BackGrenadeSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__MineSpell=160
real s__MineSpell_defaultAoE=0.
integer s__MineSpell_SpellStruct___currentAbil=0
boolean s__MineSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__PushGrenadeSpell=161
real s__PushGrenadeSpell_defaultAoE=0.
integer s__PushGrenadeSpell_SpellStruct___currentAbil=0
boolean s__PushGrenadeSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__Blink=162
real s__Blink_defaultAoE=0.
integer s__Blink_SpellStruct___currentAbil=0
boolean s__Blink_SpellStruct___doAutoDestroyDefault=true
constant integer si__Transport=163
real s__Transport_defaultAoE=0.
integer s__Transport_SpellStruct___currentAbil=0
boolean s__Transport_SpellStruct___doAutoDestroyDefault=true
constant integer si__ElectricWhipSpell=164
real s__ElectricWhipSpell_defaultAoE=0.
integer s__ElectricWhipSpell_SpellStruct___currentAbil=0
boolean s__ElectricWhipSpell_SpellStruct___doAutoDestroyDefault=true
constant integer si__AutoAim=165
real s__AutoAim_defaultAoE=0.
integer s__AutoAim_SpellStruct___currentAbil=0
boolean s__AutoAim_SpellStruct___doAutoDestroyDefault=true
constant integer si__ShootBack=166
real s__ShootBack_defaultAoE=0.
integer s__ShootBack_SpellStruct___currentAbil=0
boolean s__ShootBack_SpellStruct___doAutoDestroyDefault=true
constant integer si__BurnBuffer=167
real array s__BurnBuffer_dam
unit array s__BurnBuffer_source
effect array s__BurnBuffer_e
constant integer si__HorroBuffer=168
unit array s__HorroBuffer_source
effect array s__HorroBuffer_e
constant integer si__BleedBuffer=169
real array s__BleedBuffer_dam
unit array s__BleedBuffer_source
effect array s__BleedBuffer_e
constant integer si__IceSlowBuffer=170
effect array s__IceSlowBuffer_e
constant integer si__AutoAimBuffer=171
string array s__TECH_TREE_NAME
integer array s__TECH_TREE_COUNT
integer array s__TECH_TREES
integer array s__TimerUtils__data
integer array s__2TimerUtils__data
integer array s__3TimerUtils__data
integer array s__4TimerUtils__data
integer array s__5TimerUtils__data
integer array s__6TimerUtils__data
integer array s__7TimerUtils__data
integer array s__8TimerUtils__data
integer array s__9TimerUtils__data
integer array s__10TimerUtils__data
integer array s__11TimerUtils__data
integer array s__12TimerUtils__data
integer array s__13TimerUtils__data
integer array s__14TimerUtils__data
integer array s__15TimerUtils__data
integer array s__16TimerUtils__data
integer array s__17TimerUtils__data
integer array s__18TimerUtils__data
integer array s__19TimerUtils__data
integer array s__20TimerUtils__data
integer array s__21TimerUtils__data
integer array s__22TimerUtils__data
integer array s__23TimerUtils__data
integer array s__24TimerUtils__data
integer array s__25TimerUtils__data
integer array s__26TimerUtils__data
integer array s__27TimerUtils__data
integer array s__28TimerUtils__data
integer array s__29TimerUtils__data
integer array s__30TimerUtils__data
integer array s__31TimerUtils__data
integer array s__32TimerUtils__data
integer array s__33TimerUtils__data
integer array s__34TimerUtils__data
integer array s__35TimerUtils__data
integer array s__36TimerUtils__data
integer array s__37TimerUtils__data
integer array s__38TimerUtils__data
integer array s__39TimerUtils__data
integer array s__40TimerUtils__data
integer array s__41TimerUtils__data
integer array s__42TimerUtils__data
integer array s__43TimerUtils__data
integer array s__44TimerUtils__data
integer array s__45TimerUtils__data
integer array s__46TimerUtils__data
integer array s__47TimerUtils__data
integer array s__48TimerUtils__data
integer array s__49TimerUtils__data
integer array s__50TimerUtils__data
integer array s__GroupUtils__Status
integer array s__2GroupUtils__Status
integer array s__3GroupUtils__Status
integer array s__4GroupUtils__Status
integer array s__5GroupUtils__Status
integer array s__6GroupUtils__Status
integer array s__7GroupUtils__Status
integer array s__8GroupUtils__Status
integer array s__9GroupUtils__Status
integer array s__10GroupUtils__Status
integer array s__11GroupUtils__Status
integer array s__12GroupUtils__Status
integer array s__13GroupUtils__Status
integer array s__14GroupUtils__Status
integer array s__15GroupUtils__Status
integer array s__16GroupUtils__Status
integer array s__17GroupUtils__Status
integer array s__18GroupUtils__Status
integer array s__19GroupUtils__Status
integer array s__20GroupUtils__Status
integer array s__21GroupUtils__Status
integer array s__22GroupUtils__Status
integer array s__23GroupUtils__Status
integer array s__24GroupUtils__Status
integer array s__25GroupUtils__Status
integer array s__26GroupUtils__Status
integer array s__27GroupUtils__Status
integer array s__28GroupUtils__Status
integer array s__29GroupUtils__Status
integer array s__30GroupUtils__Status
integer array s__31GroupUtils__Status
integer array s__32GroupUtils__Status
integer array s__33GroupUtils__Status
integer array s__34GroupUtils__Status
integer array s__35GroupUtils__Status
integer array s__36GroupUtils__Status
integer array s__37GroupUtils__Status
integer array s__38GroupUtils__Status
integer array s__39GroupUtils__Status
integer array s__40GroupUtils__Status
integer array s__41GroupUtils__Status
integer array s__42GroupUtils__Status
integer array s__43GroupUtils__Status
integer array s__44GroupUtils__Status
integer array s__45GroupUtils__Status
integer array s__46GroupUtils__Status
integer array s__47GroupUtils__Status
integer array s__48GroupUtils__Status
integer array s__49GroupUtils__Status
integer array s__50GroupUtils__Status
trigger st__AII___ItemStruct_onDeath
trigger st__AII___ItemStruct_manageLock
trigger st__Event_Event__destroyNode
trigger st__Material__staticgetindex
trigger st__Material_AIDS_filter
trigger st__Material_AIDS_onCreate
trigger st__Material_AIDS_onDestroy
trigger st__DefaultTypeData_create
trigger st__DefaultTypeData_destroy
trigger st__vector_setLength
trigger st__DefaultAIStrategy_create
trigger st__DefaultAIStrategy_destroy
trigger st__Damage__Detector_AIDS_onCreate
trigger st__Damage__Detector_AIDS_onDestroy
trigger st__Damage__Detector_AIDS_onInit
trigger st__EquipmentData__staticgetindex
trigger st__EquipmentData_AIDS_filter
trigger st__EquipmentData_AIDS_onCreate
trigger st__EquipmentData_AIDS_onDestroy
trigger st__EquipmentData_periodic
trigger st__DefaultGun_create
trigger st__IndividualItemData__get_item
trigger st__ItemFeatureData_construct
trigger st__SpellStruct__get_isNotLocked
trigger st__SpellStruct__get_casterX
trigger st__SpellStruct__get_casterY
trigger st__SpellStruct_create
trigger st__SpellStruct_destroy
trigger st__Status__get_unit
trigger st__Status_stopPeriodic
trigger st__RealMan_onDestroy
trigger st__RealMan_destroy
trigger st__AIData__staticgetindex
trigger st__AIData_AIDS_filter
trigger st__AIData_AIDS_onCreate
trigger st__AIData_AIDS_onDestroy
trigger st__DefaultAIGroup_create
trigger st__DefaultAIGroup_periodic
trigger st__DefaultDialog_create
trigger st__ChangeAbDialog_create
trigger st__ChangeGunDialog_create
trigger st__TransformDialog_create
trigger st__DefaultBufferStruct_start
trigger st__DefaultBufferStruct_create
trigger st__DefaultBufferStruct_loopMoveAll
trigger st__DefaultBufferStruct_destroy
trigger st__MonsterTargetGroupManager_create
trigger st__MonsterTargetGroupManager_onDestroy
trigger st__MonsterTargetGroupManager_periodic
trigger st__PushForceStruct_create
trigger st__Missle_create
trigger st__Missle_destroy
trigger st__Mine_getDeployTime
trigger st__Mine_create
trigger st__SmartDarts_create
trigger st__AbstractShooter_periodic
trigger st__AbstractShooter_create
trigger st__DefaultShooter_getShootDir
trigger st__DefaultShooter_getShootVector
trigger st__DefaultShooter_energyConsume
trigger st__DefaultShooter_backForce
trigger st__VelocityUnit_onDestroy
trigger st__VelocityUnit_loopMoveAllMissles
trigger st__VelocityUnit_destroy
trigger st__Velocity__staticgetindex
trigger st__Velocity_AIDS_filter
trigger st__Velocity_AIDS_onCreate
trigger st__Velocity_AIDS_onDestroy
trigger st__Velocity_periodic
trigger st__BurnBuffer_create
trigger st__HorroBuffer_create
trigger st__BleedBuffer_create
trigger array st___prototype1
integer f__result_integer
trigger array st___prototype18
trigger array st___prototype37
trigger array st___prototype217
boolean f__result_boolean
trigger array st___prototype218
boolean f__arg_boolean1
unit f__arg_unit1
unit f__arg_unit2
real f__arg_real1
integer f__arg_integer1
integer f__arg_integer2
integer f__arg_integer3
button f__arg_button1
string f__arg_string1
player f__arg_player1
item f__arg_item1
integer f__arg_this
item f__result_item
real f__result_real
unit f__result_unit

endglobals
    native UnitAlive takes unit id returns boolean


function sg__TimerUtils__data_get takes integer i returns integer
    if(i<8191) then
        return s__TimerUtils__data[i]
    elseif(i<204775) then
        if(i<16382) then
            return s__2TimerUtils__data[i-8191]
        elseif(i<106483) then
            if(i<24573) then
                return s__3TimerUtils__data[i-16382]
            elseif(i<65528) then
                if(i<32764) then
                    return s__4TimerUtils__data[i-24573]
                elseif(i<49146) then
                    if(i<40955) then
                        return s__5TimerUtils__data[i-32764]
                    else
                        return s__6TimerUtils__data[i-40955]
                    endif
                elseif(i<57337) then
                    return s__7TimerUtils__data[i-49146]
                else
                    return s__8TimerUtils__data[i-57337]
                endif
            elseif(i<73719) then
                return s__9TimerUtils__data[i-65528]
            elseif(i<90101) then
                if(i<81910) then
                    return s__10TimerUtils__data[i-73719]
                else
                    return s__11TimerUtils__data[i-81910]
                endif
            elseif(i<98292) then
                return s__12TimerUtils__data[i-90101]
            else
                return s__13TimerUtils__data[i-98292]
            endif
        elseif(i<114674) then
            return s__14TimerUtils__data[i-106483]
        elseif(i<155629) then
            if(i<122865) then
                return s__15TimerUtils__data[i-114674]
            elseif(i<139247) then
                if(i<131056) then
                    return s__16TimerUtils__data[i-122865]
                else
                    return s__17TimerUtils__data[i-131056]
                endif
            elseif(i<147438) then
                return s__18TimerUtils__data[i-139247]
            else
                return s__19TimerUtils__data[i-147438]
            endif
        elseif(i<163820) then
            return s__20TimerUtils__data[i-155629]
        elseif(i<180202) then
            if(i<172011) then
                return s__21TimerUtils__data[i-163820]
            else
                return s__22TimerUtils__data[i-172011]
            endif
        elseif(i<188393) then
            return s__23TimerUtils__data[i-180202]
        elseif(i<196584) then
            return s__24TimerUtils__data[i-188393]
        else
            return s__25TimerUtils__data[i-196584]
        endif
    elseif(i<212966) then
        return s__26TimerUtils__data[i-204775]
    elseif(i<311258) then
        if(i<221157) then
            return s__27TimerUtils__data[i-212966]
        elseif(i<262112) then
            if(i<229348) then
                return s__28TimerUtils__data[i-221157]
            elseif(i<245730) then
                if(i<237539) then
                    return s__29TimerUtils__data[i-229348]
                else
                    return s__30TimerUtils__data[i-237539]
                endif
            elseif(i<253921) then
                return s__31TimerUtils__data[i-245730]
            else
                return s__32TimerUtils__data[i-253921]
            endif
        elseif(i<270303) then
            return s__33TimerUtils__data[i-262112]
        elseif(i<286685) then
            if(i<278494) then
                return s__34TimerUtils__data[i-270303]
            else
                return s__35TimerUtils__data[i-278494]
            endif
        elseif(i<294876) then
            return s__36TimerUtils__data[i-286685]
        elseif(i<303067) then
            return s__37TimerUtils__data[i-294876]
        else
            return s__38TimerUtils__data[i-303067]
        endif
    elseif(i<319449) then
        return s__39TimerUtils__data[i-311258]
    elseif(i<360404) then
        if(i<327640) then
            return s__40TimerUtils__data[i-319449]
        elseif(i<344022) then
            if(i<335831) then
                return s__41TimerUtils__data[i-327640]
            else
                return s__42TimerUtils__data[i-335831]
            endif
        elseif(i<352213) then
            return s__43TimerUtils__data[i-344022]
        else
            return s__44TimerUtils__data[i-352213]
        endif
    elseif(i<368595) then
        return s__45TimerUtils__data[i-360404]
    elseif(i<384977) then
        if(i<376786) then
            return s__46TimerUtils__data[i-368595]
        else
            return s__47TimerUtils__data[i-376786]
        endif
    elseif(i<393168) then
        return s__48TimerUtils__data[i-384977]
    elseif(i<401359) then
        return s__49TimerUtils__data[i-393168]
    else
        return s__50TimerUtils__data[i-401359]
    endif
endfunction

function sg__TimerUtils__data_set takes integer i,integer v returns nothing
    if(i<8191) then
        set s__TimerUtils__data[i]=v
    elseif(i<204775) then
        if(i<16382) then
            set s__2TimerUtils__data[i-8191]=v
        elseif(i<106483) then
            if(i<24573) then
                set s__3TimerUtils__data[i-16382]=v
            elseif(i<65528) then
                if(i<32764) then
                    set s__4TimerUtils__data[i-24573]=v
                elseif(i<49146) then
                    if(i<40955) then
                        set s__5TimerUtils__data[i-32764]=v
                    else
                        set s__6TimerUtils__data[i-40955]=v
                    endif
                elseif(i<57337) then
                    set s__7TimerUtils__data[i-49146]=v
                else
                    set s__8TimerUtils__data[i-57337]=v
                endif
            elseif(i<73719) then
                set s__9TimerUtils__data[i-65528]=v
            elseif(i<90101) then
                if(i<81910) then
                    set s__10TimerUtils__data[i-73719]=v
                else
                    set s__11TimerUtils__data[i-81910]=v
                endif
            elseif(i<98292) then
                set s__12TimerUtils__data[i-90101]=v
            else
                set s__13TimerUtils__data[i-98292]=v
            endif
        elseif(i<114674) then
            set s__14TimerUtils__data[i-106483]=v
        elseif(i<155629) then
            if(i<122865) then
                set s__15TimerUtils__data[i-114674]=v
            elseif(i<139247) then
                if(i<131056) then
                    set s__16TimerUtils__data[i-122865]=v
                else
                    set s__17TimerUtils__data[i-131056]=v
                endif
            elseif(i<147438) then
                set s__18TimerUtils__data[i-139247]=v
            else
                set s__19TimerUtils__data[i-147438]=v
            endif
        elseif(i<163820) then
            set s__20TimerUtils__data[i-155629]=v
        elseif(i<180202) then
            if(i<172011) then
                set s__21TimerUtils__data[i-163820]=v
            else
                set s__22TimerUtils__data[i-172011]=v
            endif
        elseif(i<188393) then
            set s__23TimerUtils__data[i-180202]=v
        elseif(i<196584) then
            set s__24TimerUtils__data[i-188393]=v
        else
            set s__25TimerUtils__data[i-196584]=v
        endif
    elseif(i<212966) then
        set s__26TimerUtils__data[i-204775]=v
    elseif(i<311258) then
        if(i<221157) then
            set s__27TimerUtils__data[i-212966]=v
        elseif(i<262112) then
            if(i<229348) then
                set s__28TimerUtils__data[i-221157]=v
            elseif(i<245730) then
                if(i<237539) then
                    set s__29TimerUtils__data[i-229348]=v
                else
                    set s__30TimerUtils__data[i-237539]=v
                endif
            elseif(i<253921) then
                set s__31TimerUtils__data[i-245730]=v
            else
                set s__32TimerUtils__data[i-253921]=v
            endif
        elseif(i<270303) then
            set s__33TimerUtils__data[i-262112]=v
        elseif(i<286685) then
            if(i<278494) then
                set s__34TimerUtils__data[i-270303]=v
            else
                set s__35TimerUtils__data[i-278494]=v
            endif
        elseif(i<294876) then
            set s__36TimerUtils__data[i-286685]=v
        elseif(i<303067) then
            set s__37TimerUtils__data[i-294876]=v
        else
            set s__38TimerUtils__data[i-303067]=v
        endif
    elseif(i<319449) then
        set s__39TimerUtils__data[i-311258]=v
    elseif(i<360404) then
        if(i<327640) then
            set s__40TimerUtils__data[i-319449]=v
        elseif(i<344022) then
            if(i<335831) then
                set s__41TimerUtils__data[i-327640]=v
            else
                set s__42TimerUtils__data[i-335831]=v
            endif
        elseif(i<352213) then
            set s__43TimerUtils__data[i-344022]=v
        else
            set s__44TimerUtils__data[i-352213]=v
        endif
    elseif(i<368595) then
        set s__45TimerUtils__data[i-360404]=v
    elseif(i<384977) then
        if(i<376786) then
            set s__46TimerUtils__data[i-368595]=v
        else
            set s__47TimerUtils__data[i-376786]=v
        endif
    elseif(i<393168) then
        set s__48TimerUtils__data[i-384977]=v
    elseif(i<401359) then
        set s__49TimerUtils__data[i-393168]=v
    else
        set s__50TimerUtils__data[i-401359]=v
    endif
endfunction

function sg__GroupUtils__Status_get takes integer i returns integer
    if(i<8191) then
        return s__GroupUtils__Status[i]
    elseif(i<204775) then
        if(i<16382) then
            return s__2GroupUtils__Status[i-8191]
        elseif(i<106483) then
            if(i<24573) then
                return s__3GroupUtils__Status[i-16382]
            elseif(i<65528) then
                if(i<32764) then
                    return s__4GroupUtils__Status[i-24573]
                elseif(i<49146) then
                    if(i<40955) then
                        return s__5GroupUtils__Status[i-32764]
                    else
                        return s__6GroupUtils__Status[i-40955]
                    endif
                elseif(i<57337) then
                    return s__7GroupUtils__Status[i-49146]
                else
                    return s__8GroupUtils__Status[i-57337]
                endif
            elseif(i<73719) then
                return s__9GroupUtils__Status[i-65528]
            elseif(i<90101) then
                if(i<81910) then
                    return s__10GroupUtils__Status[i-73719]
                else
                    return s__11GroupUtils__Status[i-81910]
                endif
            elseif(i<98292) then
                return s__12GroupUtils__Status[i-90101]
            else
                return s__13GroupUtils__Status[i-98292]
            endif
        elseif(i<114674) then
            return s__14GroupUtils__Status[i-106483]
        elseif(i<155629) then
            if(i<122865) then
                return s__15GroupUtils__Status[i-114674]
            elseif(i<139247) then
                if(i<131056) then
                    return s__16GroupUtils__Status[i-122865]
                else
                    return s__17GroupUtils__Status[i-131056]
                endif
            elseif(i<147438) then
                return s__18GroupUtils__Status[i-139247]
            else
                return s__19GroupUtils__Status[i-147438]
            endif
        elseif(i<163820) then
            return s__20GroupUtils__Status[i-155629]
        elseif(i<180202) then
            if(i<172011) then
                return s__21GroupUtils__Status[i-163820]
            else
                return s__22GroupUtils__Status[i-172011]
            endif
        elseif(i<188393) then
            return s__23GroupUtils__Status[i-180202]
        elseif(i<196584) then
            return s__24GroupUtils__Status[i-188393]
        else
            return s__25GroupUtils__Status[i-196584]
        endif
    elseif(i<212966) then
        return s__26GroupUtils__Status[i-204775]
    elseif(i<311258) then
        if(i<221157) then
            return s__27GroupUtils__Status[i-212966]
        elseif(i<262112) then
            if(i<229348) then
                return s__28GroupUtils__Status[i-221157]
            elseif(i<245730) then
                if(i<237539) then
                    return s__29GroupUtils__Status[i-229348]
                else
                    return s__30GroupUtils__Status[i-237539]
                endif
            elseif(i<253921) then
                return s__31GroupUtils__Status[i-245730]
            else
                return s__32GroupUtils__Status[i-253921]
            endif
        elseif(i<270303) then
            return s__33GroupUtils__Status[i-262112]
        elseif(i<286685) then
            if(i<278494) then
                return s__34GroupUtils__Status[i-270303]
            else
                return s__35GroupUtils__Status[i-278494]
            endif
        elseif(i<294876) then
            return s__36GroupUtils__Status[i-286685]
        elseif(i<303067) then
            return s__37GroupUtils__Status[i-294876]
        else
            return s__38GroupUtils__Status[i-303067]
        endif
    elseif(i<319449) then
        return s__39GroupUtils__Status[i-311258]
    elseif(i<360404) then
        if(i<327640) then
            return s__40GroupUtils__Status[i-319449]
        elseif(i<344022) then
            if(i<335831) then
                return s__41GroupUtils__Status[i-327640]
            else
                return s__42GroupUtils__Status[i-335831]
            endif
        elseif(i<352213) then
            return s__43GroupUtils__Status[i-344022]
        else
            return s__44GroupUtils__Status[i-352213]
        endif
    elseif(i<368595) then
        return s__45GroupUtils__Status[i-360404]
    elseif(i<384977) then
        if(i<376786) then
            return s__46GroupUtils__Status[i-368595]
        else
            return s__47GroupUtils__Status[i-376786]
        endif
    elseif(i<393168) then
        return s__48GroupUtils__Status[i-384977]
    elseif(i<401359) then
        return s__49GroupUtils__Status[i-393168]
    else
        return s__50GroupUtils__Status[i-401359]
    endif
endfunction

function sg__GroupUtils__Status_set takes integer i,integer v returns nothing
    if(i<8191) then
        set s__GroupUtils__Status[i]=v
    elseif(i<204775) then
        if(i<16382) then
            set s__2GroupUtils__Status[i-8191]=v
        elseif(i<106483) then
            if(i<24573) then
                set s__3GroupUtils__Status[i-16382]=v
            elseif(i<65528) then
                if(i<32764) then
                    set s__4GroupUtils__Status[i-24573]=v
                elseif(i<49146) then
                    if(i<40955) then
                        set s__5GroupUtils__Status[i-32764]=v
                    else
                        set s__6GroupUtils__Status[i-40955]=v
                    endif
                elseif(i<57337) then
                    set s__7GroupUtils__Status[i-49146]=v
                else
                    set s__8GroupUtils__Status[i-57337]=v
                endif
            elseif(i<73719) then
                set s__9GroupUtils__Status[i-65528]=v
            elseif(i<90101) then
                if(i<81910) then
                    set s__10GroupUtils__Status[i-73719]=v
                else
                    set s__11GroupUtils__Status[i-81910]=v
                endif
            elseif(i<98292) then
                set s__12GroupUtils__Status[i-90101]=v
            else
                set s__13GroupUtils__Status[i-98292]=v
            endif
        elseif(i<114674) then
            set s__14GroupUtils__Status[i-106483]=v
        elseif(i<155629) then
            if(i<122865) then
                set s__15GroupUtils__Status[i-114674]=v
            elseif(i<139247) then
                if(i<131056) then
                    set s__16GroupUtils__Status[i-122865]=v
                else
                    set s__17GroupUtils__Status[i-131056]=v
                endif
            elseif(i<147438) then
                set s__18GroupUtils__Status[i-139247]=v
            else
                set s__19GroupUtils__Status[i-147438]=v
            endif
        elseif(i<163820) then
            set s__20GroupUtils__Status[i-155629]=v
        elseif(i<180202) then
            if(i<172011) then
                set s__21GroupUtils__Status[i-163820]=v
            else
                set s__22GroupUtils__Status[i-172011]=v
            endif
        elseif(i<188393) then
            set s__23GroupUtils__Status[i-180202]=v
        elseif(i<196584) then
            set s__24GroupUtils__Status[i-188393]=v
        else
            set s__25GroupUtils__Status[i-196584]=v
        endif
    elseif(i<212966) then
        set s__26GroupUtils__Status[i-204775]=v
    elseif(i<311258) then
        if(i<221157) then
            set s__27GroupUtils__Status[i-212966]=v
        elseif(i<262112) then
            if(i<229348) then
                set s__28GroupUtils__Status[i-221157]=v
            elseif(i<245730) then
                if(i<237539) then
                    set s__29GroupUtils__Status[i-229348]=v
                else
                    set s__30GroupUtils__Status[i-237539]=v
                endif
            elseif(i<253921) then
                set s__31GroupUtils__Status[i-245730]=v
            else
                set s__32GroupUtils__Status[i-253921]=v
            endif
        elseif(i<270303) then
            set s__33GroupUtils__Status[i-262112]=v
        elseif(i<286685) then
            if(i<278494) then
                set s__34GroupUtils__Status[i-270303]=v
            else
                set s__35GroupUtils__Status[i-278494]=v
            endif
        elseif(i<294876) then
            set s__36GroupUtils__Status[i-286685]=v
        elseif(i<303067) then
            set s__37GroupUtils__Status[i-294876]=v
        else
            set s__38GroupUtils__Status[i-303067]=v
        endif
    elseif(i<319449) then
        set s__39GroupUtils__Status[i-311258]=v
    elseif(i<360404) then
        if(i<327640) then
            set s__40GroupUtils__Status[i-319449]=v
        elseif(i<344022) then
            if(i<335831) then
                set s__41GroupUtils__Status[i-327640]=v
            else
                set s__42GroupUtils__Status[i-335831]=v
            endif
        elseif(i<352213) then
            set s__43GroupUtils__Status[i-344022]=v
        else
            set s__44GroupUtils__Status[i-352213]=v
        endif
    elseif(i<368595) then
        set s__45GroupUtils__Status[i-360404]=v
    elseif(i<384977) then
        if(i<376786) then
            set s__46GroupUtils__Status[i-368595]=v
        else
            set s__47GroupUtils__Status[i-376786]=v
        endif
    elseif(i<393168) then
        set s__48GroupUtils__Status[i-384977]=v
    elseif(i<401359) then
        set s__49GroupUtils__Status[i-393168]=v
    else
        set s__50GroupUtils__Status[i-401359]=v
    endif
endfunction

//Generated method caller for AII___ItemStruct.onDeath
function sc__AII___ItemStruct_onDeath takes nothing returns boolean
    call TriggerEvaluate(st__AII___ItemStruct_onDeath)
 return f__result_boolean
endfunction

//Generated method caller for AII___ItemStruct.manageLock
function sc__AII___ItemStruct_manageLock takes integer this,boolean b returns nothing
    set f__arg_this=this
    set f__arg_boolean1=b
    call TriggerEvaluate(st__AII___ItemStruct_manageLock)
endfunction

//Generated allocator of AII___ItemStruct
function s__AII___ItemStruct__allocate takes nothing returns integer
 local integer this=si__AII___ItemStruct_F
    if (this!=0) then
        set si__AII___ItemStruct_F=si__AII___ItemStruct_V[this]
    else
        set si__AII___ItemStruct_I=si__AII___ItemStruct_I+1
        set this=si__AII___ItemStruct_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__AII___ItemStruct_V[this]=-1
 return this
endfunction

//Generated destructor of AII___ItemStruct
function s__AII___ItemStruct_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__AII___ItemStruct_V[this]!=-1) then
        return
    endif
    set si__AII___ItemStruct_V[this]=si__AII___ItemStruct_F
    set si__AII___ItemStruct_F=this
endfunction

//Generated method caller for Event.Event__destroyNode
function sc__Event_Event__destroyNode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Event_Event__destroyNode)
endfunction

//Generated allocator of Event
function s__Event__allocate takes nothing returns integer
 local integer this=si__Event_F
    if (this!=0) then
        set si__Event_F=si__Event_V[this]
    else
        set si__Event_I=si__Event_I+1
        set this=si__Event_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Event_V[this]=-1
 return this
endfunction

//Generated destructor of Event
function s__Event_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Event_V[this]!=-1) then
        return
    endif
    set si__Event_V[this]=si__Event_F
    set si__Event_F=this
endfunction

//Generated allocator of TechRecord
function s__TechRecord__allocate takes nothing returns integer
 local integer this=si__TechRecord_F
    if (this!=0) then
        set si__TechRecord_F=si__TechRecord_V[this]
    else
        set si__TechRecord_I=si__TechRecord_I+1
        set this=si__TechRecord_I
    endif
    if (this>126) then
        return 0
    endif
    set s__TechRecord_itms[this]=(this-1)*64
    set si__TechRecord_V[this]=-1
 return this
endfunction

//Generated destructor of TechRecord
function s__TechRecord_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__TechRecord_V[this]!=-1) then
        return
    endif
    set si__TechRecord_V[this]=si__TechRecord_F
    set si__TechRecord_F=this
endfunction

//Generated allocator of TechCounter
function s__TechCounter__allocate takes nothing returns integer
 local integer this=si__TechCounter_F
    if (this!=0) then
        set si__TechCounter_F=si__TechCounter_V[this]
    else
        set si__TechCounter_I=si__TechCounter_I+1
        set this=si__TechCounter_I
    endif
    if (this>2046) then
        return 0
    endif
    set s__TechCounter_cnt[this]=(this-1)*4
    set si__TechCounter_V[this]=-1
 return this
endfunction

//Generated destructor of TechCounter
function s__TechCounter_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__TechCounter_V[this]!=-1) then
        return
    endif
    set si__TechCounter_V[this]=si__TechCounter_F
    set si__TechCounter_F=this
endfunction

//Generated allocator of IHeroData
function s__IHeroData__allocate takes nothing returns integer
 local integer this=si__IHeroData_F
    if (this!=0) then
        set si__IHeroData_F=si__IHeroData_V[this]
    else
        set si__IHeroData_I=si__IHeroData_I+1
        set this=si__IHeroData_I
    endif
    if (this>408) then
        return 0
    endif
    set s__IHeroData_equips[this]=(this-1)*20
    set si__IHeroData_V[this]=-1
 return this
endfunction

//Generated destructor of IHeroData
function s__IHeroData_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IHeroData_V[this]!=-1) then
        return
    endif
    set si__IHeroData_V[this]=si__IHeroData_F
    set si__IHeroData_F=this
endfunction

//Generated method caller for Material._staticgetindex
function sc__Material__staticgetindex takes unit whichUnit returns integer
    set f__arg_unit1=whichUnit
    call TriggerEvaluate(st__Material__staticgetindex)
 return f__result_integer
endfunction

//Generated method caller for Material.AIDS_filter
function sc__Material_AIDS_filter takes unit u returns boolean
        return true
endfunction

//Generated method caller for Material.AIDS_onCreate
function sc__Material_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Material_AIDS_onCreate)
endfunction

//Generated method caller for Material.AIDS_onDestroy
function sc__Material_AIDS_onDestroy takes integer this returns nothing
endfunction

//Generated method caller for IMissleFactory.createMissle
function sc__IMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[si__IMissleFactory_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMissleFactory.createMissle
function sx__IMissleFactory_createMissle takes integer this,unit owner returns nothing
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerExecute(st__IMissleFactory_createMissle[si__IMissleFactory_type[this]])
endfunction
//Generated destructor of IMissleFactory
function sc__IMissleFactory_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IMissleFactory_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IMissleFactory_onDestroy[si__IMissleFactory_type[this]])
    set si__IMissleFactory_V[this]=si__IMissleFactory_F
    set si__IMissleFactory_F=this
endfunction

//Generated method caller for SmartDartsFactory.createMissle
function sc__SmartDartsFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[16])
 return f__result_integer
endfunction

//Generated allocator of SmartDartsFactory
function s__SmartDartsFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=16
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for DefaultMissleFactory.createMissle
function sc__DefaultMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[17])
 return f__result_integer
endfunction

//Generated allocator of DefaultMissleFactory
function s__DefaultMissleFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=17
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for ShootGunMissleFactory.createMissle
function sc__ShootGunMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[18])
 return f__result_integer
endfunction

//Generated allocator of ShootGunMissleFactory
function s__ShootGunMissleFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=18
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for SmallDartsFactory.createMissle
function sc__SmallDartsFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[19])
 return f__result_integer
endfunction

//Generated allocator of SmallDartsFactory
function s__SmallDartsFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=19
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for ReturnDartsFactory.createMissle
function sc__ReturnDartsFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[20])
 return f__result_integer
endfunction

//Generated allocator of ReturnDartsFactory
function s__ReturnDartsFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=20
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for LeaveDartsFactory.createMissle
function sc__LeaveDartsFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[21])
 return f__result_integer
endfunction

//Generated allocator of LeaveDartsFactory
function s__LeaveDartsFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=21
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for IceMissleFactory.createMissle
function sc__IceMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[22])
 return f__result_integer
endfunction

//Generated allocator of IceMissleFactory
function s__IceMissleFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=22
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for FireMissleFactory.createMissle
function sc__FireMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[23])
 return f__result_integer
endfunction

//Generated allocator of FireMissleFactory
function s__FireMissleFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=23
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for Velocity._staticgetindex
function sc__Velocity__staticgetindex takes unit whichUnit returns integer
    set f__arg_unit1=whichUnit
    call TriggerEvaluate(st__Velocity__staticgetindex)
 return f__result_integer
endfunction

//Generated method caller for Velocity.AIDS_filter
function sc__Velocity_AIDS_filter takes unit u returns boolean
    set f__arg_unit1=u
    call TriggerEvaluate(st__Velocity_AIDS_filter)
 return f__result_boolean
endfunction

//Generated method caller for Velocity.AIDS_onCreate
function sc__Velocity_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Velocity_AIDS_onCreate)
endfunction

//Generated method caller for Velocity.AIDS_onDestroy
function sc__Velocity_AIDS_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Velocity_AIDS_onDestroy)
endfunction

//Generated method caller for Velocity.periodic
function sc__Velocity_periodic takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Velocity_periodic)
endfunction

//Generated method caller for VelocityUnit.onDestroy
function sc__VelocityUnit_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__VelocityUnit_onDestroy)
endfunction

//Generated method caller for VelocityUnit.loopMoveAllMissles
function sc__VelocityUnit_loopMoveAllMissles takes nothing returns nothing
    call TriggerEvaluate(st__VelocityUnit_loopMoveAllMissles)
endfunction

//Generated allocator of VelocityUnit
function s__VelocityUnit__allocate takes nothing returns integer
 local integer this=si__VelocityUnit_F
    if (this!=0) then
        set si__VelocityUnit_F=si__VelocityUnit_V[this]
    else
        set si__VelocityUnit_I=si__VelocityUnit_I+1
        set this=si__VelocityUnit_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__VelocityUnit_List___prev[this]= 0
   set s__VelocityUnit_List___next[this]= 0
   set s__VelocityUnit_List___inlist[this]= false
    set si__VelocityUnit_V[this]=-1
 return this
endfunction

//Generated destructor of VelocityUnit
function sc__VelocityUnit_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__VelocityUnit_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__VelocityUnit_onDestroy)
    set si__VelocityUnit_V[this]=si__VelocityUnit_F
    set si__VelocityUnit_F=this
endfunction

//Generated method caller for ElectricWhipFactory.createMissle
function sc__ElectricWhipFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[24])
 return f__result_integer
endfunction

//Generated allocator of ElectricWhipFactory
function s__ElectricWhipFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=24
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for BackGrenadeFactory.createMissle
function sc__BackGrenadeFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[25])
 return f__result_integer
endfunction

//Generated allocator of BackGrenadeFactory
function s__BackGrenadeFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=25
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for PushGrenadeFactory.createMissle
function sc__PushGrenadeFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[26])
 return f__result_integer
endfunction

//Generated allocator of PushGrenadeFactory
function s__PushGrenadeFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=26
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for MineFactory.createMissle
function sc__MineFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[27])
 return f__result_integer
endfunction

//Generated allocator of MineFactory
function s__MineFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=27
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for ShoulderCannonFactory.createMissle
function sc__ShoulderCannonFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[28])
 return f__result_integer
endfunction

//Generated allocator of ShoulderCannonFactory
function s__ShoulderCannonFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=28
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for SpearMissleFactory.createMissle
function sc__SpearMissleFactory_createMissle takes integer this,unit owner returns integer
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IMissleFactory_createMissle[29])
 return f__result_integer
endfunction

//Generated allocator of SpearMissleFactory
function s__SpearMissleFactory__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissleFactory_F
    if (this!=0) then
        set si__IMissleFactory_F=si__IMissleFactory_V[this]
    else
        set si__IMissleFactory_I=si__IMissleFactory_I+1
        set this=si__IMissleFactory_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissleFactory_type[this]=29
    set kthis=this

    set si__IMissleFactory_V[this]=-1
 return this
endfunction


//Generated method caller for IMonsterTypeData.getDeadGold
function sc__IMonsterTypeData_getDeadGold takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMonsterTypeData_getDeadGold[si__IMonsterTypeData_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMonsterTypeData.getDeadGold
function sx__IMonsterTypeData_getDeadGold takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMonsterTypeData_getDeadGold[si__IMonsterTypeData_type[this]])
endfunction

//Generated method caller for IMonsterTypeData.getDeadWood
function sc__IMonsterTypeData_getDeadWood takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMonsterTypeData_getDeadWood[si__IMonsterTypeData_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMonsterTypeData.getDeadWood
function sx__IMonsterTypeData_getDeadWood takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMonsterTypeData_getDeadWood[si__IMonsterTypeData_type[this]])
endfunction

//Generated method caller for IMonsterTypeData.getTypeId
function sc__IMonsterTypeData_getTypeId takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMonsterTypeData_getTypeId[si__IMonsterTypeData_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMonsterTypeData.getTypeId
function sx__IMonsterTypeData_getTypeId takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMonsterTypeData_getTypeId[si__IMonsterTypeData_type[this]])
endfunction
//Generated destructor of IMonsterTypeData
function sc__IMonsterTypeData_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IMonsterTypeData_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IMonsterTypeData_onDestroy[si__IMonsterTypeData_type[this]])
    set si__IMonsterTypeData_V[this]=si__IMonsterTypeData_F
    set si__IMonsterTypeData_F=this
endfunction

//Generated method caller for DefaultTypeData.create
function sc__DefaultTypeData_create takes nothing returns integer
    call TriggerEvaluate(st__DefaultTypeData_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultTypeData.onDestroy
function sc__DefaultTypeData_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMonsterTypeData_onDestroy[31])
endfunction

//Generated method caller for DefaultTypeData.getTypeId
function sc__DefaultTypeData_getTypeId takes integer this returns integer
return 123
endfunction

//Generated method caller for DefaultTypeData.getDeadGold
function sc__DefaultTypeData_getDeadGold takes integer this returns integer
return 2
endfunction

//Generated method caller for DefaultTypeData.getDeadWood
function sc__DefaultTypeData_getDeadWood takes integer this returns integer
return 0
endfunction

//Generated allocator of DefaultTypeData
function s__DefaultTypeData__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMonsterTypeData_F
    if (this!=0) then
        set si__IMonsterTypeData_F=si__IMonsterTypeData_V[this]
    else
        set si__IMonsterTypeData_I=si__IMonsterTypeData_I+1
        set this=si__IMonsterTypeData_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMonsterTypeData_type[this]=31
    set kthis=this

   set s__DefaultTypeData_List___prev[this]= 0
   set s__DefaultTypeData_List___next[this]= 0
   set s__DefaultTypeData_List___inlist[this]= false
    set si__IMonsterTypeData_V[this]=-1
 return this
endfunction


//Generated method caller for IShooter.shoot
function sc__IShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[si__IShooter_type[this]])
endfunction

//Generated method executor for IShooter.shoot
function sx__IShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerExecute(st__IShooter_shoot[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.getEnergyConsume
function sc__IShooter_getEnergyConsume takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_getEnergyConsume[si__IShooter_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IShooter.getEnergyConsume
function sx__IShooter_getEnergyConsume takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_getEnergyConsume[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.subshoot
function sc__IShooter_subshoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_subshoot[si__IShooter_type[this]])
endfunction

//Generated method executor for IShooter.subshoot
function sx__IShooter_subshoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerExecute(st__IShooter_subshoot[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.getRist
function sc__IShooter_getRist takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_getRist[si__IShooter_type[this]])
 return f__result_real
endfunction

//Generated method executor for IShooter.getRist
function sx__IShooter_getRist takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_getRist[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.shootCount
function sc__IShooter_shootCount takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_shootCount[si__IShooter_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IShooter.shootCount
function sx__IShooter_shootCount takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_shootCount[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.getOriginSpeed
function sc__IShooter_getOriginSpeed takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_getOriginSpeed[si__IShooter_type[this]])
 return f__result_real
endfunction

//Generated method executor for IShooter.getOriginSpeed
function sx__IShooter_getOriginSpeed takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_getOriginSpeed[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.getClipSize
function sc__IShooter_getClipSize takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_getClipSize[si__IShooter_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IShooter.getClipSize
function sx__IShooter_getClipSize takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_getClipSize[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.shoothz
function sc__IShooter_shoothz takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_shoothz[si__IShooter_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IShooter.shoothz
function sx__IShooter_shoothz takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_shoothz[si__IShooter_type[this]])
endfunction

//Generated method caller for IShooter.tick
function sc__IShooter_tick takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_tick[si__IShooter_type[this]])
endfunction

//Generated method executor for IShooter.tick
function sx__IShooter_tick takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IShooter_tick[si__IShooter_type[this]])
endfunction
//Generated destructor of IShooter
function sc__IShooter_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IShooter_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_onDestroy[si__IShooter_type[this]])
    set si__IShooter_V[this]=si__IShooter_F
    set si__IShooter_F=this
endfunction

//Generated method caller for IMissle.doDamage
function sc__IMissle_doDamage takes integer this,real radius returns nothing
    set f__arg_this=this
    set f__arg_real1=radius
    call TriggerEvaluate(st__IMissle_doDamage[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.doDamage
function sx__IMissle_doDamage takes integer this,real radius returns nothing
    set f__arg_this=this
    set f__arg_real1=radius
    call TriggerExecute(st__IMissle_doDamage[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.getFinalDamage
function sc__IMissle_getFinalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getFinalDamage[si__IMissle_type[this]])
 return f__result_real
endfunction

//Generated method executor for IMissle.getFinalDamage
function sx__IMissle_getFinalDamage takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_getFinalDamage[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.fireMissle
function sc__IMissle_fireMissle takes integer this,integer vi returns nothing
    set f__arg_this=this
    set f__arg_integer1=vi
    call TriggerEvaluate(st__IMissle_fireMissle[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.fireMissle
function sx__IMissle_fireMissle takes integer this,integer vi returns nothing
    set f__arg_this=this
    set f__arg_integer1=vi
    call TriggerExecute(st__IMissle_fireMissle[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.onFire
function sc__IMissle_onFire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_onFire[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.onFire
function sx__IMissle_onFire takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_onFire[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.getOriginalDamage
function sc__IMissle_getOriginalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getOriginalDamage[si__IMissle_type[this]])
 return f__result_real
endfunction

//Generated method executor for IMissle.getOriginalDamage
function sx__IMissle_getOriginalDamage takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_getOriginalDamage[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.getMissleId
function sc__IMissle_getMissleId takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getMissleId[si__IMissle_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMissle.getMissleId
function sx__IMissle_getMissleId takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_getMissleId[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.step
function sc__IMissle_step takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_step[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.step
function sx__IMissle_step takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_step[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.getLife
function sc__IMissle_getLife takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getLife[si__IMissle_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IMissle.getLife
function sx__IMissle_getLife takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_getLife[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.substep
function sc__IMissle_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.substep
function sx__IMissle_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_substep[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.explode
function sc__IMissle_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.explode
function sx__IMissle_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_explode[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.damageEnemy
function sc__IMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.damageEnemy
function sx__IMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerExecute(st__IMissle_damageEnemy[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.debuffEnemy
function sc__IMissle_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.debuffEnemy
function sx__IMissle_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerExecute(st__IMissle_debuffEnemy[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.healAlly
function sc__IMissle_healAlly takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_healAlly[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.healAlly
function sx__IMissle_healAlly takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerExecute(st__IMissle_healAlly[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.hitSelf
function sc__IMissle_hitSelf takes integer this,unit self returns nothing
    set f__arg_this=this
    set f__arg_unit1=self
    call TriggerEvaluate(st__IMissle_hitSelf[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.hitSelf
function sx__IMissle_hitSelf takes integer this,unit self returns nothing
    set f__arg_this=this
    set f__arg_unit1=self
    call TriggerExecute(st__IMissle_hitSelf[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.refreshDamagedGroup
function sc__IMissle_refreshDamagedGroup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_refreshDamagedGroup[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.refreshDamagedGroup
function sx__IMissle_refreshDamagedGroup takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IMissle_refreshDamagedGroup[si__IMissle_type[this]])
endfunction

//Generated method caller for IMissle.troughDamage
function sc__IMissle_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_troughDamage[si__IMissle_type[this]])
endfunction

//Generated method executor for IMissle.troughDamage
function sx__IMissle_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerExecute(st__IMissle_troughDamage[si__IMissle_type[this]])
endfunction
//Generated destructor of IMissle
function sc__IMissle_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IMissle_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_onDestroy[si__IMissle_type[this]])
    set si__IMissle_V[this]=si__IMissle_F
    set si__IMissle_F=this
endfunction

//Generated method caller for MonsterTargetGroupManager.create
function sc__MonsterTargetGroupManager_create takes nothing returns integer
    call TriggerEvaluate(st__MonsterTargetGroupManager_create)
 return f__result_integer
endfunction

//Generated method caller for MonsterTargetGroupManager.onDestroy
function sc__MonsterTargetGroupManager_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MonsterTargetGroupManager_onDestroy)
endfunction

//Generated method caller for MonsterTargetGroupManager.periodic
function sc__MonsterTargetGroupManager_periodic takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MonsterTargetGroupManager_periodic)
endfunction

//Generated allocator of MonsterTargetGroupManager
function s__MonsterTargetGroupManager__allocate takes nothing returns integer
 local integer this=si__MonsterTargetGroupManager_F
    if (this!=0) then
        set si__MonsterTargetGroupManager_F=si__MonsterTargetGroupManager_V[this]
    else
        set si__MonsterTargetGroupManager_I=si__MonsterTargetGroupManager_I+1
        set this=si__MonsterTargetGroupManager_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__MonsterTargetGroupManager_V[this]=-1
 return this
endfunction

//Generated destructor of MonsterTargetGroupManager
function sc__MonsterTargetGroupManager_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MonsterTargetGroupManager_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__MonsterTargetGroupManager_onDestroy)
    set si__MonsterTargetGroupManager_V[this]=si__MonsterTargetGroupManager_F
    set si__MonsterTargetGroupManager_F=this
endfunction

//Generated method caller for IBufferStruct.condition
function sc__IBufferStruct_condition takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_condition[si__IBufferStruct_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for IBufferStruct.condition
function sx__IBufferStruct_condition takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IBufferStruct_condition[si__IBufferStruct_type[this]])
endfunction

//Generated method caller for IBufferStruct.addBuffer
function sc__IBufferStruct_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[si__IBufferStruct_type[this]])
endfunction

//Generated method executor for IBufferStruct.addBuffer
function sx__IBufferStruct_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IBufferStruct_addBuffer[si__IBufferStruct_type[this]])
endfunction

//Generated method caller for IBufferStruct.removeBuffer
function sc__IBufferStruct_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[si__IBufferStruct_type[this]])
endfunction

//Generated method executor for IBufferStruct.removeBuffer
function sx__IBufferStruct_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IBufferStruct_removeBuffer[si__IBufferStruct_type[this]])
endfunction

//Generated method caller for IBufferStruct.finish
function sc__IBufferStruct_finish takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_finish[si__IBufferStruct_type[this]])
endfunction

//Generated method executor for IBufferStruct.finish
function sx__IBufferStruct_finish takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IBufferStruct_finish[si__IBufferStruct_type[this]])
endfunction

//Generated method caller for IBufferStruct.init
function sc__IBufferStruct_init takes integer this,unit u,integer count returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_integer1=count
    call TriggerEvaluate(st__IBufferStruct_init[si__IBufferStruct_type[this]])
endfunction

//Generated method executor for IBufferStruct.init
function sx__IBufferStruct_init takes integer this,unit u,integer count returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_integer1=count
    call TriggerExecute(st__IBufferStruct_init[si__IBufferStruct_type[this]])
endfunction

//Generated method caller for IBufferStruct.action
function sc__IBufferStruct_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_action[si__IBufferStruct_type[this]])
endfunction

//Generated method executor for IBufferStruct.action
function sx__IBufferStruct_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IBufferStruct_action[si__IBufferStruct_type[this]])
endfunction
//Generated destructor of IBufferStruct
function sc__IBufferStruct_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IBufferStruct_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_onDestroy[si__IBufferStruct_type[this]])
    set si__IBufferStruct_V[this]=si__IBufferStruct_F
    set si__IBufferStruct_F=this
endfunction

//Generated allocator of ButtonTech
function s__ButtonTech__allocate takes nothing returns integer
 local integer this=si__ButtonTech_F
    if (this!=0) then
        set si__ButtonTech_F=si__ButtonTech_V[this]
    else
        set si__ButtonTech_I=si__ButtonTech_I+1
        set this=si__ButtonTech_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ButtonTech_V[this]=-1
 return this
endfunction

//Generated destructor of ButtonTech
function s__ButtonTech_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ButtonTech_V[this]!=-1) then
        return
    endif
    set si__ButtonTech_V[this]=si__ButtonTech_F
    set si__ButtonTech_F=this
endfunction

//Generated method caller for IDialog.init
function sc__IDialog_init takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_init[si__IDialog_type[this]])
endfunction

//Generated method executor for IDialog.init
function sx__IDialog_init takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IDialog_init[si__IDialog_type[this]])
endfunction

//Generated method caller for IDialog.display
function sc__IDialog_display takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_display[si__IDialog_type[this]])
endfunction

//Generated method executor for IDialog.display
function sx__IDialog_display takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IDialog_display[si__IDialog_type[this]])
endfunction

//Generated method caller for IDialog.button_clicked
function sc__IDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[si__IDialog_type[this]])
endfunction

//Generated method executor for IDialog.button_clicked
function sx__IDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerExecute(st__IDialog_button_clicked[si__IDialog_type[this]])
endfunction
//Generated destructor of IDialog
function sc__IDialog_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IDialog_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_onDestroy[si__IDialog_type[this]])
    set si__IDialog_V[this]=si__IDialog_F
    set si__IDialog_F=this
endfunction

//Generated method caller for IAIGroup.getInterval
function sc__IAIGroup_getInterval takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IAIGroup_getInterval[si__IAIGroup_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IAIGroup.getInterval
function sx__IAIGroup_getInterval takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IAIGroup_getInterval[si__IAIGroup_type[this]])
endfunction

//Generated method caller for IAIGroup.shouldLoop
function sc__IAIGroup_shouldLoop takes integer this,unit u returns boolean
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_shouldLoop[si__IAIGroup_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for IAIGroup.shouldLoop
function sx__IAIGroup_shouldLoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIGroup_shouldLoop[si__IAIGroup_type[this]])
endfunction

//Generated method caller for IAIGroup.afterLoop
function sc__IAIGroup_afterLoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_afterLoop[si__IAIGroup_type[this]])
endfunction

//Generated method executor for IAIGroup.afterLoop
function sx__IAIGroup_afterLoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIGroup_afterLoop[si__IAIGroup_type[this]])
endfunction

//Generated method caller for IAIGroup.ailoop
function sc__IAIGroup_ailoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_ailoop[si__IAIGroup_type[this]])
endfunction

//Generated method executor for IAIGroup.ailoop
function sx__IAIGroup_ailoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIGroup_ailoop[si__IAIGroup_type[this]])
endfunction

//Generated method caller for IAIGroup.addUnit
function sc__IAIGroup_addUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_addUnit[si__IAIGroup_type[this]])
endfunction

//Generated method executor for IAIGroup.addUnit
function sx__IAIGroup_addUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIGroup_addUnit[si__IAIGroup_type[this]])
endfunction

//Generated method caller for IAIGroup.removeUnit
function sc__IAIGroup_removeUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_removeUnit[si__IAIGroup_type[this]])
endfunction

//Generated method executor for IAIGroup.removeUnit
function sx__IAIGroup_removeUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIGroup_removeUnit[si__IAIGroup_type[this]])
endfunction
//Generated destructor of IAIGroup
function sc__IAIGroup_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IAIGroup_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IAIGroup_onDestroy[si__IAIGroup_type[this]])
    set si__IAIGroup_V[this]=si__IAIGroup_F
    set si__IAIGroup_F=this
endfunction

//Generated method caller for AIData._staticgetindex
function sc__AIData__staticgetindex takes unit whichUnit returns integer
    set f__arg_unit1=whichUnit
    call TriggerEvaluate(st__AIData__staticgetindex)
 return f__result_integer
endfunction

//Generated method caller for AIData.AIDS_filter
function sc__AIData_AIDS_filter takes unit u returns boolean
    set f__arg_unit1=u
    call TriggerEvaluate(st__AIData_AIDS_filter)
 return f__result_boolean
endfunction

//Generated method caller for AIData.AIDS_onCreate
function sc__AIData_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AIData_AIDS_onCreate)
endfunction

//Generated method caller for AIData.AIDS_onDestroy
function sc__AIData_AIDS_onDestroy takes integer this returns nothing
set s__AIData_currentAIGroup[this]=0
set s__AIData_targetUnit[this]=null
endfunction

//Generated method caller for RealMan.onDestroy
function sc__RealMan_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__RealMan_onDestroy)
endfunction

//Generated allocator of RealMan
function s__RealMan__allocate takes nothing returns integer
 local integer this=si__RealMan_F
    if (this!=0) then
        set si__RealMan_F=si__RealMan_V[this]
    else
        set si__RealMan_I=si__RealMan_I+1
        set this=si__RealMan_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__RealMan_List___prev[this]= 0
   set s__RealMan_List___next[this]= 0
   set s__RealMan_List___inlist[this]= false
    set si__RealMan_V[this]=-1
 return this
endfunction

//Generated destructor of RealMan
function sc__RealMan_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__RealMan_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__RealMan_onDestroy)
    set si__RealMan_V[this]=si__RealMan_F
    set si__RealMan_F=this
endfunction

//Generated method caller for Status._get_unit
function sc__Status__get_unit takes integer this returns unit
    set f__arg_this=this
    call TriggerEvaluate(st__Status__get_unit)
 return f__result_unit
endfunction

//Generated method caller for Status.stopPeriodic
function sc__Status_stopPeriodic takes integer this returns nothing
            if s__Status_T32xs___runningPeriodic[this] then
                // This is some real magic.
                set s__Status_T32xs___next[s__Status_T32xs___prev[this]]=s__Status_T32xs___next[this]
                set s__Status_T32xs___prev[s__Status_T32xs___next[this]]=s__Status_T32xs___prev[this]
                // This will even work for the starting element.
                
                set s__Status_T32xs___runningPeriodic[this]=false
            endif
endfunction

//Generated allocator of SpellStruct__ChainAttach
function s__SpellStruct__ChainAttach__allocate takes nothing returns integer
 local integer this=si__SpellStruct__ChainAttach_F
    if (this!=0) then
        set si__SpellStruct__ChainAttach_F=si__SpellStruct__ChainAttach_V[this]
    else
        set si__SpellStruct__ChainAttach_I=si__SpellStruct__ChainAttach_I+1
        set this=si__SpellStruct__ChainAttach_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__SpellStruct__ChainAttach_V[this]=-1
 return this
endfunction

//Generated destructor of SpellStruct__ChainAttach
function s__SpellStruct__ChainAttach_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__SpellStruct__ChainAttach_V[this]!=-1) then
        return
    endif
    set si__SpellStruct__ChainAttach_V[this]=si__SpellStruct__ChainAttach_F
    set si__SpellStruct__ChainAttach_F=this
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onCreate
function sc__SpellStruct__DefaultsInterface_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onCreate[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onCreate
function sx__SpellStruct__DefaultsInterface_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onCreate[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onChannel
function sc__SpellStruct__DefaultsInterface_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onChannel
function sx__SpellStruct__DefaultsInterface_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onChannel[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onStartCast
function sc__SpellStruct__DefaultsInterface_onStartCast takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onStartCast[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onStartCast
function sx__SpellStruct__DefaultsInterface_onStartCast takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onStartCast[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onEffect
function sc__SpellStruct__DefaultsInterface_onEffect takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onEffect[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onEffect
function sx__SpellStruct__DefaultsInterface_onEffect takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onEffect[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onFinish
function sc__SpellStruct__DefaultsInterface_onFinish takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onFinish[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onFinish
function sx__SpellStruct__DefaultsInterface_onFinish takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onFinish[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.onStopCast
function sc__SpellStruct__DefaultsInterface_onStopCast takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onStopCast[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.onStopCast
function sx__SpellStruct__DefaultsInterface_onStopCast takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_onStopCast[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method caller for SpellStruct__DefaultsInterface.cleanup
function sc__SpellStruct__DefaultsInterface_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[si__SpellStruct__DefaultsInterface_type[this]])
endfunction

//Generated method executor for SpellStruct__DefaultsInterface.cleanup
function sx__SpellStruct__DefaultsInterface_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__SpellStruct__DefaultsInterface_cleanup[si__SpellStruct__DefaultsInterface_type[this]])
endfunction
//Generated destructor of SpellStruct__DefaultsInterface
function sc__SpellStruct__DefaultsInterface_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__SpellStruct__DefaultsInterface_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onDestroy[si__SpellStruct__DefaultsInterface_type[this]])
    set si__SpellStruct__DefaultsInterface_V[this]=si__SpellStruct__DefaultsInterface_F
    set si__SpellStruct__DefaultsInterface_F=this
endfunction

//Generated allocator of ItemTypeData
function s__ItemTypeData__allocate takes nothing returns integer
 local integer this=si__ItemTypeData_F
    if (this!=0) then
        set si__ItemTypeData_F=si__ItemTypeData_V[this]
    else
        set si__ItemTypeData_I=si__ItemTypeData_I+1
        set this=si__ItemTypeData_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ItemTypeData_V[this]=-1
 return this
endfunction

//Generated destructor of ItemTypeData
function s__ItemTypeData_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ItemTypeData_V[this]!=-1) then
        return
    endif
    set si__ItemTypeData_V[this]=si__ItemTypeData_F
    set si__ItemTypeData_F=this
endfunction

//Generated method caller for ItemFeatureData.construct
function sc__ItemFeatureData_construct takes integer did returns integer
    set f__arg_integer1=did
    call TriggerEvaluate(st__ItemFeatureData_construct)
 return f__result_integer
endfunction

//Generated allocator of ItemFeatureData
function s__ItemFeatureData__allocate takes nothing returns integer
 local integer this=si__ItemFeatureData_F
    if (this!=0) then
        set si__ItemFeatureData_F=si__ItemFeatureData_V[this]
    else
        set si__ItemFeatureData_I=si__ItemFeatureData_I+1
        set this=si__ItemFeatureData_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ItemFeatureData_V[this]=-1
 return this
endfunction

//Generated destructor of ItemFeatureData
function s__ItemFeatureData_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ItemFeatureData_V[this]!=-1) then
        return
    endif
    set si__ItemFeatureData_V[this]=si__ItemFeatureData_F
    set si__ItemFeatureData_F=this
endfunction

//Generated method caller for IndividualItemData._get_item
function sc__IndividualItemData__get_item takes integer this returns item
    set f__arg_this=this
    call TriggerEvaluate(st__IndividualItemData__get_item)
 return f__result_item
endfunction

//Generated allocator of ItemFeature
function s__ItemFeature__allocate takes nothing returns integer
 local integer this=si__ItemFeature_F
    if (this!=0) then
        set si__ItemFeature_F=si__ItemFeature_V[this]
    else
        set si__ItemFeature_I=si__ItemFeature_I+1
        set this=si__ItemFeature_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ItemFeature_V[this]=-1
 return this
endfunction

//Generated destructor of ItemFeature
function s__ItemFeature_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ItemFeature_V[this]!=-1) then
        return
    endif
    set si__ItemFeature_V[this]=si__ItemFeature_F
    set si__ItemFeature_F=this
endfunction

//Generated method caller for IGun.fire
function sc__IGun_fire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_fire[si__IGun_type[this]])
endfunction

//Generated method executor for IGun.fire
function sx__IGun_fire takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IGun_fire[si__IGun_type[this]])
endfunction

//Generated method caller for IGun.stopFire
function sc__IGun_stopFire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_stopFire[si__IGun_type[this]])
endfunction

//Generated method executor for IGun.stopFire
function sx__IGun_stopFire takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IGun_stopFire[si__IGun_type[this]])
endfunction

//Generated method caller for IGun.getGunType
function sc__IGun_getGunType takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_getGunType[si__IGun_type[this]])
 return f__result_integer
endfunction

//Generated method executor for IGun.getGunType
function sx__IGun_getGunType takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__IGun_getGunType[si__IGun_type[this]])
endfunction

//Generated method caller for IGun.setOwner
function sc__IGun_setOwner takes integer this,unit owner returns nothing
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerEvaluate(st__IGun_setOwner[si__IGun_type[this]])
endfunction

//Generated method executor for IGun.setOwner
function sx__IGun_setOwner takes integer this,unit owner returns nothing
    set f__arg_this=this
    set f__arg_unit1=owner
    call TriggerExecute(st__IGun_setOwner[si__IGun_type[this]])
endfunction
//Generated destructor of IGun
function sc__IGun_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IGun_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_onDestroy[si__IGun_type[this]])
    set si__IGun_V[this]=si__IGun_F
    set si__IGun_F=this
endfunction

//Generated method caller for EquipmentData._staticgetindex
function sc__EquipmentData__staticgetindex takes unit whichUnit returns integer
    set f__arg_unit1=whichUnit
    call TriggerEvaluate(st__EquipmentData__staticgetindex)
 return f__result_integer
endfunction

//Generated method caller for EquipmentData.AIDS_filter
function sc__EquipmentData_AIDS_filter takes unit u returns boolean
    set f__arg_unit1=u
    call TriggerEvaluate(st__EquipmentData_AIDS_filter)
 return f__result_boolean
endfunction

//Generated method caller for EquipmentData.AIDS_onCreate
function sc__EquipmentData_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__EquipmentData_AIDS_onCreate)
endfunction

//Generated method caller for EquipmentData.AIDS_onDestroy
function sc__EquipmentData_AIDS_onDestroy takes integer this returns nothing
        
endfunction

//Generated method caller for EquipmentData.periodic
function sc__EquipmentData_periodic takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__EquipmentData_periodic)
endfunction

//Generated method caller for Damage__Detector.AIDS_onCreate
function sc__Damage__Detector_AIDS_onCreate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Damage__Detector_AIDS_onCreate)
endfunction

//Generated method caller for Damage__Detector.AIDS_onDestroy
function sc__Damage__Detector_AIDS_onDestroy takes integer this returns nothing
            call DestroyTrigger(s__Damage__Detector_t[this])
endfunction

//Generated method caller for Damage__Detector.AIDS_onInit
function sc__Damage__Detector_AIDS_onInit takes nothing returns nothing
    call TriggerEvaluate(st__Damage__Detector_AIDS_onInit)
endfunction

//Generated method caller for IAIStrategy.targetInRange
function sc__IAIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_unit2=tu
    set f__arg_real1=r
    call TriggerEvaluate(st__IAIStrategy_targetInRange[si__IAIStrategy_type[this]])
endfunction

//Generated method executor for IAIStrategy.targetInRange
function sx__IAIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_unit2=tu
    set f__arg_real1=r
    call TriggerExecute(st__IAIStrategy_targetInRange[si__IAIStrategy_type[this]])
endfunction

//Generated method caller for IAIStrategy.targetOutRange
function sc__IAIStrategy_targetOutRange takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_targetOutRange[si__IAIStrategy_type[this]])
endfunction

//Generated method executor for IAIStrategy.targetOutRange
function sx__IAIStrategy_targetOutRange takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIStrategy_targetOutRange[si__IAIStrategy_type[this]])
endfunction

//Generated method caller for IAIStrategy.beHurted
function sc__IAIStrategy_beHurted takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_beHurted[si__IAIStrategy_type[this]])
endfunction

//Generated method executor for IAIStrategy.beHurted
function sx__IAIStrategy_beHurted takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIStrategy_beHurted[si__IAIStrategy_type[this]])
endfunction

//Generated method caller for IAIStrategy.getInMap
function sc__IAIStrategy_getInMap takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_getInMap[si__IAIStrategy_type[this]])
endfunction

//Generated method executor for IAIStrategy.getInMap
function sx__IAIStrategy_getInMap takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__IAIStrategy_getInMap[si__IAIStrategy_type[this]])
endfunction

//Generated method caller for IAIStrategy.support
function sc__IAIStrategy_support takes integer this,integer typeid returns boolean
    set f__arg_this=this
    set f__arg_integer1=typeid
    call TriggerEvaluate(st__IAIStrategy_support[si__IAIStrategy_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for IAIStrategy.support
function sx__IAIStrategy_support takes integer this,integer typeid returns nothing
    set f__arg_this=this
    set f__arg_integer1=typeid
    call TriggerExecute(st__IAIStrategy_support[si__IAIStrategy_type[this]])
endfunction
//Generated destructor of IAIStrategy
function sc__IAIStrategy_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__IAIStrategy_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__IAIStrategy_onDestroy[si__IAIStrategy_type[this]])
    set si__IAIStrategy_V[this]=si__IAIStrategy_F
    set si__IAIStrategy_F=this
endfunction

//Generated method caller for vector.setLength
function sc__vector_setLength takes integer this,real length returns nothing
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this] + s__vector_z[this] * s__vector_z[this])
            if l == 0.0 then
                return
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
            set s__vector_z[this]=s__vector_z[this] * l
endfunction

//Generated allocator of vector
function s__vector__allocate takes nothing returns integer
 local integer this=si__vector_F
    if (this!=0) then
        set si__vector_F=si__vector_V[this]
    else
        set si__vector_I=si__vector_I+1
        set this=si__vector_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__vector_V[this]=-1
 return this
endfunction

//Generated destructor of vector
function s__vector_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__vector_V[this]!=-1) then
        return
    endif
    set si__vector_V[this]=si__vector_F
    set si__vector_F=this
endfunction

//Generated allocator of TechTree
function s__TechTree__allocate takes nothing returns integer
 local integer this=si__TechTree_F
    if (this!=0) then
        set si__TechTree_F=si__TechTree_V[this]
    else
        set si__TechTree_I=si__TechTree_I+1
        set this=si__TechTree_I
    endif
    if (this>126) then
        return 0
    endif
    set s__TechTree_itms[this]=(this-1)*64
    set si__TechTree_V[this]=-1
 return this
endfunction

//Generated destructor of TechTree
function s__TechTree_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__TechTree_V[this]!=-1) then
        return
    endif
    set si__TechTree_V[this]=si__TechTree_F
    set si__TechTree_F=this
endfunction

//Generated allocator of TechData
function s__TechData__allocate takes nothing returns integer
 local integer this=si__TechData_F
    if (this!=0) then
        set si__TechData_F=si__TechData_V[this]
    else
        set si__TechData_I=si__TechData_I+1
        set this=si__TechData_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__TechData_V[this]=-1
 return this
endfunction

//Generated destructor of TechData
function s__TechData_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__TechData_V[this]!=-1) then
        return
    endif
    set si__TechData_V[this]=si__TechData_F
    set si__TechData_F=this
endfunction

//Generated method caller for AbstractShooter.tick
function sc__AbstractShooter_tick takes integer this returns nothing
endfunction

//Generated method caller for AbstractShooter.periodic
function sc__AbstractShooter_periodic takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__AbstractShooter_periodic)
endfunction

//Generated method caller for AbstractShooter.create
function sc__AbstractShooter_create takes unit owner,integer factory returns integer
    set f__arg_unit1=owner
    set f__arg_integer1=factory
    call TriggerEvaluate(st__AbstractShooter_create)
 return f__result_integer
endfunction

//Generated method caller for AbstractShooter.shoothz
function sc__AbstractShooter_shoothz takes integer this returns integer
        return 10
endfunction

//Generated method caller for AbstractShooter.getClipSize
function sc__AbstractShooter_getClipSize takes integer this returns integer
        return 10
endfunction

//Generated method caller for AbstractShooter.shootCount
function sc__AbstractShooter_shootCount takes integer this returns integer
        return 1
endfunction

//Generated method caller for AbstractShooter.getRist
function sc__AbstractShooter_getRist takes integer this returns real
        return 100.0
endfunction

//Generated method caller for AbstractShooter.getOriginSpeed
function sc__AbstractShooter_getOriginSpeed takes integer this returns real
        return 60.0
endfunction

//Generated method caller for AbstractShooter.shoot
function sc__AbstractShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[140])
endfunction

//Generated method caller for AbstractShooter.getEnergyConsume
function sc__AbstractShooter_getEnergyConsume takes integer this returns integer
        return 1
endfunction

//Generated method caller for AbstractShooter.subshoot
function sc__AbstractShooter_subshoot takes integer this,integer dir returns nothing
endfunction

//Generated method caller for AbstractShooter.onDestroy
function sc__AbstractShooter_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_onDestroy[140])
endfunction

//Generated allocator of AbstractShooter
function s__AbstractShooter__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IShooter_F
    if (this!=0) then
        set si__IShooter_F=si__IShooter_V[this]
    else
        set si__IShooter_I=si__IShooter_I+1
        set this=si__IShooter_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IShooter_type[this]=140
    set kthis=this

    set si__IShooter_V[this]=-1
 return this
endfunction


//Generated method caller for DefaultAIStrategy.create
function sc__DefaultAIStrategy_create takes nothing returns integer
    call TriggerEvaluate(st__DefaultAIStrategy_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultAIStrategy.onDestroy
function sc__DefaultAIStrategy_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IAIStrategy_onDestroy[81])
endfunction

//Generated method caller for DefaultAIStrategy.support
function sc__DefaultAIStrategy_support takes integer this,integer typeid returns boolean
return false
endfunction

//Generated method caller for DefaultAIStrategy.targetInRange
function sc__DefaultAIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
endfunction

//Generated method caller for DefaultAIStrategy.targetOutRange
function sc__DefaultAIStrategy_targetOutRange takes integer this,unit u returns nothing
endfunction

//Generated method caller for DefaultAIStrategy.beHurted
function sc__DefaultAIStrategy_beHurted takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_beHurted[81])
endfunction

//Generated method caller for DefaultAIStrategy.getInMap
function sc__DefaultAIStrategy_getInMap takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_getInMap[81])
endfunction

//Generated allocator of DefaultAIStrategy
function s__DefaultAIStrategy__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IAIStrategy_F
    if (this!=0) then
        set si__IAIStrategy_F=si__IAIStrategy_V[this]
    else
        set si__IAIStrategy_I=si__IAIStrategy_I+1
        set this=si__IAIStrategy_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IAIStrategy_type[this]=81
    set kthis=this

   set s__DefaultAIStrategy_List___prev[this]= 0
   set s__DefaultAIStrategy_List___next[this]= 0
   set s__DefaultAIStrategy_List___inlist[this]= false
    set si__IAIStrategy_V[this]=-1
 return this
endfunction


//Generated method caller for Boss1AIStrategy.targetInRange
function sc__Boss1AIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_unit2=tu
    set f__arg_real1=r
    call TriggerEvaluate(st__IAIStrategy_targetInRange[82])
endfunction

//Generated method caller for Boss1AIStrategy.targetOutRange
function sc__Boss1AIStrategy_targetOutRange takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIStrategy_targetOutRange[82])
endfunction

//Generated method caller for Boss1AIStrategy.support
function sc__Boss1AIStrategy_support takes integer this,integer typeid returns boolean
    if typeid == 'u002' or typeid == 'u004' then
        return true
    endif
    return false
endfunction

//Generated allocator of Boss1AIStrategy
function s__Boss1AIStrategy__allocate takes nothing returns integer
 local integer this=sc__DefaultAIStrategy_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IAIStrategy_type[this]=82
    set kthis=this

 return this
endfunction


//Generated method caller for DefaultGun.fire
function sc__DefaultGun_fire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_fire[86])
endfunction

//Generated method caller for DefaultGun.setOwner
function sc__DefaultGun_setOwner takes integer this,unit owner returns nothing
        set s__IShooter_owner[s__IGun_shooter[this]]=owner
endfunction

//Generated method caller for DefaultGun.stopFire
function sc__DefaultGun_stopFire takes integer this returns nothing
endfunction

//Generated method caller for DefaultGun.getGunType
function sc__DefaultGun_getGunType takes integer this returns integer
        return SHOOT_GUN
endfunction

//Generated method caller for DefaultGun.create
function sc__DefaultGun_create takes unit owner,integer ifd returns integer
    set f__arg_unit1=owner
    set f__arg_integer1=ifd
    call TriggerEvaluate(st__DefaultGun_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultGun.onDestroy
function sc__DefaultGun_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IGun_onDestroy[86])
endfunction

//Generated allocator of DefaultGun
function s__DefaultGun__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IGun_F
    if (this!=0) then
        set si__IGun_F=si__IGun_V[this]
    else
        set si__IGun_I=si__IGun_I+1
        set this=si__IGun_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IGun_type[this]=86
    set kthis=this

    set si__IGun_V[this]=-1
 return this
endfunction


//Generated allocator of FireShotgun
function s__FireShotgun__allocate takes unit owner ,integer ifd returns integer
 local integer this=sc__DefaultGun_create(owner,ifd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IGun_type[this]=87
    set kthis=this

 return this
endfunction


//Generated allocator of HumanRifle
function s__HumanRifle__allocate takes unit owner ,integer ifd returns integer
 local integer this=sc__DefaultGun_create(owner,ifd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IGun_type[this]=88
    set kthis=this

 return this
endfunction


//Generated allocator of SpearRifle
function s__SpearRifle__allocate takes unit owner ,integer ifd returns integer
 local integer this=sc__DefaultGun_create(owner,ifd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IGun_type[this]=89
    set kthis=this

 return this
endfunction


//Generated allocator of IceMachineGun
function s__IceMachineGun__allocate takes unit owner ,integer ifd returns integer
 local integer this=sc__DefaultGun_create(owner,ifd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IGun_type[this]=90
    set kthis=this

 return this
endfunction


//Generated allocator of FireMachineGun
function s__FireMachineGun__allocate takes unit owner ,integer ifd returns integer
 local integer this=sc__DefaultGun_create(owner,ifd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IGun_type[this]=91
    set kthis=this

 return this
endfunction


//Generated method caller for SpellStruct._get_isNotLocked
function sc__SpellStruct__get_isNotLocked takes integer this returns boolean
            return s__SpellStruct_lockLevel[this] == 0
endfunction

//Generated method caller for SpellStruct._get_casterX
function sc__SpellStruct__get_casterX takes integer this returns real
            return GetUnitX(s__SpellStruct_caster[this])
endfunction

//Generated method caller for SpellStruct._get_casterY
function sc__SpellStruct__get_casterY takes integer this returns real
            return GetUnitY(s__SpellStruct_caster[this])
endfunction

//Generated method caller for SpellStruct.create
function sc__SpellStruct_create takes nothing returns integer
    call TriggerEvaluate(st__SpellStruct_create)
 return f__result_integer
endfunction

//Generated method caller for SpellStruct.destroy
function sc__SpellStruct_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct_destroy)
endfunction

//Generated allocator of SpellStruct
function s__SpellStruct__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__SpellStruct__DefaultsInterface_F
    if (this!=0) then
        set si__SpellStruct__DefaultsInterface_F=si__SpellStruct__DefaultsInterface_V[this]
    else
        set si__SpellStruct__DefaultsInterface_I=si__SpellStruct__DefaultsInterface_I+1
        set this=si__SpellStruct__DefaultsInterface_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__SpellStruct__DefaultsInterface_type[this]=100
    set kthis=this

   set s__SpellStruct_hasStoppedCasting[this]=false
   set s__SpellStruct_lockLevel[this]=0
    set si__SpellStruct__DefaultsInterface_V[this]=-1
 return this
endfunction


//Generated method caller for DefaultAIGroup.create
function sc__DefaultAIGroup_create takes nothing returns integer
    call TriggerEvaluate(st__DefaultAIGroup_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultAIGroup.shouldLoop
function sc__DefaultAIGroup_shouldLoop takes integer this,unit u returns boolean
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_shouldLoop[106])
 return f__result_boolean
endfunction

//Generated method caller for DefaultAIGroup.afterLoop
function sc__DefaultAIGroup_afterLoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_afterLoop[106])
endfunction

//Generated method caller for DefaultAIGroup.getInterval
function sc__DefaultAIGroup_getInterval takes integer this returns integer
    return 15
endfunction

//Generated method caller for DefaultAIGroup.ailoop
function sc__DefaultAIGroup_ailoop takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_ailoop[106])
endfunction

//Generated method caller for DefaultAIGroup.onDestroy
function sc__DefaultAIGroup_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IAIGroup_onDestroy[106])
endfunction

//Generated method caller for DefaultAIGroup.periodic
function sc__DefaultAIGroup_periodic takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__DefaultAIGroup_periodic)
endfunction

//Generated method caller for DefaultAIGroup.addUnit
function sc__DefaultAIGroup_addUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_addUnit[106])
endfunction

//Generated method caller for DefaultAIGroup.removeUnit
function sc__DefaultAIGroup_removeUnit takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__IAIGroup_removeUnit[106])
endfunction

//Generated allocator of DefaultAIGroup
function s__DefaultAIGroup__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IAIGroup_F
    if (this!=0) then
        set si__IAIGroup_F=si__IAIGroup_V[this]
    else
        set si__IAIGroup_I=si__IAIGroup_I+1
        set this=si__IAIGroup_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IAIGroup_type[this]=106
    set kthis=this

    set si__IAIGroup_V[this]=-1
 return this
endfunction


//Generated method caller for DefaultDialog.create
function sc__DefaultDialog_create takes string name,player p returns integer
    set f__arg_string1=name
    set f__arg_player1=p
    call TriggerEvaluate(st__DefaultDialog_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultDialog.button_clicked
function sc__DefaultDialog_button_clicked takes integer this,button b returns nothing
endfunction

//Generated method caller for DefaultDialog.init
function sc__DefaultDialog_init takes integer this returns nothing
endfunction

//Generated method caller for DefaultDialog.onDestroy
function sc__DefaultDialog_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_onDestroy[109])
endfunction

//Generated method caller for DefaultDialog.display
function sc__DefaultDialog_display takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_display[109])
endfunction

//Generated allocator of DefaultDialog
function s__DefaultDialog__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IDialog_F
    if (this!=0) then
        set si__IDialog_F=si__IDialog_V[this]
    else
        set si__IDialog_I=si__IDialog_I+1
        set this=si__IDialog_I
    endif
    if (this>408) then
        return 0
    endif
    set s__IDialog_choses[this]=(this-1)*20
    set si__IDialog_type[this]=109
    set kthis=this

    set si__IDialog_V[this]=-1
 return this
endfunction


//Generated method caller for ChangeAbDialog.create
function sc__ChangeAbDialog_create takes string name,player p,integer t,integer oi,integer ni returns integer
    set f__arg_string1=name
    set f__arg_player1=p
    set f__arg_integer1=t
    set f__arg_integer2=oi
    set f__arg_integer3=ni
    call TriggerEvaluate(st__ChangeAbDialog_create)
 return f__result_integer
endfunction

//Generated method caller for ChangeAbDialog.button_clicked
function sc__ChangeAbDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[110])
endfunction

//Generated method caller for ChangeAbDialog.init
function sc__ChangeAbDialog_init takes integer this returns nothing
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
endfunction

//Generated allocator of ChangeAbDialog
function s__ChangeAbDialog__allocate takes string name ,player p returns integer
 local integer this=sc__DefaultDialog_create(name,p)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=110
    set kthis=this

 return this
endfunction


//Generated method caller for ChangeGunDialog.create
function sc__ChangeGunDialog_create takes string name,player p,integer t,integer oi,integer ni,item itm returns integer
    set f__arg_string1=name
    set f__arg_player1=p
    set f__arg_integer1=t
    set f__arg_integer2=oi
    set f__arg_integer3=ni
    set f__arg_item1=itm
    call TriggerEvaluate(st__ChangeGunDialog_create)
 return f__result_integer
endfunction

//Generated method caller for ChangeGunDialog.button_clicked
function sc__ChangeGunDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[111])
endfunction

//Generated method caller for ChangeGunDialog.init
function sc__ChangeGunDialog_init takes integer this returns nothing
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
endfunction

//Generated allocator of ChangeGunDialog
function s__ChangeGunDialog__allocate takes string name ,player p returns integer
 local integer this=sc__DefaultDialog_create(name,p)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=111
    set kthis=this

 return this
endfunction


//Generated method caller for TransformDialog.create
function sc__TransformDialog_create takes string name,player p,integer fd returns integer
    set f__arg_string1=name
    set f__arg_player1=p
    set f__arg_integer1=fd
    call TriggerEvaluate(st__TransformDialog_create)
 return f__result_integer
endfunction

//Generated method caller for TransformDialog.button_clicked
function sc__TransformDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[112])
endfunction

//Generated method caller for TransformDialog.init
function sc__TransformDialog_init takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_init[112])
endfunction

//Generated allocator of TransformDialog
function s__TransformDialog__allocate takes string name ,player p returns integer
 local integer this=sc__DefaultDialog_create(name,p)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=112
    set kthis=this

 return this
endfunction


//Generated method caller for FreeTransformDialog.button_clicked
function sc__FreeTransformDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[113])
endfunction

//Generated allocator of FreeTransformDialog
function s__FreeTransformDialog__allocate takes string name ,player p ,integer fd returns integer
 local integer this=sc__TransformDialog_create(name,p,fd)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=113
    set kthis=this

 return this
endfunction


//Generated method caller for ChooseTechDialog.button_clicked
function sc__ChooseTechDialog_button_clicked takes integer this,button b returns nothing
    set f__arg_this=this
    set f__arg_button1=b
    call TriggerEvaluate(st__IDialog_button_clicked[115])
endfunction

//Generated method caller for ChooseTechDialog.init
function sc__ChooseTechDialog_init takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_init[115])
endfunction

//Generated method caller for ChooseTechDialog.display
function sc__ChooseTechDialog_display takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_display[115])
endfunction

//Generated allocator of ChooseTechDialog
function s__ChooseTechDialog__allocate takes string name ,player p returns integer
 local integer this=sc__DefaultDialog_create(name,p)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=115
    set kthis=this

 return this
endfunction


//Generated method caller for ChooseBonusDialog.button_clicked
function sc__ChooseBonusDialog_button_clicked takes integer this,button b returns nothing
        call SetPlayerStateBJ(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD) + 100)
endfunction

//Generated method caller for ChooseBonusDialog.init
function sc__ChooseBonusDialog_init takes integer this returns nothing
        local button b
        local unit hero= heros[GetPlayerId(s__IDialog_p[this])]
        set b=DialogAddButton(s__IDialog_d[this], "閲戝竵+100", 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
endfunction

//Generated method caller for ChooseBonusDialog.display
function sc__ChooseBonusDialog_display takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IDialog_display[116])
endfunction

//Generated allocator of ChooseBonusDialog
function s__ChooseBonusDialog__allocate takes string name ,player p returns integer
 local integer this=sc__DefaultDialog_create(name,p)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IDialog_type[this]=116
    set kthis=this

 return this
endfunction


//Generated method caller for DefaultBufferStruct.condition
function sc__DefaultBufferStruct_condition takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_condition[118])
 return f__result_boolean
endfunction

//Generated method caller for DefaultBufferStruct.action
function sc__DefaultBufferStruct_action takes integer this returns nothing
endfunction

//Generated method caller for DefaultBufferStruct.addBuffer
function sc__DefaultBufferStruct_addBuffer takes integer this returns nothing
endfunction

//Generated method caller for DefaultBufferStruct.removeBuffer
function sc__DefaultBufferStruct_removeBuffer takes integer this returns nothing
endfunction

//Generated method caller for DefaultBufferStruct.init
function sc__DefaultBufferStruct_init takes integer this,unit u,integer count returns nothing
endfunction

//Generated method caller for DefaultBufferStruct.start
function sc__DefaultBufferStruct_start takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__DefaultBufferStruct_start)
endfunction

//Generated method caller for DefaultBufferStruct.create
function sc__DefaultBufferStruct_create takes unit u,integer count returns integer
    set f__arg_unit1=u
    set f__arg_integer1=count
    call TriggerEvaluate(st__DefaultBufferStruct_create)
 return f__result_integer
endfunction

//Generated method caller for DefaultBufferStruct.onDestroy
function sc__DefaultBufferStruct_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_onDestroy[118])
endfunction

//Generated method caller for DefaultBufferStruct.finish
function sc__DefaultBufferStruct_finish takes integer this returns nothing
endfunction

//Generated method caller for DefaultBufferStruct.loopMoveAll
function sc__DefaultBufferStruct_loopMoveAll takes nothing returns nothing
    call TriggerEvaluate(st__DefaultBufferStruct_loopMoveAll)
endfunction

//Generated allocator of DefaultBufferStruct
function s__DefaultBufferStruct__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IBufferStruct_F
    if (this!=0) then
        set si__IBufferStruct_F=si__IBufferStruct_V[this]
    else
        set si__IBufferStruct_I=si__IBufferStruct_I+1
        set this=si__IBufferStruct_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IBufferStruct_type[this]=118
    set kthis=this

   set s__DefaultBufferStruct_List___prev[this]= 0
   set s__DefaultBufferStruct_List___next[this]= 0
   set s__DefaultBufferStruct_List___inlist[this]= false
    set si__IBufferStruct_V[this]=-1
 return this
endfunction


//Generated method caller for BoundUnitEffectStruct.addBuffer
function sc__BoundUnitEffectStruct_addBuffer takes integer this returns nothing
        set s__BoundUnitEffectStruct_eu[this]=CreateUnit(GetOwningPlayer(s__IBufferStruct_u[this]), s__BoundUnitEffectStruct_uid[this], GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), GetUnitFacing(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_bais[this])
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
        call SetUnitAnimation(s__BoundUnitEffectStruct_eu[this], s__BoundUnitEffectStruct_animate[this])
endfunction

//Generated method caller for BoundUnitEffectStruct.action
function sc__BoundUnitEffectStruct_action takes integer this returns nothing
        call SetUnitX(s__BoundUnitEffectStruct_eu[this], GetUnitX(s__IBufferStruct_u[this]))
        call SetUnitY(s__BoundUnitEffectStruct_eu[this], GetUnitY(s__IBufferStruct_u[this]))
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
endfunction

//Generated method caller for BoundUnitEffectStruct.removeBuffer
function sc__BoundUnitEffectStruct_removeBuffer takes integer this returns nothing
        call KillUnit(s__BoundUnitEffectStruct_eu[this])
endfunction

//Generated method caller for BoundUnitEffectStruct.finish
function sc__BoundUnitEffectStruct_finish takes integer this returns nothing
        set s__BoundUnitEffectStruct_eu[this]=null
endfunction

//Generated allocator of BoundUnitEffectStruct
function s__BoundUnitEffectStruct__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=119
    set kthis=this

 return this
endfunction


//Generated method caller for ElectricWhipBufferStruct.condition
function sc__ElectricWhipBufferStruct_condition takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_condition[120])
 return f__result_boolean
endfunction

//Generated method caller for ElectricWhipBufferStruct.addBuffer
function sc__ElectricWhipBufferStruct_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[120])
endfunction

//Generated method caller for ElectricWhipBufferStruct.action
function sc__ElectricWhipBufferStruct_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_action[120])
endfunction

//Generated method caller for ElectricWhipBufferStruct.removeBuffer
function sc__ElectricWhipBufferStruct_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[120])
endfunction

//Generated method caller for ElectricWhipBufferStruct.finish
function sc__ElectricWhipBufferStruct_finish takes integer this returns nothing
endfunction

//Generated allocator of ElectricWhipBufferStruct
function s__ElectricWhipBufferStruct__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=120
    set kthis=this

 return this
endfunction


//Generated method caller for PushForceStruct.addBuffer
function sc__PushForceStruct_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[122])
endfunction

//Generated method caller for PushForceStruct.removeBuffer
function sc__PushForceStruct_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[122])
endfunction

//Generated method caller for PushForceStruct.create
function sc__PushForceStruct_create takes unit u,integer count,integer fc returns integer
    set f__arg_unit1=u
    set f__arg_integer1=count
    set f__arg_integer2=fc
    call TriggerEvaluate(st__PushForceStruct_create)
 return f__result_integer
endfunction

//Generated method caller for PushForceStruct.finish
function sc__PushForceStruct_finish takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_finish[122])
endfunction

//Generated allocator of PushForceStruct
function s__PushForceStruct__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=122
    set kthis=this

 return this
endfunction


//Generated method caller for Missle.getMissleId
function sc__Missle_getMissleId takes integer this returns integer
        return 'e000'
endfunction

//Generated method caller for Missle.refreshDamagedGroup
function sc__Missle_refreshDamagedGroup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_refreshDamagedGroup[124])
endfunction

//Generated method caller for Missle.troughDamage
function sc__Missle_troughDamage takes integer this,unit target returns nothing
endfunction

//Generated method caller for Missle.doDamage
function sc__Missle_doDamage takes integer this,real radius returns nothing
    set f__arg_this=this
    set f__arg_real1=radius
    call TriggerEvaluate(st__IMissle_doDamage[124])
endfunction

//Generated method caller for Missle.damageEnemy
function sc__Missle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[124])
endfunction

//Generated method caller for Missle.debuffEnemy
function sc__Missle_debuffEnemy takes integer this,unit target returns nothing
endfunction

//Generated method caller for Missle.healAlly
function sc__Missle_healAlly takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_healAlly[124])
endfunction

//Generated method caller for Missle.hitSelf
function sc__Missle_hitSelf takes integer this,unit self returns nothing
endfunction

//Generated method caller for Missle.fireMissle
function sc__Missle_fireMissle takes integer this,integer vi returns nothing
    set f__arg_this=this
    set f__arg_integer1=vi
    call TriggerEvaluate(st__IMissle_fireMissle[124])
endfunction

//Generated method caller for Missle.onFire
function sc__Missle_onFire takes integer this returns nothing
endfunction

//Generated method caller for Missle.substep
function sc__Missle_substep takes integer this returns nothing
endfunction

//Generated method caller for Missle.getLife
function sc__Missle_getLife takes integer this returns integer
        return 30
endfunction

//Generated method caller for Missle.create
function sc__Missle_create takes unit owner returns integer
    set f__arg_unit1=owner
    call TriggerEvaluate(st__Missle_create)
 return f__result_integer
endfunction

//Generated method caller for Missle.step
function sc__Missle_step takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_step[124])
endfunction

//Generated method caller for Missle.getFinalDamage
function sc__Missle_getFinalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getFinalDamage[124])
 return f__result_real
endfunction

//Generated method caller for Missle.getOriginalDamage
function sc__Missle_getOriginalDamage takes integer this returns real
        return 50.0
endfunction

//Generated method caller for Missle.explode
function sc__Missle_explode takes integer this returns nothing
        //call BJDebugMsg("explode")
endfunction

//Generated method caller for Missle.onDestroy
function sc__Missle_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_onDestroy[124])
endfunction

//Generated allocator of Missle
function s__Missle__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__IMissle_F
    if (this!=0) then
        set si__IMissle_F=si__IMissle_V[this]
    else
        set si__IMissle_I=si__IMissle_I+1
        set this=si__IMissle_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__IMissle_type[this]=124
    set kthis=this

    set si__IMissle_V[this]=-1
 return this
endfunction


//Generated method caller for TroughMissle.damageEnemy
function sc__TroughMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[125])
endfunction

//Generated method caller for TroughMissle.troughDamage
function sc__TroughMissle_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_troughDamage[125])
endfunction

//Generated allocator of TroughMissle
function s__TroughMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=125
    set kthis=this

 return this
endfunction


//Generated method caller for ShootGunMissle.getLife
function sc__ShootGunMissle_getLife takes integer this returns integer
        return 15
endfunction

//Generated allocator of ShootGunMissle
function s__ShootGunMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=126
    set kthis=this

 return this
endfunction


//Generated method caller for IceMissle.getMissleId
function sc__IceMissle_getMissleId takes integer this returns integer
        return bICE_MISSLE
endfunction

//Generated method caller for IceMissle.damageEnemy
function sc__IceMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[127])
endfunction

//Generated method caller for IceMissle.debuffEnemy
function sc__IceMissle_debuffEnemy takes integer this,unit target returns nothing
        local unit dummy
        set dummy=CreateUnit(GetOwningPlayer(s__IMissle_owner[this]), MAGIC, GetUnitX(target), GetUnitY(target), 0)
        call IssueTargetOrderById(dummy, 852226, target)
        set dummy=null
endfunction

//Generated allocator of IceMissle
function s__IceMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=127
    set kthis=this

 return this
endfunction


//Generated method caller for FireMissle.damageEnemy
function sc__FireMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[128])
endfunction

//Generated method caller for FireMissle.getMissleId
function sc__FireMissle_getMissleId takes integer this returns integer
        return bFIRE_MISSLE
endfunction

//Generated method caller for FireMissle.debuffEnemy
function sc__FireMissle_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[128])
endfunction

//Generated allocator of FireMissle
function s__FireMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=128
    set kthis=this

 return this
endfunction


//Generated method caller for SmallDarts.getMissleId
function sc__SmallDarts_getMissleId takes integer this returns integer
        return 'e002'
endfunction

//Generated method caller for SmallDarts.getOriginalDamage
function sc__SmallDarts_getOriginalDamage takes integer this returns real
        return 100.0
endfunction

//Generated method caller for SmallDarts.damageEnemy
function sc__SmallDarts_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[129])
endfunction

//Generated allocator of SmallDarts
function s__SmallDarts__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=129
    set kthis=this

 return this
endfunction


//Generated method caller for ElectricWhip.getMissleId
function sc__ElectricWhip_getMissleId takes integer this returns integer
        return bELECTRIC
endfunction

//Generated method caller for ElectricWhip.getOriginalDamage
function sc__ElectricWhip_getOriginalDamage takes integer this returns real
        return 0.0
endfunction

//Generated method caller for ElectricWhip.getLife
function sc__ElectricWhip_getLife takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getLife[130])
 return f__result_integer
endfunction

//Generated method caller for ElectricWhip.debuffEnemy
function sc__ElectricWhip_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[130])
endfunction

//Generated method caller for ElectricWhip.onFire
function sc__ElectricWhip_onFire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_onFire[130])
endfunction

//Generated method caller for ElectricWhip.substep
function sc__ElectricWhip_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[130])
endfunction

//Generated method caller for ElectricWhip.explode
function sc__ElectricWhip_explode takes integer this returns nothing
        call DestroyLightning(s__ElectricWhip_l[this])
endfunction

//Generated allocator of ElectricWhip
function s__ElectricWhip__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=130
    set kthis=this

 return this
endfunction


//Generated method caller for ReturnDarts.getMissleId
function sc__ReturnDarts_getMissleId takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getMissleId[131])
 return f__result_integer
endfunction

//Generated method caller for ReturnDarts.getOriginalDamage
function sc__ReturnDarts_getOriginalDamage takes integer this returns real
        return 130.0
endfunction

//Generated method caller for ReturnDarts.getLife
function sc__ReturnDarts_getLife takes integer this returns integer
        return 10000
endfunction

//Generated method caller for ReturnDarts.debuffEnemy
function sc__ReturnDarts_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[131])
endfunction

//Generated method caller for ReturnDarts.hitSelf
function sc__ReturnDarts_hitSelf takes integer this,unit self returns nothing
    set f__arg_this=this
    set f__arg_unit1=self
    call TriggerEvaluate(st__IMissle_hitSelf[131])
endfunction

//Generated method caller for ReturnDarts.getFinalDamage
function sc__ReturnDarts_getFinalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getFinalDamage[131])
 return f__result_real
endfunction

//Generated method caller for ReturnDarts.troughDamage
function sc__ReturnDarts_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_troughDamage[131])
endfunction

//Generated method caller for ReturnDarts.explode
function sc__ReturnDarts_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[131])
endfunction

//Generated method caller for ReturnDarts.substep
function sc__ReturnDarts_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[131])
endfunction

//Generated allocator of ReturnDarts
function s__ReturnDarts__allocate takes unit owner returns integer
 local integer this=s__TroughMissle__allocate(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=131
    set kthis=this

 return this
endfunction


//Generated method caller for LeaveDarts.getMissleId
function sc__LeaveDarts_getMissleId takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getMissleId[132])
 return f__result_integer
endfunction

//Generated method caller for LeaveDarts.getOriginalDamage
function sc__LeaveDarts_getOriginalDamage takes integer this returns real
        return 100.0
endfunction

//Generated method caller for LeaveDarts.getLife
function sc__LeaveDarts_getLife takes integer this returns integer
        return 1000
endfunction

//Generated method caller for LeaveDarts.debuffEnemy
function sc__LeaveDarts_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[132])
endfunction

//Generated method caller for LeaveDarts.getFinalDamage
function sc__LeaveDarts_getFinalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getFinalDamage[132])
 return f__result_real
endfunction

//Generated method caller for LeaveDarts.troughDamage
function sc__LeaveDarts_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_troughDamage[132])
endfunction

//Generated method caller for LeaveDarts.explode
function sc__LeaveDarts_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[132])
endfunction

//Generated method caller for LeaveDarts.substep
function sc__LeaveDarts_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[132])
endfunction

//Generated allocator of LeaveDarts
function s__LeaveDarts__allocate takes unit owner returns integer
 local integer this=s__TroughMissle__allocate(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=132
    set kthis=this

 return this
endfunction


//Generated method caller for BackGrenade.getMissleId
function sc__BackGrenade_getMissleId takes integer this returns integer
        return 'e009'
endfunction

//Generated method caller for BackGrenade.getOriginalDamage
function sc__BackGrenade_getOriginalDamage takes integer this returns real
        return 100.0
endfunction

//Generated method caller for BackGrenade.debuffEnemy
function sc__BackGrenade_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[133])
endfunction

//Generated method caller for BackGrenade.damageEnemy
function sc__BackGrenade_damageEnemy takes integer this,unit target returns nothing
endfunction

//Generated method caller for BackGrenade.explode
function sc__BackGrenade_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[133])
endfunction

//Generated method caller for BackGrenade.getLife
function sc__BackGrenade_getLife takes integer this returns integer
        return 300
endfunction

//Generated allocator of BackGrenade
function s__BackGrenade__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=133
    set kthis=this

 return this
endfunction


//Generated method caller for PushGrenade.getMissleId
function sc__PushGrenade_getMissleId takes integer this returns integer
        return 'e00A'
endfunction

//Generated method caller for PushGrenade.getOriginalDamage
function sc__PushGrenade_getOriginalDamage takes integer this returns real
        return 100.0
endfunction

//Generated method caller for PushGrenade.debuffEnemy
function sc__PushGrenade_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[134])
endfunction

//Generated method caller for PushGrenade.damageEnemy
function sc__PushGrenade_damageEnemy takes integer this,unit target returns nothing
endfunction

//Generated method caller for PushGrenade.explode
function sc__PushGrenade_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[134])
endfunction

//Generated method caller for PushGrenade.getLife
function sc__PushGrenade_getLife takes integer this returns integer
        return 300
endfunction

//Generated allocator of PushGrenade
function s__PushGrenade__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=134
    set kthis=this

 return this
endfunction


//Generated method caller for Mine.getMissleId
function sc__Mine_getMissleId takes integer this returns integer
        return 'e00B'
endfunction

//Generated method caller for Mine.substep
function sc__Mine_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[135])
endfunction

//Generated method caller for Mine.explode
function sc__Mine_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[135])
endfunction

//Generated method caller for Mine.getLife
function sc__Mine_getLife takes integer this returns integer
        return 3000
endfunction

//Generated method caller for Mine.getDeployTime
function sc__Mine_getDeployTime takes integer this returns integer
        return 122
endfunction

//Generated method caller for Mine.create
function sc__Mine_create takes unit owner returns integer
    set f__arg_unit1=owner
    call TriggerEvaluate(st__Mine_create)
 return f__result_integer
endfunction

//Generated allocator of Mine
function s__Mine__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=135
    set kthis=this

 return this
endfunction


//Generated method caller for ShoulderCannonMissle.damageEnemy
function sc__ShoulderCannonMissle_damageEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_damageEnemy[136])
endfunction

//Generated method caller for ShoulderCannonMissle.getLife
function sc__ShoulderCannonMissle_getLife takes integer this returns integer
        return 30
endfunction

//Generated method caller for ShoulderCannonMissle.getOriginalDamage
function sc__ShoulderCannonMissle_getOriginalDamage takes integer this returns real
        return 400.0
endfunction

//Generated method caller for ShoulderCannonMissle.getMissleId
function sc__ShoulderCannonMissle_getMissleId takes integer this returns integer
        return 'e00E'
endfunction

//Generated allocator of ShoulderCannonMissle
function s__ShoulderCannonMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=136
    set kthis=this

 return this
endfunction


//Generated method caller for SpearMissle.getLife
function sc__SpearMissle_getLife takes integer this returns integer
        return 30
endfunction

//Generated method caller for SpearMissle.getOriginalDamage
function sc__SpearMissle_getOriginalDamage takes integer this returns real
        return g_missle_damage + 20
endfunction

//Generated method caller for SpearMissle.getMissleId
function sc__SpearMissle_getMissleId takes integer this returns integer
        return 'e00F'
endfunction

//Generated allocator of SpearMissle
function s__SpearMissle__allocate takes unit owner returns integer
 local integer this=sc__Missle_create(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=137
    set kthis=this

 return this
endfunction


//Generated method caller for SmartDarts.getMissleId
function sc__SmartDarts_getMissleId takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getMissleId[138])
 return f__result_integer
endfunction

//Generated method caller for SmartDarts.getOriginalDamage
function sc__SmartDarts_getOriginalDamage takes integer this returns real
        return 130.0
endfunction

//Generated method caller for SmartDarts.getLife
function sc__SmartDarts_getLife takes integer this returns integer
        return 10000
endfunction

//Generated method caller for SmartDarts.debuffEnemy
function sc__SmartDarts_debuffEnemy takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_debuffEnemy[138])
endfunction

//Generated method caller for SmartDarts.create
function sc__SmartDarts_create takes unit owner,unit target returns integer
    set f__arg_unit1=owner
    set f__arg_unit2=target
    call TriggerEvaluate(st__SmartDarts_create)
 return f__result_integer
endfunction

//Generated method caller for SmartDarts.hitSelf
function sc__SmartDarts_hitSelf takes integer this,unit self returns nothing
endfunction

//Generated method caller for SmartDarts.getFinalDamage
function sc__SmartDarts_getFinalDamage takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_getFinalDamage[138])
 return f__result_real
endfunction

//Generated method caller for SmartDarts.troughDamage
function sc__SmartDarts_troughDamage takes integer this,unit target returns nothing
    set f__arg_this=this
    set f__arg_unit1=target
    call TriggerEvaluate(st__IMissle_troughDamage[138])
endfunction

//Generated method caller for SmartDarts.explode
function sc__SmartDarts_explode takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_explode[138])
endfunction

//Generated method caller for SmartDarts.substep
function sc__SmartDarts_substep takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IMissle_substep[138])
endfunction

//Generated allocator of SmartDarts
function s__SmartDarts__allocate takes unit owner returns integer
 local integer this=s__TroughMissle__allocate(owner)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IMissle_type[this]=138
    set kthis=this

 return this
endfunction


//Generated method caller for AutoAimBuffer.addBuffer
function sc__AutoAimBuffer_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[171])
endfunction

//Generated method caller for AutoAimBuffer.removeBuffer
function sc__AutoAimBuffer_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[171])
endfunction

//Generated allocator of AutoAimBuffer
function s__AutoAimBuffer__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=171
    set kthis=this

 return this
endfunction


//Generated method caller for SingleShooter.shoot
function sc__SingleShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[141])
endfunction

//Generated allocator of SingleShooter
function s__SingleShooter__allocate takes unit owner ,integer factory returns integer
 local integer this=sc__AbstractShooter_create(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=141
    set kthis=this

 return this
endfunction


//Generated method caller for ShoulderCannonShooter.tick
function sc__ShoulderCannonShooter_tick takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IShooter_tick[142])
endfunction

//Generated method caller for ShoulderCannonShooter.shoot
function sc__ShoulderCannonShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[142])
endfunction

//Generated allocator of ShoulderCannonShooter
function s__ShoulderCannonShooter__allocate takes unit owner ,integer factory returns integer
 local integer this=sc__AbstractShooter_create(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=142
    set kthis=this

 return this
endfunction


//Generated method caller for GrenadeThrower.shoot
function sc__GrenadeThrower_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[143])
endfunction

//Generated allocator of GrenadeThrower
function s__GrenadeThrower__allocate takes unit owner ,integer factory returns integer
 local integer this=sc__AbstractShooter_create(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=143
    set kthis=this

 return this
endfunction


//Generated method caller for MineThrower.shoot
function sc__MineThrower_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[144])
endfunction

//Generated allocator of MineThrower
function s__MineThrower__allocate takes unit owner ,integer factory returns integer
 local integer this=sc__AbstractShooter_create(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=144
    set kthis=this

 return this
endfunction


//Generated method caller for DefaultShooter.shoot
function sc__DefaultShooter_shoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_shoot[145])
endfunction

//Generated method caller for DefaultShooter.getShootDir
function sc__DefaultShooter_getShootDir takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__DefaultShooter_getShootDir)
 return f__result_real
endfunction

//Generated method caller for DefaultShooter.getShootVector
function sc__DefaultShooter_getShootVector takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__DefaultShooter_getShootVector)
 return f__result_integer
endfunction

//Generated method caller for DefaultShooter.subshoot
function sc__DefaultShooter_subshoot takes integer this,integer dir returns nothing
    set f__arg_this=this
    set f__arg_integer1=dir
    call TriggerEvaluate(st__IShooter_subshoot[145])
endfunction

//Generated method caller for DefaultShooter.getEnergyConsume
function sc__DefaultShooter_getEnergyConsume takes integer this returns integer
        return 1
endfunction

//Generated method caller for DefaultShooter.energyConsume
function sc__DefaultShooter_energyConsume takes integer this,integer consume returns nothing
    set f__arg_this=this
    set f__arg_integer1=consume
    call TriggerEvaluate(st__DefaultShooter_energyConsume)
endfunction

//Generated method caller for DefaultShooter.backForce
function sc__DefaultShooter_backForce takes integer this,real vdir returns nothing
    set f__arg_this=this
    set f__arg_real1=vdir
    call TriggerEvaluate(st__DefaultShooter_backForce)
endfunction

//Generated allocator of DefaultShooter
function s__DefaultShooter__allocate takes unit owner ,integer factory returns integer
 local integer this=sc__AbstractShooter_create(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=145
    set kthis=this

 return this
endfunction


//Generated method caller for ShootGunShooter.getEnergyConsume
function sc__ShootGunShooter_getEnergyConsume takes integer this returns integer
        return 1
endfunction

//Generated method caller for ShootGunShooter.shootCount
function sc__ShootGunShooter_shootCount takes integer this returns integer
        return 12
endfunction

//Generated method caller for ShootGunShooter.getRist
function sc__ShootGunShooter_getRist takes integer this returns real
        return 200.0
endfunction

//Generated method caller for ShootGunShooter.getOriginSpeed
function sc__ShootGunShooter_getOriginSpeed takes integer this returns real
        return 80.0
endfunction

//Generated allocator of ShootGunShooter
function s__ShootGunShooter__allocate takes unit owner ,integer factory returns integer
 local integer this=s__DefaultShooter__allocate(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=146
    set kthis=this

 return this
endfunction


//Generated method caller for MachineGunShooter.shoothz
function sc__MachineGunShooter_shoothz takes integer this returns integer
        return 100
endfunction

//Generated method caller for MachineGunShooter.getEnergyConsume
function sc__MachineGunShooter_getEnergyConsume takes integer this returns integer
        return 1
endfunction

//Generated method caller for MachineGunShooter.getClipSize
function sc__MachineGunShooter_getClipSize takes integer this returns integer
        return 100
endfunction

//Generated allocator of MachineGunShooter
function s__MachineGunShooter__allocate takes unit owner ,integer factory returns integer
 local integer this=s__DefaultShooter__allocate(owner,factory)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IShooter_type[this]=147
    set kthis=this

 return this
endfunction


//Generated method caller for ItemJump.cleanup
function sc__ItemJump_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[150])
endfunction

//Generated method caller for ItemJump.onChannel
function sc__ItemJump_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[150])
endfunction

//Generated method caller for ItemJump.onStopCast
function sc__ItemJump_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ItemJump
function s__ItemJump__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=150
    set kthis=this

 return this
endfunction


//Generated method caller for Jump.cleanup
function sc__Jump_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[151])
endfunction

//Generated method caller for Jump.onChannel
function sc__Jump_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[151])
endfunction

//Generated method caller for Jump.onStopCast
function sc__Jump_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of Jump
function s__Jump__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=151
    set kthis=this

 return this
endfunction


//Generated method caller for InjectionSpeedUp.cleanup
function sc__InjectionSpeedUp_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[152])
endfunction

//Generated method caller for InjectionSpeedUp.onChannel
function sc__InjectionSpeedUp_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[152])
endfunction

//Generated method caller for InjectionSpeedUp.onStopCast
function sc__InjectionSpeedUp_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of InjectionSpeedUp
function s__InjectionSpeedUp__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=152
    set kthis=this

 return this
endfunction


//Generated method caller for Darts.cleanup
function sc__Darts_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[153])
endfunction

//Generated method caller for Darts.onChannel
function sc__Darts_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[153])
endfunction

//Generated method caller for Darts.onStopCast
function sc__Darts_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of Darts
function s__Darts__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=153
    set kthis=this

 return this
endfunction


//Generated method caller for ReturnDartsSpell.cleanup
function sc__ReturnDartsSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[154])
endfunction

//Generated method caller for ReturnDartsSpell.onChannel
function sc__ReturnDartsSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[154])
endfunction

//Generated method caller for ReturnDartsSpell.onStopCast
function sc__ReturnDartsSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ReturnDartsSpell
function s__ReturnDartsSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=154
    set kthis=this

 return this
endfunction


//Generated method caller for SmartDartsSpell.cleanup
function sc__SmartDartsSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[155])
endfunction

//Generated method caller for SmartDartsSpell.onChannel
function sc__SmartDartsSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[155])
endfunction

//Generated method caller for SmartDartsSpell.onStopCast
function sc__SmartDartsSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of SmartDartsSpell
function s__SmartDartsSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=155
    set kthis=this

 return this
endfunction


//Generated method caller for ShoulderCannonSpell.cleanup
function sc__ShoulderCannonSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[156])
endfunction

//Generated method caller for ShoulderCannonSpell.onChannel
function sc__ShoulderCannonSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[156])
endfunction

//Generated method caller for ShoulderCannonSpell.onStopCast
function sc__ShoulderCannonSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ShoulderCannonSpell
function s__ShoulderCannonSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=156
    set kthis=this

 return this
endfunction


//Generated method caller for ItemReturnDartsSpell.cleanup
function sc__ItemReturnDartsSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[157])
endfunction

//Generated method caller for ItemReturnDartsSpell.onChannel
function sc__ItemReturnDartsSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[157])
endfunction

//Generated method caller for ItemReturnDartsSpell.onStopCast
function sc__ItemReturnDartsSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ItemReturnDartsSpell
function s__ItemReturnDartsSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=157
    set kthis=this

 return this
endfunction


//Generated method caller for LeaveDartsSpell.cleanup
function sc__LeaveDartsSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[158])
endfunction

//Generated method caller for LeaveDartsSpell.onChannel
function sc__LeaveDartsSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[158])
endfunction

//Generated method caller for LeaveDartsSpell.onStopCast
function sc__LeaveDartsSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of LeaveDartsSpell
function s__LeaveDartsSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=158
    set kthis=this

 return this
endfunction


//Generated method caller for BackGrenadeSpell.cleanup
function sc__BackGrenadeSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[159])
endfunction

//Generated method caller for BackGrenadeSpell.onChannel
function sc__BackGrenadeSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[159])
endfunction

//Generated method caller for BackGrenadeSpell.onStopCast
function sc__BackGrenadeSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of BackGrenadeSpell
function s__BackGrenadeSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=159
    set kthis=this

 return this
endfunction


//Generated method caller for MineSpell.cleanup
function sc__MineSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[160])
endfunction

//Generated method caller for MineSpell.onChannel
function sc__MineSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[160])
endfunction

//Generated method caller for MineSpell.onStopCast
function sc__MineSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of MineSpell
function s__MineSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=160
    set kthis=this

 return this
endfunction


//Generated method caller for PushGrenadeSpell.cleanup
function sc__PushGrenadeSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[161])
endfunction

//Generated method caller for PushGrenadeSpell.onChannel
function sc__PushGrenadeSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[161])
endfunction

//Generated method caller for PushGrenadeSpell.onStopCast
function sc__PushGrenadeSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of PushGrenadeSpell
function s__PushGrenadeSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=161
    set kthis=this

 return this
endfunction


//Generated method caller for Blink.cleanup
function sc__Blink_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[162])
endfunction

//Generated method caller for Blink.onChannel
function sc__Blink_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[162])
endfunction

//Generated allocator of Blink
function s__Blink__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=162
    set kthis=this

 return this
endfunction


//Generated method caller for Transport.cleanup
function sc__Transport_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[163])
endfunction

//Generated method caller for Transport.onFinish
function sc__Transport_onFinish takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onFinish[163])
endfunction

//Generated allocator of Transport
function s__Transport__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=163
    set kthis=this

 return this
endfunction


//Generated method caller for ElectricWhipSpell.cleanup
function sc__ElectricWhipSpell_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[164])
endfunction

//Generated method caller for ElectricWhipSpell.onChannel
function sc__ElectricWhipSpell_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[164])
endfunction

//Generated method caller for ElectricWhipSpell.onStopCast
function sc__ElectricWhipSpell_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ElectricWhipSpell
function s__ElectricWhipSpell__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=164
    set kthis=this

 return this
endfunction


//Generated method caller for AutoAim.cleanup
function sc__AutoAim_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[165])
endfunction

//Generated method caller for AutoAim.onChannel
function sc__AutoAim_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[165])
endfunction

//Generated allocator of AutoAim
function s__AutoAim__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=165
    set kthis=this

 return this
endfunction


//Generated method caller for ShootBack.cleanup
function sc__ShootBack_cleanup takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_cleanup[166])
endfunction

//Generated method caller for ShootBack.onChannel
function sc__ShootBack_onChannel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__SpellStruct__DefaultsInterface_onChannel[166])
endfunction

//Generated method caller for ShootBack.onStopCast
function sc__ShootBack_onStopCast takes integer this returns nothing
endfunction

//Generated allocator of ShootBack
function s__ShootBack__allocate takes nothing returns integer
 local integer this=sc__SpellStruct_create()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__SpellStruct__DefaultsInterface_type[this]=166
    set kthis=this

 return this
endfunction


//Generated method caller for BurnBuffer.addBuffer
function sc__BurnBuffer_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[167])
endfunction

//Generated method caller for BurnBuffer.action
function sc__BurnBuffer_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_action[167])
endfunction

//Generated method caller for BurnBuffer.removeBuffer
function sc__BurnBuffer_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[167])
endfunction

//Generated method caller for BurnBuffer.create
function sc__BurnBuffer_create takes unit u,integer count,unit source,real dam returns integer
    set f__arg_unit1=u
    set f__arg_integer1=count
    set f__arg_unit2=source
    set f__arg_real1=dam
    call TriggerEvaluate(st__BurnBuffer_create)
 return f__result_integer
endfunction

//Generated allocator of BurnBuffer
function s__BurnBuffer__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=167
    set kthis=this

 return this
endfunction


//Generated method caller for HorroBuffer.addBuffer
function sc__HorroBuffer_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[168])
endfunction

//Generated method caller for HorroBuffer.action
function sc__HorroBuffer_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_action[168])
endfunction

//Generated method caller for HorroBuffer.removeBuffer
function sc__HorroBuffer_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[168])
endfunction

//Generated method caller for HorroBuffer.create
function sc__HorroBuffer_create takes unit u,unit source,integer count returns integer
    set f__arg_unit1=u
    set f__arg_unit2=source
    set f__arg_integer1=count
    call TriggerEvaluate(st__HorroBuffer_create)
 return f__result_integer
endfunction

//Generated allocator of HorroBuffer
function s__HorroBuffer__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=168
    set kthis=this

 return this
endfunction


//Generated method caller for BleedBuffer.addBuffer
function sc__BleedBuffer_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[169])
endfunction

//Generated method caller for BleedBuffer.action
function sc__BleedBuffer_action takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_action[169])
endfunction

//Generated method caller for BleedBuffer.removeBuffer
function sc__BleedBuffer_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[169])
endfunction

//Generated method caller for BleedBuffer.create
function sc__BleedBuffer_create takes unit u,integer count,unit source,real dam returns integer
    set f__arg_unit1=u
    set f__arg_integer1=count
    set f__arg_unit2=source
    set f__arg_real1=dam
    call TriggerEvaluate(st__BleedBuffer_create)
 return f__result_integer
endfunction

//Generated allocator of BleedBuffer
function s__BleedBuffer__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=169
    set kthis=this

 return this
endfunction


//Generated method caller for IceSlowBuffer.addBuffer
function sc__IceSlowBuffer_addBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_addBuffer[170])
endfunction

//Generated method caller for IceSlowBuffer.removeBuffer
function sc__IceSlowBuffer_removeBuffer takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__IBufferStruct_removeBuffer[170])
endfunction

//Generated allocator of IceSlowBuffer
function s__IceSlowBuffer__allocate takes unit u ,integer count returns integer
 local integer this=sc__DefaultBufferStruct_create(u,count)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__IBufferStruct_type[this]=170
    set kthis=this

 return this
endfunction

function sc___prototype1_execute takes integer i returns nothing

    call TriggerExecute(st___prototype1[i])
endfunction
function sc___prototype1_evaluate takes integer i returns integer

    call TriggerEvaluate(st___prototype1[i])
 return f__result_integer
endfunction
function sc___prototype18_execute takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerExecute(st___prototype18[i])
endfunction
function sc___prototype18_evaluate takes integer i,integer a1 returns nothing
    set f__arg_integer1=a1

    call TriggerEvaluate(st___prototype18[i])

endfunction
function sc___prototype37_execute takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerExecute(st___prototype37[i])
endfunction
function sc___prototype37_evaluate takes integer i,integer a1,integer a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_integer2=a2

    call TriggerEvaluate(st___prototype37[i])

endfunction
function sc___prototype217_execute takes integer i,integer a1,unit a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_unit1=a2

    call TriggerExecute(st___prototype217[i])
endfunction
function sc___prototype217_evaluate takes integer i,integer a1,unit a2 returns boolean
    set f__arg_integer1=a1
    set f__arg_unit1=a2

    call TriggerEvaluate(st___prototype217[i])
 return f__result_boolean
endfunction
function sc___prototype218_execute takes integer i,integer a1,unit a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_unit1=a2

    call TriggerExecute(st___prototype218[i])
endfunction
function sc___prototype218_evaluate takes integer i,integer a1,unit a2 returns nothing
    set f__arg_integer1=a1
    set f__arg_unit1=a2

    call TriggerEvaluate(st___prototype218[i])

endfunction

//library ABC:
//==============================================================================
//  Collision check functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerCollisionA takes nothing returns integer
    return ABC___TimerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionB takes nothing returns integer
    return ABC___TimerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTimerCollisionC takes nothing returns integer
    return ABC___TimerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionA takes nothing returns integer
    return ABC___TriggerMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionB takes nothing returns integer
    return ABC___TriggerMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetTriggerCollisionC takes nothing returns integer
    return ABC___TriggerMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionA takes nothing returns integer
    return ABC___DialogMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionB takes nothing returns integer
    return ABC___DialogMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetDialogCollisionC takes nothing returns integer
    return ABC___DialogMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionA takes nothing returns integer
    return ABC___RegionMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionB takes nothing returns integer
    return ABC___RegionMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetRegionCollisionC takes nothing returns integer
    return ABC___RegionMaxCollisionC
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionA takes nothing returns integer
    return ABC___ButtonMaxCollisionA
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionB takes nothing returns integer
    return ABC___ButtonMaxCollisionB
endfunction
//------------------------------------------------------------------------------
function GetButtonCollisionC takes nothing returns integer
    return ABC___ButtonMaxCollisionC
endfunction
//==============================================================================
//  Set functions
//==============================================================================
//------------------------------------------------------------------------------
function SetTimerStructA takes timer key,integer value returns nothing
//textmacro instance: ABC_Set("A", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TimerKeyA[i] == null then
        set ABC___TimerKeyA[i]=key
        set ABC___TimerValueA[i]=value
    else
        call SaveInteger(ABC___TimerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructB takes timer key,integer value returns nothing
//textmacro instance: ABC_Set("B", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TimerKeyB[i] == null then
        set ABC___TimerKeyB[i]=key
        set ABC___TimerValueB[i]=value
    else
        call SaveInteger(ABC___TimerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTimerStructC takes timer key,integer value returns nothing
//textmacro instance: ABC_Set("C", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TimerKeyC[i] == null then
        set ABC___TimerKeyC[i]=key
        set ABC___TimerValueC[i]=value
    else
        call SaveInteger(ABC___TimerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructA takes trigger key,integer value returns nothing
//textmacro instance: ABC_Set("A", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TriggerKeyA[i] == null then
        set ABC___TriggerKeyA[i]=key
        set ABC___TriggerValueA[i]=value
    else
        call SaveInteger(ABC___TriggerHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructB takes trigger key,integer value returns nothing
//textmacro instance: ABC_Set("B", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TriggerKeyB[i] == null then
        set ABC___TriggerKeyB[i]=key
        set ABC___TriggerValueB[i]=value
    else
        call SaveInteger(ABC___TriggerHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetTriggerStructC takes trigger key,integer value returns nothing
//textmacro instance: ABC_Set("C", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___TriggerKeyC[i] == null then
        set ABC___TriggerKeyC[i]=key
        set ABC___TriggerValueC[i]=value
    else
        call SaveInteger(ABC___TriggerHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructA takes dialog key,integer value returns nothing
//textmacro instance: ABC_Set("A", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___DialogKeyA[i] == null then
        set ABC___DialogKeyA[i]=key
        set ABC___DialogValueA[i]=value
    else
        call SaveInteger(ABC___DialogHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructB takes dialog key,integer value returns nothing
//textmacro instance: ABC_Set("B", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___DialogKeyB[i] == null then
        set ABC___DialogKeyB[i]=key
        set ABC___DialogValueB[i]=value
    else
        call SaveInteger(ABC___DialogHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetDialogStructC takes dialog key,integer value returns nothing
//textmacro instance: ABC_Set("C", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___DialogKeyC[i] == null then
        set ABC___DialogKeyC[i]=key
        set ABC___DialogValueC[i]=value
    else
        call SaveInteger(ABC___DialogHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructA takes region key,integer value returns nothing
//textmacro instance: ABC_Set("A", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___RegionKeyA[i] == null then
        set ABC___RegionKeyA[i]=key
        set ABC___RegionValueA[i]=value
    else
        call SaveInteger(ABC___RegionHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructB takes region key,integer value returns nothing
//textmacro instance: ABC_Set("B", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___RegionKeyB[i] == null then
        set ABC___RegionKeyB[i]=key
        set ABC___RegionValueB[i]=value
    else
        call SaveInteger(ABC___RegionHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetRegionStructC takes region key,integer value returns nothing
//textmacro instance: ABC_Set("C", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___RegionKeyC[i] == null then
        set ABC___RegionKeyC[i]=key
        set ABC___RegionValueC[i]=value
    else
        call SaveInteger(ABC___RegionHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructA takes button key,integer value returns nothing
//textmacro instance: ABC_Set("A", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___ButtonKeyA[i] == null then
        set ABC___ButtonKeyA[i]=key
        set ABC___ButtonValueA[i]=value
    else
        call SaveInteger(ABC___ButtonHash, 'A', GetHandleId(key), value)
	endif
//end of: ABC_Set("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructB takes button key,integer value returns nothing
//textmacro instance: ABC_Set("B", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___ButtonKeyB[i] == null then
        set ABC___ButtonKeyB[i]=key
        set ABC___ButtonValueB[i]=value
    else
        call SaveInteger(ABC___ButtonHash, 'B', GetHandleId(key), value)
	endif
//end of: ABC_Set("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function SetButtonStructC takes button key,integer value returns nothing
//textmacro instance: ABC_Set("C", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
    if ABC___ButtonKeyC[i] == null then
        set ABC___ButtonKeyC[i]=key
        set ABC___ButtonValueC[i]=value
    else
        call SaveInteger(ABC___ButtonHash, 'C', GetHandleId(key), value)
	endif
//end of: ABC_Set("C", "Button", "button")
endfunction
//==============================================================================
//  Get functions
//==============================================================================
//------------------------------------------------------------------------------
function GetTimerStructA takes timer key returns integer
//textmacro instance: ABC_Get("A", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyA[i] == key then
        return ABC___TimerValueA[i]
    else
        return LoadInteger(ABC___TimerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructB takes timer key returns integer
//textmacro instance: ABC_Get("B", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyB[i] == key then
        return ABC___TimerValueB[i]
    else
        return LoadInteger(ABC___TimerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTimerStructC takes timer key returns integer
//textmacro instance: ABC_Get("C", "Timer", "timer")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyC[i] == key then
        return ABC___TimerValueC[i]
    else
        return LoadInteger(ABC___TimerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Get("A", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyA[i] == key then
        return ABC___TriggerValueA[i]
    else
        return LoadInteger(ABC___TriggerHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Get("B", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyB[i] == key then
        return ABC___TriggerValueB[i]
    else
        return LoadInteger(ABC___TriggerHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Get("C", "Trigger", "trigger")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyC[i] == key then
        return ABC___TriggerValueC[i]
    else
        return LoadInteger(ABC___TriggerHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Get("A", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyA[i] == key then
        return ABC___DialogValueA[i]
    else
        return LoadInteger(ABC___DialogHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Get("B", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyB[i] == key then
        return ABC___DialogValueB[i]
    else
        return LoadInteger(ABC___DialogHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Get("C", "Dialog", "dialog")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyC[i] == key then
        return ABC___DialogValueC[i]
    else
        return LoadInteger(ABC___DialogHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructA takes region key returns integer
//textmacro instance: ABC_Get("A", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyA[i] == key then
        return ABC___RegionValueA[i]
    else
        return LoadInteger(ABC___RegionHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructB takes region key returns integer
//textmacro instance: ABC_Get("B", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyB[i] == key then
        return ABC___RegionValueB[i]
    else
        return LoadInteger(ABC___RegionHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetRegionStructC takes region key returns integer
//textmacro instance: ABC_Get("C", "Region", "region")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyC[i] == key then
        return ABC___RegionValueC[i]
    else
        return LoadInteger(ABC___RegionHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructA takes button key returns integer
//textmacro instance: ABC_Get("A", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyA[i] == key then
        return ABC___ButtonValueA[i]
    else
        return LoadInteger(ABC___ButtonHash, 'A', GetHandleId(key))
	endif
//end of: ABC_Get("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructB takes button key returns integer
//textmacro instance: ABC_Get("B", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyB[i] == key then
        return ABC___ButtonValueB[i]
    else
        return LoadInteger(ABC___ButtonHash, 'B', GetHandleId(key))
	endif
//end of: ABC_Get("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function GetButtonStructC takes button key returns integer
//textmacro instance: ABC_Get("C", "Button", "button")
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyC[i] == key then
        return ABC___ButtonValueC[i]
    else
        return LoadInteger(ABC___ButtonHash, 'C', GetHandleId(key))
	endif
//end of: ABC_Get("C", "Button", "button")
endfunction
//==============================================================================
//  Clear functions
//==============================================================================
//------------------------------------------------------------------------------
function ClearTimerStructA takes timer key returns integer
//textmacro instance: ABC_Clear("A", "Timer", "timer")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyA[i] == key then
        set ret=ABC___TimerValueA[i]
        set ABC___TimerKeyA[i]=null
        set ABC___TimerValueA[i]=0
    else
        if HaveSavedInteger(ABC___TimerHash, 'A', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TimerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructA(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructB takes timer key returns integer
//textmacro instance: ABC_Clear("B", "Timer", "timer")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyB[i] == key then
        set ret=ABC___TimerValueB[i]
        set ABC___TimerKeyB[i]=null
        set ABC___TimerValueB[i]=0
    else
        if HaveSavedInteger(ABC___TimerHash, 'B', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TimerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructB(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTimerStructC takes timer key returns integer
//textmacro instance: ABC_Clear("C", "Timer", "timer")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TimerKeyC[i] == key then
        set ret=ABC___TimerValueC[i]
        set ABC___TimerKeyC[i]=null
        set ABC___TimerValueC[i]=0
    else
        if HaveSavedInteger(ABC___TimerHash, 'C', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TimerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___TimerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTimerStructC(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Timer", "timer")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructA takes trigger key returns integer
//textmacro instance: ABC_Clear("A", "Trigger", "trigger")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyA[i] == key then
        set ret=ABC___TriggerValueA[i]
        set ABC___TriggerKeyA[i]=null
        set ABC___TriggerValueA[i]=0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'A', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TriggerHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructA(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructB takes trigger key returns integer
//textmacro instance: ABC_Clear("B", "Trigger", "trigger")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyB[i] == key then
        set ret=ABC___TriggerValueB[i]
        set ABC___TriggerKeyB[i]=null
        set ABC___TriggerValueB[i]=0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'B', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TriggerHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructB(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearTriggerStructC takes trigger key returns integer
//textmacro instance: ABC_Clear("C", "Trigger", "trigger")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___TriggerKeyC[i] == key then
        set ret=ABC___TriggerValueC[i]
        set ABC___TriggerKeyC[i]=null
        set ABC___TriggerValueC[i]=0
    else
        if HaveSavedInteger(ABC___TriggerHash, 'C', GetHandleId(key)) then
            set ret=LoadInteger(ABC___TriggerHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___TriggerHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearTriggerStructC(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Trigger", "trigger")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructA takes dialog key returns integer
//textmacro instance: ABC_Clear("A", "Dialog", "dialog")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyA[i] == key then
        set ret=ABC___DialogValueA[i]
        set ABC___DialogKeyA[i]=null
        set ABC___DialogValueA[i]=0
    else
        if HaveSavedInteger(ABC___DialogHash, 'A', GetHandleId(key)) then
            set ret=LoadInteger(ABC___DialogHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructA(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructB takes dialog key returns integer
//textmacro instance: ABC_Clear("B", "Dialog", "dialog")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyB[i] == key then
        set ret=ABC___DialogValueB[i]
        set ABC___DialogKeyB[i]=null
        set ABC___DialogValueB[i]=0
    else
        if HaveSavedInteger(ABC___DialogHash, 'B', GetHandleId(key)) then
            set ret=LoadInteger(ABC___DialogHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructB(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearDialogStructC takes dialog key returns integer
//textmacro instance: ABC_Clear("C", "Dialog", "dialog")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___DialogKeyC[i] == key then
        set ret=ABC___DialogValueC[i]
        set ABC___DialogKeyC[i]=null
        set ABC___DialogValueC[i]=0
    else
        if HaveSavedInteger(ABC___DialogHash, 'C', GetHandleId(key)) then
            set ret=LoadInteger(ABC___DialogHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___DialogHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearDialogStructC(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Dialog", "dialog")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructA takes region key returns integer
//textmacro instance: ABC_Clear("A", "Region", "region")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyA[i] == key then
        set ret=ABC___RegionValueA[i]
        set ABC___RegionKeyA[i]=null
        set ABC___RegionValueA[i]=0
    else
        if HaveSavedInteger(ABC___RegionHash, 'A', GetHandleId(key)) then
            set ret=LoadInteger(ABC___RegionHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructA(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructB takes region key returns integer
//textmacro instance: ABC_Clear("B", "Region", "region")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyB[i] == key then
        set ret=ABC___RegionValueB[i]
        set ABC___RegionKeyB[i]=null
        set ABC___RegionValueB[i]=0
    else
        if HaveSavedInteger(ABC___RegionHash, 'B', GetHandleId(key)) then
            set ret=LoadInteger(ABC___RegionHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructB(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearRegionStructC takes region key returns integer
//textmacro instance: ABC_Clear("C", "Region", "region")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___RegionKeyC[i] == key then
        set ret=ABC___RegionValueC[i]
        set ABC___RegionKeyC[i]=null
        set ABC___RegionValueC[i]=0
    else
        if HaveSavedInteger(ABC___RegionHash, 'C', GetHandleId(key)) then
            set ret=LoadInteger(ABC___RegionHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___RegionHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearRegionStructC(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Region", "region")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructA takes button key returns integer
//textmacro instance: ABC_Clear("A", "Button", "button")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyA[i] == key then
        set ret=ABC___ButtonValueA[i]
        set ABC___ButtonKeyA[i]=null
        set ABC___ButtonValueA[i]=0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'A', GetHandleId(key)) then
            set ret=LoadInteger(ABC___ButtonHash, 'A', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'A', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructA(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("A", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructB takes button key returns integer
//textmacro instance: ABC_Clear("B", "Button", "button")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyB[i] == key then
        set ret=ABC___ButtonValueB[i]
        set ABC___ButtonKeyB[i]=null
        set ABC___ButtonValueB[i]=0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'B', GetHandleId(key)) then
            set ret=LoadInteger(ABC___ButtonHash, 'B', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'B', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructB(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("B", "Button", "button")
endfunction
//------------------------------------------------------------------------------
function ClearButtonStructC takes button key returns integer
//textmacro instance: ABC_Clear("C", "Button", "button")
    local integer ret
    local integer i= GetHandleId(key)
    set i=i - ( i / ABC___HASH ) * ABC___HASH
	
    if ABC___ButtonKeyC[i] == key then
        set ret=ABC___ButtonValueC[i]
        set ABC___ButtonKeyC[i]=null
        set ABC___ButtonValueC[i]=0
    else
        if HaveSavedInteger(ABC___ButtonHash, 'C', GetHandleId(key)) then
            set ret=LoadInteger(ABC___ButtonHash, 'C', GetHandleId(key))
            call RemoveSavedInteger(ABC___ButtonHash, 'C', GetHandleId(key))
        else
            call BJDebugMsg("|cFFFF0000ERROR: ClearButtonStructC(" + I2S(GetHandleId(key)) + ") - clear attempt on bad key")
            set ret=0
        endif
    endif
    
    return ret
//end of: ABC_Clear("C", "Button", "button")
endfunction
//==============================================================================
//  Initialization
//==============================================================================
function ABC___Init takes nothing returns nothing
    set ABC___TimerKeyA[ABC___HASH - 1]=null
    set ABC___TimerKeyB[ABC___HASH - 1]=null
    set ABC___TimerKeyC[ABC___HASH - 1]=null
    set ABC___TriggerKeyA[ABC___HASH - 1]=null
    set ABC___TriggerKeyB[ABC___HASH - 1]=null
    set ABC___TriggerKeyC[ABC___HASH - 1]=null
    set ABC___DialogKeyA[ABC___HASH - 1]=null
    set ABC___DialogKeyB[ABC___HASH - 1]=null
    set ABC___DialogKeyC[ABC___HASH - 1]=null
    set ABC___RegionKeyA[ABC___HASH - 1]=null
    set ABC___RegionKeyB[ABC___HASH - 1]=null
    set ABC___RegionKeyC[ABC___HASH - 1]=null
    set ABC___ButtonKeyA[ABC___HASH - 1]=null
    set ABC___ButtonKeyB[ABC___HASH - 1]=null
    set ABC___ButtonKeyC[ABC___HASH - 1]=null
    
    set ABC___TimerValueA[ABC___HASH - 1]=0
    set ABC___TimerValueB[ABC___HASH - 1]=0
    set ABC___TimerValueC[ABC___HASH - 1]=0
    set ABC___TriggerValueA[ABC___HASH - 1]=0
    set ABC___TriggerValueB[ABC___HASH - 1]=0
    set ABC___TriggerValueC[ABC___HASH - 1]=0
    set ABC___DialogValueA[ABC___HASH - 1]=0
    set ABC___DialogValueB[ABC___HASH - 1]=0
    set ABC___DialogValueC[ABC___HASH - 1]=0
    set ABC___RegionValueA[ABC___HASH - 1]=0
    set ABC___RegionValueB[ABC___HASH - 1]=0
    set ABC___RegionValueC[ABC___HASH - 1]=0
    set ABC___ButtonValueA[ABC___HASH - 1]=0
    set ABC___ButtonValueB[ABC___HASH - 1]=0
    set ABC___ButtonValueC[ABC___HASH - 1]=0
    
    set ABC___TimerCollisionA[ABC___HASH - 1]=0
    set ABC___TimerCollisionB[ABC___HASH - 1]=0
    set ABC___TimerCollisionC[ABC___HASH - 1]=0
    set ABC___TriggerCollisionA[ABC___HASH - 1]=0
    set ABC___TriggerCollisionB[ABC___HASH - 1]=0
    set ABC___TriggerCollisionC[ABC___HASH - 1]=0
    set ABC___DialogCollisionA[ABC___HASH - 1]=0
    set ABC___DialogCollisionB[ABC___HASH - 1]=0
    set ABC___DialogCollisionC[ABC___HASH - 1]=0
    set ABC___RegionCollisionA[ABC___HASH - 1]=0
    set ABC___RegionCollisionB[ABC___HASH - 1]=0
    set ABC___RegionCollisionC[ABC___HASH - 1]=0
    set ABC___ButtonCollisionA[ABC___HASH - 1]=0
    set ABC___ButtonCollisionB[ABC___HASH - 1]=0
    set ABC___ButtonCollisionC[ABC___HASH - 1]=0
    
    set ABC___TimerHash=InitHashtable()
    set ABC___TriggerHash=InitHashtable()
    set ABC___DialogHash=InitHashtable()
    set ABC___RegionHash=InitHashtable()
    set ABC___ButtonHash=InitHashtable()
endfunction

//library ABC ends
//library AIAttack:
function AIAttackCondition takes nothing returns nothing
local unit ds= GetAttacker()
local integer t= GetUnitTypeId(ds)
local real sx
local real sy
local real tx
local real ty
local unit u1
if t == 'u002' then
    set sx=GetUnitX(ds)
    set sy=GetUnitY(ds)
    set tx=GetUnitX(GetTriggerUnit())
    set ty=GetUnitY(GetTriggerUnit())
    set u1=CreateUnit(Player(11), 'u000', sx, sy, 0)
    call s__vector_deallocate(s__Velocity_v[sc__Velocity__staticgetindex(u1)])
    set s__Velocity_v[sc__Velocity__staticgetindex(u1)]=GetGrenadeVector(sx , sy , tx , ty)
    call sc__vector_setLength(s__Velocity_v[sc__Velocity__staticgetindex(u1)],GetGrenadeTrajectory(casterX , casterY , targetX , targetY))
endif
set ds=null
endfunction
function InitAIAttack takes nothing returns nothing
set gtrgAIAttack=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gtrgAIAttack, EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gtrgAIAttack, Condition(function AIAttackCondition))
endfunction

//library AIAttack ends
//library AIDS:
    //==============================================================================
    // Configurables
    //
    
    function AIDS__UnitIndexingFilter takes unit u returns boolean
        return true
    endfunction
    
    //==============================================================================
    // System code
    //
    
    //==============================================================================
    
    //==============================================================================
    
    
    //==============================================================================
    
    constant function AIDS_GetEnteringIndexUnit takes nothing returns unit
        return AIDS__ARStackUnit[AIDS__ARStackLevel]
    endfunction
    
    function AIDS_GetIndexOfEnteringUnit takes nothing returns integer
        // Called in AIDS structs when units do not pass the initial AIDS filter.
        
        if AIDS__ARStackIndex[AIDS__ARStackLevel] == 0 then
            // Get new index, from recycler first, else new.
            // Store the current index on the (new) top level of the AR stack.
            if AIDS__MaxRecycledIndex == 0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex + 1
                set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__MaxIndex
            else // Get from recycle stack.
set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex - 1
            endif
            
            // Store index on unit.
            call SetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel], AIDS__ARStackIndex[AIDS__ARStackLevel])
            set AIDS__IndexUnit[AIDS__ARStackIndex[AIDS__ARStackLevel]]=AIDS__ARStackUnit[AIDS__ARStackLevel]
            
            // Add index to recycle list.
            set AIDS__MaxDecayingIndex=AIDS__MaxDecayingIndex + 1
            set AIDS__DecayingIndex[AIDS__MaxDecayingIndex]=AIDS__ARStackIndex[AIDS__ARStackLevel]
        endif
        
        return AIDS__ARStackIndex[AIDS__ARStackLevel]
    endfunction
    
    constant function AIDS_GetIndexOfEnteringUnitAllocated takes nothing returns integer
        // Called in AIDS structs when units have passed the initial AIDS filter.
        return AIDS__ARStackIndex[AIDS__ARStackLevel]
    endfunction
    constant function AIDS_GetDecayingIndex takes nothing returns integer



            return AIDS__UndefendExpiringIndex[AIDS__UndefendExpiringIndexLevel]

    endfunction
    
    //==============================================================================
    
    function AIDS_RegisterOnEnter takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnEnter, b)
    endfunction
    function AIDS_RegisterOnEnterAllocated takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnEnterAllocated, b)
    endfunction
    function AIDS_RegisterOnDeallocate takes boolexpr b returns triggercondition
        return TriggerAddCondition(AIDS__OnDeallocate, b)
    endfunction
    
    //==============================================================================
    function GetIndexUnit takes integer index returns unit
        
        return AIDS__IndexUnit[index]
    endfunction
    
    function GetUnitId takes unit u returns integer
        
        return GetUnitUserData(u)
    endfunction
    
    function GetUnitIndex takes unit u returns integer
        
        set AIDS__getindex=GetUnitUserData(u)
        
        if AIDS__getindex == 0 then
            // Get new index, from recycler first, else new.
            // Store the current index in getindex.
            if AIDS__MaxRecycledIndex == 0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex + 1
                set AIDS__getindex=AIDS__MaxIndex
            else // Get from recycle stack.
set AIDS__getindex=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex - 1
            endif
            
            // Store index on unit.
            call SetUnitUserData(u, AIDS__getindex)
            set AIDS__IndexUnit[AIDS__getindex]=u
            







            
                // Add leave detection ability.
                call UnitAddAbility(AIDS__ARStackUnit[AIDS__ARStackLevel], AIDS__LEAVE_DETECTION_ABILITY)
                call UnitMakeAbilityPermanent(AIDS__ARStackUnit[AIDS__ARStackLevel], true, AIDS__LEAVE_DETECTION_ABILITY)
                

            
            // Do not fire things here. No AIDS structs will be made at this point.
        endif
        
        return AIDS__getindex
    endfunction
    
    //==============================================================================
    function AIDS_AddLock takes integer index returns nothing
        set AIDS__LockLevel[index]=AIDS__LockLevel[index] + 1
    endfunction
    function AIDS_RemoveLock takes integer index returns nothing
        set AIDS__LockLevel[index]=AIDS__LockLevel[index] - 1
        

            if GetUnitUserData(AIDS__IndexUnit[index]) == 0 and AIDS__LockLevel[index] == 0 then
                
                // Increment stack for recursion.
                set AIDS__UndefendExpiringIndexLevel=AIDS__UndefendExpiringIndexLevel + 1
                set AIDS__UndefendExpiringIndex[AIDS__UndefendExpiringIndexLevel]=index
                
                // Fire things.
                call TriggerEvaluate(AIDS__OnDeallocate)
                
                // Decrement stack for recursion.
                set AIDS__UndefendExpiringIndexLevel=AIDS__UndefendExpiringIndexLevel - 1
                
                // Add the index to the recycler stack.
                set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex + 1
                set AIDS__RecycledIndex[AIDS__MaxRecycledIndex]=index
                
                // Null the unit.
                set AIDS__IndexUnit[index]=null
                
            endif

    endfunction
    
    //==============================================================================































        
        function AIDS__UndefendFilter takes nothing returns boolean
            return IsUnitType(GetFilterUnit(), UNIT_TYPE_DEAD)
        endfunction
        
        function AIDS__OnUndefendTimer takes nothing returns nothing
            loop
                exitwhen AIDS__UndefendStackIndex == 0
                
                set AIDS__UndefendStackIndex=AIDS__UndefendStackIndex - 1
                set AIDS__UndefendExpiringIndex[0]=AIDS__UndefendIndex[AIDS__UndefendStackIndex]
                
                if AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]] != null then
                if GetUnitUserData(AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]]) == 0 then
                if AIDS__LockLevel[AIDS__UndefendExpiringIndex[0]] == 0 then
                    
                    // Fire things.
                    call TriggerEvaluate(AIDS__OnDeallocate)
                    
                    // Add the index to the recycler stack.
                    set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex + 1
                    set AIDS__RecycledIndex[AIDS__MaxRecycledIndex]=AIDS__UndefendExpiringIndex[0]
                    
                    // Null the unit.
                    set AIDS__IndexUnit[AIDS__UndefendExpiringIndex[0]]=null
                    
                endif
                endif
                endif
                
            endloop
        endfunction
        
        function AIDS__OnUndefend takes nothing returns boolean
            if GetIssuedOrderId() == 852056 then // If undefend then...
set AIDS__UndefendFilterIndex=GetUnitUserData(GetOrderedUnit())
                
                if AIDS__UndefendIndex[AIDS__UndefendStackIndex - 1] != AIDS__UndefendFilterIndex then // Efficiency perk.
set AIDS__UndefendIndex[AIDS__UndefendStackIndex]=AIDS__UndefendFilterIndex
                    set AIDS__UndefendStackIndex=AIDS__UndefendStackIndex + 1
                    
                    call TimerStart(AIDS__UndefendTimer, 0, false, function AIDS__OnUndefendTimer)
                endif
            endif
            
            return false
        endfunction
        

    
    //==============================================================================
    function AIDS_IndexEnum takes nothing returns boolean
// Start by adding another level on the AR stack (for recursion's sake).
set AIDS__ARStackLevel=AIDS__ARStackLevel + 1
        
        // Store the current unit on the (new) top level of the AR stack.
        set AIDS__ARStackUnit[AIDS__ARStackLevel]=GetFilterUnit()
        
        if GetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel]) == 0 then // Has not been indexed.

            if AIDS__UnitIndexingFilter(AIDS__ARStackUnit[AIDS__ARStackLevel]) then
                
                // Get new index, from recycler first, else new.
                // Store the current index on the (new) top level of the AR stack.
                if AIDS__MaxRecycledIndex == 0 then // Get new.
set AIDS__MaxIndex=AIDS__MaxIndex + 1
                    set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__MaxIndex
                else // Get from recycle stack.
set AIDS__ARStackIndex[AIDS__ARStackLevel]=AIDS__RecycledIndex[AIDS__MaxRecycledIndex]
                    set AIDS__MaxRecycledIndex=AIDS__MaxRecycledIndex - 1
                endif
                
                // Store index on unit.
                call SetUnitUserData(AIDS__ARStackUnit[AIDS__ARStackLevel], AIDS__ARStackIndex[AIDS__ARStackLevel])
                set AIDS__IndexUnit[AIDS__ARStackIndex[AIDS__ARStackLevel]]=AIDS__ARStackUnit[AIDS__ARStackLevel]
                







                    
                    // Add leave detection ability.
                    call UnitAddAbility(AIDS__ARStackUnit[AIDS__ARStackLevel], AIDS__LEAVE_DETECTION_ABILITY)
                    call UnitMakeAbilityPermanent(AIDS__ARStackUnit[AIDS__ARStackLevel], true, AIDS__LEAVE_DETECTION_ABILITY)
                    

                
                // Fire things.
                call TriggerEvaluate(AIDS__OnEnter)
                
            else
                
                // The unit did not pass the filters, so does not need to be auto indexed.
                // However, for certain AIDS structs, it may still require indexing.
                // These structs may index the unit on their creation.
                // We flag that an index must be assigned by setting the current index to 0.
                set AIDS__ARStackIndex[AIDS__ARStackLevel]=0
                
                // Fire things.
                call TriggerEvaluate(AIDS__OnEnter)
                
            endif
            
        endif
        
        // Decrement the stack.
        set AIDS__ARStackLevel=AIDS__ARStackLevel - 1
        
        return false
    endfunction
    
    //==============================================================================
    function AIDS__InitAIDS takes nothing returns nothing
        local region r=CreateRegion()
        
        local group g=CreateGroup()
        local integer n=15
        





            
            local trigger t=CreateTrigger()
            
            loop
                call TriggerRegisterPlayerUnitEvent(t, Player(n), EVENT_PLAYER_UNIT_ISSUED_ORDER, Filter(function AIDS__UndefendFilter))
                call SetPlayerAbilityAvailable(Player(n), AIDS__LEAVE_DETECTION_ABILITY, false)
                // Capture "undefend" orders.
                exitwhen n == 0
                set n=n - 1
            endloop
            set n=15
            
            call TriggerAddCondition(t, Filter(function AIDS__OnUndefend))
            set t=null
            

        
        // This must be done first, due to recursion. :)
        call RegionAddRect(r, GetWorldBounds())
        call TriggerRegisterEnterRegion(CreateTrigger(), r, Filter(function AIDS_IndexEnum))
        set r=null
        
        loop
            call GroupEnumUnitsOfPlayer(g, Player(n), Filter(function AIDS_IndexEnum))
            //Enum every non-filtered unit on the map during initialization and assign it a unique
            //index. By using GroupEnumUnitsOfPlayer, even units with Locust can be detected.
            exitwhen n == 0
            set n=n - 1
        endloop
        call DestroyGroup(g)
        set g=null
    endfunction
    
    //==============================================================================
        function s__AIDS_DEFAULT_AIDS_onCreate takes integer this returns nothing
        endfunction
        function s__AIDS_DEFAULT_AIDS_onDestroy takes integer this returns nothing
        endfunction
        
        function s__AIDS_DEFAULT_AIDS_filter takes unit u returns boolean
            return AIDS__UnitIndexingFilter(u)
        endfunction
        
        function s__AIDS_DEFAULT_AIDS_onInit takes nothing returns nothing
        endfunction
    
    //===========================================================================
    //  Never create or destroy AIDS structs directly.
    //  Also, do not initialise members except by using the AIDS_onCreate method.
    //===========================================================================

//library AIDS ends
//library AIDriver:
function AIDriver___GetStrategy takes unit u returns integer
return s__AIData_strategy[sc__AIData__staticgetindex(u)]
endfunction
function TargetInRange takes unit u,unit tu,real r returns nothing
    call sc__IAIStrategy_targetInRange(s__AIData_strategy[sc__AIData__staticgetindex(u)],u , tu , r)
endfunction
function TargetOutRange takes unit u returns nothing
    call sc__IAIStrategy_targetOutRange(s__AIData_strategy[sc__AIData__staticgetindex(u)],u)
endfunction
function BeHurted takes unit u returns nothing
call sc__IAIStrategy_beHurted(s__AIData_strategy[sc__AIData__staticgetindex(u)],u)
endfunction
function GetInMap takes unit u returns nothing
call sc__IAIStrategy_getInMap(s__AIData_strategy[sc__AIData__staticgetindex(u)],u)
endfunction

//library AIDriver ends
//library AII:


    
    


    
    function AII___FireEvent takes trigger trig,integer dat returns nothing
        local integer old=AII___EventStruct
        set AII___EventStruct=dat
        call TriggerEvaluate(trig)
        set AII___EventStruct=old
        //Bye bye to stack. :)
    endfunction
    
    function AII___Hash takes widget w returns integer
        local integer int=GetHandleId(w)
        local integer hash=int - ( int / AII___MAX_HASH_VALUE ) * AII___MAX_HASH_VALUE
        loop
            exitwhen AII___HashedInt[hash] == int
            if AII___HashedInt[hash] == 0 then
                set AII___HashedInt[hash]=int
                return hash
            endif
            set hash=hash + AII___HASH_NEXT
            if hash >= AII___MAX_HASH_VALUE then
                set hash=hash - AII___MAX_HASH_VALUE
            endif
        endloop
        return hash
    endfunction
    //Handy function from Jesus4Lyf
    
    function AII___RemoveHash takes integer int returns nothing
        local integer hash=int - ( int / AII___MAX_HASH_VALUE ) * AII___MAX_HASH_VALUE
        loop
            if AII___HashedInt[hash] == int then
                set AII___HashedInt[hash]=0
                return
            endif
            set hash=hash + AII___HASH_NEXT
            if hash >= AII___MAX_HASH_VALUE then
                set hash=hash - AII___MAX_HASH_VALUE
            endif
        endloop
        //To cleaned up unused values.
    endfunction
    
        
        function s__AII___ItemStruct_refreshEventTrigger takes nothing returns nothing
            //See if the thrash is trigger is necessary to clean or not.
            local integer this
            set s__AII___ItemStruct_thrashCount=s__AII___ItemStruct_thrashCount + 1
            if s__AII___ItemStruct_thrashCount >= AII___MAX_THRASH then
            //If the thrash is over the default number, refresh the trigger. 
                call DisableTrigger(s__AII___ItemStruct_trig)
                call TriggerClearConditions(s__AII___ItemStruct_trig)
                call DestroyTrigger(s__AII___ItemStruct_trig)
                set s__AII___ItemStruct_trig=CreateTrigger()
                call TriggerAddCondition(s__AII___ItemStruct_trig, Condition(function sc__AII___ItemStruct_onDeath))
                //Reset the trigger.
                set this=s__AII___ItemStruct_nextA[(0)]
                loop
                    exitwhen this == 0
                    call TriggerRegisterDeathEvent(s__AII___ItemStruct_trig, s__AII___ItemStruct_it[this])
                    //Reregister back the event.
                    set this=s__AII___ItemStruct_nextA[this]
                endloop
                set s__AII___ItemStruct_thrashCount=0
            endif
        endfunction
        
        function s__AII___ItemStruct_onDeath takes nothing returns boolean
            call sc__AII___ItemStruct_manageLock((GetItemUserData(AII___HashedItem[AII___Hash(GetTriggerWidget())])),false) //Get the attached item.
//Item is removed.
return false
        endfunction
        
        
        function s__AII___ItemStruct_addToActive takes integer this returns nothing
            set s__AII___ItemStruct_prevA[s__AII___ItemStruct_nextA[(0)]]=this
            set s__AII___ItemStruct_nextA[this]=s__AII___ItemStruct_nextA[(0)]
            set s__AII___ItemStruct_nextA[(0)]=this
            set s__AII___ItemStruct_prevA[this]=(0)
        endfunction
        
        function s__AII___ItemStruct_removeFromActive takes integer this returns nothing
            set s__AII___ItemStruct_nextA[s__AII___ItemStruct_prevA[this]]=s__AII___ItemStruct_nextA[this]
            set s__AII___ItemStruct_prevA[s__AII___ItemStruct_nextA[this]]=s__AII___ItemStruct_prevA[this]
        endfunction
        
        function s__AII___ItemStruct_remove takes integer this returns nothing
            call AII___FireEvent(AII___dealloItem , this)
            call s__AII___ItemStruct_removeFromActive(this)
            call AII___RemoveHash(s__AII___ItemStruct_hid[this])
            call s__AII___ItemStruct_refreshEventTrigger()
            set s__AII___ItemStruct_it[this]=null
            if AII___IsInited then
                call s__AII___ItemStruct_deallocate(this)
            else
                set s__AII___ItemStruct_tFDCount=s__AII___ItemStruct_tFDCount + 1
                set s__AII___ItemStruct_toFireDeallocate[s__AII___ItemStruct_tFDCount]=this
            endif
        endfunction
        
        function s__AII___ItemStruct_manageLock takes integer this,boolean b returns nothing
            if b then
                set s__AII___ItemStruct_lockLevel[this]=s__AII___ItemStruct_lockLevel[this] + 1
            else
                set s__AII___ItemStruct_lockLevel[this]=s__AII___ItemStruct_lockLevel[this] - 1
                if s__AII___ItemStruct_lockLevel[this] == 0 then
                    call s__AII___ItemStruct_remove(this)
                endif
            endif
        endfunction
        
        function s__AII___ItemStruct_load takes item i returns integer
            local integer this
            set this=GetItemUserData(i)
            if i == null then //If item is null, then no point to index it..
return 0
            endif
            if this == 0 then //Okay, the item is not indexed.
set this=s__AII___ItemStruct__allocate()
                set s__AII___ItemStruct_it[this]=i
                set s__AII___ItemStruct_hid[this]=GetHandleId(s__AII___ItemStruct_it[this])
                call TriggerRegisterDeathEvent(s__AII___ItemStruct_trig, s__AII___ItemStruct_it[this]) //Register item death event.
set AII___HashedItem[AII___Hash(s__AII___ItemStruct_it[this])]=s__AII___ItemStruct_it[this] //Attach the item to itself.
                set s__AII___ItemStruct_lockLevel[this]=1
                
                call SetItemUserData(i, this)
                call AII___FireEvent(AII___alloItem , this) //Fire event!

                call s__AII___ItemStruct_addToActive(this)
            endif
            return this
        endfunction
        
        function s__AII___ItemStruct_refireAllocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local integer this=s__AII___ItemStruct_nextA[(0)]
            call TriggerAddCondition(trig, c)
            loop
                exitwhen this == 0
                call AII___FireEvent(trig , this)
                set this=s__AII___ItemStruct_nextA[this]
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endfunction
        
        function s__AII___ItemStruct_refireDeallocateCallback takes conditionfunc c returns nothing
            local trigger trig=CreateTrigger()
            local integer count=s__AII___ItemStruct_tFDCount
            call TriggerAddCondition(trig, c)
            loop
            exitwhen count == 0
                call AII___FireEvent(trig , s__AII___ItemStruct_toFireDeallocate[count])
                set count=count - 1
            endloop
            call DestroyTrigger(trig)
            set trig=null
        endfunction
        
        function s__AII___ItemStruct_flag takes nothing returns nothing
            //Indicates the game is initialized.
            local integer count=s__AII___ItemStruct_tFDCount
            loop
            exitwhen count == 0
                call s__AII___ItemStruct_deallocate(s__AII___ItemStruct_toFireDeallocate[count])
                set count=count - 1
            endloop
            set AII___IsInited=true
            call PauseTimer(GetExpiredTimer())
            call DestroyTimer(GetExpiredTimer())
        endfunction
        
        function s__AII___ItemStruct_onInit takes nothing returns nothing
            call TriggerAddCondition(s__AII___ItemStruct_trig, Condition(function s__AII___ItemStruct_onDeath))
            call TimerStart(CreateTimer(), 0.0, false, function s__AII___ItemStruct_flag)
        endfunction
    function GetItemId takes item i returns integer
        return GetItemUserData(i)
    endfunction
    
    function GetItemById takes integer i returns item
        return s__AII___ItemStruct_it[(i)]
    endfunction
    
    function CreateItemEx takes integer itemid,real x,real y returns item
        return s__AII___ItemStruct_it[s__AII___ItemStruct_load(CreateItem(itemid, x, y))]
    endfunction
    
    
        function s__AII___Initializer_onPickUp takes nothing returns boolean
            call s__AII___ItemStruct_load(GetManipulatedItem())
            return false
        endfunction
        
        function s__AII___Initializer_onSell takes nothing returns boolean
            call s__AII___ItemStruct_load(GetSoldItem())
            return false
        endfunction
        
        function s__AII___Initializer_onPawn takes nothing returns boolean



            call s__AII___ItemStruct_manageLock(s__AII___ItemStruct_load(GetSoldItem()),false)
            return false
        endfunction
        
        function s__AII___Initializer_indexPreplaced takes nothing returns boolean
            call s__AII___ItemStruct_load(GetFilterItem())
            return false
        endfunction
        
        function s__AII___Initializer_indexItemOnUnit takes nothing returns boolean
            local unit u=GetFilterUnit()
            local integer i= 0
            local integer maxSize= UnitInventorySize(u)
            local integer it
            loop
            exitwhen i == maxSize
                call s__AII___ItemStruct_load(UnitItemInSlot(u, i))
                set i=i + 1
            endloop
            set u=null
            return false
        endfunction
    
//Implemented from module AII___AIIInit:
        function s__AII___Initializer_AII___AIIInit___onInit takes nothing returns nothing
            local group g=CreateGroup()
            local rect world=GetWorldBounds()
            
            call EnumItemsInRect(world, Condition(function s__AII___Initializer_indexPreplaced), null)
            call GroupEnumUnitsInRect(g, world, Condition(function s__AII___Initializer_indexItemOnUnit))
            call RemoveRect(world)
            call DestroyGroup(g)
            set g=null
            set world=null
        
            call TriggerRegisterAnyUnitEventBJ(AII___pickUpItem, EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII___sellItem, EVENT_PLAYER_UNIT_SELL_ITEM)
            call TriggerRegisterAnyUnitEventBJ(AII___pawnItem, EVENT_PLAYER_UNIT_PAWN_ITEM)
            
            call TriggerAddCondition(AII___pickUpItem, Condition(function s__AII___Initializer_onPickUp))
            call TriggerAddCondition(AII___sellItem, Condition(function s__AII___Initializer_onSell))
            call TriggerAddCondition(AII___pawnItem, Condition(function s__AII___Initializer_onPawn))
        endfunction
    

//library AII ends
//library BOSS1:
function changeMelee takes nothing returns nothing
    call UnitAddAbility(boss1, 'A01Q')
    call UnitRemoveAbility(boss1, 'A01Q')
endfunction
function changeRange takes nothing returns nothing
    call UnitAddAbility(boss1, 'A01R')
    call UnitRemoveAbility(boss1, 'A01R')
endfunction

//library BOSS1 ends
//library BufferFunction:
function ApplyBurn takes unit source,unit target,real dam,real time returns nothing
    local integer burnlv= s__Material_burnlv[sc__Material__staticgetindex(target)]
    local integer debuff
    if burnlv < MAX_BURN_LV then
        set debuff=sc__BurnBuffer_create(target , R2I(time * 50) , source , dam / 2)
        call sc__DefaultBufferStruct_start(debuff)
    endif
endfunction
function ApplyBleed takes unit source,unit target,real dam,real time returns nothing
    local integer bleedlv= s__Material_bleedlv[sc__Material__staticgetindex(target)]
    local integer debuff
    if bleedlv < MAX_BLEED_LV then
        set debuff=sc__BleedBuffer_create(target , R2I(time * 50) , source , dam / 2)
        call sc__DefaultBufferStruct_start(debuff)
    endif
endfunction
function ApplyIceSlow takes unit target,real time returns nothing
    call sc__DefaultBufferStruct_start(s__IceSlowBuffer__allocate(target , R2I(time * 50)))
endfunction
function ApplyHorro takes unit source,unit target,real time returns nothing
    local boolean status= s__Material_horro[sc__Material__staticgetindex(target)]
    local integer debuff
    if not status then
        set debuff=sc__HorroBuffer_create(target , source , R2I(time * 50))
        call sc__DefaultBufferStruct_start(debuff)
    endif
endfunction

//library BufferFunction ends
//library Debuff:
function IceStar takes unit s,unit target returns nothing
    local unit dummy
    set dummy=CreateUnit(GetOwningPlayer(s), MAGIC, GetUnitX(target), GetUnitY(target), 0)
    call IssueTargetOrderById(dummy, 852226, target)
    set dummy=null
endfunction
function ElectricBlow takes unit s,unit target returns nothing
    local unit dummy
    set dummy=CreateUnit(GetOwningPlayer(s), MAGIC, GetUnitX(target), GetUnitY(target), 0)
    call IssueTargetOrderById(dummy, 852111, target)
    set dummy=null
endfunction
function Clap takes unit s,unit target,integer lv returns nothing
    local unit dummy
    set dummy=CreateUnit(GetOwningPlayer(s), MAGIC, GetUnitX(target), GetUnitY(target), 0)
    call SetUnitAbilityLevel(dummy, 'A01A', lv)
    call IssueImmediateOrderById(dummy, 852096)
    set dummy=null
endfunction
function Stun takes unit s,unit target,integer lv returns nothing
    local unit dummy
    set dummy=CreateUnit(GetOwningPlayer(s), MAGIC, GetUnitX(target), GetUnitY(target), 0)
    call SetUnitAbilityLevel(dummy, 'A018', lv)
    call IssueTargetOrderById(dummy, 852095, target)
    set dummy=null
endfunction
function Frezz takes unit s,unit target,integer lv returns nothing
    local unit dummy
    set dummy=CreateUnit(GetOwningPlayer(s), MAGIC, GetUnitX(target), GetUnitY(target), 0)
    call SetUnitAbilityLevel(dummy, 'A01C', lv)
    call IssueTargetOrderById(dummy, 852231, target)
    set dummy=null
endfunction

//library Debuff ends
//library Difficulty:
function SetDifficulty takes integer diff returns nothing
    if diff == D_HARD or diff == D_CRAZY or diff == D_HELL then
        set Difficulty=diff
    endif
endfunction

//library Difficulty ends
//library Distance:
    function DistanceTwoUnits takes unit u,unit t returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real tx=GetUnitX(t)
        local real ty=GetUnitY(t)
        local real dis=SquareRoot(Pow(ty - uy, 2) + Pow(tx - ux, 2))
        return dis
    endfunction
    
    function DistanceUnitAndXY takes unit u,real x,real y returns real
        local real ux=GetUnitX(u)
        local real uy=GetUnitY(u)
        local real dis=SquareRoot(Pow(y - uy, 2) + Pow(x - ux, 2))
        return dis
    endfunction
    
    function DistanceTwo takes real ux,real uy,real tx,real ty returns real
        return SquareRoot(Pow(ty - uy, 2) + Pow(tx - ux, 2))
    endfunction

//library Distance ends
//library DummyCaster:
    // If you're looking for where the 'dumy' type is declared, it is declared
    // in the object merger line at the end of "How to implement?" in the above
    // documentation.
    
// create/destoy methods.
// The initialisation is done this way because struct initialisers are
// called before library initialisers, making this important for adding
// abilities on map initialisation.
function s__DummyCaster___Initializer_onInit takes nothing returns nothing
            set DUMMY=CreateUnit(DUMMY_OWNER, DUMMY_TYPE, DummyCaster___CREATED_AT_X, DummyCaster___CREATED_AT_Y, 0)
        endfunction

//library DummyCaster ends
//library EffectString:
function CreateEffect takes string e,real x,real y returns nothing
    call DestroyEffect(AddSpecialEffect(e, x, y))
endfunction

//library EffectString ends
//library EffectZ:
//  _________________________________________
// +-----------------------------------------+
// |             E F F E C T   Z             |
// +-----------------------------------------+
// | - Feel free to take these out of this   |
// |   library and put them directly into    |
// |   your code.                            |
// | - I don't care about credit. I haven't  |
// |   even included my name here. :]        |
// +-----------------------------------------+
//  藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
    function AddSpecialEffectZ takes string modelName,real x,real y,real z returns effect
        set EffectZ__D=CreateDestructableZ('OTip', x, y, z, 0., 1., 0)
        set EffectZ__E=AddSpecialEffect(modelName, x, y)
        call RemoveDestructable(EffectZ__D)
        return EffectZ__E
    endfunction
    
    function AddSpecialEffectLocZ takes string modelName,location where,real z returns effect
        set EffectZ__D=CreateDestructableZ('OTip', GetLocationX(where), GetLocationY(where), z, 0., 1., 0)
        set EffectZ__E=AddSpecialEffectLoc(modelName, where)
        call RemoveDestructable(EffectZ__D)
        return EffectZ__E
    endfunction

//library EffectZ ends
//library Event:
    ///////////////
    // EventRegs //
    ////////////////////////////////////////////////////////////////////////////
    // For reading this far, you can learn one thing more.
    // Unlike normal Warcraft III events, you can attach to Event registries.
    // 
    // Event Registries are registrations of one trigger on one event.
    // These cannot be created or destroyed, just attached to.
    //
    // It is VERY efficient for loading and saving data.
    // 
    //  Functions:
    //         - set eventReg.data = someStruct --> Store data.
    //         - eventReg.data                  --> Retreive data.
    //         - Event.getTriggeringEventReg()  --> Get the triggering EventReg.
    //         - eventReg.destroy()             --> Undo this registration.
    // 
        function s__EventReg_clear takes integer this returns nothing
            set s__EventReg_data[this]=0
        endfunction
        function s__EventReg_destroy takes integer this returns nothing
            call sc__Event_Event__destroyNode((this))
        endfunction
    
    
//Implemented from module Event__Stack:
        function s__Event__EventStack_increment takes nothing returns nothing
            set s__Event__EventStack_top=(s__Event__EventStack_top + 1)
        endfunction
        function s__Event__EventStack_decrement takes nothing returns nothing
            set s__Event__EventStack_top=(s__Event__EventStack_top - 1)
        endfunction
    
        
        function s__Event_getTriggeringEventReg takes nothing returns integer
            return s__Event__EventStack_current[s__Event__EventStack_top]
        endfunction
        
        function s__Event_create takes nothing returns integer
            local integer this=s__Event__allocate()
            set s__Event_next[this]=this
            set s__Event_prev[this]=this
            return this
        endfunction
        
        function s__Event_fire takes integer this returns nothing
            local integer curr=s__Event_next[this]
            call s__Event__EventStack_increment()
            loop
                exitwhen curr == this
                set s__Event_currentTrigger=s__Event_trig[curr]
                if IsTriggerEnabled(s__Event_currentTrigger) then
                    set s__Event__EventStack_current[s__Event__EventStack_top]=curr
                    if TriggerEvaluate(s__Event_currentTrigger) then
                        call TriggerExecute(s__Event_currentTrigger)
                    endif
                else
                    call EnableTrigger(s__Event_currentTrigger) // Was trigger destroyed?
if IsTriggerEnabled(s__Event_currentTrigger) then
                        call DisableTrigger(s__Event_currentTrigger)
                    else // If trigger destroyed...
set s__Event_prev[s__Event_next[curr]]=s__Event_prev[curr]
                        set s__Event_next[s__Event_prev[curr]]=s__Event_next[curr]
                        call s__Event_deallocate(curr)
                    endif
                endif
                set curr=s__Event_next[curr]
            endloop
            call s__Event__EventStack_decrement()
        endfunction
        function s__Event_register takes integer this,trigger t returns integer
            local integer new=s__Event__allocate()
            set s__Event_prev[new]=s__Event_prev[this]
            set s__Event_next[s__Event_prev[this]]=new
            set s__Event_prev[this]=new
            set s__Event_next[new]=this
            
            set s__Event_trig[new]=t
            
            call s__EventReg_clear((new))
            return new
        endfunction
        function s__Event_Event__destroyNode takes integer this returns nothing
set s__Event_next[s__Event_prev[this]]=s__Event_next[this]
            set s__Event_prev[s__Event_next[this]]=s__Event_prev[this]
            call s__Event_deallocate(this)
        endfunction
        function s__Event_unregister takes integer this,trigger t returns nothing
            local integer curr=s__Event_next[this]
            loop
                exitwhen curr == this
                if s__Event_trig[curr] == t then
                    set s__Event_prev[s__Event_next[curr]]=s__Event_prev[curr]
                    set s__Event_next[s__Event_prev[curr]]=s__Event_next[curr]
                    call s__Event_deallocate(curr)
                    return
                endif
                set curr=s__Event_next[curr]
            endloop
        endfunction
        
        function s__Event_destroy takes integer this returns nothing
            local integer curr=s__Event_next[this]
            loop
                call s__Event_deallocate(curr)
                exitwhen curr == this
                set curr=s__Event_next[curr]
            endloop
        endfunction
        function s__Event_chainDestroy takes integer this returns nothing
            call s__Event_destroy(this) // backwards compatability.
endfunction
    
    /////////////////////////////////////////////////////
    // Demonstration Functions & Alternative Interface //
    ////////////////////////////////////////////////////////////////////////////
    // What this would look like in normal WC3 style JASS (should all inline).
    // 
    function CreateEvent takes nothing returns integer
        return s__Event_create()
    endfunction
    function DestroyEvent takes integer whichEvent returns nothing
        call s__Event_chainDestroy(whichEvent)
    endfunction
    function FireEvent takes integer whichEvent returns nothing
        call s__Event_fire(whichEvent)
    endfunction
    function TriggerRegisterEvent takes trigger whichTrigger,integer whichEvent returns integer
        return s__Event_register(whichEvent,whichTrigger)
    endfunction
    
    // And for EventRegs...
    function SetEventRegData takes integer whichEventReg,integer data returns nothing
        set s__EventReg_data[whichEventReg]=data
    endfunction
    function GetEventRegData takes integer whichEventReg returns integer
        return s__EventReg_data[whichEventReg]
    endfunction
    function GetTriggeringEventReg takes nothing returns integer
        return s__Event_getTriggeringEventReg()
    endfunction

//library Event ends
//library FloatText:
function DisplayFloatText takes real x,real y,string msg,real life returns nothing
    local location p= Location(x, y)
    call CreateTextTagLocBJ(msg, p, 100, 10, 100, 100, 100, 0)
    call SetTextTagPermanent(GetLastCreatedTextTag(), false)
    call SetTextTagLifespan(GetLastCreatedTextTag(), life)
    set p=null
endfunction

//library FloatText ends
//library HashKeyManager:
function GetNewKey takes nothing returns integer
    set currentKey=currentKey + 1
    return currentKey
endfunction

//library HashKeyManager ends
//library HashTable:
function InitHashTable takes nothing returns nothing
    call FlushParentHashtable(ht)
    set ht=InitHashtable()
endfunction

//library HashTable ends
//library Height:
    function getTerrianHeight takes real x,real y returns real
        local location l= Location(x, y)
        local real h= GetLocationZ(l)
        call RemoveLocation(l)
        set l=null
        return h
    endfunction
    
    function getUnitHeight takes unit u returns real
        local real x= GetUnitX(u)
        local real y= GetUnitY(u)
        local real f= GetUnitFlyHeight(u)
        local real h= getTerrianHeight(x , y)
        return f + h
    endfunction

//library Height ends
//library HeroData:
//textmacro instance: CreateArrayList("TechRecord")
    
    function s__TechRecord_create takes nothing returns integer
        local integer m=s__TechRecord__allocate()
        set s__TechRecord_size[m]=0
        return m
    endfunction
    
    function s__TechRecord_addItem takes integer this,integer itm returns nothing
        set s___TechRecord_itms[s__TechRecord_itms[this]+s__TechRecord_size[this]]=itm
        set s__TechRecord_size[this]=s__TechRecord_size[this] + 1
    endfunction
//end of: CreateArrayList("TechRecord")
    //real shoot_speed_buff
    //integer last_shoot_tick

//library HeroData ends
//library HeroStatus:
function HeroStatusCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    local integer s= GetLearnedSkillBJ()
    if s == sALL then
        call SetHeroStr(u, ( GetHeroStr(u, false) + 1 ), true)
        call SetHeroAgi(u, ( GetHeroAgi(u, false) + 1 ), true)
        call SetHeroInt(u, ( GetHeroInt(u, false) + 1 ), true)
    elseif s == sSTR then
        call SetHeroStr(u, ( GetHeroStr(u, false) + 2 ), true)
    elseif s == sAGI then
        call SetHeroAgi(u, ( GetHeroAgi(u, false) + 2 ), true)
    elseif s == sINT then
        call SetHeroInt(u, ( GetHeroInt(u, false) + 2 ), true)
    endif
    set u=null
endfunction
function InitHeroStatus takes nothing returns nothing
local trigger herostatus_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(herostatus_t, EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(herostatus_t, Condition(function HeroStatusCondition))
set herostatus_t=null
endfunction

//library HeroStatus ends
//library Level1:
function startLevel takes nothing returns nothing
endfunction
function endLevel takes nothing returns nothing
endfunction
function InitLevel1 takes nothing returns nothing
endfunction

//library Level1 ends
//library ListModule:
//===========================================================================
// Information: 
//==============
//
//     This module allows you to create a linked list containing all of the allocated
// instances of a struct. Iterating through a linked list is slightly faster than the
// typical method of looping through an array containing all of the instances. However,
// getting a random struct from a list is an O(n) operation instead of O(1) as with
// SetModule. This should be a good trade as most systems don't need random access.
//
//     There is no speed loss while iterating through structs compared to doing
// it yourself, since all of method calls used while iterating get inlined. The best
// use for this module is to hide a lot of ugly low-level code from your systems.
//
// How to use List:
//==================
//
//     Implement the List module in your struct. Your struct will gain all of the
// following methods:
//
// (static) getLength: Returns an integer indicating the number of structs in the list.
//
// (static) getRandom: Returns a random struct from the list. Note that this is rather
//                     slow due to the fact that this is a linked list implementation.
//
// (static) getFirst: Returns the first struct in the list.
//
// (static) getLast: Returns the last struct in the list.
//
// getNext: Returns the next struct in the list.
//
// getPrev: Returns the previous struct in the list.
//
// inList: Returns a boolean indicating whether this struct is in the list.
//
// addList: Adds this struct to the list. Returns false if adding failed because the
//          list is being destroyed or the struct was already in the list.
//
// removeList: Removes this struct from the list. Returns false if removal failed 
//             because the struct was not in the list.
//
// (static) destroyList: Destroys all of the structs in the list.
//
// Example of List usage:
//========================
//
// struct YourStruct
//     implement List
//
//     static method create takes nothing returns YourStruct
//         local YourStruct ys = .allocate()
//             call ys.addList()
//         return ys
//     endmethod
//
//     method onDestroy takes nothing returns nothing
//         call .removeList()
//     endmethod
//
//     static method GetRandomStruct takes nothing returns YourStruct
//         return .getRandom() //That was easy... but slow.
//     endmethod
//
//     static method LoopThroughAllYourStructs takes nothing returns nothing
//         local YourStruct ys = .getFirst() //This is inlined to a variable read.
//             loop
//                 exitwhen ys == 0
//                 //Do something with the YourStruct instance here.
//                 set ys = ys.getNext() //This is inlined to an array read.
//             endloop
//     endmethod
// endstruct
//
//===========================================================================

//library ListModule ends
//library Lock:
function EnableAllAbi takes unit u returns nothing
    local integer i= 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable(Player(0), i, true)
        set i=i + 1
    endloop
endfunction
function DisableAllAbi takes unit u returns nothing
    local integer i= 'A000'
    loop
        exitwhen i > 'A020'
        call SetPlayerAbilityAvailable(Player(0), i, false)
        set i=i + 1
    endloop
endfunction
function EnableAbiLock takes integer i returns nothing
    set s__IHeroData_abi_lock[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[i])]]=CreateUnit(Player(i), ABI_LOCK, GetRectCenterX(gg_rct_lock[i]), GetRectCenterY(gg_rct_lock[i]), 0)
endfunction
function DisableAbiLock takes integer i returns nothing
    call RemoveUnit(s__IHeroData_abi_lock[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[i])]])
endfunction

//library Lock ends
//library Material:
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__Material__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__Material__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Material_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__Material_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Material_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if sc__Material_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__Material_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Material_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Material_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if sc__Material_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__Material_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Material_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Material_AIDS_onDeallocate takes nothing returns boolean
            if s__Material_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__Material_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__Material_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Material_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__Material_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__Material_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__Material_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call s__AIDS_DEFAULT_AIDS_onInit()
        endfunction
//end of: AIDS()
    
    
    function s__Material_AIDS_filter takes unit u returns boolean
        return true
    endfunction
    
    function s__Material_AIDS_onCreate takes integer this returns nothing
        local integer ut= GetUnitTypeId(s__Material__get_unit(this))
        set s__Material_burnlv[this]=0
        set s__Material_bleedlv[this]=0
        set s__Material_horro[this]=false
        set s__Material_horro_dmg[this]=HORRO_DMG
        set s__Material_anti_horro[this]=0
        set s__Material_clazz[this]=MC_UNIT
        set s__Material_hardness[this]=10
        set s__Material_bounce[this]=0.2
        set s__Material_volume[this]=100
        set s__Material_weight[this]=100
        set s__Material_airk[this]=0.75
        set s__Material_fakelv[this]=LV_FREEZ
        set s__Material_shot_tick[this]=0
        set s__Material_shot_fast_buff[this]=0
        set s__Material_last_shoot[this]=0
        set s__Material_last_issue[this]=0
        if ut == ONE_WALL or ut == ONE_WALL_BREAKABLE then
            set s__Material_clazz[this]=MC_WALL
        elseif ut == 'ncop' or ut == 'ncp2' or ut == 'ncp3' then
            set s__Material_clazz[this]=MC_RING
        elseif ut == HERO then
            set s__Material_clazz[this]=MC_UNIT
            set s__Material_hardness[this]=10
            set s__Material_bounce[this]=0.2
            set s__Material_volume[this]=150
            set s__Material_weight[this]=100
            set s__Material_airk[this]=0.75
            set s__Material_fakelv[this]=LV_ACTIVE
            set s__Material_ground_action[this]=GROUND_BOUNCE
            set s__Material_horro_dmg[this]=0.01
            set s__Material_anti_horro[this]=0
            set s__Material_kill_hp[this]=0
//textmacro instance: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e000' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e000'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e001' then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e001'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e002' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e002'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
elseif ut == 'e003' then
    set s__Material_clazz[this]=MC_ARROW
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=1
    set s__Material_volume[this]=75
    set s__Material_weight[this]=2
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_SMOOTH
    
//end of: RegisterMaterial("'e003'","MC_ARROW","100","1","75","2","0.005","LV_DESTORY","GROUND_SMOOTH")
//textmacro instance: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e004' then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e004'","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e009' then
    set s__Material_clazz[this]=MC_STONE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=5
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e009'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00A' then
    set s__Material_clazz[this]=MC_STONE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=5
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e00A'","MC_STONE","100","0.5","50","5","0.005","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
elseif ut == 'e00B' then
    set s__Material_clazz[this]=MC_MINE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=200
    set s__Material_weight[this]=30
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_STICK
    
//end of: RegisterMaterial("'e00B'","MC_MINE","100","0.5","200","30","0","LV_DESTORY","GROUND_STICK")
//textmacro instance: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bICE_MISSLE then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("bICE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bFIRE_MISSLE then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("bFIRE_MISSLE","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == MAGIC then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("MAGIC","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == DUMMY_TYPE then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("DUMMY_TYPE","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == bELECTRIC then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("bELECTRIC","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == TECH_UNIT then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("TECH_UNIT","MC_EFFECT","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00E' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=150
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e00E'","MC_BULLET","100","0.5","150","0.01","0","LV_DESTORY","GROUND_DESTROY")
//textmacro instance: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
elseif ut == 'e00F' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
    
//end of: RegisterMaterial("'e00F'","MC_BULLET","100","0.5","50","0.01","0","LV_DESTORY","GROUND_DESTROY")
        endif
    endfunction
        
    function s__Material_AIDS_onDestroy takes integer this returns nothing
    endfunction
       
    

//library Material ends
//library MissleFactory:
    function s__SmartDartsFactory_create takes unit target returns integer
        local integer s= s__SmartDartsFactory__allocate()
        set s__SmartDartsFactory_t[s]=target
        return s
    endfunction
    function s__SmartDartsFactory_createMissle takes integer this,unit owner returns integer
        local integer m= sc__SmartDarts_create(owner , s__SmartDartsFactory_t[this])
        return m
    endfunction
//textmacro instance: MissleFactory("DefaultMissleFactory","Missle")
    function s__DefaultMissleFactory_createMissle takes integer this,unit owner returns integer
        local integer m=sc__Missle_create(owner)
        return m
    endfunction
//end of: MissleFactory("DefaultMissleFactory","Missle")
//textmacro instance: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
    function s__ShootGunMissleFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__ShootGunMissle__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("ShootGunMissleFactory","ShootGunMissle")
//textmacro instance: MissleFactory("SmallDartsFactory","SmallDarts")
    function s__SmallDartsFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__SmallDarts__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("SmallDartsFactory","SmallDarts")
//textmacro instance: MissleFactory("ReturnDartsFactory","ReturnDarts")
    function s__ReturnDartsFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__ReturnDarts__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("ReturnDartsFactory","ReturnDarts")
//textmacro instance: MissleFactory("LeaveDartsFactory","LeaveDarts")
    function s__LeaveDartsFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__LeaveDarts__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("LeaveDartsFactory","LeaveDarts")
//textmacro instance: MissleFactory("IceMissleFactory","IceMissle")
    function s__IceMissleFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__IceMissle__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("IceMissleFactory","IceMissle")
//textmacro instance: MissleFactory("FireMissleFactory","FireMissle")
    function s__FireMissleFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__FireMissle__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("FireMissleFactory","FireMissle")
//textmacro instance: MissleFactory("ElectricWhipFactory","ElectricWhip")
    function s__ElectricWhipFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__ElectricWhip__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("ElectricWhipFactory","ElectricWhip")
//textmacro instance: MissleFactory("BackGrenadeFactory","BackGrenade")
    function s__BackGrenadeFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__BackGrenade__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("BackGrenadeFactory","BackGrenade")
//textmacro instance: MissleFactory("PushGrenadeFactory","PushGrenade")
    function s__PushGrenadeFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__PushGrenade__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("PushGrenadeFactory","PushGrenade")
//textmacro instance: MissleFactory("MineFactory","Mine")
    function s__MineFactory_createMissle takes integer this,unit owner returns integer
        local integer m=sc__Mine_create(owner)
        return m
    endfunction
//end of: MissleFactory("MineFactory","Mine")
//textmacro instance: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
    function s__ShoulderCannonFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__ShoulderCannonMissle__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("ShoulderCannonFactory","ShoulderCannonMissle")
//textmacro instance: MissleFactory("SpearMissleFactory","SpearMissle")
    function s__SpearMissleFactory_createMissle takes integer this,unit owner returns integer
        local integer m=s__SpearMissle__allocate(owner)
        return m
    endfunction
//end of: MissleFactory("SpearMissleFactory","SpearMissle")

//library MissleFactory ends
//library MonsterDead:
function InitMonsterDead takes nothing returns nothing
set gtrgMonsterDead=CreateTrigger()
call TriggerRegisterPlayerUnitEventSimple(gtrgMonsterDead, Player(11), EVENT_PLAYER_UNIT_DEATH)
endfunction

//library MonsterDead ends
//library MonsterTypeData:
function InitMonsterTypeData takes nothing returns nothing
call sc__DefaultTypeData_create()
endfunction
//Implemented from module List:
    
    
    
        function s__DefaultTypeData_getLength takes nothing returns integer
            return s__DefaultTypeData_List___length
        endfunction
    
        function s__DefaultTypeData_getFirst takes nothing returns integer
            return s__DefaultTypeData_List___first
        endfunction
    
        function s__DefaultTypeData_getLast takes nothing returns integer
            return s__DefaultTypeData_List___last
        endfunction
    
        function s__DefaultTypeData_getRandom takes nothing returns integer
            local integer s= s__DefaultTypeData_List___first
            local integer array list
            local integer n= - 1
            loop
                exitwhen s == 0
                set n=n + 1
                set list[n]=s
                set s=s__DefaultTypeData_List___next[s]
            endloop
            if n == - 1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endfunction
    
        function s__DefaultTypeData_getNext takes integer this returns integer
            return s__DefaultTypeData_List___next[this]
        endfunction
    
        function s__DefaultTypeData_getPrev takes integer this returns integer
            return s__DefaultTypeData_List___prev[this]
        endfunction
    
        function s__DefaultTypeData_inList takes integer this returns boolean
            return s__DefaultTypeData_List___inlist[this]
        endfunction
        function s__DefaultTypeData_addList takes integer this returns boolean
            if not s__DefaultTypeData_List___inlist[this] and not s__DefaultTypeData_List___destroyinglist then
                set s__DefaultTypeData_List___inlist[this]=true
                if s__DefaultTypeData_List___first == 0 then
                    set s__DefaultTypeData_List___first=this
                else
                    set s__DefaultTypeData_List___prev[this]=s__DefaultTypeData_List___last
                    set s__DefaultTypeData_List___next[s__DefaultTypeData_List___prev[this]]=this
                endif
                set s__DefaultTypeData_List___last=this
                set s__DefaultTypeData_List___length=s__DefaultTypeData_List___length + 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultTypeData_removeList takes integer this returns boolean
            if s__DefaultTypeData_List___inlist[this] then
                if s__DefaultTypeData_List___destroyinglist then
                    return true
                endif
                set s__DefaultTypeData_List___inlist[this]=false
                if s__DefaultTypeData_List___first == this then
                    set s__DefaultTypeData_List___first=s__DefaultTypeData_List___next[this]
                endif
                if s__DefaultTypeData_List___last == this then
                    set s__DefaultTypeData_List___last=s__DefaultTypeData_List___prev[this]
                endif
                set s__DefaultTypeData_List___next[s__DefaultTypeData_List___prev[this]]=s__DefaultTypeData_List___next[this]
                set s__DefaultTypeData_List___prev[s__DefaultTypeData_List___next[this]]=s__DefaultTypeData_List___prev[this]
                set s__DefaultTypeData_List___length=s__DefaultTypeData_List___length - 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultTypeData_destroyList takes nothing returns nothing
            local integer s= s__DefaultTypeData_List___first
            if not s__DefaultTypeData_List___destroyinglist then
                loop
                    exitwhen s == 0
                    set s__DefaultTypeData_List___destroyinglist=false
                    call s__DefaultTypeData_removeList(s)
                    set s__DefaultTypeData_List___destroyinglist=true
                    call sc__IMonsterTypeData_deallocate(s)
                    set s=s__DefaultTypeData_List___next[s]
                endloop
                set s__DefaultTypeData_List___destroyinglist=false
            endif
        endfunction
    
function s__DefaultTypeData_create takes nothing returns integer
local integer s=s__DefaultTypeData__allocate()
call s__DefaultTypeData_addList(s)
return s
endfunction
function s__DefaultTypeData_onDestroy takes integer this returns nothing
call s__DefaultTypeData_removeList(this)
endfunction
function s__DefaultTypeData_getTypeId takes integer this returns integer
return 123
endfunction
function s__DefaultTypeData_getDeadGold takes integer this returns integer
return 2
endfunction
function s__DefaultTypeData_getDeadWood takes integer this returns integer
return 0
endfunction
function s__DefaultTypeData_findTypeData takes integer typeid returns integer
local integer p=s__DefaultTypeData_getFirst()
loop
    exitwhen p == 0
    if s__DefaultTypeData_getTypeId(p) == typeid then
        return p
    endif
    set p=s__DefaultTypeData_getNext(p)
endloop
return s__DefaultTypeData_getFirst()
endfunction

//library MonsterTypeData ends
//library Movie:
function MovieSay takes integer id,string msg returns nothing
    call TransmissionFromUnitWithNameBJ(GetPlayersAll(), heros[id], GetPlayerName(Player(id)), null, msg, bj_TIMETYPE_ADD, 1, true)
endfunction
function MovieStart takes nothing returns nothing
    call CinematicModeExBJ(true, GetPlayersAll(), 0.2)
endfunction
function MovieEnd takes nothing returns nothing
    call CinematicModeExBJ(false, GetPlayersAll(), 0.2)
endfunction
function Seen takes rect r returns nothing
    local integer i= 0
    loop
        exitwhen i >= PLAYER_COUNT
        if heros[i] != null then
            call CreateFogModifierRectBJ(true, Player(i), FOG_OF_WAR_VISIBLE, r)
        endif
    endloop
endfunction
function LockAgain takes nothing returns nothing
    local integer i= 0
    loop
        exitwhen i >= 3
        if heros[i] != null then
            call SetCameraTargetControllerNoZForPlayer(Player(i), heros[i], 0, 0, false)
        endif
        set i=i + 1
    endloop
endfunction
function StopShake takes nothing returns nothing
    local integer i= 0
    loop
        exitwhen i >= 3
        call CameraClearNoiseForPlayer(Player(i))
        set i=i + 1
    endloop
endfunction
function StartShake takes nothing returns nothing
    local integer i= 0
    loop
        exitwhen i >= 3
        call CameraSetEQNoiseForPlayer(Player(i), 3)
        if heros[i] != null then
            call IssueImmediateOrderById(heros[i], OI_STOP)
        endif
        set i=i + 1
    endloop
endfunction
function MoveCamera takes real x,real y returns nothing
    call PanCameraToTimed(x, y, 0.50)
endfunction

//library Movie ends
//library OrderId:

//library OrderId ends
//library RegisterSpell:
function InitRegisterSpell takes nothing returns nothing
    set kRegistedSpell=GetNewKey()
endfunction
function RegisterSpell takes unit u returns nothing
local boolean registed=LoadBoolean(ht, GetHandleId(u), kRegistedSpell)
if registed == false then
//textmacro instance: RegisterSpell("'A002'")
call UnitAddAbility(u, 'A002')
call SetPlayerAbilityAvailable(GetOwningPlayer(u), 'A002', false)
//end of: RegisterSpell("'A002'")
//textmacro instance: RegisterSpell("'A003'")
call UnitAddAbility(u, 'A003')
call SetPlayerAbilityAvailable(GetOwningPlayer(u), 'A003', false)
//end of: RegisterSpell("'A003'")
//textmacro instance: RegisterSpell("'A004'")
call UnitAddAbility(u, 'A004')
call SetPlayerAbilityAvailable(GetOwningPlayer(u), 'A004', false)
//end of: RegisterSpell("'A004'")
//textmacro instance: RegisterSpell("'A005'")
call UnitAddAbility(u, 'A005')
call SetPlayerAbilityAvailable(GetOwningPlayer(u), 'A005', false)
//end of: RegisterSpell("'A005'")
//textmacro instance: RegisterSpell("'A006'")
call UnitAddAbility(u, 'A006')
call SetPlayerAbilityAvailable(GetOwningPlayer(u), 'A006', false)
//end of: RegisterSpell("'A006'")
call SaveBoolean(ht, GetHandleId(u), kRegistedSpell, true)
endif
endfunction

//library RegisterSpell ends
//library ShootBack:
function ShootBackCondition takes nothing returns boolean
    local unit tu= GetTriggerUnit()
    if GetIssuedOrderIdBJ() == String2OrderIdBJ("unimmolation") and GetUnitTypeId(tu) == HERO then
        set s__IHeroData_a_shoot_back[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(tu)]]=s__IHeroData_a_shoot_back[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(tu)]] - s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(tu)]]
        set s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(tu)]]=0.0
    endif
    set tu=null
    return false
endfunction
function ShootBackInitializer takes nothing returns nothing
    set shoot_back_trg=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(shoot_back_trg, EVENT_PLAYER_UNIT_ISSUED_ORDER)
    call TriggerAddCondition(shoot_back_trg, Condition(function ShootBackCondition))
endfunction

//library ShootBack ends
//library ShootSpeed:
    function IncShootSpeed takes integer pid returns nothing
        call IncUnitAbilityLevel(heros[pid], SHOOT_SPEED)
    endfunction

//library ShootSpeed ends
//library SkillLearn:
function InitSpellBook takes nothing returns nothing
    local integer ut= GetUnitTypeId(GetTriggerUnit())
    if ut == HERO then
    call BJDebugMsg("init spell book")
    endif
endfunction
function GetSkillId takes integer it returns integer
    return - 1
endfunction
function LearnSkill takes nothing returns nothing
    local integer it= GetItemTypeId(GetManipulatedItem())
    local integer skill= GetSkillId(it)
    if skill != - 1 then
    endif
endfunction
function InitSkillLearn takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
local region rectRegion= CreateRegion()
call RegionAddRect(rectRegion, GetPlayableMapRect())
call TriggerRegisterEnterRegion(t, rectRegion, null)
call TriggerAddCondition(t, Condition(function InitSpellBook))
call TriggerRegisterAnyUnitEventBJ(t2, EVENT_PLAYER_UNIT_USE_ITEM)
call TriggerAddCondition(t2, Condition(function LearnSkill))
set t=null
set t2=null
set rectRegion=null
endfunction

//library SkillLearn ends
//library T32:
    
    //==============================================================================
    // The standard T32 module, T32x.
    //
    
    //==============================================================================
    // The standard T32 module with added safety checks on .startPeriodic() and
    // .stopPeriodic(), T32xs.
    //
    
    //==============================================================================
    // The original T32 module, for backwards compatability only.
    //
    
    //==============================================================================
    // System Core.
    //
    function T32__OnExpire takes nothing returns nothing
        set Tick=Tick + 1
        call TriggerEvaluate(T32__Trig)
    endfunction
    
    function T32__OnInit takes nothing returns nothing
        call TimerStart(CreateTimer(), T32_PERIOD, true, function T32__OnExpire)
    endfunction

//library T32 ends
//library Table:

    
    
//textmacro instance: NEW_TABLE("Real", "Real", "real", "true")

        function s__Table___reals__getindex takes integer this,integer key returns real
            return LoadReal(Table___ht, this, key)
        endfunction

    function s__Table___reals__setindex takes integer this,integer key,real value returns nothing
        call SaveReal(Table___ht, this, key, value)
    endfunction
    function s__Table___reals_has takes integer this,integer key returns boolean
        return HaveSavedReal(Table___ht, this, key)
    endfunction
    function s__Table___reals_remove takes integer this,integer key returns nothing
        call RemoveSavedReal(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Real", "Real", "real", "true")
//textmacro instance: NEW_TABLE("Boolean", "Boolean", "boolean", "true")

        function s__Table___booleans__getindex takes integer this,integer key returns boolean
            return LoadBoolean(Table___ht, this, key)
        endfunction

    function s__Table___booleans__setindex takes integer this,integer key,boolean value returns nothing
        call SaveBoolean(Table___ht, this, key, value)
    endfunction
    function s__Table___booleans_has takes integer this,integer key returns boolean
        return HaveSavedBoolean(Table___ht, this, key)
    endfunction
    function s__Table___booleans_remove takes integer this,integer key returns nothing
        call RemoveSavedBoolean(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Boolean", "Boolean", "boolean", "true")
//textmacro instance: NEW_TABLE("String", "Str", "string", "true")

        function s__Table___strings__getindex takes integer this,integer key returns string
            return LoadStr(Table___ht, this, key)
        endfunction

    function s__Table___strings__setindex takes integer this,integer key,string value returns nothing
        call SaveStr(Table___ht, this, key, value)
    endfunction
    function s__Table___strings_has takes integer this,integer key returns boolean
        return HaveSavedString(Table___ht, this, key)
    endfunction
    function s__Table___strings_remove takes integer this,integer key returns nothing
        call RemoveSavedString(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("String", "Str", "string", "true")
//textmacro instance: NEW_TABLE("Handle", "PlayerHandle", "player", "true")

        function s__Table___players__getindex takes integer this,integer key returns player
            return LoadPlayerHandle(Table___ht, this, key)
        endfunction

    function s__Table___players__setindex takes integer this,integer key,player value returns nothing
        call SavePlayerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___players_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___players_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "PlayerHandle", "player", "true")
//textmacro instance: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")

        function s__Table___widgets__getindex takes integer this,integer key returns widget
            return LoadWidgetHandle(Table___ht, this, key)
        endfunction

    function s__Table___widgets__setindex takes integer this,integer key,widget value returns nothing
        call SaveWidgetHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___widgets_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___widgets_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "WidgetHandle", "widget", "true")
//textmacro instance: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")

        function s__Table___destructables__getindex takes integer this,integer key returns destructable
            return LoadDestructableHandle(Table___ht, this, key)
        endfunction

    function s__Table___destructables__setindex takes integer this,integer key,destructable value returns nothing
        call SaveDestructableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___destructables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___destructables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "DestructableHandle", "destructable", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemHandle", "item", "true")

        function s__Table___items__getindex takes integer this,integer key returns item
            return LoadItemHandle(Table___ht, this, key)
        endfunction

    function s__Table___items__setindex takes integer this,integer key,item value returns nothing
        call SaveItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___items_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___items_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "ItemHandle", "item", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitHandle", "unit", "true")

        function s__Table___units__getindex takes integer this,integer key returns unit
            return LoadUnitHandle(Table___ht, this, key)
        endfunction

    function s__Table___units__setindex takes integer this,integer key,unit value returns nothing
        call SaveUnitHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___units_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___units_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "UnitHandle", "unit", "true")
//textmacro instance: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")

        function s__Table___abilitys__getindex takes integer this,integer key returns ability
            return LoadAbilityHandle(Table___ht, this, key)
        endfunction

    function s__Table___abilitys__setindex takes integer this,integer key,ability value returns nothing
        call SaveAbilityHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___abilitys_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___abilitys_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "AbilityHandle", "ability", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerHandle", "timer", "true")

        function s__Table___timers__getindex takes integer this,integer key returns timer
            return LoadTimerHandle(Table___ht, this, key)
        endfunction

    function s__Table___timers__setindex takes integer this,integer key,timer value returns nothing
        call SaveTimerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___timers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___timers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TimerHandle", "timer", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")

        function s__Table___triggers__getindex takes integer this,integer key returns trigger
            return LoadTriggerHandle(Table___ht, this, key)
        endfunction

    function s__Table___triggers__setindex takes integer this,integer key,trigger value returns nothing
        call SaveTriggerHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TriggerHandle", "trigger", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")

        function s__Table___triggerconditions__getindex takes integer this,integer key returns triggercondition
            return LoadTriggerConditionHandle(Table___ht, this, key)
        endfunction

    function s__Table___triggerconditions__setindex takes integer this,integer key,triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggerconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggerconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TriggerConditionHandle", "triggercondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")

        function s__Table___triggeractions__getindex takes integer this,integer key returns triggeraction
            return LoadTriggerActionHandle(Table___ht, this, key)
        endfunction

    function s__Table___triggeractions__setindex takes integer this,integer key,triggeraction value returns nothing
        call SaveTriggerActionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___triggeractions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggeractions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TriggerActionHandle", "triggeraction", "true")
//textmacro instance: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")

        function s__Table___events__getindex takes integer this,integer key returns event
            return LoadTriggerEventHandle(Table___ht, this, key)
        endfunction

    function s__Table___events__setindex takes integer this,integer key,event value returns nothing
        call SaveTriggerEventHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___events_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___events_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TriggerEventHandle", "event", "true")
//textmacro instance: NEW_TABLE("Handle", "ForceHandle", "force", "true")

        function s__Table___forces__getindex takes integer this,integer key returns force
            return LoadForceHandle(Table___ht, this, key)
        endfunction

    function s__Table___forces__setindex takes integer this,integer key,force value returns nothing
        call SaveForceHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___forces_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___forces_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "ForceHandle", "force", "true")
//textmacro instance: NEW_TABLE("Handle", "GroupHandle", "group", "true")

        function s__Table___groups__getindex takes integer this,integer key returns group
            return LoadGroupHandle(Table___ht, this, key)
        endfunction

    function s__Table___groups__setindex takes integer this,integer key,group value returns nothing
        call SaveGroupHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___groups_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___groups_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "GroupHandle", "group", "true")
//textmacro instance: NEW_TABLE("Handle", "LocationHandle", "location", "true")

        function s__Table___locations__getindex takes integer this,integer key returns location
            return LoadLocationHandle(Table___ht, this, key)
        endfunction

    function s__Table___locations__setindex takes integer this,integer key,location value returns nothing
        call SaveLocationHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___locations_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___locations_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "LocationHandle", "location", "true")
//textmacro instance: NEW_TABLE("Handle", "RectHandle", "rect", "true")

        function s__Table___rects__getindex takes integer this,integer key returns rect
            return LoadRectHandle(Table___ht, this, key)
        endfunction

    function s__Table___rects__setindex takes integer this,integer key,rect value returns nothing
        call SaveRectHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___rects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___rects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "RectHandle", "rect", "true")
//textmacro instance: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")

        function s__Table___boolexprs__getindex takes integer this,integer key returns boolexpr
            return LoadBooleanExprHandle(Table___ht, this, key)
        endfunction

    function s__Table___boolexprs__setindex takes integer this,integer key,boolexpr value returns nothing
        call SaveBooleanExprHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___boolexprs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___boolexprs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "BooleanExprHandle", "boolexpr", "true")
//textmacro instance: NEW_TABLE("Handle", "SoundHandle", "sound", "true")

        function s__Table___sounds__getindex takes integer this,integer key returns sound
            return LoadSoundHandle(Table___ht, this, key)
        endfunction

    function s__Table___sounds__setindex takes integer this,integer key,sound value returns nothing
        call SaveSoundHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___sounds_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___sounds_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "SoundHandle", "sound", "true")
//textmacro instance: NEW_TABLE("Handle", "EffectHandle", "effect", "true")

        function s__Table___effects__getindex takes integer this,integer key returns effect
            return LoadEffectHandle(Table___ht, this, key)
        endfunction

    function s__Table___effects__setindex takes integer this,integer key,effect value returns nothing
        call SaveEffectHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___effects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___effects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "EffectHandle", "effect", "true")
//textmacro instance: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")

        function s__Table___unitpools__getindex takes integer this,integer key returns unitpool
            return LoadUnitPoolHandle(Table___ht, this, key)
        endfunction

    function s__Table___unitpools__setindex takes integer this,integer key,unitpool value returns nothing
        call SaveUnitPoolHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___unitpools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___unitpools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "UnitPoolHandle", "unitpool", "true")
//textmacro instance: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")

        function s__Table___itempools__getindex takes integer this,integer key returns itempool
            return LoadItemPoolHandle(Table___ht, this, key)
        endfunction

    function s__Table___itempools__setindex takes integer this,integer key,itempool value returns nothing
        call SaveItemPoolHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___itempools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___itempools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "ItemPoolHandle", "itempool", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestHandle", "quest", "true")

        function s__Table___quests__getindex takes integer this,integer key returns quest
            return LoadQuestHandle(Table___ht, this, key)
        endfunction

    function s__Table___quests__setindex takes integer this,integer key,quest value returns nothing
        call SaveQuestHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___quests_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___quests_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "QuestHandle", "quest", "true")
//textmacro instance: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")

        function s__Table___questitems__getindex takes integer this,integer key returns questitem
            return LoadQuestItemHandle(Table___ht, this, key)
        endfunction

    function s__Table___questitems__setindex takes integer this,integer key,questitem value returns nothing
        call SaveQuestItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___questitems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___questitems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "QuestItemHandle", "questitem", "true")
//textmacro instance: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")

        function s__Table___defeatconditions__getindex takes integer this,integer key returns defeatcondition
            return LoadDefeatConditionHandle(Table___ht, this, key)
        endfunction

    function s__Table___defeatconditions__setindex takes integer this,integer key,defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___defeatconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___defeatconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "DefeatConditionHandle", "defeatcondition", "true")
//textmacro instance: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")

        function s__Table___timerdialogs__getindex takes integer this,integer key returns timerdialog
            return LoadTimerDialogHandle(Table___ht, this, key)
        endfunction

    function s__Table___timerdialogs__setindex takes integer this,integer key,timerdialog value returns nothing
        call SaveTimerDialogHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___timerdialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___timerdialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TimerDialogHandle", "timerdialog", "true")
//textmacro instance: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")

        function s__Table___leaderboards__getindex takes integer this,integer key returns leaderboard
            return LoadLeaderboardHandle(Table___ht, this, key)
        endfunction

    function s__Table___leaderboards__setindex takes integer this,integer key,leaderboard value returns nothing
        call SaveLeaderboardHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___leaderboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___leaderboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "LeaderboardHandle", "leaderboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")

        function s__Table___multiboards__getindex takes integer this,integer key returns multiboard
            return LoadMultiboardHandle(Table___ht, this, key)
        endfunction

    function s__Table___multiboards__setindex takes integer this,integer key,multiboard value returns nothing
        call SaveMultiboardHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___multiboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "MultiboardHandle", "multiboard", "true")
//textmacro instance: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")

        function s__Table___multiboarditems__getindex takes integer this,integer key returns multiboarditem
            return LoadMultiboardItemHandle(Table___ht, this, key)
        endfunction

    function s__Table___multiboarditems__setindex takes integer this,integer key,multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___multiboarditems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboarditems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "MultiboardItemHandle", "multiboarditem", "true")
//textmacro instance: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")

        function s__Table___trackables__getindex takes integer this,integer key returns trackable
            return LoadTrackableHandle(Table___ht, this, key)
        endfunction

    function s__Table___trackables__setindex takes integer this,integer key,trackable value returns nothing
        call SaveTrackableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___trackables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___trackables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TrackableHandle", "trackable", "true")
//textmacro instance: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")

        function s__Table___dialogs__getindex takes integer this,integer key returns dialog
            return LoadDialogHandle(Table___ht, this, key)
        endfunction

    function s__Table___dialogs__setindex takes integer this,integer key,dialog value returns nothing
        call SaveDialogHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___dialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___dialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "DialogHandle", "dialog", "true")
//textmacro instance: NEW_TABLE("Handle", "ButtonHandle", "button", "true")

        function s__Table___buttons__getindex takes integer this,integer key returns button
            return LoadButtonHandle(Table___ht, this, key)
        endfunction

    function s__Table___buttons__setindex takes integer this,integer key,button value returns nothing
        call SaveButtonHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___buttons_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___buttons_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "ButtonHandle", "button", "true")
//textmacro instance: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")

        function s__Table___texttags__getindex takes integer this,integer key returns texttag
            return LoadTextTagHandle(Table___ht, this, key)
        endfunction

    function s__Table___texttags__setindex takes integer this,integer key,texttag value returns nothing
        call SaveTextTagHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___texttags_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___texttags_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "TextTagHandle", "texttag", "true")
//textmacro instance: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")

        function s__Table___lightnings__getindex takes integer this,integer key returns lightning
            return LoadLightningHandle(Table___ht, this, key)
        endfunction

    function s__Table___lightnings__setindex takes integer this,integer key,lightning value returns nothing
        call SaveLightningHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___lightnings_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___lightnings_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "LightningHandle", "lightning", "true")
//textmacro instance: NEW_TABLE("Handle", "ImageHandle", "image", "true")

        function s__Table___images__getindex takes integer this,integer key returns image
            return LoadImageHandle(Table___ht, this, key)
        endfunction

    function s__Table___images__setindex takes integer this,integer key,image value returns nothing
        call SaveImageHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___images_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___images_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "ImageHandle", "image", "true")
//textmacro instance: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")

        function s__Table___ubersplats__getindex takes integer this,integer key returns ubersplat
            return LoadUbersplatHandle(Table___ht, this, key)
        endfunction

    function s__Table___ubersplats__setindex takes integer this,integer key,ubersplat value returns nothing
        call SaveUbersplatHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___ubersplats_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___ubersplats_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "UbersplatHandle", "ubersplat", "true")
//textmacro instance: NEW_TABLE("Handle", "RegionHandle", "region", "true")

        function s__Table___regions__getindex takes integer this,integer key returns region
            return LoadRegionHandle(Table___ht, this, key)
        endfunction

    function s__Table___regions__setindex takes integer this,integer key,region value returns nothing
        call SaveRegionHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___regions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___regions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "RegionHandle", "region", "true")
//textmacro instance: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")

        function s__Table___fogstates__getindex takes integer this,integer key returns fogstate
            return LoadFogStateHandle(Table___ht, this, key)
        endfunction

    function s__Table___fogstates__setindex takes integer this,integer key,fogstate value returns nothing
        call SaveFogStateHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___fogstates_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogstates_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "FogStateHandle", "fogstate", "true")
//textmacro instance: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")

        function s__Table___fogmodifiers__getindex takes integer this,integer key returns fogmodifier
            return LoadFogModifierHandle(Table___ht, this, key)
        endfunction

    function s__Table___fogmodifiers__setindex takes integer this,integer key,fogmodifier value returns nothing
        call SaveFogModifierHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___fogmodifiers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogmodifiers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "FogModifierHandle", "fogmodifier", "true")
//textmacro instance: NEW_TABLE("Handle", "AgentHandle", "agent", "false")





    function s__Table___agents__setindex takes integer this,integer key,agent value returns nothing
        call SaveAgentHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___agents_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___agents_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "AgentHandle", "agent", "false")
//textmacro instance: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")

        function s__Table___hashtables__getindex takes integer this,integer key returns hashtable
            return LoadHashtableHandle(Table___ht, this, key)
        endfunction

    function s__Table___hashtables__setindex takes integer this,integer key,hashtable value returns nothing
        call SaveHashtableHandle(Table___ht, this, key, value)
    endfunction
    function s__Table___hashtables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___hashtables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
//end of: NEW_TABLE("Handle", "HashtableHandle", "hashtable", "true")
    
    // Implement modules for intuitive type-syntax
//Implemented from module Table___realm:
    function s__Table__get_real takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___booleanm:
    function s__Table__get_boolean takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___stringm:
    function s__Table__get_string takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___playerm:
    function s__Table__get_player takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___widgetm:
    function s__Table__get_widget takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___destructablem:
    function s__Table__get_destructable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itemm:
    function s__Table__get_item takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitm:
    function s__Table__get_unit takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___abilitym:
    function s__Table__get_ability takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerm:
    function s__Table__get_timer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerm:
    function s__Table__get_trigger takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerconditionm:
    function s__Table__get_triggercondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggeractionm:
    function s__Table__get_triggeraction takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___eventm:
    function s__Table__get_event takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___forcem:
    function s__Table__get_force takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___groupm:
    function s__Table__get_group takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___locationm:
    function s__Table__get_location takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___rectm:
    function s__Table__get_rect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___boolexprm:
    function s__Table__get_boolexpr takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___soundm:
    function s__Table__get_sound takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___effectm:
    function s__Table__get_effect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitpoolm:
    function s__Table__get_unitpool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itempoolm:
    function s__Table__get_itempool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questm:
    function s__Table__get_quest takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questitemm:
    function s__Table__get_questitem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___defeatconditionm:
    function s__Table__get_defeatcondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerdialogm:
    function s__Table__get_timerdialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___leaderboardm:
    function s__Table__get_leaderboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboardm:
    function s__Table__get_multiboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboarditemm:
    function s__Table__get_multiboarditem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___trackablem:
    function s__Table__get_trackable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___dialogm:
    function s__Table__get_dialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___buttonm:
    function s__Table__get_button takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___texttagm:
    function s__Table__get_texttag takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___lightningm:
    function s__Table__get_lightning takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___imagem:
    function s__Table__get_image takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___ubersplatm:
    function s__Table__get_ubersplat takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___regionm:
    function s__Table__get_region takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogstatem:
    function s__Table__get_fogstate takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogmodifierm:
    function s__Table__get_fogmodifier takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___agentm:
    function s__Table__get_agent takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___hashtablem:
    function s__Table__get_hashtable takes integer this returns integer
        return this
    endfunction
    
    
    // set this = tb[GetSpellAbilityId()]
    function s__Table__getindex takes integer this,integer key returns integer
        return LoadInteger(Table___ht, this, key)
    endfunction
    
    // set tb[389034] = 8192
    function s__Table__setindex takes integer this,integer key,integer tb returns nothing
        call SaveInteger(Table___ht, this, key, tb)
    endfunction
    
    // set b = tb.has(2493223)
    function s__Table_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key)
    endfunction
    
    // call tb.remove(294080)
    function s__Table_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key)
    endfunction
    
    // Remove all data from a Table instance
    function s__Table_flush takes integer this returns nothing
        call FlushChildHashtable(Table___ht, this)
    endfunction
    
    // local Table tb = Table.create()
    function s__Table_create takes nothing returns integer
        if ( Table___lpos == 0 ) then
            set Table___grow=Table___grow + 1
            return Table___grow
        endif
        set Table___lpos=Table___lpos - 1
        return Table___list[Table___lpos]
    endfunction
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    function s__Table_destroy takes integer this returns nothing
        call s__Table_flush(this)












        if ( Table___lpos < 8191 ) then
            set Table___list[Table___lpos]=this
            set Table___lpos=Table___lpos + 1
        endif
    endfunction
    
//ignored textmacro command: TABLE_BC_METHODS()
    
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
    
    // Returns a new TableArray to do your bidding. Simply use:
    //
    //     local TableArray ta = TableArray[arraySize]
    //
    function s__TableArray__staticgetindex takes integer arraySize returns integer
        local integer tb= s__Table__getindex((1),arraySize)
local integer ta
local integer i
        if ( (tb) == 0 or s__Table__getindex(tb,0) == 0 ) then
            set Table___keys=Table___keys - arraySize // Negative values are reserved...
call s__Table__setindex((1),Table___keys, arraySize) // This remembers the array size
set ta=Table___keys // All TableArray IDs are below 0
else
            set i=s__Table__getindex(tb,0) // Get the last-destroyed TableArray's index
call s__Table_remove(tb,0) // Clear data as we go along
call s__Table__setindex(tb,0, i - 1) // Decrease and save the recycle count
set ta=s__Table__getindex(tb,i) // Retrieve the old TableArray's instance
call s__Table_remove(tb,i) // Remove the old TableArray's node
        endif
        return ta
    endfunction
    
    // Returns the size of the TableArray (arraySize)
    function s__TableArray__get_size takes integer this returns integer
        return s__Table__getindex((1),this)
    endfunction
    
    // ta[integer a].unit[integer b] = unit u
    // ta[integer a][integer c] = integer d
    //
    // Inline-friendly when not running in debug mode
    //
    function s__TableArray__getindex takes integer this,integer key returns integer










        return this + key
    endfunction
    
    // Destroys a TableArray without flushing it; assumed you'd call .flush()
    // if you want it flushed too. This is public so that if you are flushing
    // instances the whole time you don't waste efficiency when disposing the
    // TableArray.
    //
    function s__TableArray_destroy takes integer this returns nothing
        local integer i
        local integer tb= s__Table__getindex((1),s__TableArray__get_size(this))










        if ( (tb) == 0 ) then
            set tb=s__Table_create() // A Table to remember old indexes
call s__Table__setindex((1),s__TableArray__get_size(this), tb) // Save it in the reserved key (1)
set i=1 // The recycle count is initially 1
else
            set i=s__Table__getindex(tb,0) + 1 // Increase recycle count
call s__Table_remove(tb,0) // Remove the "recycle count" node
endif
        call s__Table__setindex(tb,0, i) // Save recycle count
call s__Table__setindex(tb,i, this) // Save this under recycle count's index
endfunction
    
    // All you need to know about this one is that it won't hit the op limit.
    function s__TableArray_clean takes integer tb,integer end returns nothing
        local integer i= tb + 4096
        if ( i < end ) then
            call s__TableArray_clean(i , end)
            set end=i
        endif
        loop
            call s__Table_flush(tb)
            set tb=tb + 1
            exitwhen (tb) == end
        endloop
    endfunction
    
    // Flushes the TableArray and also destroys it. Doesn't get any more
    // similar to the FlushParentHashtable native than this.
    //
    function s__TableArray_flush takes integer this returns nothing
        local integer end= s__TableArray__get_size(this) + this
        if ( (this) < end ) then
            call s__TableArray_clean(this , end)
            call s__TableArray_destroy(this)
        endif
    endfunction
    
    

//library Table ends
//library TechData:
    function s__TechData_create takes string name,integer cat returns integer
        local integer m=s__TechData__allocate()
        set s__TechData_name[m]=name
        set s__TechData_cat[m]=cat
        return m
    endfunction
//textmacro instance: CreateArrayList("TechTree")
    
    function s__TechTree_create takes nothing returns integer
        local integer m=s__TechTree__allocate()
        set s__TechTree_size[m]=0
        return m
    endfunction
    
    function s__TechTree_addItem takes integer this,integer itm returns nothing
        set s___TechTree_itms[s__TechTree_itms[this]+s__TechTree_size[this]]=itm
        set s__TechTree_size[this]=s__TechTree_size[this] + 1
    endfunction
//end of: CreateArrayList("TechTree")
function InitTechData takes nothing returns nothing
    local integer i= 0
    
    set s__TECH_TREE_NAME[0]= "TREE_GENERAL"
    set s__TECH_TREE_NAME[1]= "TREE_BLADE"
    set s__TECH_TREE_NAME[2]= "TREE_MAGIC_HUNTER"
    
    loop
        exitwhen i >= TT_COUNT
        set s__TECH_TREE_COUNT[i]= 0
        set s__TECH_TREES[i]= s__TechTree_create()
        set i=i + 1
    endloop
    
    call FlushParentHashtable(tdht)
    set tdht=InitHashtable()
//textmacro instance: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht, tKMANA, tdht_name, "閫€榄斿垉")
    call SaveInteger(tdht, tKMANA, tdht_cat, TT_MAGIC_HUNTER)
    call SaveInteger(tdht, tKMANA, tdht_tech_need, 0)
    call SaveInteger(tdht, tKMANA, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tKMANA, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_MAGIC_HUNTER],tKMANA)
    set s__TECH_TREE_COUNT[TT_MAGIC_HUNTER]= s__TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tSTRONG, tdht_name, "浣撹川澧炲己")
    call SaveInteger(tdht, tSTRONG, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tSTRONG, tdht_tech_need, 0)
    call SaveInteger(tdht, tSTRONG, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tSTRONG, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tSTRONG)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tDOGE, tdht_name, "闂伩")
    call SaveInteger(tdht, tDOGE, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tDOGE, tdht_tech_need, 0)
    call SaveInteger(tdht, tDOGE, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tDOGE, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tDOGE)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tSPEED_SHOOT, tdht_name, "鎬ラ€熷皠鍑?)
    call SaveInteger(tdht, tSPEED_SHOOT, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tSPEED_SHOOT, tdht_tech_need, 0)
    call SaveInteger(tdht, tSPEED_SHOOT, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tSPEED_SHOOT, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tSPEED_SHOOT)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tAIM_SHOOT, tdht_name, "绮惧噯灏勫嚮")
    call SaveInteger(tdht, tAIM_SHOOT, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tAIM_SHOOT, tdht_tech_need, 0)
    call SaveInteger(tdht, tAIM_SHOOT, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tAIM_SHOOT, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tAIM_SHOOT)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tSAVE, tdht_name, "鑺傝兘")
    call SaveInteger(tdht, tSAVE, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tSAVE, tdht_tech_need, 0)
    call SaveInteger(tdht, tSAVE, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tSAVE, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tSAVE)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tSAVE", "鑺傝兘", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
    call SaveStr(tdht, tFREZZ, tdht_name, "鎬ュ喕")
    call SaveInteger(tdht, tFREZZ, tdht_cat, TT_ICE)
    call SaveInteger(tdht, tFREZZ, tdht_tech_need, 0)
    call SaveInteger(tdht, tFREZZ, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tFREZZ, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_ICE],tFREZZ)
    set s__TECH_TREE_COUNT[TT_ICE]= s__TECH_TREE_COUNT[TT_ICE] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tFREZZ", "鎬ュ喕", "TT_ICE", "0","1","0")
//textmacro instance: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
    call SaveStr(tdht, tMANA_BOOM, tdht_name, "鑳介噺鐖嗙偢")
    call SaveInteger(tdht, tMANA_BOOM, tdht_cat, TT_MAGIC_HUNTER)
    call SaveInteger(tdht, tMANA_BOOM, tdht_tech_need, 0)
    call SaveInteger(tdht, tMANA_BOOM, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tMANA_BOOM, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_MAGIC_HUNTER],tMANA_BOOM)
    set s__TECH_TREE_COUNT[TT_MAGIC_HUNTER]= s__TECH_TREE_COUNT[TT_MAGIC_HUNTER] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tMANA_BOOM", "鑳介噺鐖嗙偢", "TT_MAGIC_HUNTER", "0","1","0")
//textmacro instance: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tANTRAD, tdht_name, "杈愬皠鎶垫姉")
    call SaveInteger(tdht, tANTRAD, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tANTRAD, tdht_tech_need, 0)
    call SaveInteger(tdht, tANTRAD, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tANTRAD, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tANTRAD)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tANTRAD", "杈愬皠鎶垫姉", "TT_GENERAL", "0","1","0")
//textmacro instance: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
    call SaveStr(tdht, tFIRE_CHARGE, tdht_name, "鐑堢劙鍏呰兘")
    call SaveInteger(tdht, tFIRE_CHARGE, tdht_cat, TT_GENERAL)
    call SaveInteger(tdht, tFIRE_CHARGE, tdht_tech_need, 0)
    call SaveInteger(tdht, tFIRE_CHARGE, tdht_game_lv_need, 1)
    call SaveInteger(tdht, tFIRE_CHARGE, tdht_base_point, 0)
    call s__TechTree_addItem(s__TECH_TREES[TT_GENERAL],tFIRE_CHARGE)
    set s__TECH_TREE_COUNT[TT_GENERAL]= s__TECH_TREE_COUNT[TT_GENERAL] + 1
    set TECH_COUNT=TECH_COUNT + 1
//end of: InitTechData("tFIRE_CHARGE", "鐑堢劙鍏呰兘", "TT_GENERAL", "0","1","0")
endfunction

//library TechData ends
//library Text:
function DisplayText takes player p,string msg returns nothing
    call DisplayTextToPlayer(p, 0, 0, msg)
endfunction
function DisplayInfo takes player p,string msg returns nothing
    call DisplayTextToPlayer(p, 0, 0, msg)
endfunction

//library Text ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (Purple flavor for 1.23b or later)
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: http://www.wc3c.net/
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Purple Flavor: Slower than the red flavor by a multiplication and a
//*             division, and as such faster than the blue flavor. Has
//*             a theoretical limit of timers, which is HASH_SIZE, but
//*             you should keep your timer count below 3/4 of that to
//*             insure good performance of the NewTimer function.
//*
//* Credits:  * Hash algorithm by Cohadar (used in an early version
//*             of his ABCT timer system)
//*
//*           * TimerUtils "interface" by Vexorian.
//*
//*           * This library by Iron_Doors.
//*
//********************************************************************
//================================================================
    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t,integer value returns nothing
        call sg__TimerUtils__data_set(GetHandleId(t) - TimerUtils__MIN_HANDLE_ID,value)
    endfunction
    function GetTimerData takes timer t returns integer
        return sg__TimerUtils__data_get(GetHandleId(t) - TimerUtils__MIN_HANDLE_ID)
    endfunction
    function NewTimer takes nothing returns timer
        if ( TimerUtils__tN == 0 ) then
            set TimerUtils__tT[0]=CreateTimer()
        else
            set TimerUtils__tN=TimerUtils__tN - 1
        endif
        call SetTimerData(TimerUtils__tT[TimerUtils__tN] , 0)
     return TimerUtils__tT[TimerUtils__tN]
    endfunction
    function ReleaseTimer takes timer t returns nothing
        if ( t == null ) then
            return
        endif
        if ( TimerUtils__tN == 8191 ) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if ( GetTimerData(t) == TimerUtils__HELD ) then
                return
            endif
            call SetTimerData(t , TimerUtils__HELD)
            set TimerUtils__tT[TimerUtils__tN]=t
            set TimerUtils__tN=TimerUtils__tN + 1
        endif
    endfunction

//library TimerUtils ends
//library Union:
    
    
    // If your Warcraft version isn`t 1.24 delete it, or must preserve the function.
   // function GetHandleId takes handle h returns integer
    //    return h
    //    return 0
    //endfunction
    function Adaptation takes nothing returns boolean
        return true
    endfunction
    
    function Incident takes playerunitevent case,conditionfunc cond,code act returns nothing
        local trigger t= CreateTrigger()
        local integer index= 0
        loop
            call TriggerRegisterPlayerUnitEvent(t, Player(index), case, Union__FilterLeisure)
            set index=index + 1
            exitwhen index == 12
        endloop
        call TriggerAddCondition(t, cond)
        call TriggerAddAction(t, act)
        set t=null
    endfunction
    
    function Init takes nothing returns nothing
        set Union__FilterLeisure=Filter(function Adaptation)
    endfunction
    

//library Union ends
//library UnitId:
function IsHero takes unit u returns boolean
    return GetUnitTypeId(u) == HERO
endfunction
function IsBoss takes unit u returns boolean
    local integer t= GetUnitTypeId(u)
    if t == 'u002' or t == 'u004' then
        return true
    endif
    return false
endfunction

//library UnitId ends
//library Vector:
//*****************************************************************
//*  VECTOR LIBRARY
//*
//*  written by: Anitarf
//*
//*  The library contains a struct named vector, which represents a
//*  point in 3D space. As such, it has three real members, one for
//*  each coordinate: x, y, z. It also has the following methods:
//*
//*        static method create takes real x, real y, real z returns vector
//*  Creates a new vector with the given coordinates.
//*
//*        method getLength takes nothing returns real
//*  Returns the length of the vector it is called on.
//*
//*        static method sum takes vector augend, vector addend returns vector
//*  Returns the sum of two vectors as a new vector.
//*
//*        method add takes vector addend returns nothing
//*  Similar to sum, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by adding the "added" to it.
//*
//*        static method difference takes vector minuend, vector subtrahend returns vector
//*  Returns the difference between two vectors as a new vector.
//*
//*        method subtract takes vector subtrahend returns nothing
//*  Similar to difference, except that it doesn't create a new vector for the result,
//*  but changes the vector it is called on by subtracting the "subtrahend" from it.
//*
//*        method scale takes real factor returns nothing
//*  Scales the vector it is called on by the given factor.
//*
//*        method setLength takes real length returns nothing
//*  Sets the length of the vector it is called on to the given value, maintaining its orientation.
//*
//*        static method dotProduct takes vector a, vector b returns real
//*  Calculates the dot product (also called scalar product) of two vectors.
//*
//*        static method crossProduct takes vector a, vector b returns vector
//*  Calculates the cross product (also called vector product) of two vectors
//*  and returns it as a new vector.
//*
//*        static method tripleProductScalar takes vector a, vector b, vector c returns real
//*  Calculates the triple scalar product of three vectors.
//*
//*        static method tripleProductVector takes vector a, vector b, vector c returns vector
//*  Calculates the triple vector product of three vectors and returns it as a new vector.
//*
//*
//*        static method projectionVector takes vector projected, vector direction returns vector
//*  Calculates the projection of the vector "projected" onto the vector "direction"
//*  and returns it as a new vector.
//*  Returns null if the vector "direction" has a length of 0.
//*
//*        method projectVector takes vector direction returns nothing
//*  Projects the vector it is called on onto the vector "direction".
//*  Does nothing if the vector "direction" has a length of 0.
//*
//*        static method projectionPlane takes vector projected, vector normal returns vector
//*  Calculates the projection of the vector "projected" onto a plane defined by
//*  its normal vector and returns it as a new vector.
//*  Returns null if the vector "normal" has a length of 0.
//*
//*        method projectPlane takes vector normal returns nothing
//*  Projects the vector it is called on onto a plane defined by its normal vector.
//*  Does nothing if the vector "normal" has a length of 0.
//*
//*        static method getAngle takes vector a, vector b returns real
//*  Returns the angle between two vectors, in radians, returns a value between 0 and pi.
//*  Returns 0.0 if any of the vectors are 0 units long.
//*
//*        method rotate takes vector axis, real angle returns nothing
//*  Rotates the vector it is called on around the axis defined by the vector "axis"
//*  by the given angle, which should be input in radians.
//*  Does nothing if axis is 0 units long.
//*
//*
//*        static method createTerrainPoint takes real x, real y returns vector
//*  Creates a vector to the given terrain coordinate, taking its z height into account.
//*
//*        method getTerrainPoint takes real x, real y returns nothing
//*  Sets the vector it is called on to the given terrain coordinate, taking its z height into account.
//*
//*        static method createTerrainNormal takes real x, real y, real sampleRadius returns vector
//*  Creates the normal vector of the terrain at given coordinates. "sampleRadius" defines
//*  how far apart the reference points will be, if they are further apart, the result will
//*  be an impression of smoother terrain; normaly the value should be between 0 and 128.
//*
//*        method getTerrainNormal takes real x, real y, real sampleRadius returns nothing
//*  Sets the vector it is called on to the normal of the terrain at given coordinates.
//*
//*
//*        method isInCylinder takes vector cylinderOrigin, vector cylinderHeight, real cylinderRadius returns boolean
//*  Determines if a point is within a given cylinder. The cylinder's origin vector points
//*  to the center of one of the two paralel circular sides, and the height vector points
//*  from the origin point to the center of the other of the two paralel circular sides.
//*  Returns false if the point is not in the cylinder or if the vector cylinderHeight is 0 units long.
//*
//*        method isInCone takes vector coneOrigin, vector coneHeight, real coneRadius returns boolean
//*  Determines if a point is within a given cone. The cone's origin vector points to the
//*  center of the circular side, and the height vector points from the origin point to
//*  the tip of the cone.
//*  Returns false if the point is not in the cylinder or if the vector coneHeight is 0 units long.
//*
//*        method isInSphere takes vector sphereOrigin, real sphereRadius returns boolean
//*  Determines if a point is within a give sphere. The sphere's origin vector points to the
//*  center of the sphere.
//*  Returns false if the point is not in the sphere.
//*****************************************************************
        
        function s__vector_create takes real x,real y,real z returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=x
            set s__vector_y[v]=y
            set s__vector_z[v]=z
            return v
        endfunction
        
        function s__vector_getLength takes integer this returns real
          return SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this] + s__vector_z[this] * s__vector_z[this])
        endfunction
        
        function s__vector_reverse takes integer this returns nothing
            set s__vector_x[this]=- s__vector_x[this]
            set s__vector_y[this]=- s__vector_y[this]
            set s__vector_z[this]=- s__vector_z[this]
        endfunction
        
        function s__vector_unitVector takes integer v returns integer
            local integer uv= s__vector__allocate()
            local real length= s__vector_getLength(v)
            if length == 0 then
                return s__vector_create(0 , 0 , 0)
            endif
            set s__vector_x[uv]=s__vector_x[v] / length
            set s__vector_y[uv]=s__vector_y[v] / length
            set s__vector_z[uv]=s__vector_z[v] / length
            return uv
        endfunction
        
        function s__vector_sum takes integer augend,integer addend returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=s__vector_x[augend] + s__vector_x[addend]
            set s__vector_y[v]=s__vector_y[augend] + s__vector_y[addend]
            set s__vector_z[v]=s__vector_z[augend] + s__vector_z[addend]
            return v
        endfunction
        function s__vector_add takes integer this,integer addend returns nothing
            set s__vector_x[this]=s__vector_x[this] + s__vector_x[addend]
            set s__vector_y[this]=s__vector_y[this] + s__vector_y[addend]
            set s__vector_z[this]=s__vector_z[this] + s__vector_z[addend]
        endfunction
        
        function s__vector_difference takes integer minuend,integer subtrahend returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=s__vector_x[minuend] - s__vector_x[subtrahend]
            set s__vector_y[v]=s__vector_y[minuend] - s__vector_y[subtrahend]
            set s__vector_z[v]=s__vector_z[minuend] - s__vector_z[subtrahend]
            return v
        endfunction
        function s__vector_subtract takes integer this,integer subtrahend returns nothing
            set s__vector_x[this]=s__vector_x[this] - s__vector_x[subtrahend]
            set s__vector_y[this]=s__vector_y[this] - s__vector_y[subtrahend]
            set s__vector_z[this]=s__vector_z[this] - s__vector_z[subtrahend]
        endfunction
        
        function s__vector_scale takes integer this,real factor returns nothing
            set s__vector_x[this]=s__vector_x[this] * factor
            set s__vector_y[this]=s__vector_y[this] * factor
            set s__vector_z[this]=s__vector_z[this] * factor
        endfunction
        
        function s__vector_scale2 takes integer v,real factor returns integer
            local integer r= s__vector__allocate()
            set s__vector_x[r]=s__vector_x[v] * factor
            set s__vector_y[r]=s__vector_y[v] * factor
            set s__vector_z[r]=s__vector_z[v] * factor
            return r
        endfunction
        
        function s__vector_setLength takes integer this,real length returns nothing
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this] + s__vector_z[this] * s__vector_z[this])
            if l == 0.0 then
                return
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
            set s__vector_z[this]=s__vector_z[this] * l
        endfunction
        
        function s__vector_dotProduct takes integer a,integer b returns real
            return ( s__vector_x[a] * s__vector_x[b] + s__vector_y[a] * s__vector_y[b] + s__vector_z[a] * s__vector_z[b] )
        endfunction
        
        function s__vector_crossProduct takes integer a,integer b returns integer
            local integer v= s__vector__allocate()
            set s__vector_x[v]=s__vector_y[a] * s__vector_z[b] - s__vector_z[a] * s__vector_y[b]
            set s__vector_y[v]=s__vector_z[a] * s__vector_x[b] - s__vector_x[a] * s__vector_z[b]
            set s__vector_z[v]=s__vector_x[a] * s__vector_y[b] - s__vector_y[a] * s__vector_x[b]
            return v
        endfunction
        function s__vector_tripleProductScalar takes integer a,integer b,integer c returns real
            return ( ( s__vector_y[a] * s__vector_z[b] - s__vector_z[a] * s__vector_y[b] ) * s__vector_x[c] + ( s__vector_z[a] * s__vector_x[b] - s__vector_x[a] * s__vector_z[b] ) * s__vector_y[c] + ( s__vector_x[a] * s__vector_y[b] - s__vector_y[a] * s__vector_x[b] ) * s__vector_z[c] )
        endfunction
        function s__vector_tripleProductVector takes integer a,integer b,integer c returns integer
            local integer v= s__vector__allocate()
            local real n= s__vector_x[a] * s__vector_x[c] + s__vector_y[a] * s__vector_y[c] + s__vector_z[a] * s__vector_z[c]
            local real m= s__vector_x[a] * s__vector_x[b] + s__vector_y[a] * s__vector_y[b] + s__vector_z[a] * s__vector_z[b]
            set s__vector_x[v]=s__vector_x[b] * n - s__vector_x[c] * m
            set s__vector_y[v]=s__vector_y[b] * n - s__vector_y[c] * m
            set s__vector_z[v]=s__vector_z[b] * n - s__vector_z[c] * m
            return v
        endfunction
// ================================================================
        function s__vector_projectionVector takes integer projected,integer direction returns integer
            local integer v= s__vector__allocate()
            local real l= s__vector_x[direction] * s__vector_x[direction] + s__vector_y[direction] * s__vector_y[direction] + s__vector_z[direction] * s__vector_z[direction]
            if l == 0.0 then
                call s__vector_deallocate(v)
                return 0
            endif
            set l=( s__vector_x[projected] * s__vector_x[direction] + s__vector_y[projected] * s__vector_y[direction] + s__vector_z[projected] * s__vector_z[direction] ) / l
            set s__vector_x[v]=s__vector_x[direction] * l
            set s__vector_y[v]=s__vector_y[direction] * l
            set s__vector_z[v]=s__vector_z[direction] * l
            return v
        endfunction
        function s__vector_projectVector takes integer this,integer direction returns nothing
            local real l= s__vector_x[direction] * s__vector_x[direction] + s__vector_y[direction] * s__vector_y[direction] + s__vector_z[direction] * s__vector_z[direction]
            if l == 0.0 then
                return
            endif
            set l=( s__vector_x[this] * s__vector_x[direction] + s__vector_y[this] * s__vector_y[direction] + s__vector_z[this] * s__vector_z[direction] ) / l
            set s__vector_x[this]=s__vector_x[direction] * l
            set s__vector_y[this]=s__vector_y[direction] * l
            set s__vector_z[this]=s__vector_z[direction] * l
        endfunction
        function s__vector_projectionPlane takes integer projected,integer normal returns integer
            local integer v= s__vector__allocate()
            local real l= s__vector_x[normal] * s__vector_x[normal] + s__vector_y[normal] * s__vector_y[normal] + s__vector_z[normal] * s__vector_z[normal]
            if l == 0.0 then
                call s__vector_deallocate(v)
                return 0
            endif
            set l=( s__vector_x[projected] * s__vector_x[normal] + s__vector_y[projected] * s__vector_y[normal] + s__vector_z[projected] * s__vector_z[normal] ) / l
            set s__vector_x[v]=s__vector_x[projected] - s__vector_x[normal] * l
            set s__vector_y[v]=s__vector_y[projected] - s__vector_y[normal] * l
            set s__vector_z[v]=s__vector_z[projected] - s__vector_z[normal] * l
            return v
        endfunction
        function s__vector_projectPlane takes integer this,integer normal returns nothing
            local real l= s__vector_x[normal] * s__vector_x[normal] + s__vector_y[normal] * s__vector_y[normal] + s__vector_z[normal] * s__vector_z[normal]
            if l == 0.0 then
                return
            endif
            set l=( s__vector_x[this] * s__vector_x[normal] + s__vector_y[this] * s__vector_y[normal] + s__vector_z[this] * s__vector_z[normal] ) / l
            set s__vector_x[this]=s__vector_x[this] - s__vector_x[normal] * l
            set s__vector_y[this]=s__vector_y[this] - s__vector_y[normal] * l
            set s__vector_z[this]=s__vector_z[this] - s__vector_z[normal] * l
        endfunction
        function s__vector_getAngle takes integer a,integer b returns real
            local real l= SquareRoot(s__vector_x[a] * s__vector_x[a] + s__vector_y[a] * s__vector_y[a] + s__vector_z[a] * s__vector_z[a]) * SquareRoot(s__vector_x[b] * s__vector_x[b] + s__vector_y[b] * s__vector_y[b] + s__vector_z[b] * s__vector_z[b])
            if l == 0 then
                return 0.0
            endif
            return Acos(( s__vector_x[a] * s__vector_x[b] + s__vector_y[a] * s__vector_y[b] + s__vector_z[a] * s__vector_z[b] ) / l) //angle is returned in radians
endfunction
        
        function s__vector_rotate takes integer this,integer axis,real angle returns nothing
local real xx
            local real xy
            local real xz
            local real yx
            local real yy
            local real yz
            local real zx
            local real zy
            local real zz
            local real al= s__vector_x[axis] * s__vector_x[axis] + s__vector_y[axis] * s__vector_y[axis] + s__vector_z[axis] * s__vector_z[axis]
local real f
            local real c= Cos(angle)
            local real s= Sin(angle)
            if al == 0.0 then
                return
            endif
            set f=( s__vector_x[this] * s__vector_x[axis] + s__vector_y[this] * s__vector_y[axis] + s__vector_z[this] * s__vector_z[axis] ) / al
            set zx=s__vector_x[axis] * f
            set zy=s__vector_y[axis] * f
            set zz=s__vector_z[axis] * f //axis component of rotated vector
set xx=s__vector_x[this] - zx
            set xy=s__vector_y[this] - zy
            set xz=s__vector_z[this] - zz //component of vector perpendicular to axis
set al=SquareRoot(al)
            set yx=( s__vector_y[axis] * xz - s__vector_z[axis] * xy ) / al
            set yy=( s__vector_z[axis] * xx - s__vector_x[axis] * xz ) / al //y same length as x by using cross product and dividing with axis length
set yz=( s__vector_x[axis] * xy - s__vector_y[axis] * xx ) / al //x,y - coordinate system in which we rotate
set s__vector_x[this]=xx * c + yx * s + zx
            set s__vector_y[this]=xy * c + yy * s + zy
            set s__vector_z[this]=xz * c + yz * s + zz
        endfunction
        
// ================================================================
        function s__vector_createTerrainPoint takes real x,real y returns integer
            local integer v= s__vector__allocate()
            call MoveLocation(s__vector_loc, x, y)
            set s__vector_x[v]=x
            set s__vector_y[v]=y
            set s__vector_z[v]=GetLocationZ(s__vector_loc)
            return v
        endfunction
        function s__vector_getTerrainPoint takes integer this,real x,real y returns nothing
            call MoveLocation(s__vector_loc, x, y)
            set s__vector_x[this]=x
            set s__vector_y[this]=y
            set s__vector_z[this]=GetLocationZ(s__vector_loc)
        endfunction
        function s__vector_createTerrainNormal takes real x,real y,real sampleRadius returns integer
            local integer v= s__vector__allocate()
            local real zx
            local real zy
            call MoveLocation(s__vector_loc, x - sampleRadius, y)
            set zx=GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x + sampleRadius, y)
            set zx=zx - GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x, y - sampleRadius)
            set zy=GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x, y + sampleRadius)
            set zy=zy - GetLocationZ(s__vector_loc)
            set sampleRadius=2 * sampleRadius
            set s__vector_x[v]=zx * sampleRadius
            set s__vector_y[v]=zy * sampleRadius
            set s__vector_z[v]=sampleRadius * sampleRadius
            return v
        endfunction
        function s__vector_getTerrainNormal takes integer this,real x,real y,real sampleRadius returns nothing
            local real zx
            local real zy
            call MoveLocation(s__vector_loc, x - sampleRadius, y)
            set zx=GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x + sampleRadius, y)
            set zx=zx - GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x, y - sampleRadius)
            set zy=GetLocationZ(s__vector_loc)
            call MoveLocation(s__vector_loc, x, y + sampleRadius)
            set zy=zy - GetLocationZ(s__vector_loc)
            set sampleRadius=2 * sampleRadius
            set s__vector_x[this]=zx * sampleRadius
            set s__vector_y[this]=zy * sampleRadius
            set s__vector_z[this]=sampleRadius * sampleRadius
        endfunction
// ================================================================
        function s__vector_isInCylinder takes integer this,integer cylinderOrigin,integer cylinderHeight,real cylinderRadius returns boolean
            local real l
            local real x= s__vector_x[this] - s__vector_x[cylinderOrigin]
            local real y= s__vector_y[this] - s__vector_y[cylinderOrigin]
            local real z= s__vector_z[this] - s__vector_z[cylinderOrigin]
            if x * s__vector_x[cylinderHeight] + y * s__vector_y[cylinderHeight] + z * s__vector_z[cylinderHeight] < 0.0 then //point below cylinder
return false
            endif
            
            set x=x - s__vector_x[cylinderHeight]
            set y=y - s__vector_y[cylinderHeight]
            set z=z - s__vector_z[cylinderHeight]
            if x * s__vector_x[cylinderHeight] + y * s__vector_y[cylinderHeight] + z * s__vector_z[cylinderHeight] > 0.0 then //point above cylinder
return false
            endif
            
            set l=s__vector_x[cylinderHeight] * s__vector_x[cylinderHeight] + s__vector_y[cylinderHeight] * s__vector_y[cylinderHeight] + s__vector_z[cylinderHeight] * s__vector_z[cylinderHeight]
            if l == 0.0 then
                return false
            endif
            set l=( x * s__vector_x[cylinderHeight] + y * s__vector_y[cylinderHeight] + z * s__vector_z[cylinderHeight] ) / l
            set x=x - s__vector_x[cylinderHeight] * l
            set y=y - s__vector_y[cylinderHeight] * l
            set z=z - s__vector_z[cylinderHeight] * l
            if x * x + y * y + z * z > cylinderRadius * cylinderRadius then //point outside cylinder
return false
            endif
            
            return true
        endfunction
        function s__vector_isInCone takes integer this,integer coneOrigin,integer coneHeight,real coneRadius returns boolean
            local real l
            local real x= s__vector_x[this] - s__vector_x[coneOrigin]
            local real y= s__vector_y[this] - s__vector_y[coneOrigin]
            local real z= s__vector_z[this] - s__vector_z[coneOrigin]
            if x * s__vector_x[coneHeight] + y * s__vector_y[coneHeight] + z * s__vector_z[coneHeight] < 0.0 then //point below cone
return false
            endif
            
            set l=s__vector_x[coneHeight] * s__vector_x[coneHeight] + s__vector_y[coneHeight] * s__vector_y[coneHeight] + s__vector_z[coneHeight] * s__vector_z[coneHeight]
            if l == 0.0 then
                return false
            endif
            set l=( x * s__vector_x[coneHeight] + y * s__vector_y[coneHeight] + z * s__vector_z[coneHeight] ) / l
            set x=x - s__vector_x[coneHeight] * l
            set y=y - s__vector_y[coneHeight] * l
            set z=z - s__vector_z[coneHeight] * l
            if SquareRoot(x * x + y * y + z * z) > coneRadius * ( 1.0 - l ) then //point outside cone
return false
            endif
            
            return true
        endfunction
        function s__vector_isInSphere takes integer this,integer sphereOrigin,real sphereRadius returns boolean
            if sphereRadius * sphereRadius < ( ( s__vector_x[this] - s__vector_x[sphereOrigin] ) * ( s__vector_x[this] - s__vector_x[sphereOrigin] ) + ( s__vector_y[this] - s__vector_y[sphereOrigin] ) * ( s__vector_y[this] - s__vector_y[sphereOrigin] ) + ( s__vector_z[this] - s__vector_z[sphereOrigin] ) * ( s__vector_z[this] - s__vector_z[sphereOrigin] ) ) then
                return false
            endif
            return true
        endfunction

//library Vector ends
//library YDWEBase:
//===========================================================================
//HashTable
//===========================================================================
//===========================================================================
//Return bug
//===========================================================================
function YDWEH2I takes handle h returns integer
    return GetHandleId(h)
endfunction
//清空
function YDWEFlushAllData takes nothing returns nothing
    call FlushParentHashtable(YDHT)
endfunction
function YDWEFlushMissionByInteger takes integer i returns nothing
    call FlushChildHashtable(YDHT, i)
endfunction
function YDWEFlushMissionByString takes string s returns nothing
    call FlushChildHashtable(YDHT, StringHash(s))
endfunction
function YDWEFlushStoredIntegerByInteger takes integer i,integer j returns nothing
    call RemoveSavedInteger(YDHT, i, j)
endfunction
function YDWEFlushStoredIntegerByString takes string s1,string s2 returns nothing
    call RemoveSavedInteger(YDHT, StringHash(s1), StringHash(s2))
endfunction
function YDWEHaveSavedIntegerByInteger takes integer i,integer j returns boolean
    return HaveSavedInteger(YDHT, i, j)
endfunction
function YDWEHaveSavedIntegerByString takes string s1,string s2 returns boolean
    return HaveSavedInteger(YDHT, StringHash(s1), StringHash(s2))
endfunction
//store and get integer
function YDWESaveIntegerByInteger takes integer pTable,integer pKey,integer i returns nothing
    call SaveInteger(YDHT, pTable, pKey, i)
endfunction
function YDWESaveIntegerByString takes string pTable,string pKey,integer i returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), i)
endfunction
function YDWEGetIntegerByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetIntegerByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get real
function YDWESaveRealByInteger takes integer pTable,integer pKey,real r returns nothing
    call SaveReal(YDHT, pTable, pKey, r)
endfunction
function YDWESaveRealByString takes string pTable,string pKey,real r returns nothing
    call SaveReal(YDHT, StringHash(pTable), StringHash(pKey), r)
endfunction
function YDWEGetRealByInteger takes integer pTable,integer pKey returns real
    return LoadReal(YDHT, pTable, pKey)
endfunction
function YDWEGetRealByString takes string pTable,string pKey returns real
    return LoadReal(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get string
function YDWESaveStringByInteger takes integer pTable,integer pKey,string s returns nothing
    call SaveStr(YDHT, pTable, pKey, s)
endfunction
function YDWESaveStringByString takes string pTable,string pKey,string s returns nothing
    call SaveStr(YDHT, StringHash(pTable), StringHash(pKey), s)
endfunction
function YDWEGetStringByInteger takes integer pTable,integer pKey returns string
    return LoadStr(YDHT, pTable, pKey)
endfunction
function YDWEGetStringByString takes string pTable,string pKey returns string
    return LoadStr(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//store and get boolean
function YDWESaveBooleanByInteger takes integer pTable,integer pKey,boolean b returns nothing
    call SaveBoolean(YDHT, pTable, pKey, b)
endfunction
function YDWESaveBooleanByString takes string pTable,string pKey,boolean b returns nothing
    call SaveBoolean(YDHT, StringHash(pTable), StringHash(pKey), b)
endfunction
function YDWEGetBooleanByInteger takes integer pTable,integer pKey returns boolean
    return LoadBoolean(YDHT, pTable, pKey)
endfunction
function YDWEGetBooleanByString takes string pTable,string pKey returns boolean
    return LoadBoolean(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Unit
function YDWESaveUnitByInteger takes integer pTable,integer pKey,unit u returns nothing
    call SaveUnitHandle(YDHT, pTable, pKey, u)
endfunction
function YDWESaveUnitByString takes string pTable,string pKey,unit u returns nothing
    call SaveUnitHandle(YDHT, StringHash(pTable), StringHash(pKey), u)
endfunction
function YDWEGetUnitByInteger takes integer pTable,integer pKey returns unit
    return LoadUnitHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetUnitByString takes string pTable,string pKey returns unit
    return LoadUnitHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert UnitID
function YDWESaveUnitIDByInteger takes integer pTable,integer pKey,integer uid returns nothing
    call SaveInteger(YDHT, pTable, pKey, uid)
endfunction
function YDWESaveUnitIDByString takes string pTable,string pKey,integer uid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), uid)
endfunction
function YDWEGetUnitIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetUnitIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert AbilityID
function YDWESaveAbilityIDByInteger takes integer pTable,integer pKey,integer abid returns nothing
    call SaveInteger(YDHT, pTable, pKey, abid)
endfunction
function YDWESaveAbilityIDByString takes string pTable,string pKey,integer abid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), abid)
endfunction
function YDWEGetAbilityIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetAbilityIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Player
function YDWESavePlayerByInteger takes integer pTable,integer pKey,player p returns nothing
    call SavePlayerHandle(YDHT, pTable, pKey, p)
endfunction
function YDWESavePlayerByString takes string pTable,string pKey,player p returns nothing
    call SavePlayerHandle(YDHT, StringHash(pTable), StringHash(pKey), p)
endfunction
function YDWEGetPlayerByInteger takes integer pTable,integer pKey returns player
    return LoadPlayerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetPlayerByString takes string pTable,string pKey returns player
    return LoadPlayerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Item
function YDWESaveItemByInteger takes integer pTable,integer pKey,item it returns nothing
    call SaveItemHandle(YDHT, pTable, pKey, it)
endfunction
function YDWESaveItemByString takes string pTable,string pKey,item it returns nothing
    call SaveItemHandle(YDHT, StringHash(pTable), StringHash(pKey), it)
endfunction
function YDWEGetItemByInteger takes integer pTable,integer pKey returns item
    return LoadItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetItemByString takes string pTable,string pKey returns item
    return LoadItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert ItemID
function YDWESaveItemIDByInteger takes integer pTable,integer pKey,integer itid returns nothing
    call SaveInteger(YDHT, pTable, pKey, itid)
endfunction
function YDWESaveItemIDByString takes string pTable,string pKey,integer itid returns nothing
    call SaveInteger(YDHT, StringHash(pTable), StringHash(pKey), itid)
endfunction
function YDWEGetItemIDByInteger takes integer pTable,integer pKey returns integer
    return LoadInteger(YDHT, pTable, pKey)
endfunction
function YDWEGetItemIDByString takes string pTable,string pKey returns integer
    return LoadInteger(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Timer
function YDWESaveTimerByInteger takes integer pTable,integer pKey,timer t returns nothing
    call SaveTimerHandle(YDHT, pTable, pKey, t)
endfunction
function YDWESaveTimerByString takes string pTable,string pKey,timer t returns nothing
    call SaveTimerHandle(YDHT, StringHash(pTable), StringHash(pKey), t)
endfunction
function YDWEGetTimerByInteger takes integer pTable,integer pKey returns timer
    return LoadTimerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTimerByString takes string pTable,string pKey returns timer
    return LoadTimerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Trigger
function YDWESaveTriggerByInteger takes integer pTable,integer pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT, pTable, pKey, trg)
endfunction
function YDWESaveTriggerByString takes string pTable,string pKey,trigger trg returns nothing
    call SaveTriggerHandle(YDHT, StringHash(pTable), StringHash(pKey), trg)
endfunction
function YDWEGetTriggerByInteger takes integer pTable,integer pKey returns trigger
    return LoadTriggerHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerByString takes string pTable,string pKey returns trigger
    return LoadTriggerHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Location
function YDWESaveLocationByInteger takes integer pTable,integer pKey,location pt returns nothing
    call SaveLocationHandle(YDHT, pTable, pKey, pt)
endfunction
function YDWESaveLocationByString takes string pTable,string pKey,location pt returns nothing
    call SaveLocationHandle(YDHT, StringHash(pTable), StringHash(pKey), pt)
endfunction
function YDWEGetLocationByInteger takes integer pTable,integer pKey returns location
    return LoadLocationHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLocationByString takes string pTable,string pKey returns location
    return LoadLocationHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Group
function YDWESaveGroupByInteger takes integer pTable,integer pKey,group g returns nothing
    call SaveGroupHandle(YDHT, pTable, pKey, g)
endfunction
function YDWESaveGroupByString takes string pTable,string pKey,group g returns nothing
    call SaveGroupHandle(YDHT, StringHash(pTable), StringHash(pKey), g)
endfunction
function YDWEGetGroupByInteger takes integer pTable,integer pKey returns group
    return LoadGroupHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetGroupByString takes string pTable,string pKey returns group
    return LoadGroupHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Multiboard
function YDWESaveMultiboardByInteger takes integer pTable,integer pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT, pTable, pKey, m)
endfunction
function YDWESaveMultiboardByString takes string pTable,string pKey,multiboard m returns nothing
    call SaveMultiboardHandle(YDHT, StringHash(pTable), StringHash(pKey), m)
endfunction
function YDWEGetMultiboardByInteger takes integer pTable,integer pKey returns multiboard
    return LoadMultiboardHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetMultiboardByString takes string pTable,string pKey returns multiboard
    return LoadMultiboardHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert MultiboardItem
function YDWESaveMultiboardItemByInteger takes integer pTable,integer pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT, pTable, pKey, mt)
endfunction
function YDWESaveMultiboardItemByString takes string pTable,string pKey,multiboarditem mt returns nothing
    call SaveMultiboardItemHandle(YDHT, StringHash(pTable), StringHash(pKey), mt)
endfunction
function YDWEGetMultiboardItemByInteger takes integer pTable,integer pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetMultiboardItemByString takes string pTable,string pKey returns multiboarditem
    return LoadMultiboardItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert TextTag
function YDWESaveTextTagByInteger takes integer pTable,integer pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT, pTable, pKey, tt)
endfunction
function YDWESaveTextTagByString takes string pTable,string pKey,texttag tt returns nothing
    call SaveTextTagHandle(YDHT, StringHash(pTable), StringHash(pKey), tt)
endfunction
function YDWEGetTextTagByInteger takes integer pTable,integer pKey returns texttag
    return LoadTextTagHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTextTagByString takes string pTable,string pKey returns texttag
    return LoadTextTagHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Lightning
function YDWESaveLightningByInteger takes integer pTable,integer pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT, pTable, pKey, ln)
endfunction
function YDWESaveLightningByString takes string pTable,string pKey,lightning ln returns nothing
    call SaveLightningHandle(YDHT, StringHash(pTable), StringHash(pKey), ln)
endfunction
function YDWEGetLightningByInteger takes integer pTable,integer pKey returns lightning
    return LoadLightningHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLightningByString takes string pTable,string pKey returns lightning
    return LoadLightningHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Region
function YDWESaveRegionByInteger takes integer pTable,integer pKey,region rn returns nothing
    call SaveRegionHandle(YDHT, pTable, pKey, rn)
endfunction
function YDWESaveRegionByString takes string pTable,string pKey,region rt returns nothing
    call SaveRegionHandle(YDHT, StringHash(pTable), StringHash(pKey), rt)
endfunction
function YDWEGetRegionByInteger takes integer pTable,integer pKey returns region
    return LoadRegionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetRegionByString takes string pTable,string pKey returns region
    return LoadRegionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Rect
function YDWESaveRectByInteger takes integer pTable,integer pKey,rect rn returns nothing
    call SaveRectHandle(YDHT, pTable, pKey, rn)
endfunction
function YDWESaveRectByString takes string pTable,string pKey,rect rt returns nothing
    call SaveRectHandle(YDHT, StringHash(pTable), StringHash(pKey), rt)
endfunction
function YDWEGetRectByInteger takes integer pTable,integer pKey returns rect
    return LoadRectHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetRectByString takes string pTable,string pKey returns rect
    return LoadRectHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Leaderboard
function YDWESaveLeaderboardByInteger takes integer pTable,integer pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT, pTable, pKey, lb)
endfunction
function YDWESaveLeaderboardByString takes string pTable,string pKey,leaderboard lb returns nothing
    call SaveLeaderboardHandle(YDHT, StringHash(pTable), StringHash(pKey), lb)
endfunction
function YDWEGetLeaderboardByInteger takes integer pTable,integer pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetLeaderboardByString takes string pTable,string pKey returns leaderboard
    return LoadLeaderboardHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Effect
function YDWESaveEffectByInteger takes integer pTable,integer pKey,effect e returns nothing
    call SaveEffectHandle(YDHT, pTable, pKey, e)
endfunction
function YDWESaveEffectByString takes string pTable,string pKey,effect e returns nothing
    call SaveEffectHandle(YDHT, StringHash(pTable), StringHash(pKey), e)
endfunction
function YDWEGetEffectByInteger takes integer pTable,integer pKey returns effect
    return LoadEffectHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetEffectByString takes string pTable,string pKey returns effect
    return LoadEffectHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert Destructable
function YDWESaveDestructableByInteger takes integer pTable,integer pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT, pTable, pKey, da)
endfunction
function YDWESaveDestructableByString takes string pTable,string pKey,destructable da returns nothing
    call SaveDestructableHandle(YDHT, StringHash(pTable), StringHash(pKey), da)
endfunction
function YDWEGetDestructableByInteger takes integer pTable,integer pKey returns destructable
    return LoadDestructableHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetDestructableByString takes string pTable,string pKey returns destructable
    return LoadDestructableHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert triggercondition
function YDWESaveTriggerConditionByInteger takes integer pTable,integer pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT, pTable, pKey, tc)
endfunction
function YDWESaveTriggerConditionByString takes string pTable,string pKey,triggercondition tc returns nothing
    call SaveTriggerConditionHandle(YDHT, StringHash(pTable), StringHash(pKey), tc)
endfunction
function YDWEGetTriggerConditionByInteger takes integer pTable,integer pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerConditionByString takes string pTable,string pKey returns triggercondition
    return LoadTriggerConditionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert triggeraction
function YDWESaveTriggerActionByInteger takes integer pTable,integer pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT, pTable, pKey, ta)
endfunction
function YDWESaveTriggerActionByString takes string pTable,string pKey,triggeraction ta returns nothing
    call SaveTriggerActionHandle(YDHT, StringHash(pTable), StringHash(pKey), ta)
endfunction
function YDWEGetTriggerActionByInteger takes integer pTable,integer pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerActionByString takes string pTable,string pKey returns triggeraction
    return LoadTriggerActionHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert event
function YDWESaveTriggerEventByInteger takes integer pTable,integer pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT, pTable, pKey, et)
endfunction
function YDWESaveTriggerEventByString takes string pTable,string pKey,event et returns nothing
    call SaveTriggerEventHandle(YDHT, StringHash(pTable), StringHash(pKey), et)
endfunction
function YDWEGetTriggerEventByInteger takes integer pTable,integer pKey returns event
    return LoadTriggerEventHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTriggerEventByString takes string pTable,string pKey returns event
    return LoadTriggerEventHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert force
function YDWESaveForceByInteger takes integer pTable,integer pKey,force fc returns nothing
    call SaveForceHandle(YDHT, pTable, pKey, fc)
endfunction
function YDWESaveForceByString takes string pTable,string pKey,force fc returns nothing
    call SaveForceHandle(YDHT, StringHash(pTable), StringHash(pKey), fc)
endfunction
function YDWEGetForceByInteger takes integer pTable,integer pKey returns force
    return LoadForceHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetForceByString takes string pTable,string pKey returns force
    return LoadForceHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert boolexpr
function YDWESaveBoolexprByInteger takes integer pTable,integer pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT, pTable, pKey, be)
endfunction
function YDWESaveBoolexprByString takes string pTable,string pKey,boolexpr be returns nothing
    call SaveBooleanExprHandle(YDHT, StringHash(pTable), StringHash(pKey), be)
endfunction
function YDWEGetBoolexprByInteger takes integer pTable,integer pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetBoolexprByString takes string pTable,string pKey returns boolexpr
    return LoadBooleanExprHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert sound
function YDWESaveSoundByInteger takes integer pTable,integer pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT, pTable, pKey, sd)
endfunction
function YDWESaveSoundByString takes string pTable,string pKey,sound sd returns nothing
    call SaveSoundHandle(YDHT, StringHash(pTable), StringHash(pKey), sd)
endfunction
function YDWEGetSoundByInteger takes integer pTable,integer pKey returns sound
    return LoadSoundHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetSoundByString takes string pTable,string pKey returns sound
    return LoadSoundHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert timerdialog
function YDWESaveTimerDialogByInteger takes integer pTable,integer pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT, pTable, pKey, td)
endfunction
function YDWESaveTimerDialogByString takes string pTable,string pKey,timerdialog td returns nothing
    call SaveTimerDialogHandle(YDHT, StringHash(pTable), StringHash(pKey), td)
endfunction
function YDWEGetTimerDialogByInteger takes integer pTable,integer pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTimerDialogByString takes string pTable,string pKey returns timerdialog
    return LoadTimerDialogHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert trackable
function YDWESaveTrackableByInteger takes integer pTable,integer pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT, pTable, pKey, ta)
endfunction
function YDWESaveTrackableByString takes string pTable,string pKey,trackable ta returns nothing
    call SaveTrackableHandle(YDHT, StringHash(pTable), StringHash(pKey), ta)
endfunction
function YDWEGetTrackableByInteger takes integer pTable,integer pKey returns trackable
    return LoadTrackableHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetTrackableByString takes string pTable,string pKey returns trackable
    return LoadTrackableHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert dialog
function YDWESaveDialogByInteger takes integer pTable,integer pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT, pTable, pKey, d)
endfunction
function YDWESaveDialogByString takes string pTable,string pKey,dialog d returns nothing
    call SaveDialogHandle(YDHT, StringHash(pTable), StringHash(pKey), d)
endfunction
function YDWEGetDialogByInteger takes integer pTable,integer pKey returns dialog
    return LoadDialogHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetDialogByString takes string pTable,string pKey returns dialog
    return LoadDialogHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert button
function YDWESaveButtonByInteger takes integer pTable,integer pKey,button bt returns nothing
    call SaveButtonHandle(YDHT, pTable, pKey, bt)
endfunction
function YDWESaveButtonByString takes string pTable,string pKey,button bt returns nothing
    call SaveButtonHandle(YDHT, StringHash(pTable), StringHash(pKey), bt)
endfunction
function YDWEGetButtonByInteger takes integer pTable,integer pKey returns button
    return LoadButtonHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetButtonByString takes string pTable,string pKey returns button
    return LoadButtonHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert quest
function YDWESaveQuestByInteger takes integer pTable,integer pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT, pTable, pKey, qt)
endfunction
function YDWESaveQuestByString takes string pTable,string pKey,quest qt returns nothing
    call SaveQuestHandle(YDHT, StringHash(pTable), StringHash(pKey), qt)
endfunction
function YDWEGetQuestByInteger takes integer pTable,integer pKey returns quest
    return LoadQuestHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetQuestByString takes string pTable,string pKey returns quest
    return LoadQuestHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
//Covert questitem
function YDWESaveQuestItemByInteger takes integer pTable,integer pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT, pTable, pKey, qi)
endfunction
function YDWESaveQuestItemByString takes string pTable,string pKey,questitem qi returns nothing
    call SaveQuestItemHandle(YDHT, StringHash(pTable), StringHash(pKey), qi)
endfunction
function YDWEGetQuestItemByInteger takes integer pTable,integer pKey returns questitem
    return LoadQuestItemHandle(YDHT, pTable, pKey)
endfunction
function YDWEGetQuestItemByString takes string pTable,string pKey returns questitem
    return LoadQuestItemHandle(YDHT, StringHash(pTable), StringHash(pKey))
endfunction
function YDWES2I takes string s returns integer
    return StringHash(s)
endfunction
function YDWESaveAbilityHandleBJ takes integer AbilityID,integer key,integer missionKey,hashtable table returns nothing
    call SaveInteger(table, missionKey, key, AbilityID)
endfunction
function YDWESaveAbilityHandle takes hashtable table,integer parentKey,integer childKey,integer AbilityID returns nothing
    call SaveInteger(table, parentKey, childKey, AbilityID)
endfunction
function YDWELoadAbilityHandleBJ takes integer key,integer missionKey,hashtable table returns integer
    return LoadInteger(table, missionKey, key)
endfunction
function YDWELoadAbilityHandle takes hashtable table,integer parentKey,integer childKey returns integer
    return LoadInteger(table, parentKey, childKey)
endfunction
//===========================================================================
//杩斿洖鍙傛暟
//===========================================================================
//鍦板浘杈圭晫鍒ゆ柇
function YDWECoordinateX takes real x returns real
    return RMinBJ(RMaxBJ(x, yd_MapMinX), yd_MapMaxX)
endfunction
function YDWECoordinateY takes real y returns real
    return RMinBJ(RMaxBJ(y, yd_MapMinY), yd_MapMaxY)
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮窛绂?
function YDWEDistanceBetweenUnits takes unit a,unit b returns real
    return SquareRoot(( GetUnitX(a) - GetUnitX(b) ) * ( GetUnitX(a) - GetUnitX(b) ) + ( GetUnitY(a) - GetUnitY(b) ) * ( GetUnitY(a) - GetUnitY(b) ))
endfunction
//涓や釜鍗曚綅涔嬮棿鐨勮搴?
function YDWEAngleBetweenUnits takes unit fromUnit,unit toUnit returns real
    return bj_RADTODEG * Atan2(GetUnitY(toUnit) - GetUnitY(fromUnit), GetUnitX(toUnit) - GetUnitX(fromUnit))
endfunction
//鐢熸垚鍖哄煙
function YDWEGetRect takes real x,real y,real width,real height returns rect
    return Rect(x - width * 0.5, y - height * 0.5, x + width * 0.5, y + height * 0.5)
endfunction
//===========================================================================
//璁剧疆鍗曚綅鍙互椋炶
//===========================================================================
function YDWEFlyEnable takes unit u returns nothing
    call UnitAddAbility(u, 'Amrf')
    call UnitRemoveAbility(u, 'Amrf')
endfunction
//===========================================================================
//瀛楃绐滀笌ID杞崲
//===========================================================================
function YDWEId2S takes integer value returns string
    local string charMap=bj_AllString
    local string result= ""
    local integer remainingValue= value
    local integer charValue
    local integer byteno
    set byteno=0
    loop
        set charValue=ModuloInteger(remainingValue, 256)
        set remainingValue=remainingValue / 256
        set result=SubString(charMap, charValue, charValue + 1) + result
        set byteno=byteno + 1
        exitwhen byteno == 4
    endloop
    return result
endfunction
function YDWES2Id takes string targetstr returns integer
    local string originstr=bj_AllString
    local integer strlength=StringLength(targetstr)
    local integer a=0
local integer b=0
local integer numx=1
local integer result=0
    loop
    exitwhen b > strlength - 1
        set numx=R2I(Pow(256, strlength - 1 - b))
        set a=1
        loop
            exitwhen a > 255
            if SubString(targetstr, b, b + 1) == SubString(originstr, a, a + 1) then
                set result=result + a * numx
                set a=256
            endif
            set a=a + 1
        endloop
        set b=b + 1
    endloop
    return result
endfunction
function YDWES2UnitId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function YDWES2ItemId takes string targetstr returns integer
    return YDWES2Id(targetstr)
endfunction
function GetLastAbilityCastingUnit takes nothing returns unit
    return bj_lastAbilityCastingUnit
endfunction
function GetLastAbilityTargetUnit takes nothing returns unit
    return bj_lastAbilityTargetUnit
endfunction
function YDWESetMapLimitCoordinate takes real MinX,real MaxX,real MinY,real MaxY returns nothing
    set yd_MapMaxX=MaxX
    set yd_MapMinX=MinX
    set yd_MapMaxY=MaxY
    set yd_MapMinY=MinY
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//YDWE鐗规畩鎶€鑳界粨鏉熶簨浠?
function YDWESyStemAbilityCastingOverTriggerAction takes unit hero,integer index returns nothing
 local integer i= 0
    loop
        exitwhen i >= YDWEBase__AbilityCastingOverEventNumber
        if YDWEBase__AbilityCastingOverEventType[i] == index then
            set bj_lastAbilityCastingUnit=hero
			if YDWEBase__AbilityCastingOverEventQueue[i] != null and TriggerEvaluate(YDWEBase__AbilityCastingOverEventQueue[i]) and IsTriggerEnabled(YDWEBase__AbilityCastingOverEventQueue[i]) then
				call TriggerExecute(YDWEBase__AbilityCastingOverEventQueue[i])
			endif
		endif
        set i=i + 1
    endloop
endfunction
//===========================================================================  
//YDWE鎶€鑳芥崟鎹変簨浠?
//===========================================================================  
function YDWESyStemAbilityCastingOverRegistTrigger takes trigger trg,integer index returns nothing
	set YDWEBase__AbilityCastingOverEventQueue[YDWEBase__AbilityCastingOverEventNumber]=trg
	set YDWEBase__AbilityCastingOverEventType[YDWEBase__AbilityCastingOverEventNumber]=index
	set YDWEBase__AbilityCastingOverEventNumber=YDWEBase__AbilityCastingOverEventNumber + 1
endfunction 
//===========================================================================
//绯荤粺鍑芥暟瀹屽杽
//===========================================================================
function YDWECreateUnitPool takes nothing returns nothing
    set bj_lastCreatedUnitPool=CreateUnitPool()
endfunction
function YDWEPlaceRandomUnit takes unitpool up,player p,real x,real y,real face returns nothing
set bj_lastPoolAbstractedUnit=PlaceRandomUnit(up, p, x, y, face)
endfunction
function YDWEGetLastUnitPool takes nothing returns unitpool
    return bj_lastCreatedUnitPool
endfunction
function YDWEGetLastPoolAbstractedUnit takes nothing returns unit
    return bj_lastPoolAbstractedUnit
endfunction
function YDWECreateItemPool takes nothing returns nothing
    set bj_lastCreatedItemPool=CreateItemPool()
endfunction
function YDWEPlaceRandomItem takes itempool ip,real x,real y returns nothing
set bj_lastPoolAbstractedItem=PlaceRandomItem(ip, x, y)
endfunction
function YDWEGetLastItemPool takes nothing returns itempool
    return bj_lastCreatedItemPool
endfunction
function YDWEGetLastPoolAbstractedItem takes nothing returns item
    return bj_lastPoolAbstractedItem
endfunction
function YDWESetAttackDamageWeaponType takes attacktype at,damagetype dt,weapontype wt returns nothing
    set bj_lastSetAttackType=at
    set bj_lastSetDamageType=dt
    set bj_lastSetWeaponType=wt
endfunction
//unitpool bj_lastCreatedPool=null
//unit bj_lastPoolAbstractedUnit=null
function YDWEGetPlayerColorString takes player p,string s returns string
    return YDWEBase__yd_PlayerColor[GetHandleId(GetPlayerColor(p))] + s + "|r"
endfunction
//===========================================================================
//===========================================================================
//绯荤粺鍑芥暟琛ュ厖
//===========================================================================
//===========================================================================
function YDWEGetUnitItemSoftId takes unit hero,item it returns integer
    local integer i= 0
    loop
         exitwhen i > 5
         if UnitItemInSlot(hero, i) == it then
            return i + 1
         endif
         set i=i + 1
    endloop
    return 0
endfunction
//===========================================================================
//===========================================================================
//鍦板浘鍒濆鍖?
//===========================================================================
//===========================================================================
//鏄剧ず鐗堟湰
function YDWEVersion_Display takes nothing returns boolean
    call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 30, "|cFF1E90FF褰撳墠缂栬緫鍣ㄧ増鏈负锛?|r|cFF00FF00YDWE 1.26.9.617")
    return false
endfunction
function YDWEVersion_Init takes nothing returns nothing
    local trigger t= CreateTrigger()
    local integer i= 0
    loop
        exitwhen i == 12
        call TriggerRegisterPlayerChatEvent(t, Player(i), "YDWE Version", true)
        set i=i + 1
    endloop
    call TriggerAddCondition(t, Condition(function YDWEVersion_Display))
    set t=null
endfunction
function InitializeYD takes nothing returns nothing
     set YDHT=InitHashtable()
	//=================璁剧疆鍙橀噺=====================
	set yd_MapMinX=GetCameraBoundMinX() - GetCameraMargin(CAMERA_MARGIN_LEFT)
	set yd_MapMinY=GetCameraBoundMinY() - GetCameraMargin(CAMERA_MARGIN_BOTTOM)
	set yd_MapMaxX=GetCameraBoundMaxX() + GetCameraMargin(CAMERA_MARGIN_RIGHT)
	set yd_MapMaxY=GetCameraBoundMaxY() + GetCameraMargin(CAMERA_MARGIN_TOP)
	
    set YDWEBase__yd_PlayerColor[0]="|cFFFF0303"
    set YDWEBase__yd_PlayerColor[1]="|cFF0042FF"
    set YDWEBase__yd_PlayerColor[2]="|cFF1CE6B9"
    set YDWEBase__yd_PlayerColor[3]="|cFF540081"
    set YDWEBase__yd_PlayerColor[4]="|cFFFFFC01"
    set YDWEBase__yd_PlayerColor[5]="|cFFFE8A0E"
    set YDWEBase__yd_PlayerColor[6]="|cFF20C000"
    set YDWEBase__yd_PlayerColor[7]="|cFFE55BB0"
    set YDWEBase__yd_PlayerColor[8]="|cFF959697"
    set YDWEBase__yd_PlayerColor[9]="|cFF7EBFF1"
    set YDWEBase__yd_PlayerColor[10]="|cFF106246"
    set YDWEBase__yd_PlayerColor[11]="|cFF4E2A04"
    set YDWEBase__yd_PlayerColor[12]="|cFF282828"
    set YDWEBase__yd_PlayerColor[13]="|cFF282828"
    set YDWEBase__yd_PlayerColor[14]="|cFF282828"
    set YDWEBase__yd_PlayerColor[15]="|cFF282828"
    //=================鏄剧ず鐗堟湰=====================
    call YDWEVersion_Init()
endfunction

//library YDWEBase ends
//library YDWEPolledWaitNull:
function YDWEPolledWaitNull takes real duration returns nothing
    local timer t
    local real timeRemaining
    if ( duration > 0 ) then
        set t=CreateTimer()
        call TimerStart(t, duration, false, null)
        loop
            set timeRemaining=TimerGetRemaining(t)
            exitwhen timeRemaining <= 0
            // If we have a bit of time left, skip past 10% of the remaining
            // duration instead of checking every interval, to minimize the
            // polling on long waits.
            if ( timeRemaining > bj_POLLED_WAIT_SKIP_THRESHOLD ) then
                call TriggerSleepAction(0.1 * timeRemaining)
            else
                call TriggerSleepAction(bj_POLLED_WAIT_INTERVAL)
            endif
        endloop
        call DestroyTimer(t)
    endif
    set t=null
endfunction

//library YDWEPolledWaitNull ends
//library YDWETriggerEvent:
	
//===========================================================================  
//任意单位伤害事件 
//===========================================================================
function YDWEAnyUnitDamagedTriggerAction takes nothing returns nothing
    local integer i= 0
    
    loop
        exitwhen i >= YDWETriggerEvent__DamageEventNumber
        if YDWETriggerEvent__DamageEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent__DamageEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent__DamageEventQueue[i]) then
            call TriggerExecute(YDWETriggerEvent__DamageEventQueue[i])
        endif
        set i=i + 1
    endloop
endfunction
function YDWEAnyUnitDamagedFilter takes nothing returns boolean
    if GetUnitAbilityLevel(GetFilterUnit(), 'Aloc') <= 0 then
        call TriggerRegisterUnitEvent(yd_DamageEventTrigger, GetFilterUnit(), EVENT_UNIT_DAMAGED)
    endif
    return false
endfunction
function YDWEAnyUnitDamagedEnumUnit takes nothing returns nothing
    local trigger t= CreateTrigger()
    local region r= CreateRegion()
    local group g= CreateGroup()
    call RegionAddRect(r, GetWorldBounds())
    call TriggerRegisterEnterRegion(t, r, Condition(function YDWEAnyUnitDamagedFilter))
    call GroupEnumUnitsInRect(g, GetWorldBounds(), Condition(function YDWEAnyUnitDamagedFilter))
    call DestroyGroup(g)
    set r=null
    set t=null
    set g=null
endfunction
	
function YDWESyStemAnyUnitDamagedRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent__DamageEventNumber == 0 then
        set yd_DamageEventTrigger=CreateTrigger()
        call TriggerAddAction(yd_DamageEventTrigger, function YDWEAnyUnitDamagedTriggerAction)
        call YDWEAnyUnitDamagedEnumUnit()
    endif
    
    set YDWETriggerEvent__DamageEventQueue[YDWETriggerEvent__DamageEventNumber]=trg
    set YDWETriggerEvent__DamageEventNumber=YDWETriggerEvent__DamageEventNumber + 1
endfunction
//===========================================================================  
//移动物品事件 
//===========================================================================  
function YDWESyStemItemUnmovableTriggerAction takes nothing returns nothing
    local integer i= 0
    
    if GetIssuedOrderId() >= 852002 and GetIssuedOrderId() <= 852007 then
		set bj_lastMovedItemInItemSlot=GetOrderTargetItem()
    	loop
        	exitwhen i >= YDWETriggerEvent__MoveItemEventNumber
        	if YDWETriggerEvent__MoveItemEventQueue[i] != null and IsTriggerEnabled(YDWETriggerEvent__MoveItemEventQueue[i]) and TriggerEvaluate(YDWETriggerEvent__MoveItemEventQueue[i]) then
        	    call TriggerExecute(YDWETriggerEvent__MoveItemEventQueue[i])
        	endif
        	set i=i + 1
    	endloop
	endif
endfunction
function YDWESyStemItemUnmovableRegistTrigger takes trigger trg returns nothing
    if trg == null then
        return
    endif
        
    if YDWETriggerEvent__MoveItemEventNumber == 0 then
        set YDWETriggerEvent__MoveItemEventTrigger=CreateTrigger()
        call TriggerAddAction(YDWETriggerEvent__MoveItemEventTrigger, function YDWESyStemItemUnmovableTriggerAction)
        call TriggerRegisterAnyUnitEventBJ(YDWETriggerEvent__MoveItemEventTrigger, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    endif
    
    set YDWETriggerEvent__MoveItemEventQueue[YDWETriggerEvent__MoveItemEventNumber]=trg
    set YDWETriggerEvent__MoveItemEventNumber=YDWETriggerEvent__MoveItemEventNumber + 1
endfunction
function GetLastMovedItemInItemSlot takes nothing returns item
    return bj_lastMovedItemInItemSlot
endfunction

//library YDWETriggerEvent ends
//library YDWETriggerRegisterEnterRectSimpleNull:
function YDWETriggerRegisterEnterRectSimpleNull takes trigger trig,rect r returns event
    local region rectRegion= CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion=rectRegion
    set rectRegion=null
    return TriggerRegisterEnterRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterEnterRectSimpleNull ends
//library YDWETriggerRegisterLeaveRectSimpleNull:
function YDWETriggerRegisterLeaveRectSimpleNull takes trigger trig,rect r returns event
    local region rectRegion= CreateRegion()
    call RegionAddRect(rectRegion, r)
    set yd_NullTempRegion=rectRegion
    set rectRegion=null
    return TriggerRegisterLeaveRegion(trig, yd_NullTempRegion, null)
endfunction

//library YDWETriggerRegisterLeaveRectSimpleNull ends
//library AIStrategy:
function InitAIStrategy takes nothing returns nothing
set gDefaultAIGroup=sc__DefaultAIGroup_create()
call s__Boss1AIStrategy__allocate()
endfunction
//Implemented from module List:
    
    
    
        function s__DefaultAIStrategy_getLength takes nothing returns integer
            return s__DefaultAIStrategy_List___length
        endfunction
    
        function s__DefaultAIStrategy_getFirst takes nothing returns integer
            return s__DefaultAIStrategy_List___first
        endfunction
    
        function s__DefaultAIStrategy_getLast takes nothing returns integer
            return s__DefaultAIStrategy_List___last
        endfunction
    
        function s__DefaultAIStrategy_getRandom takes nothing returns integer
            local integer s= s__DefaultAIStrategy_List___first
            local integer array list
            local integer n= - 1
            loop
                exitwhen s == 0
                set n=n + 1
                set list[n]=s
                set s=s__DefaultAIStrategy_List___next[s]
            endloop
            if n == - 1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endfunction
    
        function s__DefaultAIStrategy_getNext takes integer this returns integer
            return s__DefaultAIStrategy_List___next[this]
        endfunction
    
        function s__DefaultAIStrategy_getPrev takes integer this returns integer
            return s__DefaultAIStrategy_List___prev[this]
        endfunction
    
        function s__DefaultAIStrategy_inList takes integer this returns boolean
            return s__DefaultAIStrategy_List___inlist[this]
        endfunction
        function s__DefaultAIStrategy_addList takes integer this returns boolean
            if not s__DefaultAIStrategy_List___inlist[this] and not s__DefaultAIStrategy_List___destroyinglist then
                set s__DefaultAIStrategy_List___inlist[this]=true
                if s__DefaultAIStrategy_List___first == 0 then
                    set s__DefaultAIStrategy_List___first=this
                else
                    set s__DefaultAIStrategy_List___prev[this]=s__DefaultAIStrategy_List___last
                    set s__DefaultAIStrategy_List___next[s__DefaultAIStrategy_List___prev[this]]=this
                endif
                set s__DefaultAIStrategy_List___last=this
                set s__DefaultAIStrategy_List___length=s__DefaultAIStrategy_List___length + 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultAIStrategy_removeList takes integer this returns boolean
            if s__DefaultAIStrategy_List___inlist[this] then
                if s__DefaultAIStrategy_List___destroyinglist then
                    return true
                endif
                set s__DefaultAIStrategy_List___inlist[this]=false
                if s__DefaultAIStrategy_List___first == this then
                    set s__DefaultAIStrategy_List___first=s__DefaultAIStrategy_List___next[this]
                endif
                if s__DefaultAIStrategy_List___last == this then
                    set s__DefaultAIStrategy_List___last=s__DefaultAIStrategy_List___prev[this]
                endif
                set s__DefaultAIStrategy_List___next[s__DefaultAIStrategy_List___prev[this]]=s__DefaultAIStrategy_List___next[this]
                set s__DefaultAIStrategy_List___prev[s__DefaultAIStrategy_List___next[this]]=s__DefaultAIStrategy_List___prev[this]
                set s__DefaultAIStrategy_List___length=s__DefaultAIStrategy_List___length - 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultAIStrategy_destroyList takes nothing returns nothing
            local integer s= s__DefaultAIStrategy_List___first
            if not s__DefaultAIStrategy_List___destroyinglist then
                loop
                    exitwhen s == 0
                    set s__DefaultAIStrategy_List___destroyinglist=false
                    call s__DefaultAIStrategy_removeList(s)
                    set s__DefaultAIStrategy_List___destroyinglist=true
                    call sc__IAIStrategy_deallocate(s)
                    set s=s__DefaultAIStrategy_List___next[s]
                endloop
                set s__DefaultAIStrategy_List___destroyinglist=false
            endif
        endfunction
    
function s__DefaultAIStrategy_create takes nothing returns integer
local integer s=s__DefaultAIStrategy__allocate()
call s__DefaultAIStrategy_addList(s)
return s
endfunction
function s__DefaultAIStrategy_onDestroy takes integer this returns nothing
call s__DefaultAIStrategy_removeList(this)
endfunction
function s__DefaultAIStrategy_support takes integer this,integer typeid returns boolean
return false
endfunction
function s__DefaultAIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
endfunction
function s__DefaultAIStrategy_targetOutRange takes integer this,unit u returns nothing
endfunction
function s__DefaultAIStrategy_beHurted takes integer this,unit u returns nothing
local unit tu=s__AIData_targetUnit[sc__AIData__staticgetindex(u)]
local real d=DistanceTwoUnits(u , tu)
if d > 800 then
call IssuePointOrderById(u, 851983, GetUnitX(tu), GetUnitY(tu))
endif
endfunction
function s__DefaultAIStrategy_getInMap takes integer this,unit u returns nothing
call BJDebugMsg("get in map")
call sc__DefaultAIGroup_addUnit(gDefaultAIGroup,u)
endfunction
function s__DefaultAIStrategy_findStrategy takes integer typeid returns integer
local integer p=s__DefaultAIStrategy_getFirst()
loop
    exitwhen p == 0
    if sc__IAIStrategy_support(p,typeid) then
        return p
    endif
    set p=s__DefaultAIStrategy_getNext(p)
endloop
return gDefaultAIGroup
endfunction
function s__Boss1AIStrategy_targetInRange takes integer this,unit u,unit tu,real r returns nothing
    if GetUnitTypeId(u) != 'u004' and r < 800 then
        call changeMelee()
        if Tick - s__AIData_last_change[sc__AIData__staticgetindex(u)] > 200 then
            set s__AIData_last_change[sc__AIData__staticgetindex(u)]=Tick
            set s__AIData_targetUnit[sc__AIData__staticgetindex(u)]=tu
        endif
    endif
endfunction
function s__Boss1AIStrategy_targetOutRange takes integer this,unit u returns nothing
    if GetUnitTypeId(u) != 'u002' then
        call changeRange()
    endif
endfunction
function s__Boss1AIStrategy_support takes integer this,integer typeid returns boolean
    if typeid == 'u002' or typeid == 'u004' then
        return true
    endif
    return false
endfunction

//library AIStrategy ends
//library AutoIndex:

//library AutoIndex ends
//library Constants:
function GetGrenadeVector takes real ux,real uy,real tx,real ty returns integer
    local integer v= s__vector_create(tx - ux , ty - uy , 0)
    set s__vector_z[v]=s__vector_getLength(v) * 2
    return v
endfunction
function GetGrenadeTrajectory takes real ux,real uy,real tx,real ty returns real
    local real d= SquareRoot(Pow(ty - uy, 2) + Pow(tx - ux, 2))
    local real v= SquareRoot(d * g / Sin(2 * GRENADEDEG)) / 2.25
    return v
endfunction
function InitConstants takes nothing returns nothing
endfunction

//library Constants ends
//library Damage:
    //============================================================
    ////! external ObjectMerger w3a AIlz dprv anam "Life Bonus" ansf "(Damage System)" Ilif 1 500000 aite 0
    
    //============================================================
    
    function Damage_RegisterEvent takes trigger whichTrigger returns nothing
        call s__Event_register(Damage__OnDamageEvent,whichTrigger)
    endfunction
    
    function Damage_EnableEvent takes boolean enable returns nothing
        set Damage__EventEnabled=enable
    endfunction
    
    //============================================================
    
    function Damage_GetType takes nothing returns damagetype
        return Damage__TypeStackValue[Damage__TypeStackLevel]
    endfunction
    
    function Damage_Block takes real amount returns nothing
        set Damage__ToBlock[Damage__TypeStackLevel]=Damage__ToBlock[Damage__TypeStackLevel] + amount
    endfunction
    
    function Damage_BlockAll takes nothing returns nothing
        set Damage__ToBlock[Damage__TypeStackLevel]=Damage__ToBlock[Damage__TypeStackLevel] + GetEventDamage()
    endfunction
    
    //============================================================
    
    //============================================================
    
    function Damage__RemoveBoostedTimerFunc takes nothing returns nothing
        loop
            exitwhen Damage__RemoveBoostedMax == 0
            set Damage__BoostedLifeUnit=Damage__RemoveBoosted[Damage__RemoveBoostedMax]
            set Damage__BoostedLifeTemp=GetWidgetLife(Damage__BoostedLifeUnit)
            call UnitRemoveAbility(Damage__BoostedLifeUnit, Damage__LIFE_BONUS_ABIL)
            if Damage__BoostedLifeTemp > 0.405 then
                call SetWidgetLife(Damage__BoostedLifeUnit, Damage__BoostedLifeTemp)
            endif
            set Damage__RemoveBoostedMax=Damage__RemoveBoostedMax - 1
        endloop
    endfunction
    
    //============================================================
    function Damage__OnDamageActions takes nothing returns boolean
        if Damage__EventEnabled then
            call s__Event_fire(Damage__OnDamageEvent)
        endif
        if Damage__ToBlock[Damage__TypeStackLevel] != 0. then
            //====================================================
            // Blocking
            set Damage__ForUnit=GetTriggerUnit()
            
            set Damage__NextHealth=GetEventDamage()
            if Damage__ToBlock[Damage__TypeStackLevel] >= Damage__NextHealth then
                set Damage__NextHealth=GetWidgetLife(Damage__ForUnit) + Damage__NextHealth
            else
                set Damage__NextHealth=GetWidgetLife(Damage__ForUnit) + Damage__ToBlock[Damage__TypeStackLevel]
            endif
            
            call SetWidgetLife(Damage__ForUnit, Damage__NextHealth)
            if GetWidgetLife(Damage__ForUnit) < Damage__NextHealth then
                // NextHealth is over max health.
                call UnitAddAbility(Damage__ForUnit, Damage__LIFE_BONUS_ABIL)
                call SetWidgetLife(Damage__ForUnit, Damage__NextHealth)
                
                set Damage__RemoveBoostedMax=Damage__RemoveBoostedMax + 1
                set Damage__RemoveBoosted[Damage__RemoveBoostedMax]=Damage__ForUnit
                call ResumeTimer(Damage__RemoveBoostedTimer)
            endif
            //====================================================
            set Damage__ToBlock[Damage__TypeStackLevel]=0.
        endif
        return false
    endfunction
    
    //============================================================
    function UnitDamageTargetEx takes unit whichUnit,widget target,real amount,boolean attack,boolean ranged,attacktype attackType,damagetype damageType,weapontype weaponType returns boolean
        local boolean result
        set Damage__TypeStackLevel=Damage__TypeStackLevel + 1
        set Damage__TypeStackValue[Damage__TypeStackLevel]=damageType
        set result=UnitDamageTarget(whichUnit, target, amount, attack, ranged, attackType, damageType, weaponType)
        set Damage__TypeStackLevel=Damage__TypeStackLevel - 1
        return result
    endfunction
    
//textmacro instance: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
        function Damage_Pure takes unit source,unit target,real amount returns boolean
            return UnitDamageTargetEx(source , target , amount , false , false , ATTACK_TYPE_NORMAL , DAMAGE_TYPE_UNIVERSAL , WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Pure","DAMAGE_TYPE_UNIVERSAL")
//textmacro instance: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
        function Damage_Spell takes unit source,unit target,real amount returns boolean
            return UnitDamageTargetEx(source , target , amount , false , false , ATTACK_TYPE_NORMAL , DAMAGE_TYPE_MAGIC , WEAPON_TYPE_WHOKNOWS)
        endfunction
//end of: Damage__DealTypeFunc("Spell","DAMAGE_TYPE_MAGIC")
    
    // Uses different stuff, but works much the same way.
    function Damage_Physical takes unit source,unit target,real amount,attacktype whichType,boolean attack,boolean ranged returns boolean
        return UnitDamageTargetEx(source , target , amount , attack , ranged , whichType , DAMAGE_TYPE_NORMAL , WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    //============================================================
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__Damage__Detector__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__Damage__Detector__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage__Detector_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__Damage__Detector_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage__Detector_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__Damage__Detector_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Damage__Detector_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Damage__Detector_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__Damage__Detector_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Damage__Detector_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Damage__Detector_AIDS_onDeallocate takes nothing returns boolean
            if s__Damage__Detector_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__Damage__Detector_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__Damage__Detector_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Damage__Detector_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__Damage__Detector_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__Damage__Detector_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__Damage__Detector_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call sc__Damage__Detector_AIDS_onInit()
        endfunction
//end of: AIDS()

        
        
        function s__Damage__Detector_AIDS_onCreate takes integer this returns nothing
            set s__Damage__Detector_t[this]=CreateTrigger()
            call TriggerAddCondition(s__Damage__Detector_t[this], s__Damage__Detector_ACTIONS_COND)
            call TriggerRegisterUnitEvent(s__Damage__Detector_t[this], s__Damage__Detector__get_unit(this), EVENT_UNIT_DAMAGED)
        endfunction
        
        function s__Damage__Detector_AIDS_onDestroy takes integer this returns nothing
            call DestroyTrigger(s__Damage__Detector_t[this])
        endfunction
        
        function s__Damage__Detector_AIDS_onInit takes nothing returns nothing
            set s__Damage__Detector_ACTIONS_COND=Condition(function Damage__OnDamageActions)
        endfunction
    
    //============================================================
    function Damage__OnInit takes nothing returns nothing
        local unit abilpreload=CreateUnit(Player(15), 'uloc', 0, 0, 0)
        call UnitAddAbility(abilpreload, Damage__LIFE_BONUS_ABIL)
        call RemoveUnit(abilpreload)
        set abilpreload=null
        
        set Damage__OnDamageEvent=s__Event_create()
        set Damage__TypeStackValue[Damage__TypeStackLevel]=DAMAGE_TYPE_NORMAL
        call TimerStart(Damage__RemoveBoostedTimer, 0.0, false, function Damage__RemoveBoostedTimerFunc)
    endfunction

//library Damage ends
//library Direction:
function getDir takes real sx,real sy,real tx,real ty returns real
    return Atan2(ty - sy, tx - sx)
endfunction
function getDeg takes real y,real x returns real
    return Rad2Deg(Atan2(y, x))
endfunction
function getFacing takes unit u returns real
    return Deg2Rad(GetUnitFacing(u))
endfunction
function getTargetDir takes unit source,unit target returns real
    local real sx= GetUnitX(source)
    local real sy= GetUnitY(source)
    local real tx= GetUnitX(target)
    local real ty= GetUnitY(target)
    return getDir(sx , sy , tx , ty)
endfunction
function getDirVector takes unit owner,unit target,real speed returns integer
    local real tx= GetUnitX(target)
    local real ty= GetUnitY(target)
    local real tz= getUnitHeight(target)
    local real ux= GetUnitX(owner)
    local real uy= GetUnitY(owner)
    local real uz= getUnitHeight(owner)
    local integer t= s__vector_create(tx - ux , ty - uy , tz - uz)
    call s__vector_setLength(t,speed)
    return t
endfunction

//library Direction ends
//library DispatchTechLevel:
function DispatchTechAdd takes integer id,integer lv,integer pid returns nothing
    if id == tKMANA then
        set s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.5
    endif
    if id == tAIM_SHOOT then
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.3
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.3
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] - 0.1
    endif
    if id == tSAVE then
        set s__IHeroData_save[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_save[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.4
    endif
    if id == tSTRONG then
        set s__IHeroData_strong[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_strong[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.2
    endif
    if id == tANTRAD then
        set s__IHeroData_antrad[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_antrad[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.3
    endif
    if id == tDOGE then
        set s__IHeroData_doge[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_doge[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.2
    endif
    if id == tFREZZ then
        set s__IHeroData_frezz[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_frezz[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.05
    endif
    if id == tMANA_BOOM then
        set s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.3
    endif
endfunction
function DispatchTechLevelUp takes integer id,integer lv,integer pid returns nothing
    if id == tKMANA then
        set s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.05
    endif
    if id == tAIM_SHOOT then
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.025
    endif
    if id == tSPEED_SHOOT then
        call IncShootSpeed(pid)
        //set EquipmentData[heros[pid]].heroData.shoot_speed_buff = EquipmentData[heros[pid]].heroData.shoot_speed_buff + 0.1
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_shoot_rist[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] - 0.05
    endif
    if id == tSAVE then
        set s__IHeroData_save[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_save[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.05
    endif
    if id == tSTRONG then
        set s__IHeroData_strong[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_strong[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.02
    endif
    if id == tANTRAD then
        set s__IHeroData_antrad[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_antrad[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.05
    endif
    if id == tDOGE then
        set s__IHeroData_doge[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_doge[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.01
    endif
    if id == tFREZZ then
        set s__IHeroData_frezz[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_frezz[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.01
    endif
    if id == tMANA_BOOM then
        set s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]]=s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[sc__EquipmentData__staticgetindex(heros[pid])]] + 0.15
    endif
endfunction

//library DispatchTechLevel ends
//library DoublePacket:
function InitDoublePacket takes nothing returns nothing
    set kpacau=GetNewKey()
endfunction
//涓や釜鍗曚綅浜ゆ崲鐗╁搧
function ItemSwitch takes unit Ua,unit Ub returns nothing
      local item array Ia
      local item array Ib
      local item array Ic
      local integer i= 0
      local integer n= 0
      loop
            exitwhen i > 5
            if UnitItemInSlot(Ua, i) != null then
                  set Ia[i]=UnitItemInSlot(Ua, i)
                  call UnitRemoveItemFromSlot(Ua, i)
            endif
            if UnitItemInSlot(Ub, i) != null then
                  set Ib[i]=UnitItemInSlot(Ub, i)
                  call UnitRemoveItemFromSlot(Ub, i)
            endif
            set i=i + 1
      endloop
      set i=0
      loop
            exitwhen i > 5
            if Ia[i] == null then
               call UnitAddItem(Ub, CreateItem('mort', GetUnitX(Ub), GetUnitY(Ub)))
               set Ic[n]=UnitItemInSlot(Ub, i)
               set n=n + 1
               else
               call UnitAddItem(Ub, Ia[i])
            endif
            set i=i + 1
      endloop
      set i=0
      loop
            set i=i + 1
            exitwhen i > n
            call RemoveItem(Ic[i])
            set Ic[i]=null
      endloop
//缁橝鐨勭墿鍝?     
      set i=0
      loop
            exitwhen i > 5
            if Ib[i] == null then
               call UnitAddItem(Ua, CreateItem('mort', GetUnitX(Ua), GetUnitY(Ua)))
               set Ic[n]=UnitItemInSlot(Ua, i)
               set n=n + 1
               else
               call UnitAddItem(Ua, Ib[i])
            endif
            set i=i + 1
      endloop
      set i=0
      loop
            exitwhen i > n
            call RemoveItem(Ic[i])
            set Ic[i]=null
            set i=i + 1
      endloop
      set i=0
      loop
            exitwhen i > 5
            set Ia[i]=null
            set Ib[i]=null
            set i=i + 1
      endloop
endfunction
//瑕嗙洊A鐨勭墿鍝佺粰B
function ItemCopy takes unit ua,unit ub returns nothing
    local integer i
    set i=0
    loop
        exitwhen i > 5
        call RemoveItem(UnitItemInSlot(ub, i))
        set i=i + 1
    endloop
    set i=0
    loop
        exitwhen i > 5
        call UnitAddItem(ub, CreateItem(GetItemTypeId(UnitItemInSlot(ua, i)), 0, 0))
        set i=i + 1
    endloop
endfunction
//鍒囨崲鑳屽寘
function SwapPackageCA takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer dec=GetHandleId(u)
    if GetSpellAbilityId() == gpacspl then
        call ItemSwitch(u , LoadUnitHandle(ht, dec, kpacau))
    endif
    set u=null
endfunction
//涓鸿嫳闆勭殑褰撳墠鐗╁搧鏍忔敞鍐屽弻6鑳屽寘
function RegisterDouble6Package takes unit u returns nothing
    local integer dec=GetHandleId(u)
    local integer i
    local trigger trg
    local unit tu
    if LoadUnitHandle(ht, dec, kpacau) == null then
        set tu=CreateUnit(GetOwningPlayer(u), gpacauid, 0, 0, 0)
        call SaveUnitHandle(ht, dec, kpacau, tu)
        set trg=CreateTrigger()
        call TriggerRegisterUnitEvent(trg, u, EVENT_UNIT_SPELL_EFFECT)
        call TriggerAddCondition(trg, Condition(function SwapPackageCA))
    endif
    set trg=null
    set tu=null
endfunction

//library DoublePacket ends
//library EquipmentData:
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__EquipmentData__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__EquipmentData__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__EquipmentData_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__EquipmentData_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__EquipmentData_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if sc__EquipmentData_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__EquipmentData_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__EquipmentData_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__EquipmentData_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if sc__EquipmentData_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__EquipmentData_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__EquipmentData_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__EquipmentData_AIDS_onDeallocate takes nothing returns boolean
            if s__EquipmentData_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__EquipmentData_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__EquipmentData_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__EquipmentData_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__EquipmentData_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__EquipmentData_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__EquipmentData_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call s__AIDS_DEFAULT_AIDS_onInit()
        endfunction
//end of: AIDS()
    
//Implemented from module T32xs:
        
        function s__EquipmentData_T32xs___PeriodicLoop takes nothing returns boolean
            local integer this=s__EquipmentData_T32xs___next[(0)]
            loop
                exitwhen this == 0
                call sc__EquipmentData_periodic(this)
                set this=s__EquipmentData_T32xs___next[this]
            endloop
            return false
        endfunction
        function s__EquipmentData_startPeriodic takes integer this returns nothing
            if not s__EquipmentData_T32xs___runningPeriodic[this] then
                set s__EquipmentData_T32xs___prev[s__EquipmentData_T32xs___next[(0)]]=this
                set s__EquipmentData_T32xs___next[this]=s__EquipmentData_T32xs___next[(0)]
                set s__EquipmentData_T32xs___next[(0)]=this
                set s__EquipmentData_T32xs___prev[this]=(0)
                
                set s__EquipmentData_T32xs___runningPeriodic[this]=true
            endif
        endfunction
        
        function s__EquipmentData_stopPeriodic takes integer this returns nothing
            if s__EquipmentData_T32xs___runningPeriodic[this] then
                // This is some real magic.
                set s__EquipmentData_T32xs___next[s__EquipmentData_T32xs___prev[this]]=s__EquipmentData_T32xs___next[this]
                set s__EquipmentData_T32xs___prev[s__EquipmentData_T32xs___next[this]]=s__EquipmentData_T32xs___prev[this]
                // This will even work for the starting element.
                
                set s__EquipmentData_T32xs___runningPeriodic[this]=false
            endif
        endfunction
        
        function s__EquipmentData_T32xs___onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig, Condition(function s__EquipmentData_T32xs___PeriodicLoop))
        endfunction
    
    
    
    function s__EquipmentData_AIDS_filter takes unit u returns boolean
        if IsHero(u) or GetUnitTypeId(u) == EVIL_MARIN then
            return true
        endif
        return false
    endfunction
    
    function s__EquipmentData_AIDS_onCreate takes integer this returns nothing
        //set this.gun = IceMachineGun.create(.unit)
        set s__EquipmentData_heroData[this]=s__IHeroData__allocate()
        set s__IHeroData_bullets[s__EquipmentData_heroData[this]]=sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]])
        set s__IHeroData_shoot_energy_max[s__EquipmentData_heroData[this]]=100
        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]=100
        set s__IHeroData_shoot_energy_reg[s__EquipmentData_heroData[this]]=1
        set s__IHeroData_shoot_range_buff[s__EquipmentData_heroData[this]]=0
        //set this.heroData.shoot_speed_buff = 0.0
        //set this.heroData.last_shoot_tick = -999
        set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_a_shoot_back[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_up_point[s__EquipmentData_heroData[this]]=10
        set s__IHeroData_bonus_point[s__EquipmentData_heroData[this]]=0
        set s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]=s__TechCounter__allocate()
        set s___TechCounter_cnt[s__TechCounter_cnt[s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]]+TT_GENERAL]=1
        set s__TechCounter_size[s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]]=1
        set s__IHeroData_save[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_strong[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_antrad[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_doge[s__EquipmentData_heroData[this]]=0
        set s__IHeroData_frezz[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_fire_charge[s__EquipmentData_heroData[this]]=1.0
        set s__IHeroData_machine_gun_buff[s__EquipmentData_heroData[this]]=1.0
        set s__IHeroData_vision[s__EquipmentData_heroData[this]]=2300
        call s__EquipmentData_startPeriodic(this)
        call s__EquipmentData_AIDS_addLock(this)
    endfunction
        
    function s__EquipmentData_AIDS_onDestroy takes integer this returns nothing
        
    endfunction
    
    function s__EquipmentData_periodic takes integer this returns nothing
        local boolean reload= s__IHeroData_reload[s__EquipmentData_heroData[this]]
        local real c= s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]
        local real max= s__IHeroData_shoot_energy_max[s__EquipmentData_heroData[this]]
        local real n= RMinBJ(max, c + s__IHeroData_shoot_energy_reg[s__EquipmentData_heroData[this]])
        if reload and c < max then
            set s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]=n
            if n == max then
                if IsHero(s__EquipmentData__get_unit(this)) then
                    set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
                    call UnitRemoveAbility(s__EquipmentData__get_unit(this), 'Abun')
                    call SetPlayerState(GetOwningPlayer(s__EquipmentData__get_unit(this)), PLAYER_STATE_RESOURCE_LUMBER, sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]]))
                    call DisplayFloatText(GetUnitX(s__EquipmentData__get_unit(this)) , GetUnitY(s__EquipmentData__get_unit(this)) , "R" , 1)
                else
                    set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
                    call UnitRemoveAbility(s__EquipmentData__get_unit(this), 'Abun')
                    set s__IHeroData_bullets[s__EquipmentData_heroData[this]]=sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]])
                    call DisplayFloatText(GetUnitX(s__EquipmentData__get_unit(this)) , GetUnitY(s__EquipmentData__get_unit(this)) , "R" , 1)
                endif
            endif
        endif
    endfunction 
    

//library EquipmentData ends
//library GroupUtils:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This library is a simple implementation of a stack for groups that need to
//* be in the user's control for greater than an instant of time. Additionally,
//* this library provides a single, global group variable for use with user-end
//* enumerations. It is important to note that users should not be calling
//* DestroyGroup() on the global group, since then it may not exist for when it
//* it is next needed.
//*
//* The group stack removes the need for destroying groups and replaces it with
//* a recycling method.
//*     function NewGroup takes nothing returns group
//*     function ReleaseGroup takes group g returns boolean
//*     function GroupRefresh takes group g returns nothing
//* 
//* NewGroup grabs a currently unused group from the stack or creates one if the
//* stack is empty. You can use this group however you'd like, but always
//* remember to call ReleaseGroup on it when you are done with it. If you don't
//* release it, it will 'leak' and your stack may eventually overflow if you
//* keep doing that.
//* 
//* GroupRefresh cleans a group of any shadow references which may be clogging
//* its hash table. If you remove a unit from the game who is a member of a unit
//* group, it will 'effectively' remove the unit from the group, but leave a
//* shadow in its place. Calling GroupRefresh on a group will clean up any
//* shadow references that may exist within it.
//******************************************************************************
    function GroupUtils__AddEx takes nothing returns nothing
        if GroupUtils__Flag then
            call GroupClear(GroupUtils__Refr)
            set GroupUtils__Flag=false
        endif
        call GroupAddUnit(GroupUtils__Refr, GetEnumUnit())
    endfunction
    
    function GroupRefresh takes group g returns nothing
        set GroupUtils__Flag=true
        set GroupUtils__Refr=g
        call ForGroup(GroupUtils__Refr, function GroupUtils__AddEx)
        if GroupUtils__Flag then
            call GroupClear(g)
        endif
    endfunction
    function NewGroup takes nothing returns group
        if GroupUtils__Count == 0 then
            set GroupUtils__Groups[0]=CreateGroup()
        else
            set GroupUtils__Count=GroupUtils__Count - 1
        endif
        call sg__GroupUtils__Status_set(GetHandleId(GroupUtils__Groups[GroupUtils__Count]) - GroupUtils__MIN_HANDLE_ID,1)
        return GroupUtils__Groups[GroupUtils__Count]
    endfunction
    function ReleaseGroup takes group g returns boolean
        local integer stat= sg__GroupUtils__Status_get(GetHandleId(g) - GroupUtils__MIN_HANDLE_ID)
        if g == null then
            return false
        elseif stat == 0 then
            return false
        elseif stat == 2 then
            return false
        elseif GroupUtils__Count == 8191 then
            call DestroyGroup(g)
            return false
        else
            call GroupClear(g)
            set GroupUtils__Groups[GroupUtils__Count]=g
            set GroupUtils__Count=GroupUtils__Count + 1
            call sg__GroupUtils__Status_set(GetHandleId(g) - GroupUtils__MIN_HANDLE_ID,2)
        endif
        return true
    endfunction
    

//library GroupUtils ends
//library Gun:
    function s__DefaultGun_fire takes integer this returns nothing
        if s__IShooter_owner[s__IGun_shooter[this]] != null then
            call sc__IShooter_shoot(s__IGun_shooter[this],s__vector_create(0 , 0 , 0))
        endif
    endfunction
    
    function s__DefaultGun_setOwner takes integer this,unit owner returns nothing
        set s__IShooter_owner[s__IGun_shooter[this]]=owner
    endfunction
    
    function s__DefaultGun_stopFire takes integer this returns nothing
    endfunction
    
    function s__DefaultGun_getGunType takes integer this returns integer
        return SHOOT_GUN
    endfunction
    
    function s__DefaultGun_create takes unit owner,integer ifd returns integer
        local integer g=s__DefaultGun__allocate()
        set s__IGun_factory[g]=s__DefaultMissleFactory__allocate()
        set s__IGun_shooter[g]=s__ShootGunShooter__allocate(owner , s__IGun_factory[g])
        set s__IGun_ifd[g]=ifd
        return g
    endfunction
    
    function s__DefaultGun_onDestroy takes integer this returns nothing
        call sc__IShooter_deallocate(s__IGun_shooter[this])
        call sc__IMissleFactory_deallocate(s__IGun_factory[this])
    endfunction
//textmacro instance: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
    function s__FireShotgun_create takes unit owner,integer ifd returns integer
        local integer g=s__FireShotgun__allocate(owner , ifd)
        set s__IGun_factory[g]=s__FireMissleFactory__allocate()
        set s__IGun_shooter[g]=s__ShootGunShooter__allocate(owner , s__IGun_factory[g])
        return g
    endfunction
//end of: ExtendGun("FireShotgun","FireMissleFactory","ShootGunShooter")
//textmacro instance: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
    function s__HumanRifle_create takes unit owner,integer ifd returns integer
        local integer g=s__HumanRifle__allocate(owner , ifd)
        set s__IGun_factory[g]=s__DefaultMissleFactory__allocate()
        set s__IGun_shooter[g]=s__MachineGunShooter__allocate(owner , s__IGun_factory[g])
        return g
    endfunction
//end of: ExtendGun("HumanRifle","DefaultMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
    function s__SpearRifle_create takes unit owner,integer ifd returns integer
        local integer g=s__SpearRifle__allocate(owner , ifd)
        set s__IGun_factory[g]=s__SpearMissleFactory__allocate()
        set s__IGun_shooter[g]=s__MachineGunShooter__allocate(owner , s__IGun_factory[g])
        return g
    endfunction
//end of: ExtendGun("SpearRifle","SpearMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
    function s__IceMachineGun_create takes unit owner,integer ifd returns integer
        local integer g=s__IceMachineGun__allocate(owner , ifd)
        set s__IGun_factory[g]=s__IceMissleFactory__allocate()
        set s__IGun_shooter[g]=s__MachineGunShooter__allocate(owner , s__IGun_factory[g])
        return g
    endfunction
//end of: ExtendGun("IceMachineGun","IceMissleFactory","MachineGunShooter")
//textmacro instance: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")
    function s__FireMachineGun_create takes unit owner,integer ifd returns integer
        local integer g=s__FireMachineGun__allocate(owner , ifd)
        set s__IGun_factory[g]=s__FireMissleFactory__allocate()
        set s__IGun_shooter[g]=s__MachineGunShooter__allocate(owner , s__IGun_factory[g])
        return g
    endfunction
//end of: ExtendGun("FireMachineGun","FireMissleFactory","MachineGunShooter")

//library Gun ends
//library Heal:
    

    
        function s__HealType_new takes nothing returns integer
            set s__HealType_Counter=s__HealType_Counter + 1
            return s__HealType_Counter
        endfunction
    
    
    function Heal_RegisterEvent takes trigger trig returns integer
        return s__Event_register(Heal___HealEvent,trig)
    endfunction
    
    function Heal_UnregisterEvent takes trigger trig returns nothing
        call s__Event_unregister(Heal___HealEvent,trig)
    endfunction
    
    function Heal_EnableEvent takes boolean flag returns nothing
        set Heal___IsEventEnabled=flag
    endfunction
    
    function Heal_GetSource takes nothing returns unit
        return Heal___HealerStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetTarget takes nothing returns unit
        return Heal___TargetStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetAmount takes nothing returns real
        return Heal___HealAmountStack[Heal___StackLevel]
    endfunction
    
    function Heal_Block takes real amount returns nothing
        set Heal___HealBlockStack[Heal___StackLevel]=Heal___HealBlockStack[Heal___StackLevel] + amount
    endfunction
    
    function Heal_BlockAll takes nothing returns nothing
        set Heal___HealBlockStack[Heal___StackLevel]=Heal___HealBlockStack[Heal___StackLevel] + Heal___HealAmountStack[Heal___StackLevel]
    endfunction
    
    function Heal_GetType takes nothing returns integer
        return Heal___TypeStack[Heal___StackLevel]
    endfunction
    
    function HealUnit takes unit healer,unit target,real amount,integer htype returns boolean
        local real life
        local real maxlife
        if UnitAlive(healer) == true and UnitAlive(target) == true and amount > 0. then
            set life=GetWidgetLife(target)
            set maxlife=GetUnitState(target, UNIT_STATE_MAX_LIFE)
            call DestroyEffect(AddSpecialEffect(HEAL_EFFECT, GetUnitX(target), GetUnitY(target)))
            if life == maxlife then
                return false //If target has full hp, no healing is done.
            else
                if life + amount > maxlife then
                    set amount=maxlife - life //if current hp + amount > max hp, set amount to max hp - current hp.
endif
                call SetWidgetLife(target, life + amount)
            endif
            if Heal___IsEventEnabled == true then
                set Heal___StackLevel=Heal___StackLevel + 1
                set Heal___HealerStack[Heal___StackLevel]=healer
                set Heal___TargetStack[Heal___StackLevel]=target
                set Heal___HealAmountStack[Heal___StackLevel]=amount
                set Heal___TypeStack[Heal___StackLevel]=htype
                set Heal___HealBlockStack[Heal___StackLevel]=0.
                call s__Event_fire(Heal___HealEvent)
                if Heal___HealBlockStack[Heal___StackLevel] > amount then
                    set Heal___HealBlockStack[Heal___StackLevel]=amount
                endif
                call SetWidgetLife(target, GetWidgetLife(target) - Heal___HealBlockStack[Heal___StackLevel])
                set Heal___StackLevel=Heal___StackLevel - 1
            endif
            return true
        endif
        return false
    endfunction
    
    function Heal___Init takes nothing returns nothing
        set Heal___HealEvent=s__Event_create()
        
        set HEAL_TYPE_NORMAL=s__HealType_new()
    endfunction

//library Heal ends
//library ItemData:
    function s__ItemFeature_create takes string name,real origin,real step,integer lv,integer maxlv,integer gold,integer wood returns integer
        local integer m=s__ItemFeature__allocate()
        set s__ItemFeature_name[m]=name
        set s__ItemFeature_origin[m]=origin
        set s__ItemFeature_step[m]=step
        set s__ItemFeature_lv[m]=lv
        set s__ItemFeature_maxlv[m]=maxlv
        set s__ItemFeature_gold[m]=gold
        set s__ItemFeature_wood[m]=wood
        return m
    endfunction
    function s__ItemFeature_getValue takes integer this returns real
        return s__ItemFeature_origin[this] + s__ItemFeature_step[this] * s__ItemFeature_lv[this]
    endfunction
    
    function s__IndividualItemData_AII_onCreate takes integer this returns nothing
        local integer ii= GetItemTypeId(sc__IndividualItemData__get_item(this))
        set s__IndividualItemData_featureData[this]=sc__ItemFeatureData_construct(ii)
    endfunction
    
//Implemented from module AII:
        function s__IndividualItemData__get_item takes integer this returns item
            return s__AII___ItemStruct_it[(this)]
        endfunction
        function s__IndividualItemData_AII_addLock takes integer this returns nothing
            call s__AII___ItemStruct_manageLock((this),true)
        endfunction
        function s__IndividualItemData_AII_removeLock takes integer this returns nothing
            call s__AII___ItemStruct_manageLock((this),false)
        endfunction
        function s__IndividualItemData__staticgetindex takes item i returns integer
            return GetItemId(i)
        endfunction
        
        function s__IndividualItemData_AII___aiicreate takes nothing returns boolean
            local integer this=AII___EventStruct









                    call s__IndividualItemData_AII_onCreate(this)

                set s__IndividualItemData_flag[this]=true

            return false
        endfunction
        function s__IndividualItemData_AII___aiidestroy takes nothing returns boolean
            local integer this=AII___EventStruct
            if s__IndividualItemData_flag[this] then



                set s__IndividualItemData_flag[this]=false
            endif
            return false
        endfunction
        








        
        function s__IndividualItemData_AII___onInit takes nothing returns nothing
            call TriggerAddCondition(AII___alloItem, Condition(function s__IndividualItemData_AII___aiicreate))
            call TriggerAddCondition(AII___dealloItem, Condition(function s__IndividualItemData_AII___aiidestroy))



            if AII___IsInited == false then
                call s__AII___ItemStruct_refireAllocateCallback(Condition(function s__IndividualItemData_AII___aiicreate))
                call s__AII___ItemStruct_refireDeallocateCallback(Condition(function s__IndividualItemData_AII___aiidestroy))
            endif
        endfunction
    
    function s__ItemFeatureData_create takes integer f1,integer f2,integer f3,integer f4,integer f5,integer gun returns integer
        local integer m=s__ItemFeatureData__allocate()
        set s__ItemFeatureData_f1[m]=f1
        set s__ItemFeatureData_f2[m]=f2
        set s__ItemFeatureData_f3[m]=f3
        set s__ItemFeatureData_f4[m]=f4
        set s__ItemFeatureData_f5[m]=f5
        set s__ItemFeatureData_gun[m]=gun
        return m
    endfunction
    function s__ItemFeatureData_construct takes integer did returns integer
        local integer f1
        local integer f2
        local integer f3
        local integer f4
        local integer f5
        local integer id= did - 'I000'
        local integer gun= 0
        local integer ifd= 0
//textmacro instance: CreateItemFeature("1")
    set f1=s__ItemFeature_create(LoadStr(ifht1, id, ifht_name) , LoadReal(ifht1, id, ifht_origin) , LoadReal(ifht1, id, ifht_step) , LoadInteger(ifht1, id, ifht_lv) , LoadInteger(ifht1, id, ifht_max_lv) , LoadInteger(ifht1, id, ifht_gold) , LoadInteger(ifht1, id, ifht_wood))
//end of: CreateItemFeature("1")
//textmacro instance: CreateItemFeature("2")
    set f2=s__ItemFeature_create(LoadStr(ifht2, id, ifht_name) , LoadReal(ifht2, id, ifht_origin) , LoadReal(ifht2, id, ifht_step) , LoadInteger(ifht2, id, ifht_lv) , LoadInteger(ifht2, id, ifht_max_lv) , LoadInteger(ifht2, id, ifht_gold) , LoadInteger(ifht2, id, ifht_wood))
//end of: CreateItemFeature("2")
//textmacro instance: CreateItemFeature("3")
    set f3=s__ItemFeature_create(LoadStr(ifht3, id, ifht_name) , LoadReal(ifht3, id, ifht_origin) , LoadReal(ifht3, id, ifht_step) , LoadInteger(ifht3, id, ifht_lv) , LoadInteger(ifht3, id, ifht_max_lv) , LoadInteger(ifht3, id, ifht_gold) , LoadInteger(ifht3, id, ifht_wood))
//end of: CreateItemFeature("3")
//textmacro instance: CreateItemFeature("4")
    set f4=s__ItemFeature_create(LoadStr(ifht4, id, ifht_name) , LoadReal(ifht4, id, ifht_origin) , LoadReal(ifht4, id, ifht_step) , LoadInteger(ifht4, id, ifht_lv) , LoadInteger(ifht4, id, ifht_max_lv) , LoadInteger(ifht4, id, ifht_gold) , LoadInteger(ifht4, id, ifht_wood))
//end of: CreateItemFeature("4")
//textmacro instance: CreateItemFeature("5")
    set f5=s__ItemFeature_create(LoadStr(ifht5, id, ifht_name) , LoadReal(ifht5, id, ifht_origin) , LoadReal(ifht5, id, ifht_step) , LoadInteger(ifht5, id, ifht_lv) , LoadInteger(ifht5, id, ifht_max_lv) , LoadInteger(ifht5, id, ifht_gold) , LoadInteger(ifht5, id, ifht_wood))
//end of: CreateItemFeature("5")
        set ifd=s__ItemFeatureData_create(f1 , f2 , f3 , f4 , f5 , gun)
        if LoadInteger(idht, did - 'I000', idht_item_type) == GUN then
            if did == 'I001' then
                set gun=s__HumanRifle_create(null , ifd)
//textmacro instance: BindGun("'I00R'", "SpearRifle")
            elseif did == 'I00R' then
                set gun=s__SpearRifle_create(null , ifd)
//end of: BindGun("'I00R'", "SpearRifle")
//textmacro instance: BindGun("'I00S'", "FireShotgun")
            elseif did == 'I00S' then
                set gun=s__FireShotgun_create(null , ifd)
//end of: BindGun("'I00S'", "FireShotgun")
            endif
        endif
        set s__ItemFeatureData_gun[ifd]=gun
        return ifd
    endfunction
    
    function s__ItemTypeData_create takes string name,integer spell,integer s1,integer s2,integer s3,integer itemType returns integer
        local integer m=s__ItemTypeData__allocate()
        set s__ItemTypeData_name[m]=name
        set s__ItemTypeData_spell[m]=spell
        set s__ItemTypeData_s1[m]=s1
        set s__ItemTypeData_s2[m]=s2
        set s__ItemTypeData_s3[m]=s3
        set s__ItemTypeData_itemType[m]=itemType
        return m
    endfunction 
function InitItemData takes nothing returns nothing
    call FlushParentHashtable(idht)
    set idht=InitHashtable()
//textmacro instance: DefineIfht("1")
    call FlushParentHashtable(ifht1)
    set ifht1=InitHashtable()
//end of: DefineIfht("1")
//textmacro instance: DefineIfht("2")
    call FlushParentHashtable(ifht2)
    set ifht2=InitHashtable()
//end of: DefineIfht("2")
//textmacro instance: DefineIfht("3")
    call FlushParentHashtable(ifht3)
    set ifht3=InitHashtable()
//end of: DefineIfht("3")
//textmacro instance: DefineIfht("4")
    call FlushParentHashtable(ifht4)
    set ifht4=InitHashtable()
//end of: DefineIfht("4")
//textmacro instance: DefineIfht("5")
    call FlushParentHashtable(ifht5)
    set ifht5=InitHashtable()
//end of: DefineIfht("5")
//textmacro instance: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
    call SaveStr(idht, iJUMP - 'I000', idht_name, "寮瑰皠闉?)
    call SaveInteger(idht, iJUMP - 'I000', idht_spell, 'A00A')
    call SaveInteger(idht, iJUMP - 'I000', idht_s1, 'A00B')
    call SaveInteger(idht, iJUMP - 'I000', idht_s2, 0)
    call SaveInteger(idht, iJUMP - 'I000', idht_s3, 0)
    call SaveInteger(idht, iJUMP - 'I000', idht_item_type, SHOE)
//end of: InitWeaponTypeData("iJUMP", "寮瑰皠闉?, "'A00A'", "'A00B'","0","0","SHOE")
//textmacro instance: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€熷櫒", "'A00C'", "0","0","0","OTHER")
    call SaveStr(idht, iSPEED - 'I000', idht_name, "鍠峰皠鍔犻€熷櫒")
    call SaveInteger(idht, iSPEED - 'I000', idht_spell, 'A00C')
    call SaveInteger(idht, iSPEED - 'I000', idht_s1, 0)
    call SaveInteger(idht, iSPEED - 'I000', idht_s2, 0)
    call SaveInteger(idht, iSPEED - 'I000', idht_s3, 0)
    call SaveInteger(idht, iSPEED - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iSPEED", "鍠峰皠鍔犻€熷櫒", "'A00C'", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
    call SaveStr(idht, iRETURN - 'I000', idht_name, "鍥炴棆闀?)
    call SaveInteger(idht, iRETURN - 'I000', idht_spell, aRETURN)
    call SaveInteger(idht, iRETURN - 'I000', idht_s1, 0)
    call SaveInteger(idht, iRETURN - 'I000', idht_s2, 0)
    call SaveInteger(idht, iRETURN - 'I000', idht_s3, 0)
    call SaveInteger(idht, iRETURN - 'I000', idht_item_type, I_D)
//end of: InitWeaponTypeData("iRETURN", "鍥炴棆闀?, "aRETURN", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
    call SaveStr(idht, iREACT - 'I000', idht_name, "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆")
    call SaveInteger(idht, iREACT - 'I000', idht_spell, aREACT)
    call SaveInteger(idht, iREACT - 'I000', idht_s1, 0)
    call SaveInteger(idht, iREACT - 'I000', idht_s2, 0)
    call SaveInteger(idht, iREACT - 'I000', idht_s3, 0)
    call SaveInteger(idht, iREACT - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iREACT", "灏勫嚮鍙嶄綔鐢ㄥ姏澧炲己瑁呯疆", "aREACT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
    call SaveStr(idht, iELECTRIC - 'I000', idht_name, "鐢甸灜")
    call SaveInteger(idht, iELECTRIC - 'I000', idht_spell, aELECTRIC)
    call SaveInteger(idht, iELECTRIC - 'I000', idht_s1, 0)
    call SaveInteger(idht, iELECTRIC - 'I000', idht_s2, 0)
    call SaveInteger(idht, iELECTRIC - 'I000', idht_s3, 0)
    call SaveInteger(idht, iELECTRIC - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iELECTRIC", "鐢甸灜", "aELECTRIC", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
    call SaveStr(idht, iBLINK - 'I000', idht_name, "闂儊鍖曢")
    call SaveInteger(idht, iBLINK - 'I000', idht_spell, aBLINK)
    call SaveInteger(idht, iBLINK - 'I000', idht_s1, 0)
    call SaveInteger(idht, iBLINK - 'I000', idht_s2, 0)
    call SaveInteger(idht, iBLINK - 'I000', idht_s3, 0)
    call SaveInteger(idht, iBLINK - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iBLINK", "闂儊鍖曢", "aBLINK", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
    call SaveStr(idht, iTRANSPORT - 'I000', idht_name, "瓒呰窛浼犻€佸櫒")
    call SaveInteger(idht, iTRANSPORT - 'I000', idht_spell, aTRANSPORT)
    call SaveInteger(idht, iTRANSPORT - 'I000', idht_s1, 0)
    call SaveInteger(idht, iTRANSPORT - 'I000', idht_s2, 0)
    call SaveInteger(idht, iTRANSPORT - 'I000', idht_s3, 0)
    call SaveInteger(idht, iTRANSPORT - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iTRANSPORT", "瓒呰窛浼犻€佸櫒", "aTRANSPORT", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
    call SaveStr(idht, iAUTOAIM - 'I000', idht_name, "杈呭姪灏勫嚮瑁呯疆")
    call SaveInteger(idht, iAUTOAIM - 'I000', idht_spell, aAUTOAIM)
    call SaveInteger(idht, iAUTOAIM - 'I000', idht_s1, 0)
    call SaveInteger(idht, iAUTOAIM - 'I000', idht_s2, 0)
    call SaveInteger(idht, iAUTOAIM - 'I000', idht_s3, 0)
    call SaveInteger(idht, iAUTOAIM - 'I000', idht_item_type, OTHER)
//end of: InitWeaponTypeData("iAUTOAIM", "杈呭姪灏勫嚮瑁呯疆", "aAUTOAIM", "0","0","0","OTHER")
//textmacro instance: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
    call SaveStr(idht, iLEAVE - 'I000', idht_name, "绂诲績闀?)
    call SaveInteger(idht, iLEAVE - 'I000', idht_spell, aLEAVE)
    call SaveInteger(idht, iLEAVE - 'I000', idht_s1, 0)
    call SaveInteger(idht, iLEAVE - 'I000', idht_s2, 0)
    call SaveInteger(idht, iLEAVE - 'I000', idht_s3, 0)
    call SaveInteger(idht, iLEAVE - 'I000', idht_item_type, I_D)
//end of: InitWeaponTypeData("iLEAVE", "绂诲績闀?, "aLEAVE", "0","0","0","I_D")
//textmacro instance: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
    call SaveStr(idht, iBKGRENADE - 'I000', idht_name, "闇囪崱鎵嬮浄")
    call SaveInteger(idht, iBKGRENADE - 'I000', idht_spell, aBKGRENADE)
    call SaveInteger(idht, iBKGRENADE - 'I000', idht_s1, 0)
    call SaveInteger(idht, iBKGRENADE - 'I000', idht_s2, 0)
    call SaveInteger(idht, iBKGRENADE - 'I000', idht_s3, 0)
    call SaveInteger(idht, iBKGRENADE - 'I000', idht_item_type, I_T)
//end of: InitWeaponTypeData("iBKGRENADE", "闇囪崱鎵嬮浄", "aBKGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
    call SaveStr(idht, iPSGRENADE - 'I000', idht_name, "鍐插嚮鎵嬮浄")
    call SaveInteger(idht, iPSGRENADE - 'I000', idht_spell, aPSGRENADE)
    call SaveInteger(idht, iPSGRENADE - 'I000', idht_s1, 0)
    call SaveInteger(idht, iPSGRENADE - 'I000', idht_s2, 0)
    call SaveInteger(idht, iPSGRENADE - 'I000', idht_s3, 0)
    call SaveInteger(idht, iPSGRENADE - 'I000', idht_item_type, I_T)
//end of: InitWeaponTypeData("iPSGRENADE", "鍐插嚮鎵嬮浄", "aPSGRENADE", "0","0","0","I_T")
//textmacro instance: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
    call SaveStr(idht, iMINE - 'I000', idht_name, "鍙嶆鍏靛湴闆?)
    call SaveInteger(idht, iMINE - 'I000', idht_spell, aMINE)
    call SaveInteger(idht, iMINE - 'I000', idht_s1, 0)
    call SaveInteger(idht, iMINE - 'I000', idht_s2, 0)
    call SaveInteger(idht, iMINE - 'I000', idht_s3, 0)
    call SaveInteger(idht, iMINE - 'I000', idht_item_type, I_N)
//end of: InitWeaponTypeData("iMINE", "鍙嶆鍏靛湴闆?, "aMINE", "0","0","0","I_N")
//textmacro instance: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
    call SaveStr(idht, 'I00P' - 'I000', idht_name, "绛夌瀛愯偐鐐?)
    call SaveInteger(idht, 'I00P' - 'I000', idht_spell, 'A01N')
    call SaveInteger(idht, 'I00P' - 'I000', idht_s1, 0)
    call SaveInteger(idht, 'I00P' - 'I000', idht_s2, 0)
    call SaveInteger(idht, 'I00P' - 'I000', idht_s3, 0)
    call SaveInteger(idht, 'I00P' - 'I000', idht_item_type, AB1)
//end of: InitWeaponTypeData("'I00P'", "绛夌瀛愯偐鐐?, "'A01N'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
    call SaveStr(idht, 'I00Q' - 'I000', idht_name, "蹇垉椋炵")
    call SaveInteger(idht, 'I00Q' - 'I000', idht_spell, 'A01O')
    call SaveInteger(idht, 'I00Q' - 'I000', idht_s1, 0)
    call SaveInteger(idht, 'I00Q' - 'I000', idht_s2, 0)
    call SaveInteger(idht, 'I00Q' - 'I000', idht_s3, 0)
    call SaveInteger(idht, 'I00Q' - 'I000', idht_item_type, AB1)
//end of: InitWeaponTypeData("'I00Q'", "蹇垉椋炵", "'A01O'", "0","0","0","AB1")
//textmacro instance: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht, 'I001' - 'I000', idht_name, "鏅€氭鏋?)
    call SaveInteger(idht, 'I001' - 'I000', idht_spell, 'A01O')
    call SaveInteger(idht, 'I001' - 'I000', idht_s1, 0)
    call SaveInteger(idht, 'I001' - 'I000', idht_s2, 0)
    call SaveInteger(idht, 'I001' - 'I000', idht_s3, 0)
    call SaveInteger(idht, 'I001' - 'I000', idht_item_type, GUN)
//end of: InitWeaponTypeData("'I001'", "鏅€氭鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
    call SaveStr(idht, 'I00R' - 'I000', idht_name, "鐭涙灙")
    call SaveInteger(idht, 'I00R' - 'I000', idht_spell, 'A01O')
    call SaveInteger(idht, 'I00R' - 'I000', idht_s1, 0)
    call SaveInteger(idht, 'I00R' - 'I000', idht_s2, 0)
    call SaveInteger(idht, 'I00R' - 'I000', idht_s3, 0)
    call SaveInteger(idht, 'I00R' - 'I000', idht_item_type, GUN)
//end of: InitWeaponTypeData("'I00R'", "鐭涙灙", "'A01O'", "0","0","0","GUN")
//textmacro instance: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
    call SaveStr(idht, 'I00S' - 'I000', idht_name, "鐏劙鏁ｅ脊鏋?)
    call SaveInteger(idht, 'I00S' - 'I000', idht_spell, 'A01O')
    call SaveInteger(idht, 'I00S' - 'I000', idht_s1, 0)
    call SaveInteger(idht, 'I00S' - 'I000', idht_s2, 0)
    call SaveInteger(idht, 'I00S' - 'I000', idht_s3, 0)
    call SaveInteger(idht, 'I00S' - 'I000', idht_item_type, GUN)
//end of: InitWeaponTypeData("'I00S'", "鐏劙鏁ｅ脊鏋?, "'A01O'", "0","0","0","GUN")
//textmacro instance: InitItemFeatureData("iSPEED", "1", "鎺ㄨ繘鍔?, "3","1","0","5","100","0")
    call SaveStr(ifht1, iSPEED - 'I000', ifht_name, "鎺ㄨ繘鍔?)
    call SaveReal(ifht1, iSPEED - 'I000', ifht_origin, 3)
    call SaveReal(ifht1, iSPEED - 'I000', ifht_step, 1)
    call SaveInteger(ifht1, iSPEED - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iSPEED - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iSPEED - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iSPEED - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iSPEED", "1", "鎺ㄨ繘鍔?, "3","1","0","5","100","0")
//textmacro instance: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
    call SaveStr(ifht1, iJUMP - 'I000', ifht_name, "璺宠穬楂樺害")
    call SaveReal(ifht1, iJUMP - 'I000', ifht_origin, 35)
    call SaveReal(ifht1, iJUMP - 'I000', ifht_step, 5)
    call SaveInteger(ifht1, iJUMP - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iJUMP - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iJUMP - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iJUMP - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iJUMP", "1", "璺宠穬楂樺害", "35","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
    call SaveStr(ifht2, iJUMP - 'I000', ifht_name, "璺宠穬璺濈")
    call SaveReal(ifht2, iJUMP - 'I000', ifht_origin, 10)
    call SaveReal(ifht2, iJUMP - 'I000', ifht_step, 3)
    call SaveInteger(ifht2, iJUMP - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iJUMP - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iJUMP - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iJUMP - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iJUMP", "2", "璺宠穬璺濈", "10","3","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
    call SaveStr(ifht1, iRETURN - 'I000', ifht_name, "鎶曟幏閫熷害")
    call SaveReal(ifht1, iRETURN - 'I000', ifht_origin, 80)
    call SaveReal(ifht1, iRETURN - 'I000', ifht_step, 10)
    call SaveInteger(ifht1, iRETURN - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iRETURN - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iRETURN - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iRETURN - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iRETURN", "1", "鎶曟幏閫熷害", "80","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2, iRETURN - 'I000', ifht_name, "棰濆浼ゅ")
    call SaveReal(ifht2, iRETURN - 'I000', ifht_origin, 0)
    call SaveReal(ifht2, iRETURN - 'I000', ifht_step, 20)
    call SaveInteger(ifht2, iRETURN - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iRETURN - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iRETURN - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iRETURN - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iRETURN", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
    call SaveStr(ifht1, iLEAVE - 'I000', ifht_name, "椋炶閫熷害")
    call SaveReal(ifht1, iLEAVE - 'I000', ifht_origin, 3.5)
    call SaveReal(ifht1, iLEAVE - 'I000', ifht_step, 0.5)
    call SaveInteger(ifht1, iLEAVE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iLEAVE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iLEAVE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iLEAVE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iLEAVE", "1", "椋炶閫熷害", "3.5","0.5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
    call SaveStr(ifht2, iLEAVE - 'I000', ifht_name, "棰濆浼ゅ")
    call SaveReal(ifht2, iLEAVE - 'I000', ifht_origin, 0)
    call SaveReal(ifht2, iLEAVE - 'I000', ifht_step, 20)
    call SaveInteger(ifht2, iLEAVE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iLEAVE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iLEAVE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iLEAVE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iLEAVE", "2", "棰濆浼ゅ", "0","20","0","5","100","0")
//textmacro instance: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
    call SaveStr(ifht1, iREACT - 'I000', ifht_name, "灏勫嚮鍙嶄綔鐢ㄥ姏")
    call SaveReal(ifht1, iREACT - 'I000', ifht_origin, 0.5)
    call SaveReal(ifht1, iREACT - 'I000', ifht_step, 0.25)
    call SaveInteger(ifht1, iREACT - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iREACT - 'I000', ifht_max_lv, 2)
    call SaveInteger(ifht1, iREACT - 'I000', ifht_gold, 50)
    call SaveInteger(ifht1, iREACT - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iREACT", "1", "灏勫嚮鍙嶄綔鐢ㄥ姏", "0.5","0.25","0","2","50","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
    call SaveStr(ifht1, iELECTRIC - 'I000', ifht_name, "鎶曟幏閫熷害")
    call SaveReal(ifht1, iELECTRIC - 'I000', ifht_origin, 30)
    call SaveReal(ifht1, iELECTRIC - 'I000', ifht_step, 10)
    call SaveInteger(ifht1, iELECTRIC - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iELECTRIC - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iELECTRIC - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iELECTRIC - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iELECTRIC", "1", "鎶曟幏閫熷害", "30","10","0","5","100","0")
//textmacro instance: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
    call SaveStr(ifht2, iELECTRIC - 'I000', ifht_name, "鎶曟幏璺濈")
    call SaveReal(ifht2, iELECTRIC - 'I000', ifht_origin, 30)
    call SaveReal(ifht2, iELECTRIC - 'I000', ifht_step, 5)
    call SaveInteger(ifht2, iELECTRIC - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iELECTRIC - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iELECTRIC - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iELECTRIC - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iELECTRIC", "2", "鎶曟幏璺濈", "30","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
    call SaveStr(ifht1, iBLINK - 'I000', ifht_name, "闂儊璺濈")
    call SaveReal(ifht1, iBLINK - 'I000', ifht_origin, 600)
    call SaveReal(ifht1, iBLINK - 'I000', ifht_step, 200)
    call SaveInteger(ifht1, iBLINK - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iBLINK - 'I000', ifht_max_lv, 3)
    call SaveInteger(ifht1, iBLINK - 'I000', ifht_gold, 50)
    call SaveInteger(ifht1, iBLINK - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iBLINK", "1", "闂儊璺濈", "600","200","0","3","50","0")
//textmacro instance: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
    call SaveStr(ifht1, iTRANSPORT - 'I000', ifht_name, "浼犻€佽窛绂?)
    call SaveReal(ifht1, iTRANSPORT - 'I000', ifht_origin, 5000)
    call SaveReal(ifht1, iTRANSPORT - 'I000', ifht_step, 2000)
    call SaveInteger(ifht1, iTRANSPORT - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iTRANSPORT - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iTRANSPORT - 'I000', ifht_gold, 150)
    call SaveInteger(ifht1, iTRANSPORT - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iTRANSPORT", "1", "浼犻€佽窛绂?, "5000","2000","0","5","150","0")
//textmacro instance: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
    call SaveStr(ifht1, iAUTOAIM - 'I000', ifht_name, "鎸佺画鏃堕棿")
    call SaveReal(ifht1, iAUTOAIM - 'I000', ifht_origin, 3)
    call SaveReal(ifht1, iAUTOAIM - 'I000', ifht_step, 1)
    call SaveInteger(ifht1, iAUTOAIM - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iAUTOAIM - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iAUTOAIM - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iAUTOAIM - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iAUTOAIM", "1", "鎸佺画鏃堕棿", "3","1","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1, iBKGRENADE - 'I000', ifht_name, "鎶曟幏鍔涢噺")
    call SaveReal(ifht1, iBKGRENADE - 'I000', ifht_origin, 50)
    call SaveReal(ifht1, iBKGRENADE - 'I000', ifht_step, 5)
    call SaveInteger(ifht1, iBKGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iBKGRENADE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iBKGRENADE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iBKGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iBKGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2, iBKGRENADE - 'I000', ifht_name, "鐖嗙偢鑼冨洿")
    call SaveReal(ifht2, iBKGRENADE - 'I000', ifht_origin, 500)
    call SaveReal(ifht2, iBKGRENADE - 'I000', ifht_step, 50)
    call SaveInteger(ifht2, iBKGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iBKGRENADE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iBKGRENADE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iBKGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iBKGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
    call SaveStr(ifht3, iBKGRENADE - 'I000', ifht_name, "鐪╂檿")
    call SaveReal(ifht3, iBKGRENADE - 'I000', ifht_origin, 1)
    call SaveReal(ifht3, iBKGRENADE - 'I000', ifht_step, 1)
    call SaveInteger(ifht3, iBKGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht3, iBKGRENADE - 'I000', ifht_max_lv, 1)
    call SaveInteger(ifht3, iBKGRENADE - 'I000', ifht_gold, 300)
    call SaveInteger(ifht3, iBKGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iBKGRENADE", "3", "鐪╂檿", "1","1","0","1","300","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
    call SaveStr(ifht1, iPSGRENADE - 'I000', ifht_name, "鎶曟幏鍔涢噺")
    call SaveReal(ifht1, iPSGRENADE - 'I000', ifht_origin, 50)
    call SaveReal(ifht1, iPSGRENADE - 'I000', ifht_step, 5)
    call SaveInteger(ifht1, iPSGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht1, iPSGRENADE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht1, iPSGRENADE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht1, iPSGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iPSGRENADE", "1", "鎶曟幏鍔涢噺", "50","5","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
    call SaveStr(ifht2, iPSGRENADE - 'I000', ifht_name, "鐖嗙偢鑼冨洿")
    call SaveReal(ifht2, iPSGRENADE - 'I000', ifht_origin, 500)
    call SaveReal(ifht2, iPSGRENADE - 'I000', ifht_step, 50)
    call SaveInteger(ifht2, iPSGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht2, iPSGRENADE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht2, iPSGRENADE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht2, iPSGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iPSGRENADE", "2", "鐖嗙偢鑼冨洿", "500","50","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
    call SaveStr(ifht3, iPSGRENADE - 'I000', ifht_name, "鍑婚€€")
    call SaveReal(ifht3, iPSGRENADE - 'I000', ifht_origin, 10)
    call SaveReal(ifht3, iPSGRENADE - 'I000', ifht_step, 2)
    call SaveInteger(ifht3, iPSGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht3, iPSGRENADE - 'I000', ifht_max_lv, 5)
    call SaveInteger(ifht3, iPSGRENADE - 'I000', ifht_gold, 100)
    call SaveInteger(ifht3, iPSGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iPSGRENADE", "3", "鍑婚€€", "10","2","0","5","100","0")
//textmacro instance: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
    call SaveStr(ifht4, iPSGRENADE - 'I000', ifht_name, "鍑忛€?)
    call SaveReal(ifht4, iPSGRENADE - 'I000', ifht_origin, 0)
    call SaveReal(ifht4, iPSGRENADE - 'I000', ifht_step, 1)
    call SaveInteger(ifht4, iPSGRENADE - 'I000', ifht_lv, 0)
    call SaveInteger(ifht4, iPSGRENADE - 'I000', ifht_max_lv, 2)
    call SaveInteger(ifht4, iPSGRENADE - 'I000', ifht_gold, 200)
    call SaveInteger(ifht4, iPSGRENADE - 'I000', ifht_wood, 0)
//end of: InitItemFeatureData("iPSGRENADE", "4", "鍑忛€?, "0","1","0","2","200","0")
endfunction
function getItemTypeData takes integer idd returns integer
    local integer id= idd - 'I000'
    if HaveSavedString(idht, id, idht_name) then
        return s__ItemTypeData_create(LoadStr(idht, id, idht_name) , LoadInteger(idht, id, idht_spell) , LoadInteger(idht, id, idht_s1) , LoadInteger(idht, id, idht_s2) , LoadInteger(idht, id, idht_s3) , LoadInteger(idht, id, idht_item_type))
    endif
    return - 1
endfunction
function hasItemTypeData takes integer idd returns boolean
    local integer id= idd - 'I000'
    if HaveSavedString(idht, id, idht_name) then
        return true
    endif
    return false
endfunction
function GetItemByTypeId takes unit u,integer id returns item
local integer i=0
local item ui
loop
    exitwhen i > 5
    set ui=UnitItemInSlot(u, i)
    if GetItemTypeId(ui) == id then
        return ui
    endif
    set i=i + 1
endloop
set ui=null
return null
endfunction
//textmacro instance: getfeaturevalue("1")
function getf1value takes unit u,integer id returns real
    local item itm= GetItemByTypeId(u , id)
    local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
    set itm=null
    return s__ItemFeature_getValue(f1)
endfunction
//end of: getfeaturevalue("1")
//textmacro instance: getfeaturevalue("2")
function getf2value takes unit u,integer id returns real
    local item itm= GetItemByTypeId(u , id)
    local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
    set itm=null
    return s__ItemFeature_getValue(f2)
endfunction
//end of: getfeaturevalue("2")
//textmacro instance: getfeaturevalue("3")
function getf3value takes unit u,integer id returns real
    local item itm= GetItemByTypeId(u , id)
    local integer f3= s__ItemFeatureData_f3[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
    set itm=null
    return s__ItemFeature_getValue(f3)
endfunction
//end of: getfeaturevalue("3")
//textmacro instance: getfeaturevalue("4")
function getf4value takes unit u,integer id returns real
    local item itm= GetItemByTypeId(u , id)
    local integer f4= s__ItemFeatureData_f4[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
    set itm=null
    return s__ItemFeature_getValue(f4)
endfunction
//end of: getfeaturevalue("4")
//textmacro instance: getfeaturevalue("5")
function getf5value takes unit u,integer id returns real
    local item itm= GetItemByTypeId(u , id)
    local integer f5= s__ItemFeatureData_f5[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
    set itm=null
    return s__ItemFeature_getValue(f5)
endfunction
//end of: getfeaturevalue("5")

//library ItemData ends
//library Job:
function InitMarinJob takes unit target,integer lv returns nothing
    local integer pid= GetPlayerId(GetOwningPlayer(target))
    if IsHero(target) then
        if lv == 1 then
            call IncShootSpeed(pid)
            call IncShootSpeed(pid)
            set s__IHeroData_machine_gun_buff[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(target)]]=s__IHeroData_machine_gun_buff[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(target)]] + 0.15
        endif
    endif
endfunction

//library Job ends
//library JumpFacingStore:
function storeJumpFacing takes nothing returns nothing
    local real sx= GetUnitX(GetTriggerUnit())
    local real sy= GetUnitY(GetTriggerUnit())
    local real tx= GetOrderPointX()
    local real ty= GetOrderPointY()
    local real dir= getDir(sx , sy , tx , ty)
    if IsHero(GetTriggerUnit()) and GetIssuedOrderId() == OI_RIGHT_CLICK_MOVE then
        set s__IHeroData_jump_direction[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(GetTriggerUnit())]]=dir
    endif
endfunction
function InitJumpFacingStore takes nothing returns nothing
local trigger jumpPointFacing_t=CreateTrigger()
call TriggerAddCondition(jumpPointFacing_t, Condition(function storeJumpFacing))
call TriggerRegisterAnyUnitEventBJ(jumpPointFacing_t, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
set jumpPointFacing_t=null
endfunction

//library JumpFacingStore ends
//library MonsterBonus:
function MonsterBonus takes nothing returns nothing
local integer typeId=GetUnitTypeId(GetTriggerUnit())
local player p=GetOwningPlayer(GetKillingUnitBJ())
local integer data=s__DefaultTypeData_findTypeData(typeId)
call AdjustPlayerStateBJ(sc__IMonsterTypeData_getDeadGold(data), p, PLAYER_STATE_RESOURCE_GOLD)
call AdjustPlayerStateBJ(sc__IMonsterTypeData_getDeadWood(data), p, PLAYER_STATE_RESOURCE_LUMBER)
endfunction
function InitMonsterBonus takes nothing returns nothing
call TriggerAddCondition(gtrgMonsterDead, Condition(function MonsterBonus))
endfunction

//library MonsterBonus ends
//library Move:
function UpdateBoard takes nothing returns nothing
    set lx=GetRectMinX(area)
    set rx=GetRectMaxX(area)
    set ly=GetRectMinY(area)
    set ry=GetRectMaxY(area)
    set lz=0
    set rz=3000
endfunction
function InitMove takes nothing returns nothing
    set area=GetPlayableMapRect()
    call UpdateBoard()
endfunction
function ChangeRect takes rect newrect returns nothing
    set area=newrect
    call UpdateBoard()
endfunction
function MoveUnit takes unit u,real tx,real ty,real tz returns nothing
    local real z= tz - getTerrianHeight(tx , ty)
    local real fz= GetUnitFlyHeight(u)
    if fz > 0 then
        set z=RMaxBJ(0, z)
    endif
    if tx >= rx or tx <= lx or ty >= ry or ty <= ly or tz > rz or z < 0 then
    else
        call SetUnitX(u, tx)
        call SetUnitY(u, ty)
        call SetUnitFlyHeight(u, z, 0)
        //if z == 0 then
            //call BJDebugMsg("set fly height zero")
        //endif
    endif
endfunction

//library Move ends
//library PUI:
    //===========================================================================
    //  Allowed PUI_PROPERTY TYPES are: unit, integer, real, boolean, string
    //  Do NOT put handles that need to be destroyed here (timer, trigger, ...)
    //  Instead put them in a struct and use PUI textmacro
    //===========================================================================
    //===========================================================================
    //  Never destroy PUI structs directly.
    //  Use .release() instead, will call .destroy()
    //===========================================================================

//library PUI ends
//library Save:
function BeforeSaveCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    if IsHero(u) then
        set s__IHeroData_beforesave[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]=GetUnitStateSwap(UNIT_STATE_MANA, u)
    endif
    set u=null
endfunction
function DoSaveCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    local real mana
    local real save
    local real before
    if IsHero(u) then
        set before=s__IHeroData_beforesave[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]
        set mana=GetUnitStateSwap(UNIT_STATE_MANA, u)
        if before > mana then
            set save=s__IHeroData_save[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]
            call SetUnitManaBJ(u, mana + save * ( before - mana ))
        endif
    endif
    set u=null
endfunction
function InitSave takes nothing returns nothing
local trigger beforesave_t=CreateTrigger()
local trigger dosave_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(beforesave_t, EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerRegisterAnyUnitEventBJ(dosave_t, EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(beforesave_t, Condition(function BeforeSaveCondition))
call TriggerAddCondition(dosave_t, Condition(function DoSaveCondition))
set beforesave_t=null
set dosave_t=null
endfunction

//library Save ends
//library SpellStruct:
    //===========================================================================
    // Configurables
    //
    
    //===========================================================================
    // Header Declarations
    //
    
//processed:     function interface SpellStruct__Method takes integer this returns nothing
//processed:     function interface SpellStruct__UnitMethodFilter takes integer this, unit u returns boolean
//processed:     function interface SpellStruct__UnitMethod takes integer this, unit u returns nothing
//processed:     function interface SpellStruct__Allocator takes nothing returns integer
    
    //===========================================================================
    // Recursion stack
    //
    
    //===========================================================================
    // Defaults
    //
        // For methods that are not implemented.
        // In order of firing.

    
    //===========================================================================
    // Event Handlers
    //
    
    
//textmacro instance: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
        function SpellStruct__OnChannel takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()

                set SpellStruct__ThisCastData=(LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, SpellStruct__ALLOCATOR))
                if SpellStruct__ThisCastData == 0 then
                    return false
                endif
                set SpellStruct__ThisCastData=(sc___prototype1_evaluate((LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, SpellStruct__ALLOCATOR))))
                call SaveInteger(SpellStruct__STORE, SpellStruct__CastingAbility, GetHandleId(GetTriggerUnit()), SpellStruct__ThisCastData)



            //call BJDebugMsg("OnChannel - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData != 0 then
                call sx__SpellStruct__DefaultsInterface_onChannel(SpellStruct__ThisCastData)



            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onChannel","OnChannel","true","false")
//textmacro instance: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
        function SpellStruct__OnStartCast takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()








                set SpellStruct__ThisCastData=(LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, GetHandleId(GetTriggerUnit())))

            //call BJDebugMsg("OnStartCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData != 0 then
                call sx__SpellStruct__DefaultsInterface_onStartCast(SpellStruct__ThisCastData)



            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStartCast","OnStartCast","false","false")
//textmacro instance: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
        function SpellStruct__OnEffect takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()








                set SpellStruct__ThisCastData=(LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, GetHandleId(GetTriggerUnit())))

            //call BJDebugMsg("OnEffect - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData != 0 then
                call sx__SpellStruct__DefaultsInterface_onEffect(SpellStruct__ThisCastData)



            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onEffect","OnEffect","false","false")
//textmacro instance: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
        function SpellStruct__OnFinish takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()








                set SpellStruct__ThisCastData=(LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, GetHandleId(GetTriggerUnit())))

            //call BJDebugMsg("OnFinish - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData != 0 then
                call sx__SpellStruct__DefaultsInterface_onFinish(SpellStruct__ThisCastData)



            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onFinish","OnFinish","false","false")
//textmacro instance: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
        function SpellStruct__OnStopCast takes nothing returns boolean
            set SpellStruct__CastingAbility=GetSpellAbilityId()








                set SpellStruct__ThisCastData=(LoadInteger(SpellStruct__STORE, SpellStruct__CastingAbility, GetHandleId(GetTriggerUnit())))

            //call BJDebugMsg("OnStopCast - Method: "+I2S(LoadInteger(STORE,CastingAbility,$METHOD_KEY$))+" for struct "+I2S(ThisCastData))
            if SpellStruct__ThisCastData != 0 then
                call sx__SpellStruct__DefaultsInterface_onStopCast(SpellStruct__ThisCastData)

                    call sc__SpellStruct__DefaultsInterface_cleanup(SpellStruct__ThisCastData)

            endif
            return false
        endfunction
//end of: SpellStruct__EventResponse("onStopCast","OnStopCast","false","true")
    
    //===========================================================================
    // Attachment.
    //
    
    //===========================================================================
    // Timers (requires Attachment).
    //
    function SpellStruct__SetTimerStruct takes timer t,integer data returns nothing

            call SetTimerData(t , data)



    endfunction
    function SpellStruct__GetTimerStruct takes timer t returns integer

            return GetTimerData(t)



    endfunction
    
    //===========================================================================
    // Triggers (requires Attachment).
    //
    function SpellStruct__SetTriggerStruct takes trigger t,integer data returns nothing
        call SaveInteger(SpellStruct__STORE, GetHandleId(t), SpellStruct__TRIGGER_DATA, data)
    endfunction
    function SpellStruct__GetTriggerStruct takes trigger t returns integer
        return LoadInteger(SpellStruct__STORE, GetHandleId(t), SpellStruct__TRIGGER_DATA)
    endfunction
    
    //===========================================================================
    // AoE enumeration.
    //
//Implemented from module SpellStruct__Stack:
function s__SpellStruct__EnumStack_increment takes nothing returns nothing
            set s__SpellStruct__EnumStack_top=(s__SpellStruct__EnumStack_top + 1)
        endfunction
        function s__SpellStruct__EnumStack_decrement takes nothing returns nothing
            set s__SpellStruct__EnumStack_top=(s__SpellStruct__EnumStack_top - 1)
        endfunction
    function SpellStruct__InternalEnum takes nothing returns boolean
local unit u=GetFilterUnit()
if IsUnitInRangeXY(u, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]) then // Factors in collision sizes.
if sc___prototype217_evaluate((s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]),s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top] , u) then
                call GroupAddUnit(s__SpellStruct__EnumStack_for[s__SpellStruct__EnumStack_top], u)
            endif
        endif
        set u=null
        return false
    endfunction
    function SpellStruct__InternalFor takes nothing returns boolean
local unit u=GetFilterUnit()
if IsUnitInRangeXY(u, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]) then // Factors in collision sizes.
call sc___prototype218_execute((s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]),s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top] , u)
        endif
        set u=null
        return false
    endfunction
    
    //===========================================================================
    // Exposed Interface - SpellStruct
    //
        //===========================================================================
        // Various Spell-based Methods.
        //
        function s__SpellStruct_getDistanceToTargetWidget takes integer this returns real
            local real x=GetWidgetX(s__SpellStruct_targetWidget[this]) - sc__SpellStruct__get_casterX(this)
            local real y=GetWidgetY(s__SpellStruct_targetWidget[this]) - sc__SpellStruct__get_casterY(this)
            return SquareRoot(x * x + y * y)
        endfunction
        function s__SpellStruct_getDistanceToTargetPoint takes integer this returns real
            local real x=s__SpellStruct_targetX[this] - sc__SpellStruct__get_casterX(this)
            local real y=s__SpellStruct_targetY[this] - sc__SpellStruct__get_casterY(this)
            return SquareRoot(x * x + y * y)
        endfunction
        function s__SpellStruct_getAngleToTargetWidget takes integer this returns real
return Atan2(GetWidgetY(s__SpellStruct_targetWidget[this]) - sc__SpellStruct__get_casterY(this), GetWidgetX(s__SpellStruct_targetWidget[this]) - sc__SpellStruct__get_casterX(this))
        endfunction
        function s__SpellStruct_getAngleToTargetPoint takes integer this returns real
return Atan2(s__SpellStruct_targetY[this] - sc__SpellStruct__get_casterY(this), s__SpellStruct_targetX[this] - sc__SpellStruct__get_casterX(this))
        endfunction
        
        //===========================================================================
        // ForGroup.
        //
        function s__SpellStruct_forGroupCallback takes nothing returns nothing
            call sc___prototype218_execute((s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]),s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top] , GetEnumUnit()) // bigger crimes have been committed, but not much bigger.
endfunction
        function s__SpellStruct_forGroup takes integer this,group g,integer callback returns nothing
            call s__SpellStruct__EnumStack_increment() // just borrowing that stack... would break if event reponses accessed the stack directly, but they don't.
set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=callback
            call ForGroup(g, function s__SpellStruct_forGroupCallback)
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        //===========================================================================
        // AoE enumeration.
        //
        
        function s__SpellStruct_enumUnitsInAoE takes integer this,group whichGroup,integer filter returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=s__SpellStruct_targetX[this]
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=s__SpellStruct_targetY[this]
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=filter
            set s__SpellStruct__EnumStack_for[s__SpellStruct__EnumStack_top]=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalEnum))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_enumUnitsInAoETarget takes integer this,group whichGroup,integer filter returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=GetWidgetX(s__SpellStruct_targetWidget[this])
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=GetWidgetY(s__SpellStruct_targetWidget[this])
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=filter
            set s__SpellStruct__EnumStack_for[s__SpellStruct__EnumStack_top]=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalEnum))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_enumUnitsInAoECaster takes integer this,group whichGroup,integer filter returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=GetUnitX(s__SpellStruct_caster[this])
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=GetUnitY(s__SpellStruct_caster[this])
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=filter
            set s__SpellStruct__EnumStack_for[s__SpellStruct__EnumStack_top]=whichGroup
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalEnum))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_forUnitsInAoE takes integer this,integer callback returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=s__SpellStruct_targetX[this]
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=s__SpellStruct_targetY[this]
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalFor))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_forUnitsInAoETarget takes integer this,integer callback returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=GetWidgetX(s__SpellStruct_targetWidget[this])
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=GetWidgetY(s__SpellStruct_targetWidget[this])
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalFor))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_forUnitsInAoECaster takes integer this,integer callback returns nothing
            call s__SpellStruct__EnumStack_increment()
            set s__SpellStruct__EnumStack_instance[s__SpellStruct__EnumStack_top]=this
            set s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top]=GetUnitX(s__SpellStruct_caster[this])
            set s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top]=GetUnitY(s__SpellStruct_caster[this])
            set s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top]=s__SpellStruct_aoe[this]
            set s__SpellStruct__EnumStack_callback[s__SpellStruct__EnumStack_top]=callback
            call GroupEnumUnitsInRange(SpellStruct__GROUP, s__SpellStruct__EnumStack_x[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_y[s__SpellStruct__EnumStack_top], s__SpellStruct__EnumStack_range[s__SpellStruct__EnumStack_top] + SpellStruct__MAX_UNIT_COLLISION_SIZE, Filter(function SpellStruct__InternalFor))
            call s__SpellStruct__EnumStack_decrement()
        endfunction
        
        function s__SpellStruct_isUnitInAoE takes integer this,unit u returns boolean
            return IsUnitInRangeXY(u, s__SpellStruct_targetX[this], s__SpellStruct_targetY[this], s__SpellStruct_aoe[this])
        endfunction
        function s__SpellStruct_isUnitInAoETarget takes integer this,unit u returns boolean
            return IsUnitInRangeXY(u, GetWidgetX(s__SpellStruct_targetWidget[this]), GetWidgetY(s__SpellStruct_targetWidget[this]), s__SpellStruct_aoe[this])
        endfunction
        function s__SpellStruct_isUnitInAoECaster takes integer this,unit u returns boolean
            return IsUnitInRangeXY(u, GetUnitX(s__SpellStruct_caster[this]), GetUnitY(s__SpellStruct_caster[this]), s__SpellStruct_aoe[this])
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__SpellStruct__set_autoDestroy takes integer this,boolean flag returns nothing
            if flag then
                if s__SpellStruct_hasStoppedCasting[this] and sc__SpellStruct__get_isNotLocked(this) then
                    set s__SpellStruct_hasStoppedCasting[this]=false // double free safety
call sc__SpellStruct_destroy(this)
                else
                    set s__SpellStruct_doAutoDestroy[this]=true
                endif
            else
                set s__SpellStruct_doAutoDestroy[this]=false
            endif
        endfunction
        function s__SpellStruct__get_autoDestroy takes integer this returns boolean
            return s__SpellStruct_doAutoDestroy[this]
        endfunction
        
        //===========================================================================
        // Locking.
        //
        function s__SpellStruct__get_isLocked takes integer this returns boolean
            return s__SpellStruct_lockLevel[this] > 0
        endfunction
        function s__SpellStruct__get_isNotLocked takes integer this returns boolean
            return s__SpellStruct_lockLevel[this] == 0
        endfunction
        function s__SpellStruct_addLock takes integer this returns nothing
            set s__SpellStruct_lockLevel[this]=s__SpellStruct_lockLevel[this] + 1
        endfunction
        function s__SpellStruct_removeLock takes integer this returns nothing
            set s__SpellStruct_lockLevel[this]=s__SpellStruct_lockLevel[this] - 1
            if s__SpellStruct_hasStoppedCasting[this] and s__SpellStruct__get_isNotLocked(this) and s__SpellStruct_doAutoDestroy[this] then
                set s__SpellStruct_hasStoppedCasting[this]=false // double free safety
call sc__SpellStruct_destroy(this)
            endif
        endfunction
        
        //===========================================================================
        // Attachment.
        //
        
        
        
        
        //===========================================================================
        // Timers (requires Locking).
        //
        function s__SpellStruct_timerCallback takes nothing returns nothing
            set s__SpellStruct_attachNode=SpellStruct__GetTimerStruct(GetExpiredTimer()) // first time since h2i/gamecache I've needed this.
call sc___prototype18_execute(s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode],s__SpellStruct__ChainAttach_instance[s__SpellStruct_attachNode]) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
endfunction
        function s__SpellStruct_startTimer takes integer this,integer callback,real period returns nothing
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            // Create node.
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach__allocate()
            // Link node (at end of list).
            set s__SpellStruct_attachHead=s__SpellStruct_timerAttachments[this]
            set s__SpellStruct__ChainAttach_next[s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]]=s__SpellStruct_attachNode
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]=s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachNode
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]=s__SpellStruct_attachHead
//end of: SpellStruct__CreateAttachmentNode("this.timerAttachments")
            set s__SpellStruct__ChainAttach_instance[s__SpellStruct_attachNode]=this
            set s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode]=callback
            // Create timer and attach data.
//textmacro instance: SpellStruct__GetTimer("thistype.attachNode.timer")

            set s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode]=NewTimer()





//end of: SpellStruct__GetTimer("thistype.attachNode.timer")
            call SpellStruct__SetTimerStruct(s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode] , s__SpellStruct_attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct__STORE, this, callback, s__SpellStruct_attachNode)
            // Start timer.
            call TimerStart(s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode], period, true, function s__SpellStruct_timerCallback)
            call s__SpellStruct_addLock(this)
        endfunction
        function s__SpellStruct_stopTimer takes integer this,integer callback returns nothing
            set s__SpellStruct_attachNode=(LoadInteger(SpellStruct__STORE, this, callback))
            // Unchain attachment
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]]=s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]
            set s__SpellStruct__ChainAttach_next[s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]]=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            // Release Timer.
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")

            call ReleaseTimer(s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode])









//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
            call RemoveSavedInteger(SpellStruct__STORE, this, callback)
            call s__SpellStruct_removeLock(this)
        endfunction
        
        //===========================================================================
        // Triggers (requires Locking).
        //
        function s__SpellStruct_triggerCallback takes nothing returns boolean
            set s__SpellStruct_attachNode=SpellStruct__GetTriggerStruct(GetTriggeringTrigger()) // first time since h2i/gamecache I've needed this.
call sc___prototype18_execute(s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode],s__SpellStruct__ChainAttach_instance[s__SpellStruct_attachNode]) // good reason to use T32 instead.
// cannot use thistype.attachNode anymore, value may have changed.
return false
        endfunction
        function s__SpellStruct_createTrigger takes integer this,integer callback returns trigger
            // Make node and attach data.
//textmacro instance: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            // Create node.
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach__allocate()
            // Link node (at end of list).
            set s__SpellStruct_attachHead=s__SpellStruct_triggerAttachments[this]
            set s__SpellStruct__ChainAttach_next[s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]]=s__SpellStruct_attachNode
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]=s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachNode
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]=s__SpellStruct_attachHead
//end of: SpellStruct__CreateAttachmentNode("this.triggerAttachments")
            set s__SpellStruct__ChainAttach_instance[s__SpellStruct_attachNode]=this
            set s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode]=callback
            // Create timer and attach data.
            set s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode]=CreateTrigger()
            call SpellStruct__SetTriggerStruct(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode] , s__SpellStruct_attachNode)
            // Attach node to struct/method.
            call SaveInteger(SpellStruct__STORE, this, callback, s__SpellStruct_attachNode)
            // Init trigger.
            call TriggerAddCondition(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode], Filter(function s__SpellStruct_triggerCallback))
            call s__SpellStruct_addLock(this)
            return s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode]
        endfunction
        function s__SpellStruct_destroyTrigger takes integer this,integer callback returns nothing
            set s__SpellStruct_attachNode=(LoadInteger(SpellStruct__STORE, this, callback))
            // Unchain attachment
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]]=s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]
            set s__SpellStruct__ChainAttach_next[s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachNode]]=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            // Destroy trigger
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct__STORE, GetHandleId(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode]), SpellStruct__TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
            call DestroyTrigger(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode])
            call RemoveSavedInteger(SpellStruct__STORE, this, callback)
            call s__SpellStruct_removeLock(this)
        endfunction
        
        //===========================================================================
        // Event responses.
        //
        
        function s__SpellStruct__get_casterX takes integer this returns real
            return GetUnitX(s__SpellStruct_caster[this])
        endfunction
        function s__SpellStruct__get_casterY takes integer this returns real
            return GetUnitY(s__SpellStruct_caster[this])
        endfunction
        
        function s__SpellStruct_create takes nothing returns integer
            local integer this=s__SpellStruct__allocate()
            
            //===========================================================================
            // Event responses.
            //
            set s__SpellStruct_abilId[this]=GetSpellAbilityId()
            set s__SpellStruct_caster[this]=GetTriggerUnit()
            set s__SpellStruct_owner[this]=GetOwningPlayer(s__SpellStruct_caster[this])
            set s__SpellStruct_level[this]=GetUnitAbilityLevel(s__SpellStruct_caster[this], s__SpellStruct_abilId[this])
            set s__SpellStruct_order[this]=GetUnitCurrentOrder(s__SpellStruct_caster[this])
            // Target stuff
            set s__SpellStruct_targetUnit[this]=GetSpellTargetUnit()
            if s__SpellStruct_targetUnit[this] == null then
                set s__SpellStruct_targetDest[this]=GetSpellTargetDestructable()
                if s__SpellStruct_targetDest[this] == null then
                    set s__SpellStruct_targetItem[this]=GetSpellTargetItem()
                    if s__SpellStruct_targetItem[this] == null then
                        set s__SpellStruct_targetWidget[this]=null
                        set s__SpellStruct_loc=GetSpellTargetLoc()
                        if s__SpellStruct_loc == null then
                            set s__SpellStruct_targetX[this]=GetUnitX(s__SpellStruct_caster[this])
                            set s__SpellStruct_targetY[this]=GetUnitY(s__SpellStruct_caster[this])
                        else
                            set s__SpellStruct_targetX[this]=GetLocationX(s__SpellStruct_loc)
                            set s__SpellStruct_targetY[this]=GetLocationY(s__SpellStruct_loc)
                            call RemoveLocation(s__SpellStruct_loc)
                            set s__SpellStruct_loc=null // worthwhile
endif
                    else
                        set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetItem[this]
                        set s__SpellStruct_targetX[this]=GetItemX(s__SpellStruct_targetItem[this])
                        set s__SpellStruct_targetY[this]=GetItemY(s__SpellStruct_targetItem[this])
                    endif
                else
                    set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetDest[this]
                    set s__SpellStruct_targetItem[this]=null
                    set s__SpellStruct_targetX[this]=GetWidgetX(s__SpellStruct_targetDest[this]) // shorter
set s__SpellStruct_targetY[this]=GetWidgetY(s__SpellStruct_targetDest[this])
                endif
            else
                set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetUnit[this]
                set s__SpellStruct_targetDest[this]=null
                set s__SpellStruct_targetItem[this]=null
                set s__SpellStruct_targetX[this]=GetUnitX(s__SpellStruct_targetUnit[this])
                set s__SpellStruct_targetY[this]=GetUnitY(s__SpellStruct_targetUnit[this])
            endif
            
            //===========================================================================
            // Attachment (timer & trigger).
            //
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set s__SpellStruct_attachHead=s__SpellStruct__ChainAttach__allocate()
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set s__SpellStruct_timerAttachments[this]=s__SpellStruct_attachHead
//textmacro instance: SpellStruct__CreateAttachmentHead()
            set s__SpellStruct_attachHead=s__SpellStruct__ChainAttach__allocate()
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
//end of: SpellStruct__CreateAttachmentHead()
            set s__SpellStruct_triggerAttachments[this]=s__SpellStruct_attachHead
            
            return this
        endfunction
        
        function s__SpellStruct_destroy takes integer this returns nothing
            if s__SpellStruct_hasStoppedCasting[this] then
                set s__SpellStruct_hasStoppedCasting[this]=false // random double free protection on autoDestroy stuff.
else
                call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            endif
            
            //===========================================================================
            // Timers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.timerAttachments")
            set s__SpellStruct_attachHead=s__SpellStruct_timerAttachments[this]
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]
            loop
                exitwhen s__SpellStruct_attachNode == s__SpellStruct_attachHead
//end of: SpellStruct__AttachmentChainLoop("this.timerAttachments")
//textmacro instance: SpellStruct__ReleaseTimer("thistype.attachNode.timer")

            call ReleaseTimer(s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode])









//end of: SpellStruct__ReleaseTimer("thistype.attachNode.timer")
                call RemoveSavedInteger(SpellStruct__STORE, this, s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode])
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call s__SpellStruct__ChainAttach_deallocate(s__SpellStruct_timerAttachments[this])
            
            //===========================================================================
            // Triggers
            //
//textmacro instance: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
            set s__SpellStruct_attachHead=s__SpellStruct_triggerAttachments[this]
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]
            loop
                exitwhen s__SpellStruct_attachNode == s__SpellStruct_attachHead
//end of: SpellStruct__AttachmentChainLoop("this.triggerAttachments")
//textmacro instance: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
        call RemoveSavedInteger(SpellStruct__STORE, GetHandleId(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode]), SpellStruct__TRIGGER_DATA)
//end of: SpellStruct__FlushTrigger("thistype.attachNode.trigger")
                call DestroyTrigger(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode])
                call RemoveSavedInteger(SpellStruct__STORE, this, s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode])
//textmacro instance: SpellStruct__AttachmentChainEndloop()
                set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            endloop
//end of: SpellStruct__AttachmentChainEndloop()
            call s__SpellStruct__ChainAttach_deallocate(s__SpellStruct_triggerAttachments[this])
            
            call sc__SpellStruct__DefaultsInterface_deallocate(this)
        endfunction
    
    //===========================================================================
    // Exposed Module - SpellStruct
    //
    
    //===========================================================================
    // Init
    //
        function s__SpellStruct__Init_onInit takes nothing returns nothing
            //===========================================================================
            // Event Responses
            //
            local trigger t
            
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_CHANNEL)
                call TriggerAddCondition(t, Filter(function SpellStruct__OnChannel))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CHANNEL","OnChannel")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_CAST)
                call TriggerAddCondition(t, Filter(function SpellStruct__OnStartCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_CAST","OnStartCast")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_EFFECT)
                call TriggerAddCondition(t, Filter(function SpellStruct__OnEffect))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_EFFECT","OnEffect")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_FINISH)
                call TriggerAddCondition(t, Filter(function SpellStruct__OnFinish))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_FINISH","OnFinish")
//textmacro instance: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
                set t=CreateTrigger()
                call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_ENDCAST)
                call TriggerAddCondition(t, Filter(function SpellStruct__OnStopCast))
//end of: SpellStruct__RegisterEvent("EVENT_PLAYER_UNIT_SPELL_ENDCAST","OnStopCast")
            
            set t=null
        endfunction

//library SpellStruct ends
//library Status:
    

    
    
    
    
    
        function s__Status_AIDS_onCreate takes integer this returns nothing

                call UnitShareVision(sc__Status__get_unit(this), Status___DUMMY_CASTER_OWNER, true)

            
            set s__Status_disableLevel[this]=0
            set s__Status_stunLevel[this]=0
            set s__Status_silenceLevel[this]=0
            set s__Status_doomLevel[this]=0
            set s__Status_disarmMeleeLevel[this]=0
            set s__Status_disarmRangeLevel[this]=0
            set s__Status_immoboliseLevel[this]=0
            set s__Status_invisibleLevel[this]=0
            set s__Status_ghostLevel[this]=0
            set s__Status_invulnerableLevel[this]=0
            set s__Status_immunityLevel[this]=0
            set s__Status_pauseLevel[this]=0
            set s__Status_hideLevel[this]=0
            set s__Status_unpathLevel[this]=0
            set s__Status_hexLevel[this]=0
            set s__Status_locustLevel[this]=0
            set s__Status_neverMissLevel[this]=0
            set s__Status_alwaysMissLevel[this]=0
            set s__Status_untouchableLevel[this]=0
            set s__Status_banishLevel[this]=0
            set s__Status_phaseLevel[this]=0
            set s__Status_resistantSkinLevel[this]=0
            set s__Status_reflectPiercingLevel[this]=0
            
            set s__Status_armorBonus[this]=0
            set s__Status_damageBonus[this]=0
            set s__Status_strBonus[this]=0
            set s__Status_agiBonus[this]=0
            set s__Status_intBonus[this]=0
            set s__Status_attackSpeedBonus[this]=0
            set s__Status_healthBonus[this]=0
            set s__Status_manaBonus[this]=0
            set s__Status_healthRegenBonus[this]=0
            set s__Status_manaRegenBonus[this]=0
            set s__Status_healthRegenPercentBonus[this]=0
            set s__Status_manaRegenPercentBonus[this]=0
            
            set s__Status_moveSpeedBonus[this]=0.0
            set s__Status_moveSpeedPercentBonus[this]=0.0
            call sc__Status_stopPeriodic(this)
        endfunction
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__Status__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__Status__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Status_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__Status_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Status_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__Status_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call s__Status_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Status_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if s__AIDS_DEFAULT_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__Status_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call s__Status_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Status_AIDS_onDeallocate takes nothing returns boolean
            if s__Status_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call s__AIDS_DEFAULT_AIDS_onDestroy(s__Status_AIDS_DELEGATE)
                // Unflag destruction on deallocation.
                set s__Status_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Status_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__Status_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__Status_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__Status_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call s__AIDS_DEFAULT_AIDS_onInit()
        endfunction
//end of: AIDS()
        
//Implemented from module Status___StatusInit:
        function s__Status_Status___StatusInit___onInit takes nothing returns nothing
            local integer i
            set s__Status_dummyCaster=CreateUnit(Status___DUMMY_CASTER_OWNER, DUMMY_TYPE, 0, 0, 0)
            set s__Status_dummyCaster2=CreateUnit(Status___DUMMY_CASTER_OWNER, DUMMY_TYPE, 0, 0, 0)
            set s__Status_dummyCaster3=CreateUnit(Status___DUMMY_CASTER_OWNER, DUMMY_TYPE, 0, 0, 0)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_STUN)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_DISABLE)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_SILENCE)
            set Status___CASTER_DISARM_BOTH=s__Status_dummyCaster
            set Status___CASTER_DISARM_MELEE=s__Status_dummyCaster2
            set Status___CASTER_DISARM_RANGE=s__Status_dummyCaster3
            call UnitAddAbility(Status___CASTER_DISARM_BOTH, Status___ABIL_DISARM_BOTH)
            call UnitAddAbility(Status___CASTER_DISARM_MELEE, Status___ABIL_DISARM_MELEE)
            call UnitAddAbility(Status___CASTER_DISARM_RANGE, Status___ABIL_DISARM_RANGE)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_IMMOBOLISE)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_DOOM)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_HEX)
            call UnitAddAbility(s__Status_dummyCaster, Status___ABIL_BANISH)
            set i=bj_MAX_PLAYERS
            loop
                set i=i - 1
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_IMMUNITY, false)
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_NEVER_MISS, false)
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_ALWAYS_MISS, false)
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_UNTOUCHABLE, false)
                //call SetPlayerAbilityAvailable(Player(i),ABIL_DOUBLE_ATTACK,false)
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_RESISTANT_SKIN, false)
                call SetPlayerAbilityAvailable(Player(i), Status___ABIL_REFLECT_PIERCING, false)
                exitwhen i == 0
            endloop
        endfunction
//Implemented from module Status___TwoPowArray:
        function s__Status_Status___TwoPowArray___onInit takes nothing returns nothing
            local integer i=0
            local integer val=1
            loop
                set s__Status_twoPow[i]=val // thistype.twoPow[0]=1
exitwhen i == 30
                set i=i + 1
                set val=val * 2
            endloop
        endfunction
        
        ////////////////////
        // Status Effects //
        ////////////////////
        
        // Stun
        function s__Status_addStun takes integer this returns nothing
            set s__Status_stunLevel[this]=s__Status_stunLevel[this] + 1
            if s__Status_stunLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_STUN, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeStun takes integer this returns nothing
            set s__Status_stunLevel[this]=s__Status_stunLevel[this] - 1
            if s__Status_stunLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_STUN)
            endif
        endfunction
        function s__Status_isStunned takes integer this returns boolean
            return s__Status_stunLevel[this] > 0
        endfunction
        
        // Disable
        function s__Status_addDisable takes integer this returns nothing
            set s__Status_disableLevel[this]=s__Status_disableLevel[this] + 1
            if s__Status_disableLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_DISABLE, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeDisable takes integer this returns nothing
            set s__Status_disableLevel[this]=s__Status_disableLevel[this] - 1
            if s__Status_disableLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISABLE)
            endif
        endfunction
        function s__Status_isDisabled takes integer this returns boolean
            return s__Status_disableLevel[this] > 0
        endfunction
        
        // Silence
        function s__Status_addSilence takes integer this returns nothing
            set s__Status_silenceLevel[this]=s__Status_silenceLevel[this] + 1
            if s__Status_silenceLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_SILENCE, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeSilence takes integer this returns nothing
            set s__Status_silenceLevel[this]=s__Status_silenceLevel[this] - 1
            if s__Status_silenceLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_SILENCE)
            endif
        endfunction
        function s__Status_isSilenced takes integer this returns boolean
            return s__Status_silenceLevel[this] > 0
        endfunction
        
        function s__Status_addDoom takes integer this returns nothing
            set s__Status_doomLevel[this]=s__Status_doomLevel[this] + 1
            if s__Status_doomLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_DOOM, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeDoom takes integer this returns nothing
            set s__Status_doomLevel[this]=s__Status_doomLevel[this] - 1
            if s__Status_doomLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DOOM)
            endif
        endfunction
        function s__Status_isDoomed takes integer this returns boolean
            return s__Status_doomLevel[this] > 0
        endfunction
        
        // Disarm (Melee)
        function s__Status_addDisarmMelee takes integer this returns nothing
            set s__Status_disarmMeleeLevel[this]=s__Status_disarmMeleeLevel[this] + 1
            if s__Status_disarmMeleeLevel[this] > 0 then



                if s__Status_disarmRangeLevel[this] > 0 then
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_RANGE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH, Status___OID_DISARM, s__Status__get_unit(this))
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE, Status___OID_DISARM, s__Status__get_unit(this))
                endif



            endif
        endfunction
        function s__Status_addDisarmRange takes integer this returns nothing
            set s__Status_disarmRangeLevel[this]=s__Status_disarmRangeLevel[this] + 1
            if s__Status_disarmRangeLevel[this] > 0 then



                if s__Status_disarmMeleeLevel[this] > 0 then
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH, Status___OID_DISARM, s__Status__get_unit(this))
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE, Status___OID_DISARM, s__Status__get_unit(this))
                endif



            endif
        endfunction
        function s__Status_addDisarm takes integer this returns nothing
            set s__Status_disarmMeleeLevel[this]=s__Status_disarmMeleeLevel[this] + 1
            set s__Status_disarmRangeLevel[this]=s__Status_disarmRangeLevel[this] + 1
            if s__Status_disarmMeleeLevel[this] > 0 then



                if s__Status_disarmRangeLevel[this] > 0 then
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_RANGE)
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_MELEE)
                    call IssueTargetOrderById(Status___CASTER_DISARM_BOTH, Status___OID_DISARM, s__Status__get_unit(this))
                else
                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE, Status___OID_DISARM, s__Status__get_unit(this))
                endif



            else
                if s__Status_disarmRangeLevel[this] > 0 then



                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE, Status___OID_DISARM, s__Status__get_unit(this))



                endif
            endif
        endfunction
        function s__Status_removeDisarmMelee takes integer this returns nothing
            set s__Status_disarmMeleeLevel[this]=s__Status_disarmMeleeLevel[this] - 1
            if s__Status_disarmMeleeLevel[this] == 0 then
                if s__Status_disarmRangeLevel[this] > 0 then
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_BOTH)



                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE, Status___OID_DISARM, s__Status__get_unit(this))



                else
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_MELEE)
                endif
            endif
        endfunction
        function s__Status_removeDisarmRange takes integer this returns nothing
            set s__Status_disarmRangeLevel[this]=s__Status_disarmRangeLevel[this] - 1
            if s__Status_disarmRangeLevel[this] == 0 then
                if s__Status_disarmMeleeLevel[this] > 0 then
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_BOTH)



                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE, Status___OID_DISARM, s__Status__get_unit(this))



                else
                    call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_RANGE)
                endif
            endif
        endfunction
        function s__Status_removeDisarm takes integer this returns nothing
            set s__Status_disarmMeleeLevel[this]=s__Status_disarmMeleeLevel[this] - 1
            set s__Status_disarmRangeLevel[this]=s__Status_disarmRangeLevel[this] - 1
            if s__Status_disarmMeleeLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_MELEE)
                if s__Status_disarmRangeLevel[this] > 0 then



                    call IssueTargetOrderById(Status___CASTER_DISARM_RANGE, Status___OID_DISARM, s__Status__get_unit(this))



                endif
            elseif s__Status_disarmRangeLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_BOTH)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_DISARM_RANGE)
                if s__Status_disarmMeleeLevel[this] > 0 then



                    call IssueTargetOrderById(Status___CASTER_DISARM_MELEE, Status___OID_DISARM, s__Status__get_unit(this))



                endif
            endif
        endfunction
        function s__Status_isDisarmedMelee takes integer this returns boolean
            return s__Status_disarmMeleeLevel[this] > 0
        endfunction
        function s__Status_isDisarmedRange takes integer this returns boolean
            return s__Status_disarmRangeLevel[this] > 0
        endfunction
        function s__Status_isDisarmed takes integer this returns boolean
            return s__Status_disarmMeleeLevel[this] > 0 and s__Status_disarmRangeLevel[this] > 0
        endfunction
        
        // Immobolise
        function s__Status_addImmobolise takes integer this returns nothing
            set s__Status_immoboliseLevel[this]=s__Status_immoboliseLevel[this] + 1
            if s__Status_immoboliseLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_IMMOBOLISE, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeImmobolise takes integer this returns nothing
            set s__Status_immoboliseLevel[this]=s__Status_immoboliseLevel[this] - 1
            if s__Status_immoboliseLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_IMMOBOLISE_GROUND)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_IMMOBOLISE_AIR)
            endif
        endfunction
        function s__Status_isImmobolised takes integer this returns boolean
            return s__Status_immoboliseLevel[this] > 0
        endfunction
        
        // Invisibility
        function s__Status_addInvisible takes integer this returns nothing
            set s__Status_invisibleLevel[this]=s__Status_invisibleLevel[this] + 1
            if s__Status_invisibleLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_INVISIBLE)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_INVISIBLE)
            endif
        endfunction
        function s__Status_removeInvisible takes integer this returns nothing
            set s__Status_invisibleLevel[this]=s__Status_invisibleLevel[this] - 1
            if s__Status_invisibleLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_INVISIBLE)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_INVISIBLE)
            endif
        endfunction
        function s__Status_isInvisible takes integer this returns boolean
            return s__Status_invisibleLevel[this] > 0
        endfunction
        
        // Ghost
        function s__Status_addGhost takes integer this returns nothing
            set s__Status_ghostLevel[this]=s__Status_ghostLevel[this] + 1
            if s__Status_ghostLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_GHOST)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_GHOST)
            endif
        endfunction
        function s__Status_removeGhost takes integer this returns nothing
            set s__Status_ghostLevel[this]=s__Status_ghostLevel[this] - 1
            if s__Status_ghostLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_GHOST)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_GHOST)
            endif
        endfunction
        function s__Status_isGhost takes integer this returns boolean
            return s__Status_ghostLevel[this] > 0
        endfunction
        
        // Invulnerability
        function s__Status_addInvulnerable takes integer this returns nothing
            set s__Status_invulnerableLevel[this]=s__Status_invulnerableLevel[this] + 1
            if s__Status_invulnerableLevel[this] > 0 then
                call SetUnitInvulnerable(s__Status__get_unit(this), true)
            endif
        endfunction
        function s__Status_removeInvulnerable takes integer this returns nothing
            set s__Status_invulnerableLevel[this]=s__Status_invulnerableLevel[this] - 1
            if s__Status_invulnerableLevel[this] == 0 then
                call SetUnitInvulnerable(s__Status__get_unit(this), false)
            endif
        endfunction
        function s__Status_isInvulnerable takes integer this returns boolean
            return s__Status_invulnerableLevel[this] > 0
        endfunction
        
        // Spell Immunity
        function s__Status_addImmunity takes integer this returns nothing
            set s__Status_immunityLevel[this]=s__Status_immunityLevel[this] + 1
            if s__Status_immunityLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_IMMUNITY)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_IMMUNITY)
            endif
        endfunction
        function s__Status_removeImmunity takes integer this returns nothing
            set s__Status_immunityLevel[this]=s__Status_immunityLevel[this] - 1
            if s__Status_immunityLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_IMMUNITY)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_IMMUNITY)
            endif
        endfunction
        function s__Status_isImmune takes integer this returns boolean
            return s__Status_immunityLevel[this] > 0
        endfunction
        
        // Pause
        function s__Status_addPause takes integer this returns nothing
            set s__Status_pauseLevel[this]=s__Status_pauseLevel[this] + 1
            if s__Status_pauseLevel[this] > 0 then
                call PauseUnit(s__Status__get_unit(this), true)
            endif
        endfunction
        function s__Status_removePause takes integer this returns nothing
            set s__Status_pauseLevel[this]=s__Status_pauseLevel[this] - 1
            if s__Status_pauseLevel[this] == 0 then
                call PauseUnit(s__Status__get_unit(this), false)
            endif
        endfunction
        function s__Status_isPaused takes integer this returns boolean
            return s__Status_pauseLevel[this] > 0
        endfunction
        
        // Hide
        function s__Status_addHide takes integer this returns nothing
            set s__Status_hideLevel[this]=s__Status_hideLevel[this] + 1
            if s__Status_hideLevel[this] > 0 then
                call ShowUnit(s__Status__get_unit(this), false)
            endif
        endfunction
        function s__Status_removeHide takes integer this returns nothing
            set s__Status_hideLevel[this]=s__Status_hideLevel[this] - 1
            if s__Status_hideLevel[this] == 0 then
                call ShowUnit(s__Status__get_unit(this), true)
            endif
        endfunction
        function s__Status_isHidden takes integer this returns boolean
            return s__Status_hideLevel[this] > 0
        endfunction
        
        // Unpath
        function s__Status_addUnpath takes integer this returns nothing
            set s__Status_unpathLevel[this]=s__Status_unpathLevel[this] + 1
            if s__Status_unpathLevel[this] > 0 then
                call SetUnitPathing(s__Status__get_unit(this), false)
            endif
        endfunction
        function s__Status_removeUnpath takes integer this returns nothing
            set s__Status_unpathLevel[this]=s__Status_unpathLevel[this] - 1
            if s__Status_unpathLevel[this] == 0 then
                call SetUnitPathing(s__Status__get_unit(this), true)
            endif
        endfunction
        function s__Status_isUnpathed takes integer this returns boolean
            return s__Status_unpathLevel[this] > 0
        endfunction
        
        // Hex
        function s__Status_addHex takes integer this returns nothing
            set s__Status_hexLevel[this]=s__Status_hexLevel[this] + 1
            if s__Status_hexLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_HEX, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeHex takes integer this returns nothing
            set s__Status_hexLevel[this]=s__Status_hexLevel[this] - 1
            if s__Status_hexLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_HEX)
            endif
        endfunction
        function s__Status_isHexed takes integer this returns boolean
            return s__Status_hexLevel[this] > 0
        endfunction
        
        // Locust
        function s__Status_addLocust takes integer this returns nothing
            set s__Status_locustLevel[this]=s__Status_locustLevel[this] + 1
            if s__Status_locustLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), 'Aloc')
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, 'Aloc')
            endif
        endfunction
        function s__Status_removeLocust takes integer this returns nothing
            set s__Status_locustLevel[this]=s__Status_locustLevel[this] - 1
            if s__Status_locustLevel[this] == 0 then
                call ShowUnit(s__Status__get_unit(this), false)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, 'Aloc')
                call UnitRemoveAbility(s__Status__get_unit(this), 'Aloc')
                call ShowUnit(s__Status__get_unit(this), true)
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_UNLOCUST)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_UNLOCUST)
                call IssueImmediateOrderById(s__Status__get_unit(this), Status___OID_UNLOCUST)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_UNLOCUST)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_UNLOCUST)
            endif
        endfunction
        function s__Status_isLocust takes integer this returns boolean
            return s__Status_locustLevel[this] > 0
        endfunction
        
        // Never Miss
        function s__Status_addNeverMiss takes integer this returns nothing
            set s__Status_neverMissLevel[this]=s__Status_neverMissLevel[this] + 1
            if s__Status_neverMissLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_NEVER_MISS)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_NEVER_MISS)
            endif
        endfunction
        function s__Status_removeNeverMiss takes integer this returns nothing
            set s__Status_neverMissLevel[this]=s__Status_neverMissLevel[this] - 1
            if s__Status_neverMissLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_NEVER_MISS)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_NEVER_MISS)
            endif
        endfunction
        function s__Status_isNeverMiss takes integer this returns boolean
            return s__Status_neverMissLevel[this] > 0
        endfunction
        
        // Always Miss
        function s__Status_addAlwaysMiss takes integer this returns nothing
            set s__Status_alwaysMissLevel[this]=s__Status_alwaysMissLevel[this] + 1
            if s__Status_alwaysMissLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_ALWAYS_MISS)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_ALWAYS_MISS)
            endif
        endfunction
        function s__Status_alwaysNeverMiss takes integer this returns nothing
            set s__Status_alwaysMissLevel[this]=s__Status_alwaysMissLevel[this] - 1
            if s__Status_alwaysMissLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_ALWAYS_MISS)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_ALWAYS_MISS)
            endif
        endfunction
        function s__Status_isAlwaysMiss takes integer this returns boolean
            return s__Status_alwaysMissLevel[this] > 0
        endfunction
        
        // Untouchable
        function s__Status_addUntouchable takes integer this returns nothing
            set s__Status_untouchableLevel[this]=s__Status_untouchableLevel[this] + 1
            if s__Status_untouchableLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_UNTOUCHABLE)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_UNTOUCHABLE)
            endif
        endfunction
        function s__Status_removeUntouchable takes integer this returns nothing
            set s__Status_untouchableLevel[this]=s__Status_untouchableLevel[this] - 1
            if s__Status_untouchableLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_UNTOUCHABLE)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_UNTOUCHABLE)
            endif
        endfunction
        function s__Status_isUntouchable takes integer this returns boolean
            return s__Status_untouchableLevel[this] > 0
        endfunction
        
        // Banish
        function s__Status_addBanish takes integer this returns nothing
            set s__Status_banishLevel[this]=s__Status_banishLevel[this] + 1
            if s__Status_banishLevel[this] > 0 then



                call IssueTargetOrderById(s__Status_dummyCaster, Status___OID_BANISH, s__Status__get_unit(this))



            endif
        endfunction
        function s__Status_removeBanish takes integer this returns nothing
            set s__Status_banishLevel[this]=s__Status_banishLevel[this] - 1
            if s__Status_banishLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_BANISH)
            endif
        endfunction
        function s__Status_isBanished takes integer this returns boolean
            return s__Status_banishLevel[this] > 0
        endfunction
        
        // Phase
        function s__Status_addPhase takes integer this returns nothing
            set s__Status_phaseLevel[this]=s__Status_phaseLevel[this] + 1
            if s__Status_phaseLevel[this] > 0 then
                call SetPlayerAbilityAvailable(GetOwningPlayer(s__Status__get_unit(this)), Status___ABIL_PHASE, true)
                if UnitAddAbility(s__Status__get_unit(this), Status___ABIL_PHASE) then
                    call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_PHASE)
                endif
                call IssueImmediateOrderById(s__Status__get_unit(this), Status___OID_PHASE)
                call SetPlayerAbilityAvailable(GetOwningPlayer(s__Status__get_unit(this)), Status___ABIL_PHASE, false)
            endif
        endfunction
        function s__Status_removePhase takes integer this returns nothing
            set s__Status_phaseLevel[this]=s__Status_phaseLevel[this] - 1
            if s__Status_phaseLevel[this] == 0 then
                call UnitRemoveAbility(s__Status__get_unit(this), Status___BUFF_PHASE)
            endif
        endfunction
        function s__Status_isPhased takes integer this returns boolean
            return s__Status_phaseLevel[this] > 0
        endfunction
        
        // Resistant Skin
        function s__Status_addResistantSkin takes integer this returns nothing
            set s__Status_resistantSkinLevel[this]=s__Status_resistantSkinLevel[this] + 1
            if s__Status_resistantSkinLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_RESISTANT_SKIN)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_RESISTANT_SKIN)
            endif
        endfunction
        function s__Status_removeResistantSkin takes integer this returns nothing
            set s__Status_resistantSkinLevel[this]=s__Status_resistantSkinLevel[this] - 1
            if s__Status_resistantSkinLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_RESISTANT_SKIN)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_RESISTANT_SKIN)
            endif
        endfunction
        function s__Status_isResistantSkin takes integer this returns boolean
            return s__Status_resistantSkinLevel[this] > 0
        endfunction
        
        // Reflect Piercing
        function s__Status_addReflectPiercing takes integer this returns nothing
            set s__Status_reflectPiercingLevel[this]=s__Status_reflectPiercingLevel[this] + 1
            if s__Status_reflectPiercingLevel[this] > 0 then
                call UnitAddAbility(s__Status__get_unit(this), Status___ABIL_REFLECT_PIERCING)
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), true, Status___ABIL_REFLECT_PIERCING)
            endif
        endfunction
        function s__Status_removeReflectPiercing takes integer this returns nothing
            set s__Status_reflectPiercingLevel[this]=s__Status_reflectPiercingLevel[this] - 1
            if s__Status_reflectPiercingLevel[this] == 0 then
                call UnitMakeAbilityPermanent(s__Status__get_unit(this), false, Status___ABIL_REFLECT_PIERCING)
                call UnitRemoveAbility(s__Status__get_unit(this), Status___ABIL_REFLECT_PIERCING)
            endif
        endfunction
        function s__Status_isReflectPiercing takes integer this returns boolean
            return s__Status_reflectPiercingLevel[this] > 0
        endfunction
        
        
        ////////////////////
        // Status Bonuses //
        ////////////////////
        function s__Status_setBonus takes unit u,integer abil,integer levels,integer amount returns nothing
            local boolean addNeg=false
            if amount < 0 then
                set addNeg=true
                set amount=amount + s__Status_twoPow[levels]
            else
                call UnitMakeAbilityPermanent(u, false, abil)
                call UnitRemoveAbility(u, abil)
            endif
            
            set abil=abil + levels
            set levels=s__Status_twoPow[levels]
            loop
                set levels=levels / 2
                
                if amount >= levels then
                    call UnitAddAbility(u, abil)
                    call UnitMakeAbilityPermanent(u, true, abil)
                    set amount=amount - levels
                else
                    call UnitMakeAbilityPermanent(u, false, abil)
                    call UnitRemoveAbility(u, abil)
                endif
                
                set abil=abil - 1
                exitwhen levels == 1
            endloop
            
            if addNeg then
                call UnitAddAbility(u, abil)
                call UnitMakeAbilityPermanent(u, true, abil)
            endif
        endfunction
        
        function s__Status_modArmorBonus takes integer this,integer amount returns nothing
            set s__Status_armorBonus[this]=s__Status_armorBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_ARMOR , Status___LEVELS_ARMOR , s__Status_armorBonus[this])
        endfunction
        function s__Status_getArmorBonus takes integer this returns integer
            return s__Status_armorBonus[this]
        endfunction
        
        function s__Status_modDamageBonus takes integer this,integer amount returns nothing
            set s__Status_damageBonus[this]=s__Status_damageBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_DAMAGE , Status___LEVELS_DAMAGE , s__Status_damageBonus[this])
        endfunction
        function s__Status_getDamageBonus takes integer this returns integer
            return s__Status_damageBonus[this]
        endfunction
        
        function s__Status_modStrBonus takes integer this,integer amount returns nothing
            set s__Status_strBonus[this]=s__Status_strBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_STR , Status___LEVELS_STR , s__Status_strBonus[this])
        endfunction
        function s__Status_getStrBonus takes integer this returns integer
            return s__Status_strBonus[this]
        endfunction
        
        function s__Status_modAgiBonus takes integer this,integer amount returns nothing
            set s__Status_agiBonus[this]=s__Status_agiBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_AGI , Status___LEVELS_AGI , s__Status_agiBonus[this])
        endfunction
        function s__Status_getAgiBonus takes integer this returns integer
            return s__Status_agiBonus[this]
        endfunction
        
        function s__Status_modIntBonus takes integer this,integer amount returns nothing
            set s__Status_intBonus[this]=s__Status_intBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_INT , Status___LEVELS_INT , s__Status_intBonus[this])
        endfunction
        function s__Status_getIntBonus takes integer this returns integer
            return s__Status_intBonus[this]
        endfunction
        
        function s__Status_modAttackSpeedBonus takes integer this,integer amount returns nothing
            set s__Status_attackSpeedBonus[this]=s__Status_attackSpeedBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_ATTACK_SPEED , Status___LEVELS_ATTACK_SPEED , s__Status_attackSpeedBonus[this])
        endfunction
        function s__Status_getAttackSpeedBonus takes integer this returns integer
            return s__Status_attackSpeedBonus[this]
        endfunction
        
        function s__Status_modHealthBonus takes integer this,integer amount returns nothing
            set s__Status_healthBonus[this]=s__Status_healthBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_HEALTH , Status___LEVELS_HEALTH , s__Status_healthBonus[this])
        endfunction
        function s__Status_getHealthBonus takes integer this returns integer
            return s__Status_healthBonus[this]
        endfunction
        
        function s__Status_modManaBonus takes integer this,integer amount returns nothing
            set s__Status_manaBonus[this]=s__Status_manaBonus[this] + amount
            call s__Status_setBonus(s__Status__get_unit(this) , Status___ABIL_MANA , Status___LEVELS_MANA , s__Status_manaBonus[this])
        endfunction
        function s__Status_getManaBonus takes integer this returns integer
            return s__Status_manaBonus[this]
        endfunction
        
        // Periodic bonuses
        
        function s__Status_healthRegenPeriodic takes nothing returns nothing
            set s__Status_updateUnit=GetEnumUnit()
            if UnitAlive(s__Status_updateUnit) then
                call SetWidgetLife(s__Status_updateUnit, GetWidgetLife(s__Status_updateUnit) + s__Status_healthRegenBonus[s__Status__staticgetindex(s__Status_updateUnit)])
            endif
        endfunction
        function s__Status_modHealthRegenBonus takes integer this,real amount returns nothing
            set s__Status_healthRegenBonus[this]=s__Status_healthRegenBonus[this] + amount * Status___PERIOD
            if s__Status_healthRegenBonus[this] == 0 then
                call GroupRemoveUnit(s__Status_healthRegenGroup, s__Status__get_unit(this))
            else
                call GroupAddUnit(s__Status_healthRegenGroup, s__Status__get_unit(this))
            endif
        endfunction
        function s__Status_getHealthRegenBonus takes integer this returns real
            return s__Status_healthRegenBonus[this] / Status___PERIOD
        endfunction
        
        function s__Status_manaRegenPeriodic takes nothing returns nothing
            set s__Status_updateUnit=GetEnumUnit()
            if UnitAlive(s__Status_updateUnit) then
                call SetUnitState(s__Status_updateUnit, UNIT_STATE_MANA, GetUnitState(s__Status_updateUnit, UNIT_STATE_MANA) + s__Status_manaRegenBonus[s__Status__staticgetindex(s__Status_updateUnit)])
            endif
        endfunction
        function s__Status_modManaRegenBonus takes integer this,real amount returns nothing
            set s__Status_manaRegenBonus[this]=s__Status_manaRegenBonus[this] + amount * Status___PERIOD
            if s__Status_manaRegenBonus[this] == 0 then
                call GroupRemoveUnit(s__Status_manaRegenGroup, s__Status__get_unit(this))
            else
                call GroupAddUnit(s__Status_manaRegenGroup, s__Status__get_unit(this))
            endif
        endfunction
        function s__Status_getManaRegenBonus takes integer this returns real
            return s__Status_manaRegenBonus[this] / Status___PERIOD
        endfunction
        
        function s__Status_healthRegenPercentPeriodic takes nothing returns nothing
            set s__Status_updateUnit=GetEnumUnit()
            if UnitAlive(s__Status_updateUnit) then
                call SetWidgetLife(s__Status_updateUnit, GetWidgetLife(s__Status_updateUnit) + GetUnitState(s__Status_updateUnit, UNIT_STATE_MAX_LIFE) * s__Status_healthRegenPercentBonus[s__Status__staticgetindex(s__Status_updateUnit)])
            endif
        endfunction
        function s__Status_modHealthRegenPercentBonus takes integer this,real amount returns nothing
            set s__Status_healthRegenPercentBonus[this]=s__Status_healthRegenPercentBonus[this] + amount * Status___PERIOD * 0.01
            if s__Status_healthRegenPercentBonus[this] == 0 then
                call GroupRemoveUnit(s__Status_healthRegenPercentGroup, s__Status__get_unit(this))
            else
                call GroupAddUnit(s__Status_healthRegenPercentGroup, s__Status__get_unit(this))
            endif
        endfunction
        function s__Status_getHealthRegenPercentBonus takes integer this returns real
            return s__Status_healthRegenPercentBonus[this] / Status___PERIOD / 0.01
        endfunction
        
        function s__Status_manaRegenPercentPeriodic takes nothing returns nothing
            set s__Status_updateUnit=GetEnumUnit()
            if UnitAlive(s__Status_updateUnit) then
                call SetUnitState(s__Status_updateUnit, UNIT_STATE_MANA, GetUnitState(s__Status_updateUnit, UNIT_STATE_MANA) + GetUnitState(s__Status_updateUnit, UNIT_STATE_MAX_MANA) * s__Status_manaRegenPercentBonus[s__Status__staticgetindex(s__Status_updateUnit)])
            endif
        endfunction
        function s__Status_modManaRegenPercentBonus takes integer this,real amount returns nothing
            set s__Status_manaRegenPercentBonus[this]=s__Status_manaRegenPercentBonus[this] + amount * Status___PERIOD * 0.01
            if s__Status_manaRegenPercentBonus[this] == 0 then
                call GroupRemoveUnit(s__Status_manaRegenPercentGroup, s__Status__get_unit(this))
            else
                call GroupAddUnit(s__Status_manaRegenPercentGroup, s__Status__get_unit(this))
            endif
        endfunction
        function s__Status_getManaRegenPercentBonus takes integer this returns real
            return s__Status_manaRegenPercentBonus[this] / Status___PERIOD / 0.01
        endfunction
        
        // Links periodic effects.
        function s__Status_periodicLink takes nothing returns nothing
            call ForGroup(s__Status_healthRegenGroup, function s__Status_healthRegenPeriodic)
            call ForGroup(s__Status_manaRegenGroup, function s__Status_manaRegenPeriodic)
            call ForGroup(s__Status_healthRegenPercentGroup, function s__Status_healthRegenPercentPeriodic)
            call ForGroup(s__Status_manaRegenPercentGroup, function s__Status_manaRegenPercentPeriodic)
        endfunction
//Implemented from module Status___StaticPeriodic:
        function s__Status_Status___StaticPeriodic___onInit takes nothing returns nothing
            call TimerStart(CreateTimer(), Status___PERIOD, true, function s__Status_periodicLink)
        endfunction
        
        ////////////////////
        // Movement Speed //
        ////////////////////
        
        function s__Status_periodic takes integer this returns nothing
            set s__Status_updateUnit=s__Status__get_unit(this)
            set s__Status_updateUnitX=GetUnitX(s__Status_updateUnit)
            set s__Status_updateUnitY=GetUnitY(s__Status_updateUnit)
            set s__Status_xInc=s__Status_updateUnitX - s__Status_x[this]
            set s__Status_yInc=s__Status_updateUnitY - s__Status_y[this]
            set s__Status_updateDist=SquareRoot(s__Status_xInc * s__Status_xInc + s__Status_yInc * s__Status_yInc)
            if s__Status_updateDist > 0 then
                if UnitAlive(s__Status_updateUnit) and s__Status_disableLevel[this] <= 0 and s__Status_stunLevel[this] <= 0 and s__Status_pauseLevel[this] <= 0 and s__Status_immoboliseLevel[this] <= 0 and GetUnitMoveSpeed(s__Status_updateUnit) > 0 then
                    if s__Status_moveSpeedPercentBonus[this] != 0.0 then
                        set s__Status_updateUnitX=s__Status_updateUnitX + s__Status_xInc * s__Status_moveSpeedPercentBonus[this]
                        set s__Status_updateUnitY=s__Status_updateUnitY + s__Status_yInc * s__Status_moveSpeedPercentBonus[this]
                    endif
                    if s__Status_moveSpeedBonus[this] != 0.0 then
                        set s__Status_updateDist=s__Status_moveSpeedBonus[this] / s__Status_updateDist
                        set s__Status_updateUnitX=s__Status_updateUnitX + s__Status_xInc * s__Status_updateDist
                        set s__Status_updateUnitY=s__Status_updateUnitY + s__Status_yInc * s__Status_updateDist
                    endif
                    call SetUnitX(s__Status_updateUnit, s__Status_updateUnitX)
                    call SetUnitY(s__Status_updateUnit, s__Status_updateUnitY)
                endif
            endif
            set s__Status_x[this]=s__Status_updateUnitX
            set s__Status_y[this]=s__Status_updateUnitY
        endfunction
//Implemented from module T32xs:
        
        function s__Status_T32xs___PeriodicLoop takes nothing returns boolean
            local integer this=s__Status_T32xs___next[(0)]
            loop
                exitwhen this == 0
                call s__Status_periodic(this)
                set this=s__Status_T32xs___next[this]
            endloop
            return false
        endfunction
        function s__Status_startPeriodic takes integer this returns nothing
            if not s__Status_T32xs___runningPeriodic[this] then
                set s__Status_T32xs___prev[s__Status_T32xs___next[(0)]]=this
                set s__Status_T32xs___next[this]=s__Status_T32xs___next[(0)]
                set s__Status_T32xs___next[(0)]=this
                set s__Status_T32xs___prev[this]=(0)
                
                set s__Status_T32xs___runningPeriodic[this]=true
            endif
        endfunction
        
        function s__Status_stopPeriodic takes integer this returns nothing
            if s__Status_T32xs___runningPeriodic[this] then
                // This is some real magic.
                set s__Status_T32xs___next[s__Status_T32xs___prev[this]]=s__Status_T32xs___next[this]
                set s__Status_T32xs___prev[s__Status_T32xs___next[this]]=s__Status_T32xs___prev[this]
                // This will even work for the starting element.
                
                set s__Status_T32xs___runningPeriodic[this]=false
            endif
        endfunction
        
        function s__Status_T32xs___onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig, Condition(function s__Status_T32xs___PeriodicLoop))
        endfunction
        function s__Status_modMoveSpeedBonus takes integer this,real amount returns nothing
            set s__Status_moveSpeedBonus[this]=s__Status_moveSpeedBonus[this] + amount * T32_PERIOD
            if s__Status_moveSpeedBonus[this] == 0 and s__Status_moveSpeedPercentBonus[this] == 0 then
                call s__Status_stopPeriodic(this)
            else
                set s__Status_x[this]=GetUnitX(s__Status__get_unit(this))
                set s__Status_y[this]=GetUnitY(s__Status__get_unit(this))
                call s__Status_startPeriodic(this)
            endif
        endfunction
        function s__Status_getMoveSpeedBonus takes integer this returns real
            return s__Status_moveSpeedBonus[this] / T32_PERIOD
        endfunction
        function s__Status_modMoveSpeedPercentBonus takes integer this,real amount returns nothing
            set s__Status_moveSpeedPercentBonus[this]=s__Status_moveSpeedPercentBonus[this] + amount * 0.01
            if s__Status_moveSpeedBonus[this] == 0 and s__Status_moveSpeedPercentBonus[this] == 0 then
                call s__Status_stopPeriodic(this)
            else
                set s__Status_x[this]=GetUnitX(s__Status__get_unit(this))
                set s__Status_y[this]=GetUnitY(s__Status__get_unit(this))
                call s__Status_startPeriodic(this)
            endif
        endfunction
        function s__Status_getMoveSpeedPercentBonus takes integer this returns real
            return s__Status_moveSpeedPercentBonus[this] / 0.01
        endfunction

//library Status ends
//library VectorLib:

//library VectorLib ends
//library CameraLock:
function TrackCamera takes real x,real y,integer i returns nothing
    if ( GetLocalPlayer() == Player(i) ) then
        call PanCameraToTimed(x, y, 1)
    endif
endfunction
function CameraLockAction takes nothing returns nothing
    local integer i= 0
    local real dir= 0
    local real x
    local real y
    local real d= 500
    if g_camera_lock then
        if heros[i] != null and IsUnitAliveBJ(heros[i]) then
            set dir=getFacing(heros[i])
            set x=GetUnitX(heros[i]) + Cos(dir) * d
            set y=GetUnitY(heros[i]) + Sin(dir) * d
            call TrackCamera(x , y , i)
        endif
    endif
endfunction
    
function CameraLockInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer, 0.1, true, function CameraLockAction)
endfunction

//library CameraLock ends
//library FakeMan:
function FakeManInit takes nothing returns nothing
endfunction
//Implemented from module List:
    
    
    
        function s__RealMan_getLength takes nothing returns integer
            return s__RealMan_List___length
        endfunction
    
        function s__RealMan_getFirst takes nothing returns integer
            return s__RealMan_List___first
        endfunction
    
        function s__RealMan_getLast takes nothing returns integer
            return s__RealMan_List___last
        endfunction
    
        function s__RealMan_getRandom takes nothing returns integer
            local integer s= s__RealMan_List___first
            local integer array list
            local integer n= - 1
            loop
                exitwhen s == 0
                set n=n + 1
                set list[n]=s
                set s=s__RealMan_List___next[s]
            endloop
            if n == - 1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endfunction
    
        function s__RealMan_getNext takes integer this returns integer
            return s__RealMan_List___next[this]
        endfunction
    
        function s__RealMan_getPrev takes integer this returns integer
            return s__RealMan_List___prev[this]
        endfunction
    
        function s__RealMan_inList takes integer this returns boolean
            return s__RealMan_List___inlist[this]
        endfunction
        function s__RealMan_addList takes integer this returns boolean
            if not s__RealMan_List___inlist[this] and not s__RealMan_List___destroyinglist then
                set s__RealMan_List___inlist[this]=true
                if s__RealMan_List___first == 0 then
                    set s__RealMan_List___first=this
                else
                    set s__RealMan_List___prev[this]=s__RealMan_List___last
                    set s__RealMan_List___next[s__RealMan_List___prev[this]]=this
                endif
                set s__RealMan_List___last=this
                set s__RealMan_List___length=s__RealMan_List___length + 1
                return true
            endif
            return false
        endfunction
    
        function s__RealMan_removeList takes integer this returns boolean
            if s__RealMan_List___inlist[this] then
                if s__RealMan_List___destroyinglist then
                    return true
                endif
                set s__RealMan_List___inlist[this]=false
                if s__RealMan_List___first == this then
                    set s__RealMan_List___first=s__RealMan_List___next[this]
                endif
                if s__RealMan_List___last == this then
                    set s__RealMan_List___last=s__RealMan_List___prev[this]
                endif
                set s__RealMan_List___next[s__RealMan_List___prev[this]]=s__RealMan_List___next[this]
                set s__RealMan_List___prev[s__RealMan_List___next[this]]=s__RealMan_List___prev[this]
                set s__RealMan_List___length=s__RealMan_List___length - 1
                return true
            endif
            return false
        endfunction
    
        function s__RealMan_destroyList takes nothing returns nothing
            local integer s= s__RealMan_List___first
            if not s__RealMan_List___destroyinglist then
                loop
                    exitwhen s == 0
                    set s__RealMan_List___destroyinglist=false
                    call s__RealMan_removeList(s)
                    set s__RealMan_List___destroyinglist=true
                    call sc__RealMan_deallocate(s)
                    set s=s__RealMan_List___next[s]
                endloop
                set s__RealMan_List___destroyinglist=false
            endif
        endfunction
    
    function s__RealMan_create takes unit man returns integer
        local integer ys= s__RealMan__allocate()
            set s__RealMan_man[ys]=man
            call s__RealMan_addList(ys)
        return ys
    endfunction
    function s__RealMan_onDestroy takes integer this returns nothing
        call s__RealMan_removeList(this)
    endfunction

//Generated destructor of RealMan
function s__RealMan_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__RealMan_V[this]!=-1) then
        return
    endif
    call s__RealMan_onDestroy(this)
    set si__RealMan_V[this]=si__RealMan_F
    set si__RealMan_F=this
endfunction
    function s__RealMan_CheckLevel takes real x,real y,string lv returns string
        local real distance= 1000000
        local real temp
        local integer ys= s__RealMan_getFirst()
        loop
            exitwhen ys == 0
            set temp=DistanceUnitAndXY(s__RealMan_man[ys] , x , y)
            if temp < distance then
                set distance=temp
            endif
            set ys=s__RealMan_getNext(ys)
        endloop
        if distance >= LV_FREEZ_DISTANCE then
            return lv
        endif
        return LV_ACTIVE
    endfunction
function AddRealMan takes unit man returns nothing
    call s__RealMan_create(man)
endfunction

//library FakeMan ends
//library FogControl:
function FogControlAction takes nothing returns nothing
    local integer i= 0
    local real x
    local real y
    local location l
    if g_fog then
        if heros[i] != null and IsUnitAliveBJ(heros[i]) then
            if fogms[i] != null then
                call FogModifierStop(fogms[i])
                call DestroyFogModifier(fogms[i])
            endif
            set x=GetUnitX(heros[i])
            set y=GetUnitY(heros[i])
            set l=Location(x, y)
            set fogms[i]=CreateFogModifierRadiusLocBJ(true, Player(i), FOG_OF_WAR_VISIBLE, l, s__IHeroData_vision[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[i])]])
            set l=null
        endif
    endif
endfunction
    
function FogControlInit takes nothing returns nothing
    set fctimer=CreateTimer()
    call TimerStart(fctimer, 1, true, function FogControlAction)
endfunction

//library FogControl ends
//library ItemEquip:
function HasConflictItemType takes unit u,item itm returns boolean
local integer i=0
local integer t
local integer typeid=GetItemTypeId(itm)
local item ui
if HaveSavedInteger(ht, typeid, kit) == false then
    return false
endif
set t=LoadInteger(ht, typeid, kit)
loop
    exitwhen i > 5
    set ui=UnitItemInSlot(u, i)
    if ui != itm and LoadInteger(ht, GetItemTypeId(ui), kit) == t then
        return true
    endif
    set i=i + 1
endloop
return false
endfunction
function UnequipGun takes unit u,item i returns nothing
endfunction
function EquipGun takes unit u,item i returns nothing
    local integer t= GetItemTypeId(i)
    local integer gun= s__ItemFeatureData_gun[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(i)]]
    call sc__IGun_setOwner(gun,u)
    set s__EquipmentData_gun[s__EquipmentData__staticgetindex(u)]=gun
    set s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+GUN]=t
endfunction
function AddItemSpell takes unit u,integer itemType returns nothing
    local integer data= getItemTypeData(itemType)
    local integer spell= s__ItemTypeData_spell[data]
    local integer lv= GetUnitAbilityLevel(GetTriggerUnit(), spell)
    if lv == 0 then
        call UnitAddAbility(u, spell)
    endif
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, true)
    call s__ItemTypeData_deallocate(data)
endfunction
function RemoveItemSpell takes unit u,integer itemType returns nothing
    local integer data= getItemTypeData(itemType)
    local integer spell= s__ItemTypeData_spell[data]
    call SetPlayerAbilityAvailable(GetOwningPlayer(u), spell, false)
    call s__ItemTypeData_deallocate(data)
endfunction
function AddItemStaticAbility takes unit u,integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local integer data= getItemTypeData(itemType)
//textmacro instance: AddStaticAbility("s1")
    set s1=s__ItemTypeData_s1[data]
    if s1 != 0 then
        call UnitAddAbility(u, s1)
    endif
//end of: AddStaticAbility("s1")
//textmacro instance: AddStaticAbility("s2")
    set s2=s__ItemTypeData_s2[data]
    if s2 != 0 then
        call UnitAddAbility(u, s2)
    endif
//end of: AddStaticAbility("s2")
//textmacro instance: AddStaticAbility("s3")
    set s3=s__ItemTypeData_s3[data]
    if s3 != 0 then
        call UnitAddAbility(u, s3)
    endif
//end of: AddStaticAbility("s3")
call s__ItemTypeData_deallocate(data)
endfunction
function RemoveItemStaticAbility takes unit u,integer itemType returns nothing
local integer s1
local integer s2
local integer s3
local integer s4
local integer s5
local integer data= getItemTypeData(itemType)
//textmacro instance: RemoveStaticAbility("s1")
    set s1=s__ItemTypeData_s1[getItemTypeData(itemType)]
    if s1 != 0 then
        call UnitRemoveAbility(u, s1)
    endif
//end of: RemoveStaticAbility("s1")
//textmacro instance: RemoveStaticAbility("s2")
    set s2=s__ItemTypeData_s2[getItemTypeData(itemType)]
    if s2 != 0 then
        call UnitRemoveAbility(u, s2)
    endif
//end of: RemoveStaticAbility("s2")
//textmacro instance: RemoveStaticAbility("s3")
    set s3=s__ItemTypeData_s3[getItemTypeData(itemType)]
    if s3 != 0 then
        call UnitRemoveAbility(u, s3)
    endif
//end of: RemoveStaticAbility("s3")
call s__ItemTypeData_deallocate(data)
endfunction
function ItemEquip takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType= GetItemTypeId(i)
    local integer t
    local integer itd
    local integer d
    local string s
    if GetUnitTypeId(u) == HERO then
        if hasItemTypeData(itemType) then
            set itd=getItemTypeData(itemType)
            set t=s__ItemTypeData_itemType[itd]
            if t == AB1 or t == AB2 then
                if s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+t] > 0 then
                    if t == AB1 then
                        set s=MAJOR_AB
                    else
                        set s=MINOR_AB
                    endif
                    set d=sc__ChangeAbDialog_create("鏄惁鍒囨崲" + s + "锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥? , GetOwningPlayer(u) , t , s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+t] , itemType)
                    call sc__IDialog_display(d)
                else
                    call AddItemSpell(u , itemType)
                    call AddItemStaticAbility(u , itemType)
                    set s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+t]=itemType
                endif
            elseif t == GUN then
                if s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+t] > 0 then
                    set d=sc__ChangeGunDialog_create("鏄惁鍒囨崲鏋锛焲n鎵€鏈夎姳璐圭殑鏀硅鐐规暟灏嗕細琚繑鍥? , GetOwningPlayer(u) , t , s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+t] , itemType , i)
                    call sc__IDialog_display(d)
                else
                    call EquipGun(u , i)
                endif
            endif
            call s__ItemTypeData_deallocate(itd)
        endif
    endif
    set u=null
endfunction
function DropItem takes unit u,integer t returns nothing
    local integer i= 0
    local item itm
    loop
        exitwhen i > 5
        set itm=UnitItemInSlot(u, i)
        if GetItemTypeId(itm) == t then
            call UnitRemoveItemSwapped(itm, u)
        endif
        set i=i + 1
    endloop
    set itm=null
endfunction
function UnEquipItem takes nothing returns nothing
    local item i=GetManipulatedItem()
    local unit u=GetTriggerUnit()
    local integer itemType=GetItemTypeId(i)
    if GetUnitTypeId(u) == HERO then
        if hasItemTypeData(itemType) then
            call RemoveItemSpell(u , itemType)
            call RemoveItemStaticAbility(u , itemType)
        endif
    endif
    set u=null
endfunction
function InitItemEquip takes nothing returns nothing
local trigger t=CreateTrigger()
local trigger t2=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddCondition(t, Condition(function ItemEquip))
call TriggerRegisterAnyUnitEventBJ(t2, EVENT_PLAYER_UNIT_DROP_ITEM)
call TriggerAddCondition(t2, Condition(function UnEquipItem))
set t=null
set t2=null
endfunction

//library ItemEquip ends
//library ShootTarget:
function ShootEnergy takes nothing returns nothing
//local damagetype dt = Damage_GetType()
//local unit ds = GetEventDamageSource()
local unit ds= GetAttacker()
//if dt == DAMAGE_TYPE_NORMAL and GetUnitTypeId(ds) == 'h000' then
if GetUnitTypeId(ds) == HERO or GetUnitTypeId(ds) == EVIL_MARIN then
    set s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(ds)]]=GetTriggerUnit()
    //call BJDebugMsg(R2S( GetTimeOfDay()))
    if s__EquipmentData_gun[s__EquipmentData__staticgetindex(ds)] != null then
        call sc__IGun_fire(s__EquipmentData_gun[s__EquipmentData__staticgetindex(ds)])
    endif
endif
set ds=null
endfunction
function InitShootTarget takes nothing returns nothing
set gtrgShootTarget=CreateTrigger()
//all Damage_RegisterEvent( gtrgShootTarget)
call TriggerRegisterAnyUnitEventBJ(gtrgShootTarget, EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gtrgShootTarget, Condition(function ShootEnergy))
endfunction

//library ShootTarget ends
//library StartRoom:
function GamePlay_GaveGuns takes nothing returns nothing
    call TriggerSleepAction(1)
    call MovieStart()
    call MoveCamera(1221 , - 1785)
    call TriggerSleepAction(2)
    call CreateEffect(E_GUN_SHOW , 1214 , - 1470)
    call CreateEffect(E_GUN_SHOW , 1214 , - 1784)
    call CreateEffect(E_GUN_SHOW , 1214 , - 2109)
    call TriggerSleepAction(5)
    call MovieSay(act1 , "鍗фЫ锛屼粈涔堢帺鎰忓効锛?)
    call MovieSay(act1 , "鐩磋鍛婅瘔鎴戜笉瑕佺瀹冧滑")
    call MovieEnd()
endfunction
function GamePlay_StartRoom_Open_Gate takes nothing returns nothing
    if not gateOpened then
        call TriggerSleepAction(1)
        call MovieStart()
        call StartShake()
        call TriggerSleepAction(2)
        call MovieSay(act1 , "浠€涔堟儏鍐碉紒锛熴€傘€傘€?)
        call MoveCamera(3498.00 , - 1767.00)
        call TriggerSleepAction(5)
        call RemoveUnit(gg_unit_h006_0185)
        call RemoveUnit(gg_unit_h006_0184)
        call RemoveUnit(gg_unit_h006_0048)
        call RemoveUnit(gg_unit_h006_0049)
        call RemoveUnit(gg_unit_h006_0065)
        call RemoveUnit(gg_unit_h006_0186)
        call RemoveUnit(gg_unit_h006_0187)
        call RemoveUnit(gg_unit_h006_0188)
        set gateOpened=true
        call StopShake()
        call MovieSay(act1 , "鐭冲鎵撳紑浜嗐€傘€傘€?)
        call MovieEnd()
        call LockAgain()
        call Seen(gg_rct_start_road_1)
    endif
endfunction
function GamePlay_StartRoom_Action takes nothing returns nothing
    local real x
    local real y
    local real tx= 0
    local real ty= 0
    local unit u= GetTriggerUnit()
    local integer i= 0
    local integer j= 0
    if not IsHero(u) then
        return
    endif
    set x=GetUnitX(u)
    set y=GetUnitY(u)
    loop
        exitwhen i >= 4
        set j=0
        loop
            exitwhen j >= 60
            if ModuloInteger(j, 4) == 0 then
                set ty=y
                set tx=x + j * 100
            elseif ModuloInteger(j, 4) == 1 then
                set tx=x - j * 100
                set ty=y
            elseif ModuloInteger(j, 4) == 2 then
                set ty=y + j * 100
                set tx=x
            else
                set ty=y - j * 100
                set tx=x
            endif
            if IsPointInRegion(GetTriggeringRegion(), tx, ty) then
                call SetUnitX(u, tx)
                call SetUnitY(u, ty)
                set i=100
                set j=1000
            endif
            set j=j + 1
        endloop
        set i=i + 1
    endloop
    set u=null
endfunction
function GamePlay_StartRoom takes nothing returns nothing
    local trigger trg= CreateTrigger()
    local trigger trg2= CreateTrigger()
    local trigger trg3= CreateTrigger()
    local region r= CreateRegion()
    local integer i= 0
    call RegionAddRect(r, gg_rct_start_road_1)
    call RegionAddRect(r, gg_rct_start_road_2)
    call TriggerRegisterLeaveRegionSimple(trg, r)
    call TriggerAddAction(trg, function GamePlay_StartRoom_Action)
    call YDWETriggerRegisterEnterRectSimpleNull(trg2 , gg_rct_start_road_gate)
    call TriggerAddAction(trg2, function GamePlay_StartRoom_Open_Gate)
    call YDWETriggerRegisterEnterRectSimpleNull(trg3 , gg_rct_gave_guns)
    call TriggerAddAction(trg3, function GamePlay_GaveGuns)
    loop
        exitwhen i >= 3
        if heros[i] != null then
            set cur_player=cur_player + 1
        endif
        set i=i + 1
    endloop
endfunction

//library StartRoom ends
//library Strong:
function DoStrongCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    local real strong
    local real dam= GetEventDamage()
    local real doge
    if dam > 0.1 and IsHero(u) then
        set doge=s__IHeroData_doge[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]
        if GetRandomReal(0, 1) <= doge then
            call Damage_BlockAll()
            call DestroyEffect(AddSpecialEffect(E_DOGE, GetUnitX(u), GetUnitY(u)))
        else
            set strong=s__IHeroData_strong[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]
            call Damage_Block(dam * strong)
        endif
    endif
    set u=null
endfunction
function InitStrong takes nothing returns nothing
local trigger doStrong_t=CreateTrigger()
call TriggerAddCondition(doStrong_t, Condition(function DoStrongCondition))
call Damage_RegisterEvent(doStrong_t)
set doStrong_t=null
endfunction

//library Strong ends
//library Stun:
function AddStun takes unit whichUnit returns nothing
        call s__Status_addStun(s__Status__staticgetindex(whichUnit))
    endfunction
    function RemoveStun takes unit whichUnit returns nothing
        call s__Status_removeStun(s__Status__staticgetindex(whichUnit))
    endfunction
    function Stun_IsUnitStunned takes unit whichUnit returns boolean
        return s__Status_isStunned(s__Status__staticgetindex(whichUnit))
    endfunction

//library Stun ends
//library TargetFilter:
    function IsLiveEnemy takes unit s,unit u returns boolean
        return s != u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u))
    endfunction
    function IsLiveAlly takes unit s,unit u returns boolean
        return s != u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u))
    endfunction
    
    function IsLiveEnemyUnit takes unit s,unit u returns boolean
        return s != u and IsUnitAliveBJ(u) and IsUnitEnemy(s, GetOwningPlayer(u)) and ( s__Material_clazz[s__Material__staticgetindex(u)] == MC_UNIT )
    endfunction 
    
    function IsLiveAllyUnit takes unit s,unit u returns boolean
        return s != u and IsUnitAliveBJ(u) and IsUnitAlly(s, GetOwningPlayer(u)) and ( s__Material_clazz[s__Material__staticgetindex(u)] == MC_UNIT )
    endfunction 
    
    function IsLiveUnit takes unit s,unit u returns boolean
        return IsUnitAliveBJ(u) and s__Material_clazz[s__Material__staticgetindex(u)] == MC_UNIT
    endfunction
    function IsLiveUnitOrWall takes unit s,unit u returns boolean
        return IsUnitAliveBJ(u) and ( s__Material_clazz[s__Material__staticgetindex(u)] == MC_UNIT or s__Material_clazz[s__Material__staticgetindex(u)] == MC_WALL )
    endfunction
    
//textmacro instance: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
    function HasLiveEnemyUnitInRange takes unit s,real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result= null
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= ( r * 2 ) and IsLiveEnemyUnit(s , ydl_unit) then
                set result=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return result
    endfunction
//end of: HasThingInRange("HasLiveEnemyUnitInRange","IsLiveEnemyUnit")
//textmacro instance: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
    function HasLiveUnitInRange takes unit s,real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit result= null
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null or result != null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            if s != ydl_unit and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= ( r * 2 ) and IsLiveUnit(s , ydl_unit) then
                set result=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return result
    endfunction
//end of: HasThingInRange("HasLiveUnitInRange","IsLiveUnit") 
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
    function GetNearestLiveUnit takes unit s,real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru=null
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s , ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= ( r * 2 ) and IsLiveUnit(s , ydl_unit) and d < mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnit","IsLiveUnit")
//textmacro instance: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
    function GetNearestLiveUnitOrWall takes unit s,real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru=null
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s , ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= ( r * 2 ) and IsLiveUnitOrWall(s , ydl_unit) and d < mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestLiveUnitOrWall","IsLiveUnitOrWall")
//textmacro instance: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    function GetNearestEnemy takes unit s,real r returns unit
        local group ydl_group
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        set ru=null
        set ydl_group=CreateGroup()
        call GroupEnumUnitsInRange(ydl_group, GetUnitX(s), GetUnitY(s), r, null)
        loop
            set ydl_unit=FirstOfGroup(ydl_group)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(ydl_group, ydl_unit)
            set d=DistanceTwoUnits(s , ydl_unit)
            if ydl_unit != s and RAbsBJ(getUnitHeight(ydl_unit) - getUnitHeight(s)) <= ( r * 2 ) and IsLiveEnemyUnit(s , ydl_unit) and d < mind then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        call DestroyGroup(ydl_group)
        set ydl_group=null
        set ydl_unit=null
        return ru
    endfunction
//end of: GetNearestThingInRange("GetNearestEnemy","IsLiveEnemyUnit")
    
    function GetNearestEnemyInGroup takes unit u,group g returns unit
        local unit ydl_unit
        local unit ru
        local real d
        local real mind=1000000
        local group tg=NewGroup()
        call GroupAddGroup(g, tg)
        set ru=null
        loop
            set ydl_unit=FirstOfGroup(tg)
            exitwhen ydl_unit == null
            call GroupRemoveUnit(tg, ydl_unit)
            set d=DistanceTwoUnits(u , ydl_unit)
            if d < mind and IsLiveEnemy(u , ydl_unit) then
                set mind=d
                set ru=ydl_unit
            endif
        endloop
        set ydl_unit=null
        call ReleaseGroup(tg)
        return ru
    endfunction
    

//library TargetFilter ends
//library AIData:
function IsAIUnit takes unit u returns boolean
    return GetOwningPlayer(u) == Player(11) and s__Material_clazz[s__Material__staticgetindex(u)] == MC_UNIT
endfunction
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__AIData__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__AIData__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__AIData_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__AIData_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__AIData_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if sc__AIData_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__AIData_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__AIData_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__AIData_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if sc__AIData_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__AIData_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__AIData_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__AIData_AIDS_onDeallocate takes nothing returns boolean
            if s__AIData_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__AIData_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__AIData_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__AIData_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__AIData_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__AIData_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__AIData_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call s__AIDS_DEFAULT_AIDS_onInit()
        endfunction
//end of: AIDS()
function s__AIData_AIDS_filter takes unit u returns boolean
    if IsAIUnit(u) then
        return true
    endif
    return false
endfunction
function s__AIData_AIDS_onCreate takes integer this returns nothing
set s__AIData_targetUnit[this]=GetNearestEnemyInGroup(s__AIData__get_unit(this) , MonsterTargetGroup)
set s__AIData_last_change[this]=Tick
set s__AIData_strategy[this]=s__DefaultAIStrategy_findStrategy(GetUnitTypeId(s__AIData__get_unit(this)))
call GetInMap(s__AIData__get_unit(this))
endfunction
function s__AIData_AIDS_onDestroy takes integer this returns nothing
set s__AIData_currentAIGroup[this]=0
set s__AIData_targetUnit[this]=null
endfunction

//library AIData ends
//library AIGroup:
function InitAIGroup takes nothing returns nothing
    
endfunction
//Implemented from module T32x:
        
        function s__DefaultAIGroup_T32x___PeriodicLoop takes nothing returns boolean
            local integer this=s__DefaultAIGroup_T32x___next[(0)]
            loop
                exitwhen this == 0
                call sc__DefaultAIGroup_periodic(this)
                set this=s__DefaultAIGroup_T32x___next[this]
            endloop
            return false
        endfunction
        function s__DefaultAIGroup_startPeriodic takes integer this returns nothing
            set s__DefaultAIGroup_T32x___prev[s__DefaultAIGroup_T32x___next[(0)]]=this
            set s__DefaultAIGroup_T32x___next[this]=s__DefaultAIGroup_T32x___next[(0)]
            set s__DefaultAIGroup_T32x___next[(0)]=this
            set s__DefaultAIGroup_T32x___prev[this]=(0)
        endfunction
        
        function s__DefaultAIGroup_stopPeriodic takes integer this returns nothing
            // This is some real magic.
            set s__DefaultAIGroup_T32x___next[s__DefaultAIGroup_T32x___prev[this]]=s__DefaultAIGroup_T32x___next[this]
            set s__DefaultAIGroup_T32x___prev[s__DefaultAIGroup_T32x___next[this]]=s__DefaultAIGroup_T32x___prev[this]
            // This will even work for the starting element.
        endfunction
        
        function s__DefaultAIGroup_T32x___onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig, Condition(function s__DefaultAIGroup_T32x___PeriodicLoop))
        endfunction
function s__DefaultAIGroup_create takes nothing returns integer
    local integer dag=s__DefaultAIGroup__allocate()
    set s__IAIGroup_g[dag]=NewGroup()
    set s__IAIGroup_tg[dag]=NewGroup()
    call GroupAddGroup(s__IAIGroup_g[dag], s__IAIGroup_tg[dag])
    call s__DefaultAIGroup_startPeriodic(dag)
    return dag
endfunction
function s__DefaultAIGroup_shouldLoop takes integer this,unit u returns boolean
    return Tick - s__Material_last_issue[s__Material__staticgetindex(u)] > 150
endfunction
function s__DefaultAIGroup_afterLoop takes integer this,unit u returns nothing
    call BJDebugMsg("after loop")
    set s__Material_last_issue[s__Material__staticgetindex(u)]=Tick
endfunction
function s__DefaultAIGroup_getInterval takes integer this returns integer
    return 15
endfunction
function s__DefaultAIGroup_ailoop takes integer this,unit u returns nothing
    local unit tu
    local real dir
    local real r
    local real d
    local real x
    local real y
    set tu=s__AIData_targetUnit[s__AIData__staticgetindex(u)]
    set d=DistanceTwoUnits(u , tu) / 2
    set dir=GetRandomReal(0, 3.1416)
    set r=GetRandomReal(0, d)
    set x=GetUnitX(tu) + r * Cos(dir)
    set y=GetUnitY(tu) + r * Sin(dir)
    call IssuePointOrderById(u, 851983, x, y)
    set tu=null
endfunction
function s__DefaultAIGroup_onDestroy takes integer this returns nothing
    call s__DefaultAIGroup_stopPeriodic(this)
    call ReleaseGroup(s__IAIGroup_g[this])
    call ReleaseGroup(s__IAIGroup_tg[this])
endfunction
function s__DefaultAIGroup_periodic takes integer this returns nothing
    local unit u
    if ModuloInteger(Tick, s__DefaultAIGroup_getInterval(this)) == 0 then
    set u=FirstOfGroup(s__IAIGroup_tg[this])
    if u == null then
        call GroupRefresh(s__IAIGroup_tg[this])
        call GroupAddGroup(s__IAIGroup_g[this], s__IAIGroup_tg[this])
    else
        call GroupRemoveUnit(s__IAIGroup_tg[this], u)
        if IsUnitInGroup(u, s__IAIGroup_g[this]) then
            if IsUnitAliveBJ(u) then
                if s__DefaultAIGroup_shouldLoop(this,u) then
                    call s__DefaultAIGroup_ailoop(this,u)
                    call s__DefaultAIGroup_afterLoop(this,u)
                endif
            else
                call sc__DefaultAIGroup_removeUnit(this,u)
            endif
        endif
        set u=null
    endif
    endif
endfunction
function s__DefaultAIGroup_addUnit takes integer this,unit u returns nothing
    local integer cg=s__AIData_currentAIGroup[s__AIData__staticgetindex(u)]
    if cg != 0 then
        call sc__IAIGroup_removeUnit(cg,u)
        call BJDebugMsg("group change")
    endif
    set s__AIData_currentAIGroup[s__AIData__staticgetindex(u)]=this
    call GroupAddUnit(s__IAIGroup_g[this], u)
    call GroupAddUnit(s__IAIGroup_tg[this], u)
endfunction
function s__DefaultAIGroup_removeUnit takes integer this,unit u returns nothing
    set s__AIData_currentAIGroup[s__AIData__staticgetindex(u)]=0
    call GroupRemoveUnit(s__IAIGroup_g[this], u)
    call GroupRefresh(s__IAIGroup_g[this])
endfunction

//library AIGroup ends
//library CustomDamage:
function NormalDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
endfunction
function rangeOneTimeSpellDamageToUnit takes unit source,real x,real y,real radius,real damage,string efs,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    set ydl_group=CreateGroup()
    call GroupEnumUnitsInRange(ydl_group, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ydl_group)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ydl_group, ydl_unit)
        if IsLiveEnemy(source , ydl_unit) and ( not IsUnitInGroup(ydl_unit, gro) ) and s__Material_clazz[s__Material__staticgetindex(ydl_unit)] == MC_UNIT then
            call Damage_Spell(source , ydl_unit , damage)
            call GroupAddUnit(gro, ydl_unit)
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    call DestroyGroup(ydl_group)
    set ydl_group=null
    set ydl_unit=null
endfunction
function BulletDamage takes unit source,unit target,real damage,string efs returns nothing
    local real finalDamage= damage
    if IsHero(source) then
        if sc__IGun_getGunType(s__EquipmentData_gun[s__EquipmentData__staticgetindex(source)]) == MACHINE_GUN then
            set finalDamage=finalDamage * s__IHeroData_machine_gun_buff[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(source)]]
        endif
    endif
    call Damage_Spell(source , target , finalDamage)
    call DestroyEffect(AddSpecialEffect(efs, GetUnitX(target), GetUnitY(target)))
endfunction
function ExplodeDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
endfunction
function rangeExplodeDamage takes unit source,real x,real y,real radius,real damage returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemyUnit(source , ydl_unit) then
            call ExplodeDamage(source , ydl_unit , damage)
        endif
        endloop
    set ydl_unit=null
endfunction
function RadiationDamage takes unit target returns nothing
    local real finalDamage= 1
    local real antrad
    if IsHero(target) then
        set finalDamage=finalDamage * ( 1 - s__IHeroData_antrad[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(target)]] )
        set finalDamage=RMaxBJ(0, finalDamage)
    endif
    call SetUnitLifeBJ(target, GetUnitStateSwap(UNIT_STATE_LIFE, target) - finalDamage)
endfunction
function KillMana takes unit source,unit target,real damage returns nothing
    local real mana= GetUnitState(target, UNIT_STATE_MANA)
    local real mb
    if IsHero(source) then
        set mb=s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(source)]]
        call BJDebugMsg(R2S(damage))
        call BJDebugMsg(R2S(damage * mb))
        call NormalDamage(source , target , damage * mb)
        call DestroyEffect(AddSpecialEffectZ(E_MANA_BOOM , GetUnitX(target) , GetUnitY(target) , 100))
    endif
    call SetUnitState(target, UNIT_STATE_MANA, mana - damage)
    call DestroyEffect(AddSpecialEffectZ(E_KILL_MANA , GetUnitX(target) , GetUnitY(target) , 100))
endfunction
function IceDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    local real frezz
    if IsHero(source) then
        set frezz=s__IHeroData_frezz[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(source)]]
        if GetRandomReal(0, 1) <= frezz then
            call Frezz(source , target , 1)
        endif
    endif
    call Damage_Spell(source , target , finalDamage)
endfunction
function FireDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
endfunction
function EnergyDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
endfunction
function LightningDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
endfunction
function BladeDamage takes unit source,unit target,real damage returns nothing
    local real finalDamage= damage
    local real kill_mana= damage * s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(source)]]
    call Damage_Spell(source , target , finalDamage)
endfunction
function CollisionDamage takes unit source,unit target,real damage,real dir,boolean efs returns nothing
    local real finalDamage= damage
    call Damage_Spell(source , target , finalDamage)
    if efs then
        call KillUnit(CreateUnit(GetOwningPlayer(source), euCOLLISION, GetUnitX(target), GetUnitY(target), dir - ( pi / 2 )))
    endif
endfunction
function rangeSpellDamage takes unit source,real x,real y,real radius,real damage,string efs returns nothing
    local unit ydl_unit
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        if IsLiveEnemy(source , ydl_unit) then
            call Damage_Spell(source , ydl_unit , damage)
        endif
        endloop
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    set ydl_unit=null
endfunction
function rangeSpellDamageOneUnit takes unit source,real x,real y,real radius,real damage,string efs returns nothing
    local unit t=GetNearestEnemy(source , radius)
    call Damage_Spell(source , t , damage)
    call DestroyEffect(AddSpecialEffect(efs, x, y))
    set t=null
endfunction

//library CustomDamage ends
//library DialogSystem:
function CancelDialog takes nothing returns nothing
    local dialog d=GetClickedDialogBJ()
    local button b=GetClickedButton()
    local integer data= GetDialogStructA(d)
    call sc__IDialog_button_clicked(data,b)
    call DialogDisplay(s__IDialog_p[data], d, false)
    call sc__IDialog_deallocate(data)
    call ClearDialogStructA(d)
endfunction
    function s__DefaultDialog_create takes string name,player p returns integer
        local integer g=s__DefaultDialog__allocate()
        set s__IDialog_d[g]=DialogCreate()
        set s__IDialog_dtr[g]=CreateTrigger()
        set s__IDialog_p[g]=p
        set s__IDialog_name[g]=name
        set s__IDialog_choses_size[g]=0
        call DialogSetMessage(s__IDialog_d[g], name)
        call SetDialogStructA(s__IDialog_d[g] , g)
        call TriggerRegisterDialogEvent(s__IDialog_dtr[g], s__IDialog_d[g])
        call TriggerAddCondition(s__IDialog_dtr[g], Condition(function CancelDialog))
        return g
    endfunction
    function s__DefaultDialog_button_clicked takes integer this,button b returns nothing
    endfunction
    function s__DefaultDialog_init takes integer this returns nothing
    endfunction
    function s__DefaultDialog_onDestroy takes integer this returns nothing
        local integer i= 0
        loop
            exitwhen i >= s__IDialog_choses_size[this]
            if GetButtonStructA(s___IDialog_choses[s__IDialog_choses[this]+i]) != 0 then
                call ClearButtonStructA(s___IDialog_choses[s__IDialog_choses[this]+i])
                set s___IDialog_choses[s__IDialog_choses[this]+i]=null
                set i=i + 1
            endif
        endloop
        call DialogClear(s__IDialog_d[this])
        call DialogDestroy(s__IDialog_d[this])
        call TriggerClearConditions(s__IDialog_dtr[this])
        call DestroyTrigger(s__IDialog_dtr[this])
        set s__IDialog_cancel_button[this]=null
        set s__IDialog_d[this]=null
        set s__IDialog_dtr[this]=null
        set s__IDialog_p[this]=null
    endfunction
    function s__DefaultDialog_display takes integer this returns nothing
        call sc__IDialog_init(this)
        set s__IDialog_cancel_button[this]=DialogAddButton(s__IDialog_d[this], "鍙栨秷", 0)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
    endfunction
    function s__ChangeAbDialog_create takes string name,player p,integer t,integer oi,integer ni returns integer
        local integer g=s__ChangeAbDialog__allocate(name , p)
        set s__ChangeAbDialog_oi[g]=oi
        set s__ChangeAbDialog_ni[g]=ni
        set s__ChangeAbDialog_t[g]=t
        return g
    endfunction
    function s__ChangeAbDialog_button_clicked takes integer this,button b returns nothing
        local unit u
        if b != s__IDialog_cancel_button[this] then
            set u=heros[GetPlayerId(s__IDialog_p[this])]
            call DropItem(u , s__ChangeAbDialog_oi[this])
            call AddItemSpell(u , s__ChangeAbDialog_ni[this])
            call AddItemStaticAbility(u , s__ChangeAbDialog_ni[this])
            set s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+s__ChangeAbDialog_t[this]]=s__ChangeAbDialog_ni[this]
        else
            set u=heros[GetPlayerId(s__IDialog_p[this])]
            call DropItem(u , s__ChangeAbDialog_ni[this])
        endif
        set u=null
    endfunction
    function s__ChangeAbDialog_init takes integer this returns nothing
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
    endfunction
    function s__ChangeGunDialog_create takes string name,player p,integer t,integer oi,integer ni,item itm returns integer
        local integer g=s__ChangeGunDialog__allocate(name , p)
        set s__ChangeGunDialog_oi[g]=oi
        set s__ChangeGunDialog_ni[g]=ni
        set s__ChangeGunDialog_t[g]=t
        set s__ChangeGunDialog_itm[g]=itm
        return g
    endfunction
    function s__ChangeGunDialog_button_clicked takes integer this,button b returns nothing
        local unit u
        if b != s__IDialog_cancel_button[this] then
            set u=heros[GetPlayerId(s__IDialog_p[this])]
            call DropItem(u , s__ChangeGunDialog_oi[this])
            call EquipGun(u , s__ChangeGunDialog_itm[this])
            set s___IHeroData_equips[s__IHeroData_equips[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]+s__ChangeGunDialog_t[this]]=s__ChangeGunDialog_ni[this]
        else
            set u=heros[GetPlayerId(s__IDialog_p[this])]
            call DropItem(u , s__ChangeGunDialog_ni[this])
        endif
        set u=null
    endfunction
    function s__ChangeGunDialog_init takes integer this returns nothing
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
    endfunction
    function s__TransformDialog_create takes string name,player p,integer fd returns integer
        local integer g=s__TransformDialog__allocate(name , p)
        set s__TransformDialog_fd[g]=fd
        return g
    endfunction
    function s__TransformDialog_button_clicked takes integer this,button b returns nothing
        local unit hero
        local integer f
        set f=GetButtonStructA(b)
        if b != s__IDialog_cancel_button[this] then
            if GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD) >= ( s__ItemFeature_lv[f] + 1 ) * s__ItemFeature_gold[f] then
                if GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_FOOD_USED) >= ( s__ItemFeature_lv[f] + 1 ) * s__ItemFeature_wood[f] then
                    set s__ItemFeature_lv[f]=s__ItemFeature_lv[f] + 1
                    call SetPlayerStateBJ(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD) - s__ItemFeature_lv[f] * s__ItemFeature_gold[f])
                    call SetPlayerStateBJ(s__IDialog_p[this], PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_FOOD_USED) - s__ItemFeature_lv[f] * s__ItemFeature_wood[f])
                else
                    call DisplayText(s__IDialog_p[this] , "杩涘寲鐐逛笉澶燂紝闇€瑕?" + I2S(( s__ItemFeature_lv[f] + 1 ) * s__ItemFeature_wood[f]))
                endif
            else
                call DisplayText(s__IDialog_p[this] , "榛勯噾涓嶅锛岄渶瑕?" + I2S(( s__ItemFeature_lv[f] + 1 ) * s__ItemFeature_gold[f]))
            endif
        else
            set hero=heros[GetPlayerId(s__IDialog_p[this])]
            //call CreateItem(iUPGADE,GetUnitX(hero),GetUnitY(hero))
        endif
        set hero=null
    endfunction
    function s__TransformDialog_init takes integer this returns nothing
        local button b
        local string s
//textmacro instance: AddFeatureButton("1")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 1)
            call SetButtonStructA(b , s__ItemFeatureData_f1[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
//end of: AddFeatureButton("1")
//textmacro instance: AddFeatureButton("2")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 2)
            call SetButtonStructA(b , s__ItemFeatureData_f2[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
//end of: AddFeatureButton("2")
//textmacro instance: AddFeatureButton("3")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 3)
            call SetButtonStructA(b , s__ItemFeatureData_f3[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
//end of: AddFeatureButton("3")
//textmacro instance: AddFeatureButton("4")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 4)
            call SetButtonStructA(b , s__ItemFeatureData_f4[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
//end of: AddFeatureButton("4")
//textmacro instance: AddFeatureButton("5")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 5)
            call SetButtonStructA(b , s__ItemFeatureData_f5[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
//end of: AddFeatureButton("5")
        set b=null
    endfunction
    function s__FreeTransformDialog_button_clicked takes integer this,button b returns nothing
        local unit hero
        local integer f
        set f=GetButtonStructA(b)
        if b != s__IDialog_cancel_button[this] then
            set s__ItemFeature_lv[f]=s__ItemFeature_lv[f] + 1
        else
            set hero=heros[GetPlayerId(s__IDialog_p[this])]
            call CreateItem(iFREEUP, GetUnitX(hero), GetUnitY(hero))
        endif
        set hero=null
    endfunction
    function s__ButtonTech_create takes integer id returns integer
        local integer g=s__ButtonTech__allocate()
        set s__ButtonTech_id[g]=id
        return g
    endfunction
    
    function s__ChooseTechDialog_heroHasTech takes integer this,unit hero,integer tech returns boolean
        return false
    endfunction
    function s__ChooseTechDialog_getHotestTech takes integer this,unit hero,integer selectId1,integer selectId2,integer selectId3,integer selectId4 returns integer
        local integer array prob
        local integer size= s__TechCounter_size[s__IHeroData_tech_counter[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(hero)]]]
        local string s= ""
        local integer i= 0
        local integer id= - 1
        local integer r= 0
        local integer j= 0
        local integer k= 0
        local integer c= 0
        local integer t= 0
        local integer l= 0
        local integer array randtree
        local integer array randtech
        //call BJDebugMsg("-------------------------")
        //calculate proberity
        loop
            exitwhen i >= TT_COUNT
            set prob[i]=s___TechCounter_cnt[s__TechCounter_cnt[s__IHeroData_tech_counter[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(hero)]]]+i]
            //call BJDebugMsg("prob " + I2S(i) + " " + I2S(prob[i]))
            set i=i + 1
        endloop
        
        //rand seq tech tree chose
        set k=0
        loop
            exitwhen k > TT_COUNT - 1
            set randtree[k]=k
            set k=k + 1
        endloop
        
        set j=0
        loop
            exitwhen j >= TT_COUNT
            set k=GetRandomInt(0, TT_COUNT - 1)
            set r=GetRandomInt(0, TT_COUNT - 1)
            if ( GetRandomReal(0, 1) > 0.9 ) or ( prob[r] <= prob[k] and r < k ) then
                set t=randtree[r]
                set randtree[r]=randtree[k]
                set randtree[k]=t
            endif
            set j=j + 1
        endloop
            
        //main loop tech tree
        loop
            exitwhen id > 0 or l >= TT_COUNT
            set c=randtree[l]
            //call BJDebugMsg("tech tree " + I2S(c))
            //rand seq tech chose
            set k=0
            loop
                exitwhen k >= s__TECH_TREE_COUNT[c]
                set randtech[k]=k
                set k=k + 1
            endloop
            
            set j=0
            loop
                exitwhen j >= s__TECH_TREE_COUNT[c]
                set k=GetRandomInt(0, s__TECH_TREE_COUNT[c] - 1)
                //call BJDebugMsg("rand chose " + I2S(k))
                set t=randtech[0]
                set randtech[0]=randtech[k]
                set randtech[k]=t
                set j=j + 1
            endloop
            //loop chose tech
            set i=0
            loop
                exitwhen id > 0 or i >= s__TECH_TREE_COUNT[c]
                set r=randtech[i]
                //call BJDebugMsg("tech nth " + I2S(r))
                //call BJDebugMsg("tech " + I2S(TECH_TREES[c].itms[r]))
                if s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r] != selectId1 and s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r] != selectId2 and s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r] != selectId3 and s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r] != selectId4 then
                    if not s__ChooseTechDialog_heroHasTech(this,hero , s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r]) then
                        set id=s___TechTree_itms[s__TechTree_itms[s__TECH_TREES[c]]+r]
                    endif
                endif
                set i=i + 1
            endloop
            set l=l + 1
        endloop
        return id
    endfunction
    function s__ChooseTechDialog_button_clicked takes integer this,button b returns nothing
        local integer bt
        local integer pid
        local integer id
        local string name
        if b == s___IDialog_choses[s__IDialog_choses[this]+3] then
            call SetPlayerStateBJ(s__IDialog_p[this], PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
            call DisplayInfo(s__IDialog_p[this] , "鑾峰緱涓ょ偣绉戞妧鐐?)
        else
            set bt=GetButtonStructA(b)
            set pid=GetPlayerId(s__IDialog_p[this])
            set id=s__ButtonTech_id[bt]
            set name=LoadStr(tdht, id, tdht_name)
            call DisplayInfo(s__IDialog_p[this] , "浣犲浼氫簡 " + name)
            set s__IHeroData_up_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(s__IDialog_p[this])])]]=s__IHeroData_up_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(s__IDialog_p[this])])]] - 1
            call UnitAddAbility(techs[pid], id)
            call DispatchTechAdd(id , GetUnitAbilityLevel(techs[pid], id) , pid)
        endif
    endfunction
    
    function s__ChooseTechDialog_init takes integer this returns nothing
        local button b
        local unit hero= heros[GetPlayerId(s__IDialog_p[this])]
        local integer tech1= s__ChooseTechDialog_getHotestTech(this,hero , - 1 , - 1 , - 1 , - 1)
        local integer tech2= s__ChooseTechDialog_getHotestTech(this,hero , tech1 , - 1 , - 1 , - 1)
        local integer tech3= s__ChooseTechDialog_getHotestTech(this,hero , tech1 , tech2 , - 1 , - 1)
        local string s1
        local string s2
        local string s3
        local string s4
        local string s5
        //local integer tech2 = getHotestTech(hero,tech1,-1,-1,-1)
//textmacro instance: AddTechButton("1")
        if tech1 > 0 then
            //call BJDebugMsg(I2S(tech1))
            set s1=LoadStr(tdht, tech1, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s1, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech1))
            set b=null
        endif
//end of: AddTechButton("1")
//textmacro instance: AddTechButton("2")
        if tech2 > 0 then
            //call BJDebugMsg(I2S(tech2))
            set s2=LoadStr(tdht, tech2, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s2, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech2))
            set b=null
        endif
//end of: AddTechButton("2")
//textmacro instance: AddTechButton("3")
        if tech3 > 0 then
            //call BJDebugMsg(I2S(tech3))
            set s3=LoadStr(tdht, tech3, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s3, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech3))
            set b=null
        endif
//end of: AddTechButton("3")
        set s___IDialog_choses[s__IDialog_choses[this]+3]=DialogAddButton(s__IDialog_d[this], "涓ょ偣绉戞妧鐐?, 0)
    endfunction
    
    function s__ChooseTechDialog_display takes integer this returns nothing
        call s__ChooseTechDialog_init(this)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
    endfunction
    
    function s__ChooseBonusDialog_button_clicked takes integer this,button b returns nothing
        call SetPlayerStateBJ(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(s__IDialog_p[this], PLAYER_STATE_RESOURCE_GOLD) + 100)
    endfunction
    
    function s__ChooseBonusDialog_init takes integer this returns nothing
        local button b
        local unit hero= heros[GetPlayerId(s__IDialog_p[this])]
        set b=DialogAddButton(s__IDialog_d[this], "閲戝竵+100", 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
    endfunction
    
    function s__ChooseBonusDialog_display takes integer this returns nothing
        call s__ChooseBonusDialog_init(this)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
    endfunction
    

//library DialogSystem ends
//library HorrorOrder:
    function HorrorMove takes unit u returns nothing
        local unit ne
        local real tx
        local real ty
        local real dir
        set ne=GetNearestEnemy(u , 800)
        if ne != null then
            set dir=getTargetDir(ne , u) + GetRandomReal(- 1.5, 1.5)
        else
            set dir=GetRandomReal(0, 2 * pi)
        endif
        set tx=GetUnitX(u) + 1200 * Cos(dir)
        set ty=GetUnitY(u) + 1200 * Sin(dir)
        call IssuePointOrderById(u, OI_MOVE, tx, ty)
        set ne=null
    endfunction

//library HorrorOrder ends
//library Buffer:
function MoveBufferStruct takes nothing returns nothing
    call sc__DefaultBufferStruct_loopMoveAll()
endfunction
    
function BufferStructInit takes nothing returns nothing
    set moveTimer=CreateTimer()
    call TimerStart(moveTimer, 0.02, true, function MoveBufferStruct)
endfunction
    
    
    
    
    
    
//Implemented from module List:
    
    
    
        function s__DefaultBufferStruct_getLength takes nothing returns integer
            return s__DefaultBufferStruct_List___length
        endfunction
    
        function s__DefaultBufferStruct_getFirst takes nothing returns integer
            return s__DefaultBufferStruct_List___first
        endfunction
    
        function s__DefaultBufferStruct_getLast takes nothing returns integer
            return s__DefaultBufferStruct_List___last
        endfunction
    
        function s__DefaultBufferStruct_getRandom takes nothing returns integer
            local integer s= s__DefaultBufferStruct_List___first
            local integer array list
            local integer n= - 1
            loop
                exitwhen s == 0
                set n=n + 1
                set list[n]=s
                set s=s__DefaultBufferStruct_List___next[s]
            endloop
            if n == - 1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endfunction
    
        function s__DefaultBufferStruct_getNext takes integer this returns integer
            return s__DefaultBufferStruct_List___next[this]
        endfunction
    
        function s__DefaultBufferStruct_getPrev takes integer this returns integer
            return s__DefaultBufferStruct_List___prev[this]
        endfunction
    
        function s__DefaultBufferStruct_inList takes integer this returns boolean
            return s__DefaultBufferStruct_List___inlist[this]
        endfunction
        function s__DefaultBufferStruct_addList takes integer this returns boolean
            if not s__DefaultBufferStruct_List___inlist[this] and not s__DefaultBufferStruct_List___destroyinglist then
                set s__DefaultBufferStruct_List___inlist[this]=true
                if s__DefaultBufferStruct_List___first == 0 then
                    set s__DefaultBufferStruct_List___first=this
                else
                    set s__DefaultBufferStruct_List___prev[this]=s__DefaultBufferStruct_List___last
                    set s__DefaultBufferStruct_List___next[s__DefaultBufferStruct_List___prev[this]]=this
                endif
                set s__DefaultBufferStruct_List___last=this
                set s__DefaultBufferStruct_List___length=s__DefaultBufferStruct_List___length + 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultBufferStruct_removeList takes integer this returns boolean
            if s__DefaultBufferStruct_List___inlist[this] then
                if s__DefaultBufferStruct_List___destroyinglist then
                    return true
                endif
                set s__DefaultBufferStruct_List___inlist[this]=false
                if s__DefaultBufferStruct_List___first == this then
                    set s__DefaultBufferStruct_List___first=s__DefaultBufferStruct_List___next[this]
                endif
                if s__DefaultBufferStruct_List___last == this then
                    set s__DefaultBufferStruct_List___last=s__DefaultBufferStruct_List___prev[this]
                endif
                set s__DefaultBufferStruct_List___next[s__DefaultBufferStruct_List___prev[this]]=s__DefaultBufferStruct_List___next[this]
                set s__DefaultBufferStruct_List___prev[s__DefaultBufferStruct_List___next[this]]=s__DefaultBufferStruct_List___prev[this]
                set s__DefaultBufferStruct_List___length=s__DefaultBufferStruct_List___length - 1
                return true
            endif
            return false
        endfunction
    
        function s__DefaultBufferStruct_destroyList takes nothing returns nothing
            local integer s= s__DefaultBufferStruct_List___first
            if not s__DefaultBufferStruct_List___destroyinglist then
                loop
                    exitwhen s == 0
                    set s__DefaultBufferStruct_List___destroyinglist=false
                    call s__DefaultBufferStruct_removeList(s)
                    set s__DefaultBufferStruct_List___destroyinglist=true
                    call sc__IBufferStruct_deallocate(s)
                    set s=s__DefaultBufferStruct_List___next[s]
                endloop
                set s__DefaultBufferStruct_List___destroyinglist=false
            endif
        endfunction
    
    
    function s__DefaultBufferStruct_condition takes integer this returns boolean
        set s__IBufferStruct_count[this]=s__IBufferStruct_count[this] - 1
        call sc__IBufferStruct_action(this)
        return s__IBufferStruct_count[this] >= 0 and IsUnitAliveBJ(s__IBufferStruct_u[this])
    endfunction
    
    function s__DefaultBufferStruct_action takes integer this returns nothing
    endfunction
    
    function s__DefaultBufferStruct_addBuffer takes integer this returns nothing
    endfunction
    
    function s__DefaultBufferStruct_removeBuffer takes integer this returns nothing
    endfunction
    
    function s__DefaultBufferStruct_init takes integer this,unit u,integer count returns nothing
    endfunction
    
    function s__DefaultBufferStruct_start takes integer this returns nothing
        set s__IBufferStruct_flag[this]=true
        call sc__IBufferStruct_addBuffer(this)
    endfunction
       
    function s__DefaultBufferStruct_create takes unit u,integer count returns integer
        local integer m=s__DefaultBufferStruct__allocate()
        set s__IBufferStruct_u[m]=u
        set s__IBufferStruct_count[m]=count
        set s__IBufferStruct_flag[m]=false
        call s__DefaultBufferStruct_addList(m)
        call sc__IBufferStruct_init(m,u , count)
        return m
    endfunction
    
    function s__DefaultBufferStruct_onDestroy takes integer this returns nothing
        if s__IBufferStruct_flag[this] then
            call sc__IBufferStruct_removeBuffer(this)
        endif
        set s__IBufferStruct_u[this]=null
        call s__DefaultBufferStruct_removeList(this)
        call sc__IBufferStruct_finish(this)
    endfunction
    
    function s__DefaultBufferStruct_finish takes integer this returns nothing
    endfunction
    
    function s__DefaultBufferStruct_loopMoveAll takes nothing returns nothing
         local boolean r
         local integer m= s__DefaultBufferStruct_getFirst()
             loop
                 exitwhen m == 0
                 if s__IBufferStruct_flag[m] then
                     set r=sc__IBufferStruct_condition(m)
                     if r then
                     else
                        call sc__IBufferStruct_deallocate(m)
                     endif
                     set m=s__DefaultBufferStruct_getNext(m)
                 endif
             endloop
    endfunction
    
    
    
    
    
    
    function s__BoundUnitEffectStruct_addBuffer takes integer this returns nothing
        set s__BoundUnitEffectStruct_eu[this]=CreateUnit(GetOwningPlayer(s__IBufferStruct_u[this]), s__BoundUnitEffectStruct_uid[this], GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), GetUnitFacing(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_bais[this])
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
        call SetUnitAnimation(s__BoundUnitEffectStruct_eu[this], s__BoundUnitEffectStruct_animate[this])
    endfunction
    
    function s__BoundUnitEffectStruct_action takes integer this returns nothing
        call SetUnitX(s__BoundUnitEffectStruct_eu[this], GetUnitX(s__IBufferStruct_u[this]))
        call SetUnitY(s__BoundUnitEffectStruct_eu[this], GetUnitY(s__IBufferStruct_u[this]))
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
    endfunction
    
    function s__BoundUnitEffectStruct_removeBuffer takes integer this returns nothing
        call KillUnit(s__BoundUnitEffectStruct_eu[this])
    endfunction
    
    function s__BoundUnitEffectStruct_create takes unit u,integer count,integer uid,real bais,string animate,real z returns integer
        local integer m=s__BoundUnitEffectStruct__allocate(u , count)
        set s__BoundUnitEffectStruct_uid[m]=uid
        set s__BoundUnitEffectStruct_bais[m]=bais
        set s__BoundUnitEffectStruct_animate[m]=animate
        set s__BoundUnitEffectStruct_z[m]=z
        return m
    endfunction
    
    function s__BoundUnitEffectStruct_finish takes integer this returns nothing
        set s__BoundUnitEffectStruct_eu[this]=null
    endfunction
    
       
    
    
    function s__ElectricWhipBufferStruct_condition takes integer this returns boolean
        local real dis= DistanceTwoUnits(s__ElectricWhipBufferStruct_source[this] , s__IBufferStruct_u[this])
        set s__IBufferStruct_count[this]=s__IBufferStruct_count[this] - 1
        call sc__ElectricWhipBufferStruct_action(this)
        return s__IBufferStruct_count[this] >= 0 and dis > 200 and IsUnitAliveBJ(s__ElectricWhipBufferStruct_source[this]) and IsUnitAliveBJ(s__IBufferStruct_u[this])
    endfunction
    
    function s__ElectricWhipBufferStruct_removef takes integer this,integer v returns nothing
        call s__vector_subtract(s__Velocity_a[sc__Velocity__staticgetindex(s__IBufferStruct_u[this])],v)
    endfunction
    
    function s__ElectricWhipBufferStruct_addf takes integer this,integer v returns nothing
        call s__vector_add(s__Velocity_a[sc__Velocity__staticgetindex(s__IBufferStruct_u[this])],v)
    endfunction
    
    function s__ElectricWhipBufferStruct_getReturnForce takes integer this returns integer
        local real fl= 0.5
        local integer v= s__Velocity_v[sc__Velocity__staticgetindex(s__IBufferStruct_u[this])]
        local real len= s__vector_getLength(v)
        local integer dir= getDirVector(s__IBufferStruct_u[this] , s__ElectricWhipBufferStruct_source[this] , fl * 5)
        local real angle= s__vector_getAngle(v , dir)
        local real a= Sin(angle) * len
        local real sd
        local integer r
        local real dl
        if angle >= ( pi / 2 ) then
            set sd=len
        else
            set sd=a
        endif
        if sd > fl then
            set r=s__vector_create(- s__vector_x[v] , - s__vector_y[v] , - s__vector_z[v])
            call s__vector_setLength(r,RMinBJ(len, fl))
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        else
            if angle >= ( pi / 2 ) then
                set dl=SquareRoot(fl * fl - a * a) - SquareRoot(len * len - a * a)
            else
                set dl=SquareRoot(fl * fl - a * a) + SquareRoot(len * len - a * a)
            endif
            set r=s__vector_create(s__vector_x[dir] , s__vector_y[dir] , s__vector_z[dir])
            call s__vector_setLength(r,dl)
            call s__vector_subtract(r,v)
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        endif
        return dir
    endfunction
    function s__ElectricWhipBufferStruct_addBuffer takes integer this returns nothing
        set s__ElectricWhipBufferStruct_l[this]=AddLightningEx("CLPB", false, GetUnitX(s__ElectricWhipBufferStruct_source[this]), GetUnitY(s__ElectricWhipBufferStruct_source[this]), getUnitHeight(s__ElectricWhipBufferStruct_source[this]), GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), getUnitHeight(s__IBufferStruct_u[this]))
    endfunction
    
    function s__ElectricWhipBufferStruct_action takes integer this returns nothing
        local integer returnForce
        set returnForce=s__ElectricWhipBufferStruct_getReturnForce(this)
        call s__ElectricWhipBufferStruct_removef(this,s__ElectricWhipBufferStruct_pref[this])
        set s__vector_x[s__ElectricWhipBufferStruct_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__ElectricWhipBufferStruct_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__ElectricWhipBufferStruct_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call s__ElectricWhipBufferStruct_addf(this,s__ElectricWhipBufferStruct_pref[this])
        call LightningDamage(s__ElectricWhipBufferStruct_source[this] , s__IBufferStruct_u[this] , s__ElectricWhipBufferStruct_dam[this] / 50)
        call MoveLightningEx(s__ElectricWhipBufferStruct_l[this], false, GetUnitX(s__ElectricWhipBufferStruct_source[this]), GetUnitY(s__ElectricWhipBufferStruct_source[this]), getUnitHeight(s__ElectricWhipBufferStruct_source[this]), GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), getUnitHeight(s__IBufferStruct_u[this]))
    endfunction
    
    function s__ElectricWhipBufferStruct_removeBuffer takes integer this returns nothing
        call DestroyLightning(s__ElectricWhipBufferStruct_l[this])
        call s__ElectricWhipBufferStruct_removef(this,s__ElectricWhipBufferStruct_pref[this])
        call s__vector_deallocate(s__ElectricWhipBufferStruct_pref[this])
        set s__ElectricWhipBufferStruct_l[this]=null
        set s__ElectricWhipBufferStruct_source[this]=null
        set s__IBufferStruct_u[this]=null
    endfunction
    
    function s__ElectricWhipBufferStruct_create takes unit u,integer count,unit source,real dam returns integer
        local integer m= s__ElectricWhipBufferStruct__allocate(u , count)
        set s__ElectricWhipBufferStruct_source[m]=source
        set s__ElectricWhipBufferStruct_dam[m]=dam
        set s__ElectricWhipBufferStruct_pref[m]=s__vector_create(0 , 0 , 0)
        return m
    endfunction
    
    function s__ElectricWhipBufferStruct_finish takes integer this returns nothing
    endfunction
    

//library Buffer ends
//library ChooseBonus:
function ChooseBonusCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    set s__IHeroData_bonus_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]=s__IHeroData_bonus_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]] + 1
    set u=null
endfunction
function UseBonusCondition takes nothing returns nothing
    local player p= GetTriggerPlayer()
    local unit hero= heros[GetPlayerId(p)]
    if s__IHeroData_bonus_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(hero)]] > 0 then
        call s__ChooseBonusDialog_display(s__ChooseBonusDialog__allocate("閫夋嫨涓€涓崌绾у鍔? , p))
    endif
    set p=null
    set hero=null
endfunction
function InitChooseBonus takes nothing returns nothing
local trigger choosebonus_t=CreateTrigger()
local trigger usebonus_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(choosebonus_t, EVENT_PLAYER_HERO_LEVEL)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(1), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(2), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(3), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(4), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(5), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(usebonus_t, Player(0), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
call TriggerAddCondition(choosebonus_t, Condition(function ChooseBonusCondition))
call TriggerAddCondition(usebonus_t, Condition(function UseBonusCondition))
set choosebonus_t=null
set usebonus_t=null
endfunction

//library ChooseBonus ends
//library ChooseTech:
function ChooseTechCondition takes nothing returns nothing
    local unit u= GetTriggerUnit()
    local integer lv= GetHeroLevel(u)
    if ModuloInteger(lv, 3) == 0 then
        set s__IHeroData_up_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]]=s__IHeroData_up_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(u)]] + 1
        call BJDebugMsg("uppoint")
    endif
    set u=null
endfunction
function UseTechCondition takes nothing returns nothing
    local player p= GetTriggerPlayer()
    local unit hero= heros[GetPlayerId(p)]
    if s__IHeroData_up_point[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(hero)]] > 0 then
        call s__ChooseTechDialog_display(s__ChooseTechDialog__allocate("閫夋嫨涓€涓鎶€" , p))
    endif
    set p=null
    set hero=null
endfunction
function InitChooseTech takes nothing returns nothing
local trigger choosetech_t=CreateTrigger()
local trigger usetech_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(choosetech_t, EVENT_PLAYER_HERO_LEVEL)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(1), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(2), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(3), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(4), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(5), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(usetech_t, Player(0), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_UP)
call TriggerAddCondition(choosetech_t, Condition(function ChooseTechCondition))
call TriggerAddCondition(usetech_t, Condition(function UseTechCondition))
set choosetech_t=null
set usetech_t=null
endfunction

//library ChooseTech ends
//library MonsterTargetGroup:
function InitMonsterTargetGroup takes nothing returns nothing
    set MonsterTargetGroup=NewGroup()
    set MeleeGroup=NewGroup()
    set mtm=sc__MonsterTargetGroupManager_create()
endfunction
function BeMonsterTarget takes unit u returns nothing
    call GroupAddUnit(MonsterTargetGroup, u)
endfunction
function NotMonsterTarget takes unit u returns nothing
    call GroupRemoveUnit(MonsterTargetGroup, u)
    call GroupRefresh(MonsterTargetGroup)
endfunction
//Implemented from module T32x:
        
        function s__MonsterTargetGroupManager_T32x___PeriodicLoop takes nothing returns boolean
            local integer this=s__MonsterTargetGroupManager_T32x___next[(0)]
            loop
                exitwhen this == 0
                call sc__MonsterTargetGroupManager_periodic(this)
                set this=s__MonsterTargetGroupManager_T32x___next[this]
            endloop
            return false
        endfunction
        function s__MonsterTargetGroupManager_startPeriodic takes integer this returns nothing
            set s__MonsterTargetGroupManager_T32x___prev[s__MonsterTargetGroupManager_T32x___next[(0)]]=this
            set s__MonsterTargetGroupManager_T32x___next[this]=s__MonsterTargetGroupManager_T32x___next[(0)]
            set s__MonsterTargetGroupManager_T32x___next[(0)]=this
            set s__MonsterTargetGroupManager_T32x___prev[this]=(0)
        endfunction
        
        function s__MonsterTargetGroupManager_stopPeriodic takes integer this returns nothing
            // This is some real magic.
            set s__MonsterTargetGroupManager_T32x___next[s__MonsterTargetGroupManager_T32x___prev[this]]=s__MonsterTargetGroupManager_T32x___next[this]
            set s__MonsterTargetGroupManager_T32x___prev[s__MonsterTargetGroupManager_T32x___next[this]]=s__MonsterTargetGroupManager_T32x___prev[this]
            // This will even work for the starting element.
        endfunction
        
        function s__MonsterTargetGroupManager_T32x___onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig, Condition(function s__MonsterTargetGroupManager_T32x___PeriodicLoop))
        endfunction
function s__MonsterTargetGroupManager_create takes nothing returns integer
    local integer dag=s__MonsterTargetGroupManager__allocate()
    call s__MonsterTargetGroupManager_startPeriodic(dag)
    return dag
endfunction
function s__MonsterTargetGroupManager_onDestroy takes integer this returns nothing
    call s__MonsterTargetGroupManager_stopPeriodic(this)
endfunction

//Generated destructor of MonsterTargetGroupManager
function s__MonsterTargetGroupManager_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MonsterTargetGroupManager_V[this]!=-1) then
        return
    endif
    call s__MonsterTargetGroupManager_onDestroy(this)
    set si__MonsterTargetGroupManager_V[this]=si__MonsterTargetGroupManager_F
    set si__MonsterTargetGroupManager_F=this
endfunction
function s__MonsterTargetGroupManager_periodic takes integer this returns nothing
    local unit u
    local group tg
    local group ydl_group
    local unit ydl_unit
    local unit u2
    if ModuloInteger(Tick, 200) == 0 then
        set tg=NewGroup()
        call GroupAddGroup(MonsterTargetGroup, tg)
        set u=FirstOfGroup(tg)
        loop
            exitwhen u == null
            if IsUnitAliveBJ(u) then
                set ydl_group=NewGroup()
                call GroupEnumUnitsInRange(ydl_group, GetUnitX(u), GetUnitY(u), 1500, null)
                loop
                    set ydl_unit=FirstOfGroup(ydl_group)
                    exitwhen ydl_unit == null
                    call GroupRemoveUnit(ydl_group, ydl_unit)
                    if u != ydl_unit and IsAIUnit(ydl_unit) and IsLiveEnemyUnit(u , ydl_unit) then
                        call GroupAddUnit(MeleeGroup, ydl_unit)
                        call TargetInRange(ydl_unit , u , DistanceTwoUnits(u , ydl_unit))
                    endif
                endloop
                call ReleaseGroup(ydl_group)
                set ydl_group=null
                set ydl_unit=null
            else
                call NotMonsterTarget(u)
            endif
            call GroupRemoveUnit(tg, u)
            set u=FirstOfGroup(tg)
        endloop
        set u=null
        call GroupRefresh(tg)
        call GroupAddGroup(MeleeGroup, tg)
        loop
            set u2=FirstOfGroup(tg)
            exitwhen u2 == null
            call GroupRemoveUnit(tg, u2)
            if DistanceTwoUnits(u2 , s__AIData_targetUnit[s__AIData__staticgetindex(u2)]) > 1500 then
                call GroupRemoveUnit(MeleeGroup, u2)
                call TargetOutRange(u2)
            endif
        endloop
        set u2=null
        call ReleaseGroup(tg)
        set tg=null
    endif
endfunction

//library MonsterTargetGroup ends
//library Radiation:
function DoRadiationCondition takes nothing returns nothing
    local integer i= 0
    loop
        exitwhen i > 4
        if heros[i] != null and IsUnitAliveBJ(heros[i]) and UnitHasBuffBJ(heros[i], 'B004') then
            call RadiationDamage(heros[i])
        endif
        set i=i + 1
    endloop
endfunction
function InitRadiation takes nothing returns nothing
local trigger doRadiation_t=CreateTrigger()
call TriggerAddCondition(doRadiation_t, Condition(function DoRadiationCondition))
call TriggerRegisterTimerEventPeriodic(doRadiation_t, 1.00)
set doRadiation_t=null
endfunction

//library Radiation ends
//library Transform:
function TransformCondition takes nothing returns nothing
    local unit tu= GetTriggerUnit()
    local player owner= GetOwningPlayer(tu)
    local item ti= GetManipulatedItem()
    local integer tii= GetItemTypeId(ti)
    local item target_item
    local integer fd
    local integer data
    local integer d
    local string s= " 閫夋嫨涓€涓己鍖?
    if GetUnitTypeId(tu) == HERO and tii == iUPGADE then
        set target_item=UnitItemInSlot(tu, 0)
        if target_item != null then
            set data=getItemTypeData(GetItemTypeId(target_item))
            set fd=s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(target_item)]
            set d=s__TransformDialog_create(s__ItemTypeData_name[data] + s , owner , fd)
            call sc__IDialog_display(d)
            call s__ItemTypeData_deallocate(data)
        endif
    elseif GetUnitTypeId(tu) == HERO and tii == iFREEUP then
        set target_item=UnitItemInSlot(tu, 0)
        if target_item != null then
            set data=getItemTypeData(GetItemTypeId(target_item))
            set fd=s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(target_item)]
            set d=s__FreeTransformDialog__allocate(s__ItemTypeData_name[data] + " 鍏嶈垂寮哄寲" , owner , fd)
            call sc__IDialog_display(d)
            call s__ItemTypeData_deallocate(data)
        else
            call CreateItem(iFREEUP, GetUnitX(heros[GetPlayerId(owner)]), GetUnitY(heros[GetPlayerId(owner)]))
        endif
    endif
    set tu=null
    set owner=null
    set ti=null
    set target_item=null
endfunction
function InitTransform takes nothing returns nothing
local trigger transform_t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(transform_t, EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddCondition(transform_t, Condition(function TransformCondition))
set transform_t=null
endfunction

//library Transform ends
//library PhysicsSystem:
function AddVelocity takes unit u,integer n returns nothing
    call s__vector_add(s__Velocity_v[sc__Velocity__staticgetindex(u)],n)
endfunction
function AddForce takes unit u,integer a returns nothing
    call s__vector_add(s__Velocity_a[sc__Velocity__staticgetindex(u)],a)
endfunction
function RemoveForce takes unit u,integer a returns nothing
    call s__vector_subtract(s__Velocity_a[sc__Velocity__staticgetindex(u)],a)
endfunction
function Push takes unit u,real dir,real d,real h,integer s returns nothing
    local integer a= s__vector_create(d * Cos(dir) , d * Sin(dir) , h)
    local integer pfs= sc__PushForceStruct_create(u , s , a)
    call s__DefaultBufferStruct_start(pfs)
endfunction
    
    function s__PushForceStruct_addBuffer takes integer this returns nothing
        call AddForce(s__IBufferStruct_u[this] , s__PushForceStruct_fc[this])
    endfunction
    
    function s__PushForceStruct_removeBuffer takes integer this returns nothing
        call RemoveForce(s__IBufferStruct_u[this] , s__PushForceStruct_fc[this])
    endfunction
    
    function s__PushForceStruct_create takes unit u,integer count,integer fc returns integer
        local integer m=s__PushForceStruct__allocate(u , count)
        set s__PushForceStruct_fc[m]=fc
        return m
    endfunction
    
    function s__PushForceStruct_finish takes integer this returns nothing
        call s__vector_deallocate(s__PushForceStruct_fc[this])
    endfunction
    

//library PhysicsSystem ends
//library Missle:
function missleRangeOneTimeActionToUnit takes integer source,real x,real y,real radius,group gro returns nothing
    local group ydl_group
    local unit ydl_unit
    //set ydl_group = NewGroup()
    call GroupEnumUnitsInRange(ENUM_GROUP, x, y, radius, null)
        loop
        set ydl_unit=FirstOfGroup(ENUM_GROUP)
        exitwhen ydl_unit == null
        call GroupRemoveUnit(ENUM_GROUP, ydl_unit)
        //if DistanceUnitAndXY(ydl_unit,x,y) <= Material[ydl_unit].volume + radius then
        
            if IsLiveEnemyUnit(s__IMissle_owner[source] , ydl_unit) and ( not IsUnitInGroup(ydl_unit, gro) ) then
                call sc__IMissle_debuffEnemy(source,ydl_unit)
                call sc__IMissle_damageEnemy(source,ydl_unit)
                call GroupAddUnit(gro, ydl_unit)
            elseif IsLiveAllyUnit(s__IMissle_owner[source] , ydl_unit) and ( not IsUnitInGroup(ydl_unit, gro) ) then
            //call BJDebugMsg("fdsa")
                call sc__IMissle_healAlly(source,ydl_unit)
                call GroupAddUnit(gro, ydl_unit)
            elseif IsUnitAliveBJ(ydl_unit) and ydl_unit == s__IMissle_owner[source] and s__IMissle_origin_life[source] - s__IMissle_life[source] > LEAVE_COUNT then
                call sc__IMissle_hitSelf(source,ydl_unit)
                call GroupAddUnit(gro, ydl_unit)
            endif
        //endif
        endloop
    //call ReleaseGroup(ydl_group)
    //set ydl_group = null
    set ydl_unit=null
endfunction
    
    
    function s__Missle_getMissleId takes integer this returns integer
        return 'e000'
    endfunction
    
    function s__Missle_refreshDamagedGroup takes integer this returns nothing
        local group newGroup
        local unit ydl_unit
        if not IsUnitGroupEmptyBJ(s__IMissle_damaged[this]) then
            set newGroup=CreateGroup()
            loop
            set ydl_unit=FirstOfGroup(s__IMissle_damaged[this])
            exitwhen ydl_unit == null
            call GroupRemoveUnit(s__IMissle_damaged[this], ydl_unit)
            if DistanceTwoUnits(s__IMissle_missle[this] , ydl_unit) <= REDAMAGE_DISTANCE then
                call GroupAddUnit(newGroup, ydl_unit)
            endif
            endloop
            set s__IMissle_damaged[this]=newGroup
        endif
        set newGroup=null
        set ydl_unit=null
    endfunction
    function s__Missle_troughDamage takes integer this,unit target returns nothing
    endfunction
    
    function s__Missle_doDamage takes integer this,real radius returns nothing
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
    endfunction
    
    function s__Missle_damageEnemy takes integer this,unit target returns nothing
        call BulletDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this) , SMALL_BLOOD)
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__Missle_debuffEnemy takes integer this,unit target returns nothing
    endfunction
    
    function s__Missle_healAlly takes integer this,unit target returns nothing
        //call HealUnit(owner, target, 50, HEAL_TYPE_NORMAL)
        //call destroy()
    endfunction
    
    function s__Missle_hitSelf takes integer this,unit self returns nothing
    endfunction
    
    
    function s__Missle_fireMissle takes integer this,integer vi returns nothing
        set s__IMissle_missle[this]=CreateUnit(GetOwningPlayer(s__IMissle_owner[this]), sc__IMissle_getMissleId(this), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getDeg(s__vector_y[vi] , s__vector_x[vi]))
        if GetUnitFlyHeight(s__IMissle_owner[this]) > g_sd_th then
            call SetUnitFlyHeight(s__IMissle_missle[this], GetUnitFlyHeight(s__IMissle_owner[this]), 0)
        endif
        set s__IMissle_life[this]=sc__IMissle_getLife(this)
        set s__IMissle_origin_life[this]=s__IMissle_life[this]
        call sc__IMissle_onFire(this)
        set s__IMissle_started[this]=true
        call s__vector_deallocate(s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])])
        set s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])]=vi
        set s__Velocity_missleStruct[sc__Velocity__staticgetindex(s__IMissle_missle[this])]=this
    endfunction
    
    function s__Missle_onFire takes integer this returns nothing
    endfunction
    
    function s__Missle_substep takes integer this returns nothing
    endfunction
    
    function s__Missle_getLife takes integer this returns integer
        return 30
    endfunction
    
    function s__Missle_create takes unit owner returns integer
        local integer m=s__Missle__allocate()
        //set m.damaged=NewGroup()
        set s__IMissle_damaged[m]=CreateGroup()
        set s__IMissle_owner[m]=owner
        set s__IMissle_started[m]=false
        return m
    endfunction
    
    function s__Missle_step takes integer this returns nothing
        set s__IMissle_life[this]=s__IMissle_life[this] - 1
        call sc__IMissle_substep(this)
        if s__IMissle_life[this] <= 0 then
            call sc__IMissle_deallocate(this)
        endif
    endfunction
    
    function s__Missle_getFinalDamage takes integer this returns real
        local real od= sc__IMissle_getOriginalDamage(this)
        return od
    endfunction
    
    function s__Missle_getOriginalDamage takes integer this returns real
        return 50.0
    endfunction
    
    function s__Missle_hitGround takes integer this returns nothing
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__Missle_explode takes integer this returns nothing
        //call BJDebugMsg("explode")
    endfunction
    
    function s__Missle_onDestroy takes integer this returns nothing
        call sc__IMissle_explode(this)
        set s__IMissle_owner[this]=null
        call KillUnit(s__IMissle_missle[this])
        call GroupClear(s__IMissle_damaged[this])
        call DestroyGroup(s__IMissle_damaged[this])
        //call GroupRefresh(damaged)
        //call ReleaseGroup(damaged)
        set s__IMissle_damaged[this]=null
        set s__IMissle_missle[this]=null
    endfunction
    
    
    function s__TroughMissle_damageEnemy takes integer this,unit target returns nothing
        local real consume
        call sc__IMissle_troughDamage(this,target)
        set consume=( s__Material_hardness[s__Material__staticgetindex(target)] * s__Material_volume[s__Material__staticgetindex(target)] ) / 100
        if s__IMissle_life[this] <= consume then
            call sc__IMissle_deallocate(this)
        else
            set s__IMissle_life[this]=s__IMissle_life[this] - R2I(consume)
        endif
    endfunction
    
    function s__TroughMissle_troughDamage takes integer this,unit target returns nothing
        call BulletDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this) , SMALL_BLOOD)
    endfunction
    
    function s__ShootGunMissle_getLife takes integer this returns integer
        return 15
    endfunction
    function s__IceMissle_getMissleId takes integer this returns integer
        return bICE_MISSLE
    endfunction
    
    function s__IceMissle_damageEnemy takes integer this,unit target returns nothing
        call IceDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this))
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__IceMissle_debuffEnemy takes integer this,unit target returns nothing
        local unit dummy
        set dummy=CreateUnit(GetOwningPlayer(s__IMissle_owner[this]), MAGIC, GetUnitX(target), GetUnitY(target), 0)
        call IssueTargetOrderById(dummy, 852226, target)
        set dummy=null
    endfunction
    
    function s__FireMissle_damageEnemy takes integer this,unit target returns nothing
        call FireDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this))
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__FireMissle_getMissleId takes integer this returns integer
        return bFIRE_MISSLE
    endfunction
    
    function s__FireMissle_debuffEnemy takes integer this,unit target returns nothing
        call ApplyBurn(s__IMissle_owner[this] , target , 1 , 3)
    endfunction
    function s__SmallDarts_getMissleId takes integer this returns integer
        return 'e002'
    endfunction 
    function s__SmallDarts_getOriginalDamage takes integer this returns real
        return 100.0
    endfunction
    function s__SmallDarts_damageEnemy takes integer this,unit target returns nothing
        call BladeDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this))
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__ElectricWhip_getMissleId takes integer this returns integer
        return bELECTRIC
    endfunction 
    
    function s__ElectricWhip_getOriginalDamage takes integer this returns real
        return 0.0
    endfunction
    
    function s__ElectricWhip_getLife takes integer this returns integer
        return R2I(getf2value(s__IMissle_owner[this] , iELECTRIC))
    endfunction
    
    function s__ElectricWhip_debuffEnemy takes integer this,unit target returns nothing
        call ElectricBlow(s__IMissle_owner[this] , target)
        call s__DefaultBufferStruct_start(s__ElectricWhipBufferStruct_create(target , 150 , s__IMissle_owner[this] , 5))
    endfunction
    
    function s__ElectricWhip_onFire takes integer this returns nothing
        set s__ElectricWhip_l[this]=AddLightningEx("CLPB", false, GetUnitX(s__IMissle_missle[this]), GetUnitY(s__IMissle_missle[this]), getUnitHeight(s__IMissle_missle[this]), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getUnitHeight(s__IMissle_owner[this]))
    endfunction
    
    function s__ElectricWhip_substep takes integer this returns nothing
        call MoveLightningEx(s__ElectricWhip_l[this], false, GetUnitX(s__IMissle_missle[this]), GetUnitY(s__IMissle_missle[this]), getUnitHeight(s__IMissle_missle[this]), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getUnitHeight(s__IMissle_owner[this]))
    endfunction
    
    function s__ElectricWhip_explode takes integer this returns nothing
        call DestroyLightning(s__ElectricWhip_l[this])
    endfunction
    
    
    function s__ReturnDarts_getMissleId takes integer this returns integer
        set s__ReturnDarts_pref[this]=s__vector_create(0 , 0 , 0)
        return 'e003'
    endfunction 
    function s__ReturnDarts_getOriginalDamage takes integer this returns real
        return 130.0
    endfunction
    function s__ReturnDarts_getLife takes integer this returns integer
        return 10000
    endfunction
    function s__ReturnDarts_debuffEnemy takes integer this,unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endfunction
    function s__ReturnDarts_hitSelf takes integer this,unit self returns nothing
        call sc__IMissle_deallocate(this)
    endfunction
    function s__ReturnDarts_getFinalDamage takes integer this returns real
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__ReturnDarts_getOriginalDamage(this)
        set itm=null
        return od + daminc
    endfunction
    
    function s__ReturnDarts_troughDamage takes integer this,unit target returns nothing
        call BladeDamage(s__IMissle_owner[this] , target , s__ReturnDarts_getFinalDamage(this))
    endfunction
    
    function s__ReturnDarts_getReturnForce takes integer this returns integer
        local real fl= 0.7
        local integer v= s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])]
        local real len= s__vector_getLength(v)
        local integer dir= getDirVector(s__IMissle_missle[this] , s__IMissle_owner[this] , fl * 5)
        local real angle= s__vector_getAngle(v , dir)
        local real a= Sin(angle) * len
        local real sd
        local integer r
        local real dl
        if angle >= ( pi / 2 ) then
            set sd=len
        else
            set sd=a
        endif
        if sd > fl then
            set r=s__vector_create(- s__vector_x[v] , - s__vector_y[v] , - s__vector_z[v])
            call s__vector_setLength(r,RMinBJ(len, fl))
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        else
            if angle >= ( pi / 2 ) then
                set dl=SquareRoot(fl * fl - a * a) - SquareRoot(len * len - a * a)
            else
                set dl=SquareRoot(fl * fl - a * a) + SquareRoot(len * len - a * a)
            endif
            set r=s__vector_create(s__vector_x[dir] , s__vector_y[dir] , s__vector_z[dir])
            call s__vector_setLength(r,dl)
            call s__vector_subtract(r,v)
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        endif
        return dir
    endfunction
    function s__ReturnDarts_explode takes integer this returns nothing
        call s__vector_deallocate(s__ReturnDarts_pref[this])
    endfunction
    
    function s__ReturnDarts_substep takes integer this returns nothing
        local integer returnForce
        set returnForce=s__ReturnDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__ReturnDarts_pref[this])
        set s__vector_x[s__ReturnDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__ReturnDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__ReturnDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__ReturnDarts_pref[this])
    endfunction
    
    function s__LeaveDarts_getMissleId takes integer this returns integer
        set s__LeaveDarts_pref[this]=s__vector_create(0 , 0 , 0)
        return 'e003'
    endfunction 
    function s__LeaveDarts_getOriginalDamage takes integer this returns real
        return 100.0
    endfunction
    function s__LeaveDarts_getLife takes integer this returns integer
        return 1000
    endfunction
    function s__LeaveDarts_debuffEnemy takes integer this,unit target returns nothing
        call DestroyEffect(AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)))
        call ApplyBleed(s__IMissle_owner[this] , target , 1 , 10)
    endfunction
    function s__LeaveDarts_getFinalDamage takes integer this returns real
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__LeaveDarts_getOriginalDamage(this)
        set itm=null
        return od + daminc
    endfunction
    
    function s__LeaveDarts_troughDamage takes integer this,unit target returns nothing
        call BladeDamage(s__IMissle_owner[this] , target , s__LeaveDarts_getFinalDamage(this))
    endfunction
    
    function s__LeaveDarts_getReturnForce takes integer this returns integer
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local integer dir= getDirVector(s__IMissle_missle[this] , s__IMissle_owner[this] , 6)
        set itm=null
        return dir
    endfunction
    function s__LeaveDarts_explode takes integer this returns nothing
        call s__vector_deallocate(s__LeaveDarts_pref[this])
    endfunction
    
    function s__LeaveDarts_substep takes integer this returns nothing
        local integer returnForce
        set returnForce=s__LeaveDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__LeaveDarts_pref[this])
        set s__vector_x[s__LeaveDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__LeaveDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__LeaveDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__LeaveDarts_pref[this])
    endfunction
    function s__BackGrenade_getMissleId takes integer this returns integer
        return 'e009'
    endfunction 
    function s__BackGrenade_getOriginalDamage takes integer this returns real
        return 100.0
    endfunction
    function s__BackGrenade_debuffEnemy takes integer this,unit target returns nothing
        local integer lv= R2I(s__ItemFeature_getValue(s__ItemFeatureData_f3[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(GetItemByTypeId(s__IMissle_owner[this] , iBKGRENADE))]]))
        if lv > 0 then
            call Stun(s__IMissle_owner[this] , target , lv)
        endif
    endfunction
    function s__BackGrenade_damageEnemy takes integer this,unit target returns nothing
    endfunction
    function s__BackGrenade_explode takes integer this returns nothing
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iBKGRENADE)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real radius= s__ItemFeature_getValue(f2)
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
        call DestroyEffect(AddSpecialEffect(E_TUNDER_CLAP, x, y))
        set itm=null
    endfunction
    function s__BackGrenade_getLife takes integer this returns integer
        return 300
    endfunction
    function s__PushGrenade_getMissleId takes integer this returns integer
        return 'e00A'
    endfunction 
    function s__PushGrenade_getOriginalDamage takes integer this returns real
        return 100.0
    endfunction
    function s__PushGrenade_debuffEnemy takes integer this,unit target returns nothing
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iPSGRENADE)
        local integer f3= s__ItemFeatureData_f3[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real speed= s__ItemFeature_getValue(f3)
        local real lv= s__ItemFeature_getValue(s__ItemFeatureData_f4[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(GetItemByTypeId(s__IMissle_owner[this] , iPSGRENADE))]])
        local real facing= getTargetDir(s__IMissle_missle[this] , target)
        if lv > 0 then
            call Clap(s__IMissle_owner[this] , target , R2I(lv))
        endif
        call Push(target , facing , speed , 0 , 5)
        set itm=null
    endfunction
    function s__PushGrenade_damageEnemy takes integer this,unit target returns nothing
    endfunction
    function s__PushGrenade_explode takes integer this returns nothing
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iPSGRENADE)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real radius= s__ItemFeature_getValue(f2)
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
        call DestroyEffect(AddSpecialEffect(E_CLAP, x, y))
        set itm=null
    endfunction
    function s__PushGrenade_getLife takes integer this returns integer
        return 300
    endfunction
    
    
    
    function s__Mine_getMissleId takes integer this returns integer
        return 'e00B'
    endfunction 
    function s__Mine_substep takes integer this returns nothing
        if s__Mine_active[this] == false then
            if s__IMissle_life[this] < sc__Mine_getLife(this) - sc__Mine_getDeployTime(this) and HasLiveEnemyUnitInRange(s__IMissle_missle[this] , 200) != null then
                set s__Mine_active[this]=true
            endif
        else
            if s__Mine_count[this] > 0 then
                set s__Mine_count[this]=s__Mine_count[this] - 1
            else
                call sc__IMissle_deallocate(this)
            endif
        endif
    endfunction
    function s__Mine_explode takes integer this returns nothing
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        call DestroyEffect(AddSpecialEffect(E_MINE_EXPLODE, x, y))
        call rangeExplodeDamage(s__IMissle_owner[this] , x , y , 200 , 300)
    endfunction
    function s__Mine_getLife takes integer this returns integer
        return 3000
    endfunction
    function s__Mine_getDeployTime takes integer this returns integer
        return 122
    endfunction
    function s__Mine_create takes unit owner returns integer
        local integer m=s__Mine__allocate(owner)
        set s__Mine_active[m]=false
        set s__Mine_count[m]=20
        return m
    endfunction
    function s__ShoulderCannonMissle_damageEnemy takes integer this,unit target returns nothing
        call BulletDamage(s__IMissle_owner[this] , target , sc__IMissle_getFinalDamage(this) , SMALL_BLOOD)
        call sc__IMissle_deallocate(this)
    endfunction
    
    function s__ShoulderCannonMissle_getLife takes integer this returns integer
        return 30
    endfunction
    function s__ShoulderCannonMissle_getOriginalDamage takes integer this returns real
        return 400.0
    endfunction
    
    function s__ShoulderCannonMissle_getMissleId takes integer this returns integer
        return 'e00E'
    endfunction
    function s__SpearMissle_getLife takes integer this returns integer
        return 30
    endfunction
    function s__SpearMissle_getOriginalDamage takes integer this returns real
        return g_missle_damage + 20
    endfunction
    function s__SpearMissle_getMissleId takes integer this returns integer
        return 'e00F'
    endfunction
    
    
    
    
    function s__SmartDarts_getMissleId takes integer this returns integer
        set s__SmartDarts_pref[this]=s__vector_create(0 , 0 , 0)
        return 'e003'
    endfunction
    
    function s__SmartDarts_getOriginalDamage takes integer this returns real
        return 130.0
    endfunction
    function s__SmartDarts_getLife takes integer this returns integer
        return 10000
    endfunction
    function s__SmartDarts_debuffEnemy takes integer this,unit target returns nothing
        //call DestroyEffect( AddSpecialEffect(BLADE_BLOOD, GetUnitX(target), GetUnitY(target)) )
        //call ApplyBleed(owner, target, 1, 10)
    endfunction
    
    function s__SmartDarts_create takes unit owner,unit target returns integer
        local integer m=s__SmartDarts__allocate(owner)
        set s__SmartDarts_t[m]=target
        set s__SmartDarts_count[m]=3
        set s__SmartDarts_swift[m]=0
        return m
    endfunction
    function s__SmartDarts_hitSelf takes integer this,unit self returns nothing
    endfunction
    function s__SmartDarts_getFinalDamage takes integer this returns real
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__SmartDarts_getOriginalDamage(this)
        set itm=null
        return od + daminc
    endfunction
    
    function s__SmartDarts_troughDamage takes integer this,unit target returns nothing
        call BladeDamage(s__IMissle_owner[this] , target , s__SmartDarts_getFinalDamage(this))
        if target == s__SmartDarts_t[this] then
            set s__SmartDarts_count[this]=s__SmartDarts_count[this] - 1
            set s__SmartDarts_swift[this]=10
            if s__SmartDarts_count[this] == 0 then
                set s__SmartDarts_t[this]=null
                call sc__IMissle_deallocate(this)
            endif
        endif
    endfunction
    
    function s__SmartDarts_getReturnForce takes integer this returns integer
        local real fl= 0.7
        local integer v= s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])]
        local real len= s__vector_getLength(v)
        local integer dir= getDirVector(s__IMissle_missle[this] , s__SmartDarts_t[this] , fl * 5)
        local real angle= s__vector_getAngle(v , dir)
        local real a= Sin(angle) * len
        local real sd
        local integer r
        local real dl
        if s__SmartDarts_swift[this] > 0 then
            set s__SmartDarts_swift[this]=s__SmartDarts_swift[this] - 1
            return s__vector_create(0 , 0 , 0)
        endif
        if angle >= ( pi / 2 ) then
            set sd=len
        else
            set sd=a
        endif
        if sd > fl then
            set r=s__vector_create(- s__vector_x[v] , - s__vector_y[v] , - s__vector_z[v])
            call s__vector_setLength(r,RMinBJ(len, fl))
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        else
            if angle >= ( pi / 2 ) then
                set dl=SquareRoot(fl * fl - a * a) - SquareRoot(len * len - a * a)
            else
                set dl=SquareRoot(fl * fl - a * a) + SquareRoot(len * len - a * a)
            endif
            set r=s__vector_create(s__vector_x[dir] , s__vector_y[dir] , s__vector_z[dir])
            call s__vector_setLength(r,dl)
            call s__vector_subtract(r,v)
            call s__vector_add(r,dir)
            call s__vector_deallocate(dir)
            return r
        endif
        return dir
    endfunction
    function s__SmartDarts_explode takes integer this returns nothing
        call s__vector_deallocate(s__SmartDarts_pref[this])
    endfunction
    
    function s__SmartDarts_substep takes integer this returns nothing
        local integer returnForce
        set returnForce=s__SmartDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__SmartDarts_pref[this])
        set s__vector_x[s__SmartDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__SmartDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__SmartDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__SmartDarts_pref[this])
    endfunction

//library Missle ends
//library Shooter:
    
//Implemented from module T32xs:
        
        function s__AbstractShooter_T32xs___PeriodicLoop takes nothing returns boolean
            local integer this=s__AbstractShooter_T32xs___next[(0)]
            loop
                exitwhen this == 0
                call sc__AbstractShooter_periodic(this)
                set this=s__AbstractShooter_T32xs___next[this]
            endloop
            return false
        endfunction
        function s__AbstractShooter_startPeriodic takes integer this returns nothing
            if not s__AbstractShooter_T32xs___runningPeriodic[this] then
                set s__AbstractShooter_T32xs___prev[s__AbstractShooter_T32xs___next[(0)]]=this
                set s__AbstractShooter_T32xs___next[this]=s__AbstractShooter_T32xs___next[(0)]
                set s__AbstractShooter_T32xs___next[(0)]=this
                set s__AbstractShooter_T32xs___prev[this]=(0)
                
                set s__AbstractShooter_T32xs___runningPeriodic[this]=true
            endif
        endfunction
        
        function s__AbstractShooter_stopPeriodic takes integer this returns nothing
            if s__AbstractShooter_T32xs___runningPeriodic[this] then
                // This is some real magic.
                set s__AbstractShooter_T32xs___next[s__AbstractShooter_T32xs___prev[this]]=s__AbstractShooter_T32xs___next[this]
                set s__AbstractShooter_T32xs___prev[s__AbstractShooter_T32xs___next[this]]=s__AbstractShooter_T32xs___prev[this]
                // This will even work for the starting element.
                
                set s__AbstractShooter_T32xs___runningPeriodic[this]=false
            endif
        endfunction
        
        function s__AbstractShooter_T32xs___onInit takes nothing returns nothing
            call TriggerAddCondition(T32__Trig, Condition(function s__AbstractShooter_T32xs___PeriodicLoop))
        endfunction
    
    function s__AbstractShooter_tick takes integer this returns nothing
    endfunction
    
    function s__AbstractShooter_periodic takes integer this returns nothing
        call sc__IShooter_tick(this)
    endfunction
        
    function s__AbstractShooter_create takes unit owner,integer factory returns integer
        local integer s=s__AbstractShooter__allocate()
        set s__IShooter_owner[s]=owner
        set s__IShooter_factory[s]=factory
        call s__AbstractShooter_startPeriodic(s)
        return s
    endfunction
    
    function s__AbstractShooter_shoothz takes integer this returns integer
        return 10
    endfunction
    
    function s__AbstractShooter_getClipSize takes integer this returns integer
        return 10
    endfunction
    
    function s__AbstractShooter_shootCount takes integer this returns integer
        return 1
    endfunction
    function s__AbstractShooter_getRist takes integer this returns real
        return 100.0
    endfunction
    function s__AbstractShooter_getOriginSpeed takes integer this returns real
        return 60.0
    endfunction
    
    function s__AbstractShooter_shoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
    endfunction
    
    function s__AbstractShooter_getEnergyConsume takes integer this returns integer
        return 1
    endfunction
    function s__AbstractShooter_subshoot takes integer this,integer dir returns nothing
    endfunction
    
    function s__AbstractShooter_onDestroy takes integer this returns nothing
        call s__AbstractShooter_stopPeriodic(this)
        set s__IShooter_owner[this]=null
    endfunction
    
    function s__SingleShooter_shoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
    endfunction
    
    
    
    function s__ShoulderCannonShooter_create takes unit owner,integer factory returns integer
        local integer s=s__ShoulderCannonShooter__allocate(owner , factory)
        set s__ShoulderCannonShooter_c[s]=2
        return s
    endfunction
    function s__ShoulderCannonShooter_tick takes integer this returns nothing
        local integer v
        if ModuloInteger(Tick - s__ShoulderCannonShooter_t[this], 4) == 0 then
            if s__ShoulderCannonShooter_c[this] > 0 then
                set v=s__vector_create(s__vector_x[s__ShoulderCannonShooter_d[this]] , s__vector_y[s__ShoulderCannonShooter_d[this]] , s__vector_z[s__ShoulderCannonShooter_d[this]])
                call s__vector_rotate(v,s__vector_create(0 , 0 , 1) , 0.1 * ( 3 - s__ShoulderCannonShooter_c[this] ))
                call sc__IMissle_fireMissle(sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this]),v)
                set s__ShoulderCannonShooter_c[this]=s__ShoulderCannonShooter_c[this] - 1
            else
                call sc__IShooter_deallocate(this)
            endif
        endif
    endfunction
    function s__ShoulderCannonShooter_shoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call s__vector_rotate(dir,s__vector_create(0 , 0 , 1) , - 0.1)
        set s__ShoulderCannonShooter_d[this]=dir
        call sc__IMissle_fireMissle(m,dir)
        set s__ShoulderCannonShooter_t[this]=Tick
    endfunction
    function s__GrenadeThrower_shoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
    endfunction
    function s__MineThrower_shoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
    endfunction
    function s__DefaultShooter_shoot takes integer this,integer dir returns nothing
        local integer ec= sc__IShooter_getEnergyConsume(this)
        local integer vdir
        local integer i= 1
        local integer n= 0
        set n=( s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])] + sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])] ) / SHOTHZ
        set s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])]=ModuloInteger(s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])] + sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])], SHOTHZ)
        if n == 0 then
            if ( ( GetTimeOfDay() - s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])] ) / 0.005 ) * ( sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])] ) > 100 then
                set n=1
                set s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])]=0
            endif
        endif
        loop
            exitwhen i > n * sc__IShooter_shootCount(this)
            set i=i + 1
            set vdir=sc__DefaultShooter_getShootVector(this)
            if IsHero(s__IShooter_owner[this]) then
                if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] and GetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER) >= ec then
                    call sc__DefaultShooter_energyConsume(this,ec)
                    call sc__DefaultShooter_backForce(this,sc__DefaultShooter_getShootDir(this))
                    call sc__IShooter_subshoot(this,vdir)
                    set s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])]=GetTimeOfDay()
                else
                    if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] then
                        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        call SetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER, 0)
                        call UnitAddAbility(s__IShooter_owner[this], 'Abun')
                        set s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=true
                    endif
                    call DisplayFloatText(GetUnitX(s__IShooter_owner[this]) , GetUnitY(s__IShooter_owner[this]) , "!" , 1)
                endif
            else
                if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] and s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] >= ec then
                    call sc__DefaultShooter_energyConsume(this,ec)
                    call sc__DefaultShooter_backForce(this,sc__DefaultShooter_getShootDir(this))
                    call sc__IShooter_subshoot(this,vdir)
                    set s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])]=GetTimeOfDay()
                else
                    if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] then
                        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        set s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        call UnitAddAbility(s__IShooter_owner[this], 'Abun')
                        set s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=true
                    endif
                    call DisplayFloatText(GetUnitX(s__IShooter_owner[this]) , GetUnitY(s__IShooter_owner[this]) , "!" , 1)
                endif
            endif
        endloop
    endfunction
    
    function s__DefaultShooter_getSpeed takes integer this returns real
        return sc__IShooter_getOriginSpeed(this)
    endfunction
    
    function s__DefaultShooter_getShootDir takes integer this returns real
        local unit target= s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real ux= GetUnitX(s__IShooter_owner[this])
        local real uy= GetUnitY(s__IShooter_owner[this])
        local real tx= GetUnitX(target)
        local real ty= GetUnitY(target)
        local real dir= getDir(ux , uy , tx , ty)
        set target=null
        return dir
    endfunction
    
    function s__DefaultShooter_getShootVector takes integer this returns integer
        local unit target= s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real ux= GetUnitX(s__IShooter_owner[this])
        local real uy= GetUnitY(s__IShooter_owner[this])
        local real uz= getUnitHeight(s__IShooter_owner[this])
        local real tx= GetUnitX(target)
        local real ty= GetUnitY(target)
        local real tz= getUnitHeight(target)
        local real rr= GetRandomReal(0, 2 * pi)
        local real hr= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real rist= sc__IShooter_getRist(this) * RMaxBJ(0, ( 1 - hr )) * SquareRoot(Pow(ty - uy, 2) + Pow(tx - ux, 2)) / 900
        local real tx2= GetUnitX(target) + Cos(rr) * rist
        local real ty2= GetUnitY(target) + Sin(rr) * rist
        local integer t= s__vector_create(tx2 - ux , ty2 - uy , tz - uz)
        call s__vector_setLength(t,s__DefaultShooter_getSpeed(this))
        return t
    endfunction
    
    function s__DefaultShooter_subshoot takes integer this,integer dir returns nothing
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
    endfunction
    
    function s__DefaultShooter_getEnergyConsume takes integer this returns integer
        return 1
    endfunction
    
    function s__DefaultShooter_energyConsume takes integer this,integer consume returns nothing
        local integer l
        if IsHero(s__IShooter_owner[this]) then
            set l=GetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER)
            call SetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER, l - consume)
        else
            set l=s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
            set s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=l - consume
        endif
    endfunction
    
    function s__DefaultShooter_backForce takes integer this,real vdir returns nothing
        local real facing= vdir + pi
        call Push(s__IShooter_owner[this] , facing , s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] , 0 , 5)
    endfunction
    
    function s__ShootGunShooter_getEnergyConsume takes integer this returns integer
        return 1
    endfunction
    
    function s__ShootGunShooter_shootCount takes integer this returns integer
        return 12
    endfunction
    function s__ShootGunShooter_getRist takes integer this returns real
        return 200.0
    endfunction
    function s__ShootGunShooter_getOriginSpeed takes integer this returns real
        return 80.0
    endfunction
    function s__MachineGunShooter_shoothz takes integer this returns integer
        return 100
    endfunction
    function s__MachineGunShooter_getEnergyConsume takes integer this returns integer
        return 1
    endfunction
    function s__MachineGunShooter_getClipSize takes integer this returns integer
        return 100
    endfunction

//library Shooter ends
//library Velocity:
function LoopCollisionGroupUnit takes nothing returns nothing
    local unit u= GetEnumUnit()
    local group tempGroup= NewGroup()
    call GroupEnumUnitsInRange(tempGroup, GetUnitX(u), GetUnitY(u), s__Material_volume[s__Material__staticgetindex(u)], null)
    if CountUnitsInGroup(tempGroup) == 1 then
        call GroupRemoveUnit(COLLISION_GROUP, u)
    endif
    call ReleaseGroup(tempGroup)
    set tempGroup=null
endfunction
function LoopCollisionGroup takes nothing returns nothing
    call ForGroup(COLLISION_GROUP, function LoopCollisionGroupUnit)
    call GroupRefresh(COLLISION_GROUP)
endfunction
function MoveMissles takes nothing returns nothing
    call sc__VelocityUnit_loopMoveAllMissles()
endfunction
    
function MissleInit takes nothing returns nothing
    set missleMoveTimer=CreateTimer()
    set collisionGroupTimer=CreateTimer()
    set COLLISION_GROUP=NewGroup()
    call TimerStart(missleMoveTimer, 0.03125, true, function MoveMissles)
    call TimerStart(collisionGroupTimer, 1, true, function LoopCollisionGroup)
endfunction
function BulletCollision takes unit b,unit u,real r returns nothing
    local integer missle= s__Velocity_missleStruct[sc__Velocity__staticgetindex(b)]
    call sc__IMissle_doDamage(missle,r)
endfunction
function UnitHitWall takes unit s,unit u,real v,real dir,boolean efs returns nothing
    call CollisionDamage(s , u , v , dir , efs)
endfunction
function UnitCollision takes unit u1,unit u2 returns nothing
    local real x1= GetUnitX(u1)
    local real y1= GetUnitY(u1)
    local real x2= GetUnitX(u2)
    local real y2= GetUnitY(u2)
    local integer vn= s__vector_create(x1 - x2 , y1 - y2 , 0)
    local integer v_un= s__vector_unitVector(vn)
    local integer v_ut= s__vector_create(- s__vector_y[v_un] , s__vector_x[v_un] , 0)
    local integer v1= s__Velocity_v[sc__Velocity__staticgetindex(u1)]
    local integer v2= s__Velocity_v[sc__Velocity__staticgetindex(u2)]
    
    local integer dv1= s__vector_create(x2 - x1 , y2 - y1 , 0)
    local integer dv2= s__vector_create(x1 - x2 , y1 - y2 , 0)
    local real pv1= s__vector_getLength(s__vector_projectionVector(v1 , dv1))
    local real pv2= s__vector_getLength(s__vector_projectionVector(v2 , dv2))
    local real pvd= ( pv1 + pv2 ) / 2
    
    local real m1= s__Material_weight[s__Material__staticgetindex(u1)]
    local real m2= s__Material_weight[s__Material__staticgetindex(u2)]
    local real v1n= s__vector_dotProduct(v_un , v1)
    local real v1t= s__vector_dotProduct(v_ut , v1)
    local real v2n= s__vector_dotProduct(v_un , v2)
    local real v2t= s__vector_dotProduct(v_ut , v2)
    local real v1tPrime= v1t
    local real v2tPrime= v2t
    local real v1nPrime= ( v1n * ( m1 - m2 ) ) + 2 * m2 * v2n / ( m1 + m2 )
    local real v2nPrime= ( v2n * ( m2 - m1 ) ) + 2 * m1 * v1n / ( m1 + m2 )
    local integer v_v1nPrime= s__vector_scale2(v_un , v1nPrime)
    local integer v_v1tPrime= s__vector_scale2(v_ut , v1tPrime)
    local integer v_v2nPrime= s__vector_scale2(v_un , v2nPrime)
    local integer v_v2tPrime= s__vector_scale2(v_ut , v2tPrime)
    set s__vector_x[v1]=s__vector_x[v_v1nPrime] + s__vector_x[v_v1tPrime]
    set s__vector_y[v1]=s__vector_y[v_v1nPrime] + s__vector_y[v_v1tPrime]
    set s__vector_x[v2]=s__vector_x[v_v2nPrime] + s__vector_x[v_v2tPrime]
    set s__vector_y[v2]=s__vector_y[v_v2nPrime] + s__vector_y[v_v2tPrime]
    
    if s__Material_clazz[s__Material__staticgetindex(u1)] == MC_WALL then
        call s__vector_setLength(v1,0)
    elseif s__Material_clazz[s__Material__staticgetindex(u2)] == MC_WALL then
        call s__vector_setLength(v2,0)
    endif
    if pvd > DAMAGE_SPEED then
        call UnitHitWall(u1 , u2 , pvd , getTargetDir(u1 , u2) , true)
        call UnitHitWall(u2 , u1 , pvd , getTargetDir(u2 , u1) , false)
    endif
endfunction
//Implemented from module List:
    
    
    
        function s__VelocityUnit_getLength takes nothing returns integer
            return s__VelocityUnit_List___length
        endfunction
    
        function s__VelocityUnit_getFirst takes nothing returns integer
            return s__VelocityUnit_List___first
        endfunction
    
        function s__VelocityUnit_getLast takes nothing returns integer
            return s__VelocityUnit_List___last
        endfunction
    
        function s__VelocityUnit_getRandom takes nothing returns integer
            local integer s= s__VelocityUnit_List___first
            local integer array list
            local integer n= - 1
            loop
                exitwhen s == 0
                set n=n + 1
                set list[n]=s
                set s=s__VelocityUnit_List___next[s]
            endloop
            if n == - 1 then
                return 0
            endif
            return list[GetRandomInt(0, n)]
        endfunction
    
        function s__VelocityUnit_getNext takes integer this returns integer
            return s__VelocityUnit_List___next[this]
        endfunction
    
        function s__VelocityUnit_getPrev takes integer this returns integer
            return s__VelocityUnit_List___prev[this]
        endfunction
    
        function s__VelocityUnit_inList takes integer this returns boolean
            return s__VelocityUnit_List___inlist[this]
        endfunction
        function s__VelocityUnit_addList takes integer this returns boolean
            if not s__VelocityUnit_List___inlist[this] and not s__VelocityUnit_List___destroyinglist then
                set s__VelocityUnit_List___inlist[this]=true
                if s__VelocityUnit_List___first == 0 then
                    set s__VelocityUnit_List___first=this
                else
                    set s__VelocityUnit_List___prev[this]=s__VelocityUnit_List___last
                    set s__VelocityUnit_List___next[s__VelocityUnit_List___prev[this]]=this
                endif
                set s__VelocityUnit_List___last=this
                set s__VelocityUnit_List___length=s__VelocityUnit_List___length + 1
                return true
            endif
            return false
        endfunction
    
        function s__VelocityUnit_removeList takes integer this returns boolean
            if s__VelocityUnit_List___inlist[this] then
                if s__VelocityUnit_List___destroyinglist then
                    return true
                endif
                set s__VelocityUnit_List___inlist[this]=false
                if s__VelocityUnit_List___first == this then
                    set s__VelocityUnit_List___first=s__VelocityUnit_List___next[this]
                endif
                if s__VelocityUnit_List___last == this then
                    set s__VelocityUnit_List___last=s__VelocityUnit_List___prev[this]
                endif
                set s__VelocityUnit_List___next[s__VelocityUnit_List___prev[this]]=s__VelocityUnit_List___next[this]
                set s__VelocityUnit_List___prev[s__VelocityUnit_List___next[this]]=s__VelocityUnit_List___prev[this]
                set s__VelocityUnit_List___length=s__VelocityUnit_List___length - 1
                return true
            endif
            return false
        endfunction
    
        function s__VelocityUnit_destroyList takes nothing returns nothing
            local integer s= s__VelocityUnit_List___first
            if not s__VelocityUnit_List___destroyinglist then
                loop
                    exitwhen s == 0
                    set s__VelocityUnit_List___destroyinglist=false
                    call s__VelocityUnit_removeList(s)
                    set s__VelocityUnit_List___destroyinglist=true
                    call sc__VelocityUnit_deallocate(s)
                    set s=s__VelocityUnit_List___next[s]
                endloop
                set s__VelocityUnit_List___destroyinglist=false
            endif
        endfunction
    
    
    
    function s__VelocityUnit_create takes unit target returns integer
        local integer m=s__VelocityUnit__allocate()
        set s__VelocityUnit_target[m]=target
        call s__VelocityUnit_addList(m)
        return m
    endfunction
    
    function s__VelocityUnit_onDestroy takes integer this returns nothing
        set s__VelocityUnit_target[this]=null
        call s__VelocityUnit_removeList(this)
    endfunction

//Generated destructor of VelocityUnit
function s__VelocityUnit_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__VelocityUnit_V[this]!=-1) then
        return
    endif
    call s__VelocityUnit_onDestroy(this)
    set si__VelocityUnit_V[this]=si__VelocityUnit_F
    set si__VelocityUnit_F=this
endfunction
    
    function s__VelocityUnit_loopMoveAllMissles takes nothing returns nothing
         local string fakeManLv
         local integer m= s__VelocityUnit_getFirst()
             loop
                 exitwhen m == 0
                 set fakeManLv=s__RealMan_CheckLevel(GetUnitX(s__VelocityUnit_target[m]) , GetUnitY(s__VelocityUnit_target[m]) , s__Material_fakelv[s__Material__staticgetindex(s__VelocityUnit_target[m])])
                 if fakeManLv == LV_ACTIVE then
                    call sc__Velocity_periodic(sc__Velocity__staticgetindex(s__VelocityUnit_target[m]))
                 elseif fakeManLv == LV_DESTORY then
                    call KillUnit(s__VelocityUnit_target[m])
                 endif
                 set m=s__VelocityUnit_getNext(m)
             endloop
    endfunction
//textmacro instance: AIDS()
        // This magic line makes default methods get called which do nothing
        // if the methods are otherwise undefined.
        
        //-----------------------------------------------------------------------
        // Gotta know whether or not to destroy on deallocation...
        
        //-----------------------------------------------------------------------
        function s__Velocity__staticgetindex takes unit whichUnit returns integer
            return GetUnitId(whichUnit)
        endfunction
        
        function s__Velocity__get_unit takes integer this returns unit
            // Allows structVar.unit to return the unit.
            return GetIndexUnit(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Velocity_AIDS_addLock takes integer this returns nothing
            call AIDS_AddLock(this)
        endfunction
        function s__Velocity_AIDS_removeLock takes integer this returns nothing
            call AIDS_RemoveLock(this)
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Velocity_AIDS_onEnter takes nothing returns boolean
            // At this point, the unit might not have been assigned an index.
            if sc__Velocity_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation.
                set s__Velocity_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnit())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Velocity_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Velocity_AIDS_onEnterAllocated takes nothing returns boolean
            // At this point, the unit must have been assigned an index.
            if sc__Velocity_AIDS_filter(AIDS_GetEnteringIndexUnit()) then
                // Flag it for destruction on deallocation. Slightly faster!
                set s__Velocity_AIDS_instanciated[(AIDS_GetIndexOfEnteringUnitAllocated())]=true
                // Can use inlining "Assigned" function now, as it must be assigned.
                call sc__Velocity_AIDS_onCreate((AIDS_GetIndexOfEnteringUnitAllocated()))
            endif
            
            return false
        endfunction
        
        function s__Velocity_AIDS_onDeallocate takes nothing returns boolean
            if s__Velocity_AIDS_instanciated[(AIDS_GetDecayingIndex())] then
                call sc__Velocity_AIDS_onDestroy((AIDS_GetDecayingIndex()))
                // Unflag destruction on deallocation.
                set s__Velocity_AIDS_instanciated[(AIDS_GetDecayingIndex())]=false
            endif
            
            return false
        endfunction
        
        //-----------------------------------------------------------------------
        function s__Velocity_onInit takes nothing returns nothing
            call AIDS_RegisterOnEnter(Filter(function s__Velocity_AIDS_onEnter))
            call AIDS_RegisterOnEnterAllocated(Filter(function s__Velocity_AIDS_onEnterAllocated))
            call AIDS_RegisterOnDeallocate(Filter(function s__Velocity_AIDS_onDeallocate))
            
            // Because I robbed you of your struct's onInit method.
            call s__AIDS_DEFAULT_AIDS_onInit()
        endfunction
//end of: AIDS()
    
    
    
    
    function s__Velocity_AIDS_filter takes unit u returns boolean
        local string materialType= s__Material_clazz[s__Material__staticgetindex(u)]
        if GetUnitTypeId(u) == HERO or GetUnitTypeId(u) == 'ewsp' then
            return true
        endif
        if materialType == MC_BULLET or materialType == MC_UNIT or materialType == MC_ARROW or materialType == MC_STONE or materialType == MC_MINE then
            return true
        endif
        return false
    endfunction
    
    function s__Velocity_AIDS_onCreate takes integer this returns nothing
        if GetUnitTypeId(s__Velocity__get_unit(this)) == HERO then
            set s__Velocity_v[this]=s__vector_create(0 , 0 , 0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            //call CreateUnit(GetOwningPlayer(.unit),'ewsp',GetUnitX(.unit) + 400,GetUnitY(.unit)+410,0)
            set s__Velocity_a[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_vu[this]=s__VelocityUnit_create(s__Velocity__get_unit(this))
        else
            set s__Velocity_v[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_a[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_vu[this]=s__VelocityUnit_create(s__Velocity__get_unit(this))
        endif
    endfunction
        
    function s__Velocity_AIDS_onDestroy takes integer this returns nothing
        call s__vector_deallocate(s__Velocity_v[this])
        call s__vector_deallocate(s__Velocity_a[this])
        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
        call s__VelocityUnit_deallocate(s__Velocity_vu[this])
    endfunction
    
    function s__Velocity_periodic takes integer this returns nothing
        local real x= GetUnitX(s__Velocity__get_unit(this))
        local real y= GetUnitY(s__Velocity__get_unit(this))
        local real z= getUnitHeight(s__Velocity__get_unit(this))
        local real v
        local real a= s__vector_getLength(s__Velocity_a[this])
        local real fz
        local real tx
        local real ty
        local real tz
        local real f1
        local real f2
        local real af
        local real fs
        local real as
        local unit tu= null
        local string clazz= s__Material_clazz[s__Material__staticgetindex(s__Velocity__get_unit(this))]
        local integer gravity
        local boolean unitHitWall= false
        local real addon= 0
        if IsUnitAliveBJ(s__Velocity__get_unit(this)) then
            set fz=GetUnitFlyHeight(s__Velocity__get_unit(this))
            if fz > 0.1 then
                if clazz == MC_UNIT or clazz == MC_STONE or clazz == MC_MINE then
                    set gravity=s__vector_create(0 , 0 , - 2)
                    call s__vector_add(s__Velocity_v[this],gravity)
                endif
            endif
            if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                call sc__IMissle_step(s__Velocity_missleStruct[this])
            endif
            set v=s__vector_getLength(s__Velocity_v[this])
            if v > 0 then
                //call BJDebugMsg("velocity "+R2S(v) + R2S(this.v.x)+ " " + R2S(this.v.y)+ " " + R2S(this.v.z))
                //call BJDebugMsg("v " + R2S(v))
                //call BJDebugMsg("f1 " + R2S(f1))
                //call BJDebugMsg("f2 " + R2S(f2))
                //call BJDebugMsg("af " + R2S(af))
                set tz=z + s__vector_z[s__Velocity_v[this]]
                set tx=x + s__vector_x[s__Velocity_v[this]]
                set ty=y + s__vector_y[s__Velocity_v[this]]
                //call BJDebugMsg(R2S(fz) + " " + R2S(this.v.z))
                call MoveUnit(s__Velocity__get_unit(this) , tx , ty , tz)
                //hit ground
                if fz < 0.1 and s__vector_z[s__Velocity_v[this]] < 0 then
                    if s__Material_ground_action[s__Material__staticgetindex(s__Velocity__get_unit(this))] == GROUND_DESTROY then
                        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
                    elseif s__Material_ground_action[s__Material__staticgetindex(s__Velocity__get_unit(this))] == GROUND_STICK then
                        call s__vector_setLength(s__Velocity_v[this],0)
                    endif
                endif
                //F
                if clazz == MC_UNIT or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                    set f2=s__Material_airk[s__Material__staticgetindex(s__Velocity__get_unit(this))] * v * v / 10
                    if fz > 0.1 or clazz == MC_ARROW then
                        set af=f2 / s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))]
                    else
                        set f1=s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))] * g * u / 20
                        set af=( f1 + f2 ) / s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))]
                    endif
                    if af >= v then
                        call s__vector_setLength(s__Velocity_v[this],0)
                    else
                        call s__vector_setLength(s__Velocity_v[this],v - af)
                    endif
                endif
                //hit wall
                if getTerrianHeight(tx , ty) > z + 5 then
                    //call BJDebugMsg("prepare hit wall")
                    if clazz == MC_BULLET or clazz == MC_STONE then
                        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
                    elseif clazz == MC_ARROW then
                    elseif clazz == MC_UNIT then
                        if v > DAMAGE_SPEED then
                            call UnitHitWall(s__Velocity__get_unit(this) , s__Velocity__get_unit(this) , v , getDir(x , y , tx , ty) , true)
                        endif
                        set unitHitWall=true
                    elseif clazz == MC_MINE then
                        set unitHitWall=true
                    endif
                endif
                //CollisionRefresh
                if clazz == MC_BULLET or clazz == MC_ARROW then
                    call sc__IMissle_refreshDamagedGroup(s__Velocity_missleStruct[this])
                endif
                //Collision
                if IsUnitAliveBJ(s__Velocity__get_unit(this)) then
                    //handle boss big collision
                    if GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this))) < 3 then
                        if IsBoss(s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this)))])]]) then
                            set addon=s__Material_volume[s__Material__staticgetindex(s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this)))])]])]
                        endif
                    endif
                    if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                        set tu=HasLiveUnitInRange(s__Velocity__get_unit(this) , addon + RMaxBJ(s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))], v + BULLET_RANGE_ADDON))
                    elseif clazz == MC_UNIT then
                        set tu=GetNearestLiveUnitOrWall(s__Velocity__get_unit(this) , s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))])
                    endif
                    if tu != null then
                        if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                            call BulletCollision(s__Velocity__get_unit(this) , tu , addon + RMaxBJ(s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))], v + BULLET_RANGE_ADDON))
                        elseif clazz == MC_UNIT then
                            if IsUnitInGroup(s__Velocity__get_unit(this), COLLISION_GROUP) and IsUnitInGroup(tu, COLLISION_GROUP) then
                            else
                                call UnitCollision(s__Velocity__get_unit(this) , tu)
                                call GroupAddUnit(COLLISION_GROUP, s__Velocity__get_unit(this))
                                call GroupAddUnit(COLLISION_GROUP, tu)
                            endif
                        endif
                    endif
                endif
            endif
            if a > 0 then
                //call BJDebugMsg("as " + R2S(as))
                //call BJDebugMsg("a " + R2S(a))
                if v == 0 and clazz == MC_UNIT then
                    //set fs = Material[.unit].weight * g * us / 30
                    //set as = fs / Material[.unit].weight
                    set as=g * us / 30
                    if a > as then
                        call s__vector_add(s__Velocity_v[this],s__Velocity_a[this])
                    endif
                else
                    call s__vector_add(s__Velocity_v[this],s__Velocity_a[this])
                endif
            endif
            
            if unitHitWall then
                call s__vector_setLength(s__Velocity_v[this],0)
            endif
        else
            call s__VelocityUnit_deallocate(s__Velocity_vu[this])
        endif
        set tu=null
    endfunction 
    

//library Velocity ends
//===========================================================================
// 
// 鍙槸鍙﹀涓€寮犻瓟鍏戒簤闇哥殑鍦板浘
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Wed Mar 04 20:49:55 2020
//   Map Author: 鏈煡
// 
//===========================================================================
//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************
function InitGlobals takes nothing returns nothing
    set udg_r=0
endfunction
//***************************************************************************
//*
//*  Items
//*
//***************************************************************************
function CreateAllItems takes nothing returns nothing
    local integer itemID
    call CreateItem('I00T', 70.9, 336.7)
    call CreateItem('I00U', - 141.6, 322.9)
endfunction
//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************
//===========================================================================
function CreateBuildingsForPlayer11 takes nothing returns nothing
    local player p= Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u=CreateUnit(p, 'h006', 3200.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3072.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2944.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3328.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3456.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3584.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3712.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3840.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 3968.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4096.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4224.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4352.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4480.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4608.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4736.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4864.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 4992.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5120.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5248.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5376.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2816.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2688.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2560.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 1088.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 960.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 832.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 704.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 2304.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 2176.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 2048.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1920.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1792.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1664.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1536.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1408.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1280.0, - 576.0, 270.000)
    set gg_unit_h006_0048=CreateUnit(p, 'h006', 3520.0, - 1600.0, 270.000)
    set gg_unit_h006_0049=CreateUnit(p, 'h006', 3520.0, - 1728.0, 270.000)
    set u=CreateUnit(p, 'h006', 896.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 768.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 640.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 512.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 384.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 256.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 704.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 832.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 960.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1088.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1344.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1472.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1600.0, 270.000)
    set gg_unit_h006_0065=CreateUnit(p, 'h006', 3520.0, - 1856.0, 270.000)
    set u=CreateUnit(p, 'h006', 6400.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1984.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2112.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2240.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2496.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2624.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2752.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 2880.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 256.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 384.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 512.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 640.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 768.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 896.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1024.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1152.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1280.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1408.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1536.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1664.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1792.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 1920.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 2048.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 2176.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 2304.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 3008.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 2880.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 2752.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 2624.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 2496.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 2560.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 2688.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 2816.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 2944.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3072.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3200.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3328.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3456.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3584.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3712.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3840.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 3968.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4096.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4224.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4352.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4480.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4608.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4736.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4864.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 4992.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5120.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5248.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5376.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5504.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5632.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5760.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 5888.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6016.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6144.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6272.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6400.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6528.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6656.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6784.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 6912.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 7040.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 7168.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 7296.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 7424.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', 7552.0, - 2368.0, 270.000)
    set u=CreateUnit(p, 'h006', - 3328.0, - 1408.0, 270.000)
    set u=CreateUnit(p, 'h006', 6528.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h007', - 3328.0, - 1536.0, 270.000)
    set u=CreateUnit(p, 'h007', - 3328.0, - 1664.0, 270.000)
    set u=CreateUnit(p, 'h007', - 3328.0, - 1792.0, 270.000)
    set u=CreateUnit(p, 'h007', - 3328.0, - 1920.0, 270.000)
    set u=CreateUnit(p, 'h007', - 3328.0, - 2048.0, 270.000)
    set u=CreateUnit(p, 'h006', 6656.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', - 3328.0, - 2176.0, 270.000)
    set u=CreateUnit(p, 'h006', 5504.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5632.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5760.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 5888.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 6016.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 6144.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 6272.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 6784.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 6912.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 7040.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 7168.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 7296.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 7424.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 7552.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 2432.0, - 1216.0, 270.000)
    set u=CreateUnit(p, 'h006', 896.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1024.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1152.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1024.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 1280.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1408.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1152.0, - 576.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1728.0, 270.000)
    set u=CreateUnit(p, 'h006', 128.0, - 1856.0, 270.000)
    set gg_unit_h006_0184=CreateUnit(p, 'h006', 3520.0, - 1472.0, 270.000)
    set gg_unit_h006_0185=CreateUnit(p, 'h006', 3520.0, - 1344.0, 270.000)
    set gg_unit_h006_0186=CreateUnit(p, 'h006', 3520.0, - 1984.0, 270.000)
    set gg_unit_h006_0187=CreateUnit(p, 'h006', 3520.0, - 2112.0, 270.000)
    set gg_unit_h006_0188=CreateUnit(p, 'h006', 3520.0, - 2240.0, 270.000)
    set u=CreateUnit(p, 'h006', 1536.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 1664.0, 2816.0, 270.000)
    set u=CreateUnit(p, 'h006', 896.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1024.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1152.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1280.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1408.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1536.0, - 6400.0, 270.000)
    set u=CreateUnit(p, 'h006', 1664.0, - 6400.0, 270.000)
endfunction
//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life
    set u=CreateUnit(p, 'ncop', 1216.0, - 1792.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1216.0, - 1472.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1216.0, - 2112.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1280.0, 3776.0, 270.000)
    set u=CreateUnit(p, 'ncop', 960.0, 3776.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1600.0, 3776.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1280.0, - 7360.0, 270.000)
    set u=CreateUnit(p, 'ncop', 960.0, - 7360.0, 270.000)
    set u=CreateUnit(p, 'ncop', 1600.0, - 7360.0, 270.000)
    set u=CreateUnit(p, 'ncop', - 4288.0, - 2112.0, 270.000)
    set u=CreateUnit(p, 'ncop', - 4288.0, - 1792.0, 270.000)
    set u=CreateUnit(p, 'ncop', - 4288.0, - 1472.0, 270.000)
    set u=CreateUnit(p, 'ncp3', 2048.0, - 1792.0, 270.000)
endfunction
//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer11()
endfunction
//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
endfunction
//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings()
    call CreatePlayerBuildings()
    call CreatePlayerUnits()
endfunction
//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************
function CreateRegions takes nothing returns nothing
    local weathereffect we
    set gg_rct_lock_1=Rect(6912.0, 8512.0, 7616.0, 9120.0)
    set gg_rct_lock_2=Rect(7680.0, 8512.0, 8384.0, 9120.0)
    set gg_rct_lock_3=Rect(8448.0, 8512.0, 9152.0, 9120.0)
    set gg_rct_lock_11=Rect(6912.0, 7840.0, 7616.0, 8448.0)
    set gg_rct_start=Rect(6592.0, - 2208.0, 7648.0, - 1312.0)
    set gg_rct_start_road_1=Rect(- 32.0, - 3072.0, 2560.0, - 512.0)
    set gg_rct_start_road_2=Rect(2400.0, - 2432.0, 7680.0, - 1152.0)
    set gg_rct_start_road_gate=Rect(4160.0, - 1856.0, 4288.0, - 1728.0)
    set gg_rct_gave_guns=Rect(1952.0, - 1888.0, 2144.0, - 1696.0)
endfunction
//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//TESH.scrollpos=0
//TESH.alwaysfold=0
//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************
//===========================================================================
// Trigger: StartRoom
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: level1
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: InitJobData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Save
//
// call SetUnitManaBJ( GetTriggerUnit(), GetUnitStateSwap(UNIT_STATE_MANA, GetTriggerUnit()) )
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Strong
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemJump
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ItemJump__set_abil takes integer abilId returns nothing
            if s__ItemJump_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ItemJump_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ItemJump_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (1))
            endif
        endfunction
        function s__ItemJump__get_abil takes nothing returns integer
            return s__ItemJump_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ItemJump__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ItemJump_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ItemJump__get_autoDestroyDefault takes nothing returns boolean
            return s__ItemJump_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ItemJump_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ItemJump_create takes nothing returns integer
            local integer this=s__ItemJump__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ItemJump__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ItemJump_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ItemJump_onInit takes nothing returns nothing
        call s__ItemJump__set_abil('A00A')
    endfunction
    
    function s__ItemJump_onChannel takes integer this returns nothing
        local real facing= getFacing(s__SpellStruct_caster[this])
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iJUMP)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real d= s__ItemFeature_getValue(f2)
        local real h= s__ItemFeature_getValue(f1)
        local integer v= s__vector_create(d * Cos(facing) , d * Sin(facing) , h)
        call AddVelocity(s__SpellStruct_caster[this] , v)
    endfunction
    
    function s__ItemJump_onStopCast takes integer this returns nothing
    endfunction
//===========================================================================
// Trigger: GunSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Jump
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__Jump__set_abil takes integer abilId returns nothing
            if s__Jump_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__Jump_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__Jump_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (2))
            endif
        endfunction
        function s__Jump__get_abil takes nothing returns integer
            return s__Jump_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__Jump__set_autoDestroyDefault takes boolean flag returns nothing
            set s__Jump_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__Jump__get_autoDestroyDefault takes nothing returns boolean
            return s__Jump_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__Jump_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__Jump_create takes nothing returns integer
            local integer this=s__Jump__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__Jump__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Jump_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__Jump_onInit takes nothing returns nothing
        call s__Jump__set_abil('A01K')
    endfunction
    
    function s__Jump_onChannel takes integer this returns nothing
        local real facing= s__IHeroData_jump_direction[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]
        local real d= 13
        local real h= 35
        local integer v= s__vector_create(d * Cos(facing) , d * Sin(facing) , h)
        call IssueImmediateOrder(s__SpellStruct_caster[this], "stop")
        call AddVelocity(s__SpellStruct_caster[this] , v)
    endfunction
    
    function s__Jump_onStopCast takes integer this returns nothing
    endfunction
//===========================================================================
// Trigger: JumpFacingStore
//
// function Trig_fd________4_______uConditions takes nothing returns boolean
//     return ((GetIssuedOrderIdBJ() == String2OrderIdBJ("move")) and (GetUnitTypeId(GetTriggerUnit()) == 'hfoo'))
// endfunction
// function Trig_fd________4_______uActions takes nothing returns nothing
//     call CreateTextTagLocBJ( "TRIGSTR_1340", GetRectCenter(GetPlayableMapRect()), GetOrderPointX(), GetOrderPointY(), 100, 100, 100, 0 )
// endfunction
// IsHero(GetOrderTargetUnit()) and 
// //===========================================================================
// function InitTrig_fd________4_______u takes nothing returns nothing
//     set gg_trg_fd________4_______u = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_fd________4_______u, "fd 澶嶅埗 4 澶嶅埗")
// #endif
//     call TriggerRegisterAnyUnitEventBJ( gg_trg_fd________4_______u, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER )
//     call TriggerAddCondition(gg_trg_fd________4_______u, Condition(function Trig_fd________4_______uConditions))
//     call TriggerAddAction(gg_trg_fd________4_______u, function Trig_fd________4_______uActions)
// endfunction
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: InjectionSpeedUp
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__InjectionSpeedUp__set_abil takes integer abilId returns nothing
            if s__InjectionSpeedUp_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__InjectionSpeedUp_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__InjectionSpeedUp_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (3))
            endif
        endfunction
        function s__InjectionSpeedUp__get_abil takes nothing returns integer
            return s__InjectionSpeedUp_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__InjectionSpeedUp__set_autoDestroyDefault takes boolean flag returns nothing
            set s__InjectionSpeedUp_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__InjectionSpeedUp__get_autoDestroyDefault takes nothing returns boolean
            return s__InjectionSpeedUp_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__InjectionSpeedUp_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__InjectionSpeedUp_create takes nothing returns integer
            local integer this=s__InjectionSpeedUp__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__InjectionSpeedUp__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__InjectionSpeedUp_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__InjectionSpeedUp_onInit takes nothing returns nothing
        call s__InjectionSpeedUp__set_abil('A00C')
    endfunction
    
    function s__InjectionSpeedUp_onChannel takes integer this returns nothing
        local real facing= getFacing(s__SpellStruct_caster[this])
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iSPEED)
        local integer f= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real speed= s__ItemFeature_origin[f] + s__ItemFeature_lv[f] * s__ItemFeature_step[f]
        call Push(s__SpellStruct_caster[this] , facing , speed , 0 , 30)
        call s__DefaultBufferStruct_start(s__BoundUnitEffectStruct_create(s__SpellStruct_caster[this] , 30 , 'e001' , - 90 , "stand" , 70))
    endfunction
    
    function s__InjectionSpeedUp_onStopCast takes integer this returns nothing
    endfunction
//===========================================================================
// Trigger: RegisterSpell
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Darts
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__Darts__set_abil takes integer abilId returns nothing
            if s__Darts_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__Darts_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__Darts_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (4))
            endif
        endfunction
        function s__Darts__get_abil takes nothing returns integer
            return s__Darts_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__Darts__set_autoDestroyDefault takes boolean flag returns nothing
            set s__Darts_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__Darts__get_autoDestroyDefault takes nothing returns boolean
            return s__Darts_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__Darts_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__Darts_create takes nothing returns integer
            local integer this=s__Darts__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__Darts__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Darts_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__Darts_onInit takes nothing returns nothing
        call s__Darts__set_abil('A00D')
    endfunction
    
    function s__Darts_getSpeed takes integer this returns real
        return 60.0
    endfunction
    
    function s__Darts_onChannel takes integer this returns nothing
        local unit tu= GetNearestEnemy(s__SpellStruct_caster[this] , 1000)
        local real speed= s__Darts_getSpeed(this)
        local real dd
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , s__SmallDartsFactory__allocate())
        local integer dir
        if ( tu == null ) then
            set dd=getFacing(s__SpellStruct_caster[this])
            set dir=s__vector_create(speed * Cos(dd) , speed * Sin(dd) , 0)
        else
            set dir=getDirVector(s__SpellStruct_caster[this] , tu , speed)
        endif
        call sc__IShooter_shoot(shooter,dir)
        set tu=null
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__Darts_onStopCast takes integer this returns nothing
    endfunction
//===========================================================================
// Trigger: RetrunDarts
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ReturnDartsSpell__set_abil takes integer abilId returns nothing
            if s__ReturnDartsSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ReturnDartsSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ReturnDartsSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (5))
            endif
        endfunction
        function s__ReturnDartsSpell__get_abil takes nothing returns integer
            return s__ReturnDartsSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ReturnDartsSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ReturnDartsSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ReturnDartsSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__ReturnDartsSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ReturnDartsSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ReturnDartsSpell_create takes nothing returns integer
            local integer this=s__ReturnDartsSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ReturnDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ReturnDartsSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ReturnDartsSpell_onInit takes nothing returns nothing
        call s__ReturnDartsSpell__set_abil('A01L')
    endfunction
    
    function s__ReturnDartsSpell_getSpeed takes integer this returns real
        local real speed= 100
        return speed
    endfunction
    
    function s__ReturnDartsSpell_onChannel takes integer this returns nothing
        local real speed= s__ReturnDartsSpell_getSpeed(this)
        local integer factory= s__ReturnDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ReturnDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__ReturnDartsSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: SmartDarts
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__SmartDartsSpell__set_abil takes integer abilId returns nothing
            if s__SmartDartsSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__SmartDartsSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__SmartDartsSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (6))
            endif
        endfunction
        function s__SmartDartsSpell__get_abil takes nothing returns integer
            return s__SmartDartsSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__SmartDartsSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__SmartDartsSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__SmartDartsSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__SmartDartsSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__SmartDartsSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__SmartDartsSpell_create takes nothing returns integer
            local integer this=s__SmartDartsSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__SmartDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__SmartDartsSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__SmartDartsSpell_onInit takes nothing returns nothing
        call s__SmartDartsSpell__set_abil('A01O')
    endfunction
    
    function s__SmartDartsSpell_getSpeed takes integer this returns real
        local real speed= 60
        return speed
    endfunction
    
    function s__SmartDartsSpell_onChannel takes integer this returns nothing
        local real speed= s__SmartDartsSpell_getSpeed(this)
        local integer factory= s__SmartDartsFactory_create(s__SpellStruct_targetUnit[this])
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call BJDebugMsg("fire")
        call s__vector_setLength(dir,s__SmartDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__SmartDartsSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: ShoulderCannon
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ShoulderCannonSpell__set_abil takes integer abilId returns nothing
            if s__ShoulderCannonSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ShoulderCannonSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ShoulderCannonSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (7))
            endif
        endfunction
        function s__ShoulderCannonSpell__get_abil takes nothing returns integer
            return s__ShoulderCannonSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ShoulderCannonSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ShoulderCannonSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ShoulderCannonSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__ShoulderCannonSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ShoulderCannonSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ShoulderCannonSpell_create takes nothing returns integer
            local integer this=s__ShoulderCannonSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ShoulderCannonSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ShoulderCannonSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ShoulderCannonSpell_onInit takes nothing returns nothing
        call s__ShoulderCannonSpell__set_abil('A01N')
    endfunction
    
    function s__ShoulderCannonSpell_getSpeed takes integer this returns real
        local real speed= 75
        return speed
    endfunction
    
    function s__ShoulderCannonSpell_onChannel takes integer this returns nothing
        local real speed= s__ShoulderCannonSpell_getSpeed(this)
        local integer factory= s__ShoulderCannonFactory__allocate()
        local integer shooter= s__ShoulderCannonShooter_create(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ShoulderCannonSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
    endfunction
    
    function s__ShoulderCannonSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: ItemRetrunDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ItemReturnDartsSpell__set_abil takes integer abilId returns nothing
            if s__ItemReturnDartsSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ItemReturnDartsSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ItemReturnDartsSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (8))
            endif
        endfunction
        function s__ItemReturnDartsSpell__get_abil takes nothing returns integer
            return s__ItemReturnDartsSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ItemReturnDartsSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ItemReturnDartsSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ItemReturnDartsSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__ItemReturnDartsSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ItemReturnDartsSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ItemReturnDartsSpell_create takes nothing returns integer
            local integer this=s__ItemReturnDartsSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ItemReturnDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ItemReturnDartsSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ItemReturnDartsSpell_onInit takes nothing returns nothing
        call s__ItemReturnDartsSpell__set_abil('A002')
    endfunction
    
    function s__ItemReturnDartsSpell_getSpeed takes integer this returns real
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iRETURN)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        set itm=null
        return s__ItemFeature_getValue(f1)
    endfunction
    
    function s__ItemReturnDartsSpell_onChannel takes integer this returns nothing
        local real speed= s__ItemReturnDartsSpell_getSpeed(this)
        local integer factory= s__ReturnDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ItemReturnDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__ItemReturnDartsSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: LeaveDarts
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__LeaveDartsSpell__set_abil takes integer abilId returns nothing
            if s__LeaveDartsSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__LeaveDartsSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__LeaveDartsSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (9))
            endif
        endfunction
        function s__LeaveDartsSpell__get_abil takes nothing returns integer
            return s__LeaveDartsSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__LeaveDartsSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__LeaveDartsSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__LeaveDartsSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__LeaveDartsSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__LeaveDartsSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__LeaveDartsSpell_create takes nothing returns integer
            local integer this=s__LeaveDartsSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__LeaveDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__LeaveDartsSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__LeaveDartsSpell_onInit takes nothing returns nothing
        call s__LeaveDartsSpell__set_abil(aLEAVE)
    endfunction
    
    function s__LeaveDartsSpell_getSpeed takes integer this returns real
        return 80.0
    endfunction
    
    function s__LeaveDartsSpell_onChannel takes integer this returns nothing
        local real speed= s__LeaveDartsSpell_getSpeed(this)
        local integer factory= s__LeaveDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__LeaveDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__LeaveDartsSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: BackGrenade
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__BackGrenadeSpell__set_abil takes integer abilId returns nothing
            if s__BackGrenadeSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__BackGrenadeSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__BackGrenadeSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (10))
            endif
        endfunction
        function s__BackGrenadeSpell__get_abil takes nothing returns integer
            return s__BackGrenadeSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__BackGrenadeSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__BackGrenadeSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__BackGrenadeSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__BackGrenadeSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__BackGrenadeSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__BackGrenadeSpell_create takes nothing returns integer
            local integer this=s__BackGrenadeSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__BackGrenadeSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__BackGrenadeSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__BackGrenadeSpell_onInit takes nothing returns nothing
        call s__BackGrenadeSpell__set_abil(aBKGRENADE)
    endfunction
    
    function s__BackGrenadeSpell_getSpeed takes integer this returns real
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iBKGRENADE)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        set itm=null
        return s__ItemFeature_getValue(f1)
    endfunction
    
    function s__BackGrenadeSpell_onChannel takes integer this returns nothing
        local real speed= s__BackGrenadeSpell_getSpeed(this)
        local integer factory= s__BackGrenadeFactory__allocate()
        local integer shooter= s__GrenadeThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= GetGrenadeVector(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real v= GetGrenadeTrajectory(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        call s__vector_setLength(dir,RMinBJ(v, speed))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__BackGrenadeSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: Mine
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__MineSpell__set_abil takes integer abilId returns nothing
            if s__MineSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__MineSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__MineSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (11))
            endif
        endfunction
        function s__MineSpell__get_abil takes nothing returns integer
            return s__MineSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__MineSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__MineSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__MineSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__MineSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__MineSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__MineSpell_create takes nothing returns integer
            local integer this=s__MineSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__MineSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__MineSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__MineSpell_onInit takes nothing returns nothing
        call s__MineSpell__set_abil(aMINE)
    endfunction
       
    function s__MineSpell_onChannel takes integer this returns nothing
        local integer factory= s__MineFactory__allocate()
        local integer shooter= s__MineThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(0 , 0 , 0)
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__MineSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: PushGrenade
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__PushGrenadeSpell__set_abil takes integer abilId returns nothing
            if s__PushGrenadeSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__PushGrenadeSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__PushGrenadeSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (12))
            endif
        endfunction
        function s__PushGrenadeSpell__get_abil takes nothing returns integer
            return s__PushGrenadeSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__PushGrenadeSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__PushGrenadeSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__PushGrenadeSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__PushGrenadeSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__PushGrenadeSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__PushGrenadeSpell_create takes nothing returns integer
            local integer this=s__PushGrenadeSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__PushGrenadeSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__PushGrenadeSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__PushGrenadeSpell_onInit takes nothing returns nothing
        call s__PushGrenadeSpell__set_abil(aPSGRENADE)
    endfunction
    
    function s__PushGrenadeSpell_getSpeed takes integer this returns real
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iPSGRENADE)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        set itm=null
        return s__ItemFeature_getValue(f1)
    endfunction
    
    function s__PushGrenadeSpell_onChannel takes integer this returns nothing
        local real speed= s__PushGrenadeSpell_getSpeed(this)
        local integer factory= s__PushGrenadeFactory__allocate()
        local integer shooter= s__GrenadeThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= GetGrenadeVector(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real v= GetGrenadeTrajectory(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        call s__vector_setLength(dir,RMinBJ(v, speed))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__PushGrenadeSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: Blink
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__Blink__set_abil takes integer abilId returns nothing
            if s__Blink_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__Blink_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__Blink_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (13))
            endif
        endfunction
        function s__Blink__get_abil takes nothing returns integer
            return s__Blink_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__Blink__set_autoDestroyDefault takes boolean flag returns nothing
            set s__Blink_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__Blink__get_autoDestroyDefault takes nothing returns boolean
            return s__Blink_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__Blink_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__Blink_create takes nothing returns integer
            local integer this=s__Blink__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__Blink__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Blink_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__Blink_onInit takes nothing returns nothing
        call s__Blink__set_abil(aBLINK)
    endfunction
    
    function s__Blink_onChannel takes integer this returns nothing
        local real dis= DistanceTwo(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real max= getf1value(s__SpellStruct_caster[this] , iBLINK)
        local real r= RMinBJ(max, dis)
        local real ang= getDir(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real tx= s__SpellStruct__get_casterX(this) + r * Cos(ang)
        local real ty= s__SpellStruct__get_casterY(this) + r * Sin(ang)
        call DestroyEffect(AddSpecialEffect(E_BLINK_CASTER, s__SpellStruct__get_casterX(this), s__SpellStruct__get_casterY(this)))
        call SetUnitX(s__SpellStruct_caster[this], tx)
        call SetUnitY(s__SpellStruct_caster[this], ty)
        call DestroyEffect(AddSpecialEffect(E_BLINK_TARGET, tx, ty))
    endfunction
    
// Trigger: Transport
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__Transport__set_abil takes integer abilId returns nothing
            if s__Transport_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__Transport_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__Transport_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (14))
            endif
        endfunction
        function s__Transport__get_abil takes nothing returns integer
            return s__Transport_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__Transport__set_autoDestroyDefault takes boolean flag returns nothing
            set s__Transport_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__Transport__get_autoDestroyDefault takes nothing returns boolean
            return s__Transport_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__Transport_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__Transport_create takes nothing returns integer
            local integer this=s__Transport__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__Transport__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Transport_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__Transport_onInit takes nothing returns nothing
        call s__Transport__set_abil(aTRANSPORT)
    endfunction
    
    function s__Transport_onFinish takes integer this returns nothing
        local real dis= DistanceTwo(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real max= getf1value(s__SpellStruct_caster[this] , iTRANSPORT)
        local real r= RMinBJ(max, dis)
        local real ang= getDir(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real tx= s__SpellStruct__get_casterX(this) + r * Cos(ang)
        local real ty= s__SpellStruct__get_casterY(this) + r * Sin(ang)
        call DestroyEffect(AddSpecialEffect(E_TRANSPORT_CASTER, s__SpellStruct__get_casterX(this), s__SpellStruct__get_casterY(this)))
        call SetUnitX(s__SpellStruct_caster[this], tx)
        call SetUnitY(s__SpellStruct_caster[this], ty)
        call DestroyEffect(AddSpecialEffect(E_TRANSPORT_TARGET, tx, ty))
    endfunction
    
//===========================================================================
// Trigger: ElectricWhip
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ElectricWhipSpell__set_abil takes integer abilId returns nothing
            if s__ElectricWhipSpell_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ElectricWhipSpell_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ElectricWhipSpell_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (15))
            endif
        endfunction
        function s__ElectricWhipSpell__get_abil takes nothing returns integer
            return s__ElectricWhipSpell_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ElectricWhipSpell__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ElectricWhipSpell_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ElectricWhipSpell__get_autoDestroyDefault takes nothing returns boolean
            return s__ElectricWhipSpell_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ElectricWhipSpell_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ElectricWhipSpell_create takes nothing returns integer
            local integer this=s__ElectricWhipSpell__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ElectricWhipSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ElectricWhipSpell_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ElectricWhipSpell_onInit takes nothing returns nothing
        call s__ElectricWhipSpell__set_abil('A00G')
    endfunction
    
    
    function s__ElectricWhipSpell_onChannel takes integer this returns nothing
        local integer factory= s__ElectricWhipFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local real uz= getUnitHeight(s__SpellStruct_caster[this])
        local real tz
        local integer dir
        if s__SpellStruct_targetUnit[this] == null then
            set tz=getTerrianHeight(s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
            set dir=s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , tz - uz)
        else
            set tz=getUnitHeight(s__SpellStruct_targetUnit[this])
            set dir=s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , tz - uz)
        endif
        call s__vector_setLength(dir,getf1value(s__SpellStruct_caster[this] , iELECTRIC))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
    endfunction
    
    function s__ElectricWhipSpell_onStopCast takes integer this returns nothing
    endfunction
// Trigger: AutoAim
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__AutoAim__set_abil takes integer abilId returns nothing
            if s__AutoAim_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__AutoAim_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__AutoAim_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (16))
            endif
        endfunction
        function s__AutoAim__get_abil takes nothing returns integer
            return s__AutoAim_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__AutoAim__set_autoDestroyDefault takes boolean flag returns nothing
            set s__AutoAim_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__AutoAim__get_autoDestroyDefault takes nothing returns boolean
            return s__AutoAim_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__AutoAim_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__AutoAim_create takes nothing returns integer
            local integer this=s__AutoAim__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__AutoAim__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__AutoAim_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__AutoAim_onInit takes nothing returns nothing
        call s__AutoAim__set_abil(aAUTOAIM)
    endfunction
    
    function s__AutoAim_onChannel takes integer this returns nothing
        local real time= getf1value(s__SpellStruct_caster[this] , iAUTOAIM)
        call s__DefaultBufferStruct_start(s__AutoAimBuffer__allocate(s__SpellStruct_caster[this] , R2I(time * 50)))
    endfunction
    
//===========================================================================
// Trigger: ShootBack
//
//         local real facing = getFacing(caster) + pi
//         local item itm = GetItemByTypeId(caster, iREACT)
//         local ItemFeature f = IndividualItemData[itm].featureData.f1
//         local real speed = f.getValue()
//         call Push(caster, facing, speed, 0, 5)
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Implemented from module SpellStruct:
        //===========================================================================
        // AoE enumeration.
        //
        
        //===========================================================================
        // Setting up the struct.
        //
        function s__ShootBack__set_abil takes integer abilId returns nothing
            if s__ShootBack_SpellStruct___currentAbil != 0 then
                call RemoveSavedInteger(SpellStruct__STORE, s__ShootBack_SpellStruct___currentAbil, SpellStruct__ALLOCATOR)
            endif
            set s__ShootBack_SpellStruct___currentAbil=abilId
            if abilId != 0 then
                call SaveInteger(SpellStruct__STORE, abilId, SpellStruct__ALLOCATOR, (17))
            endif
        endfunction
        function s__ShootBack__get_abil takes nothing returns integer
            return s__ShootBack_SpellStruct___currentAbil
        endfunction
        
        //===========================================================================
        // Auto Cleanup.
        //
        function s__ShootBack__set_autoDestroyDefault takes boolean flag returns nothing
            set s__ShootBack_SpellStruct___doAutoDestroyDefault=flag
        endfunction
        function s__ShootBack__get_autoDestroyDefault takes nothing returns boolean
            return s__ShootBack_SpellStruct___doAutoDestroyDefault
        endfunction
        function s__ShootBack_cleanup takes integer this returns nothing
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
        endfunction
        
        //===========================================================================
        // Struct Allocation.
        //
        function s__ShootBack_create takes nothing returns integer
            local integer this=s__ShootBack__allocate()
            // General stuff
            call s__SpellStruct__set_autoDestroy(this,s__ShootBack__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ShootBack_defaultAoE
            
            //static if thistype.onCreate!=DEFAULTS.onCreate then
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
//endif
return this
        endfunction
    
    function s__ShootBack_onInit takes nothing returns nothing
        call s__ShootBack__set_abil('A00F')
    endfunction
    
    function s__ShootBack_onChannel takes integer this returns nothing
        local real facing= getFacing(s__SpellStruct_caster[this]) + pi
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iREACT)
        local integer f= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real speed= s__ItemFeature_getValue(f)
        set s__IHeroData_a_shoot_back[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]=s__IHeroData_a_shoot_back[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]] + speed
        set s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]=speed
    endfunction
    
    function s__ShootBack_onStopCast takes integer this returns nothing
    endfunction
// Trigger: TeckLock
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TeckLockActions takes nothing returns nothing
    local integer i= 10
    set gg_rct_lock[0]=gg_rct_lock_1
    set gg_rct_lock[1]=gg_rct_lock_2
    set gg_rct_lock[2]=gg_rct_lock_3
    loop
        exitwhen i >= PLAYER_COUNT
        call EnableAbiLock(i)
        set i=i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_TeckLock takes nothing returns nothing
    set gg_trg_TeckLock=CreateTrigger()
    call TriggerAddAction(gg_trg_TeckLock, function Trig_TeckLockActions)
endfunction
//===========================================================================
// Trigger: Register
//===========================================================================
function Trig_RegisterConditions takes nothing returns boolean
    return ( ( GetUnitTypeId(GetTriggerUnit()) == 'H002' ) )
endfunction
function Trig_RegisterActions takes nothing returns nothing
    call RegisterDouble6Package(GetTriggerUnit())
    call AddRealMan(GetTriggerUnit())
    call UnitAddAbility(GetTriggerUnit(), 'A00B')
    call UnitRemoveAbility(GetTriggerUnit(), 'A00B')
endfunction
//===========================================================================
function InitTrig_Register takes nothing returns nothing
    set gg_trg_Register=CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull(gg_trg_Register , GetPlayableMapRect())
    call TriggerAddCondition(gg_trg_Register, Condition(function Trig_RegisterConditions))
    call TriggerAddAction(gg_trg_Register, function Trig_RegisterActions)
endfunction
//===========================================================================
// Trigger: RegisterFly
//===========================================================================
function Trig_RegisterFlyActions takes nothing returns nothing
    call YDWEFlyEnable(GetTriggerUnit())
endfunction
//===========================================================================
function InitTrig_RegisterFly takes nothing returns nothing
    set gg_trg_RegisterFly=CreateTrigger()
    call YDWETriggerRegisterEnterRectSimpleNull(gg_trg_RegisterFly , GetPlayableMapRect())
    call TriggerAddAction(gg_trg_RegisterFly, function Trig_RegisterFlyActions)
endfunction
//===========================================================================
// Trigger: FogControl
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
// Trigger: CameraLock
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Movie
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//===========================================================================
// Trigger: GV
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: LearnAbility
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_LearnAbilityConditions takes nothing returns boolean
    if GetLearnedSkill() == 'A00O' then
        set s__Material_kill_hp[s__Material__staticgetindex(GetTriggerUnit())]=s__Material_kill_hp[s__Material__staticgetindex(GetTriggerUnit())] + 1
        set s__Material_anti_horro[s__Material__staticgetindex(GetTriggerUnit())]=s__Material_anti_horro[s__Material__staticgetindex(GetTriggerUnit())] + 0.1
    endif
    return false
endfunction
//===========================================================================
function InitTrig_LearnAbility takes nothing returns nothing
    set gg_trg_LearnAbility=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_LearnAbility, EVENT_PLAYER_HERO_SKILL)
    call TriggerAddCondition(gg_trg_LearnAbility, Condition(function Trig_LearnAbilityConditions))
endfunction
//===========================================================================
// Trigger: TriggerKillHpBuff
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerKillHpBuffActions takes nothing returns nothing
    call SetUnitState(GetKillingUnitBJ(), UNIT_STATE_LIFE, GetUnitState(GetKillingUnitBJ(), UNIT_STATE_LIFE) + s__Material_kill_hp[s__Material__staticgetindex(GetKillingUnitBJ())])
endfunction
//===========================================================================
function InitTrig_TriggerKillHpBuff takes nothing returns nothing
    set gg_trg_TriggerKillHpBuff=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_TriggerKillHpBuff, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddAction(gg_trg_TriggerKillHpBuff, function Trig_TriggerKillHpBuffActions)
endfunction
//===========================================================================
// Trigger: TriggerHorro
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TriggerHorroConditions takes nothing returns boolean
    if GetEventDamage() > 1 and GetRandomReal(0, 1) <= RMaxBJ(s__Material_horro_dmg[s__Material__staticgetindex(GetEventDamageSource())] - s__Material_anti_horro[s__Material__staticgetindex(GetTriggerUnit())], 0) then
        call ApplyHorro(GetEventDamageSource() , GetTriggerUnit() , 5)
    endif
    return false
endfunction
//===========================================================================
function InitTrig_TriggerHorro takes nothing returns nothing
    set gg_trg_TriggerHorro=CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger(gg_trg_TriggerHorro)
    call TriggerAddCondition(gg_trg_TriggerHorro, Condition(function Trig_TriggerHorroConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrderFilter
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_HorrorOrderFilterConditions takes nothing returns boolean
    if s__Material_horro[s__Material__staticgetindex(GetTriggerUnit())] and GetIssuedOrderId() != OI_MOVE then
        call HorrorMove(GetTriggerUnit())
    endif
    return false
endfunction
//===========================================================================
function InitTrig_HorrorOrderFilter takes nothing returns nothing
    set gg_trg_HorrorOrderFilter=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_HorrorOrderFilter, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerAddCondition(gg_trg_HorrorOrderFilter, Condition(function Trig_HorrorOrderFilterConditions))
endfunction
//===========================================================================
// Trigger: HorrorOrder
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: OrderId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootSpeed
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Radiation
//
// UnitHasBuffBJ(GetTriggerUnit(), 'Bcor')
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ArrayList
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ChooseTech
//
// I2S(GetHeroLevel(GetTriggerUnit()))
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ChooseBonus
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: TechLevelUp
//
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_MAGIC_HUNTER", "0","1","0")
// //! runtextmacro InitTechData("tSTRONG", "浣撹川澧炲己", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tDOGE", "闂伩", "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tSPEED_SHOOT", "鎬ラ€熷皠鍑?, "TT_GENERAL", "0","1","0")
// //! runtextmacro InitTechData("tAIM_SHOOT", "绮惧噯灏勫嚮", "TT_GENERAL", "0","1","0")
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_TechLevelUpConditions takes nothing returns boolean
    local integer ai= GetSpellAbilityId()
    local integer bp= 0
    local unit u
    local integer lv
    local integer p
    local player owner
    local integer pid
    if ( ai >= 'A00Q' and ai <= 'A013' ) or ai == 'A004' then
        set owner=GetOwningPlayer(GetTriggerUnit())
        set pid=GetPlayerId(owner)
        set u=techs[pid]
        set lv=GetUnitAbilityLevel(u, ai)
        set bp=LoadInteger(tdht, ai, tdht_base_point)
        if lv >= 1 and lv <= 2 then
            set bp=bp + 1
        elseif lv >= 3 and lv <= 4 then
            set bp=bp + 2
        elseif lv >= 5 and lv <= 6 then
            set bp=bp + 3
        else
            return true
        endif
        set p=GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED)
        if p >= bp then
            call DisplayInfo(owner , "鎶€鑳藉崌绾ф垚鍔?)
            call SetPlayerStateBJ(owner, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(owner, PLAYER_STATE_RESOURCE_FOOD_USED) - bp)
            call IncUnitAbilityLevel(techs[pid], ai)
            call DispatchTechLevelUp(ai , lv + 1 , pid)
        else
            call DisplayInfo(owner , "绉戞妧鐐逛笉瓒筹紝闇€瑕?" + I2S(bp))
        endif
    endif
    set u=null
    return true
endfunction
//===========================================================================
function InitTrig_TechLevelUp takes nothing returns nothing
    set gg_trg_TechLevelUp=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_TechLevelUp, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_TechLevelUp, Condition(function Trig_TechLevelUpConditions))
endfunction
//===========================================================================
// Trigger: TechData
//
// struct TechTree
//     integer size
//     integer array ids[64]
//     
//     static method create takes nothing returns TechTree
//         local TechTree m=TechTree.allocate()
//         set m.size = 0
//         return m
//     endmethod
//     
//     method addTech takes integer id returns nothing
//         set ids[size] = id
//         set size = size + 1
//     endmethod
// endstruct
//===========================================================================
//TESH.scrollpos=22
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Transform
//
// function TransformAction takes nothing returns nothing
//     local button b=GetClickedButtonBJ()
//     local dialog d=GetClickedDialogBJ()
//     local integer i
// globals
// endglobals
// function Trig_TransformConditions takes nothing returns boolean
//     call BJDebugMsg("jjj")
//     return ((GetItemTypeId(GetManipulatedItem()) == 'I004'))
// endfunction
// function Trig_TransformActions takes nothing returns nothing
//     local unit tu = GetTriggerUnit()
//     local player owner = GetOwningPlayer(tu)
//     local integer i = GetPlayerId(owner)
//     if GetUnitTypeId(tu)== HERO then
//         call DefaultDialog.create("閫夋嫨涓€涓己鍖?,owner)
//     endif
// endfunction
// //===========================================================================
// function InitTrig_Transform takes nothing returns nothing
//     local integer i = 0
//     set gg_trg_Transform = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_Transform, "Transform")
// #endif
//     call TriggerRegisterAnyUnitEventBJ( gg_trg_Transform, EVENT_PLAYER_UNIT_USE_ITEM )
//     call TriggerAddCondition(gg_trg_Transform, Condition(function Trig_TransformConditions))
//     call TriggerAddAction(gg_trg_Transform, function Trig_TransformActions)
// endfunction
//     loop
//         exitwhen td[i]==d or i>PLAYER_COUNT - 1
//         set i=i+1
//     endloop
// endfunction
//     loop
//         exitwhen i > PLAYER_COUNT - 1
//         set td[i] = DialogCreate()
//         set i_trg[i] = CreateTrigger()
//     endloop
//     dialog array td
//     trigger array i_trg
//     unit array i_tu
//     ItemFeatureData fd
//     static method create takes string name, player p, ItemFeatureData fd returns TransformDialog
//         local TransformDialog g=TransformDialog.allocate(name,p)
//         set g.fd = fd
//         return g
//     endmethod
//     method button_clicked takes button b returns nothing
//         local unit hero
//         local ItemFeature f
//         set f  = GetButtonStructA(b)
//         if b != cancel_button then
//             if GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) >= (f.lv
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DialogSystem
//
//             exitwhen id > 0 or i <= 0
//             set i = i - 1
//             set r = GetRandomInt(1, size)
//             
//             //rand tech tree choose
//             set j = 0
//             loop
//                 exitwhen EquipmentData[hero].heroData.tech_counter.cnt[j] >= r or j >= TT_COUNT
//                 set r = r - EquipmentData[hero].heroData.tech_counter.cnt[j]
//                 set j = j + 1
//             endloop
//     method button_clicked takes button b returns nothing
//         call SetPlayerStateBJ( p, PLAYER_STATE_RESOURCE_FOOD_USED, GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) + 2)
//         call DisplayText(p, "鑾峰緱涓ょ偣绉戞妧鐐?)
//         set EquipmentData[heros[GetPlayerId(p)]].heroData.up_point = EquipmentData[heros[GetPlayerId(p)]].heroData.up_point - 1
//     endmethod
//     
//     method init takes nothing returns nothing
//         local button b
//         local string s
//         set s = "绉戞妧鐐?+ 2"
//         set b = DialogAddButton(d, s ,0)
//         set b = null
//     endmethod
// //! textmacro InitTechData takes ID, NAME, CAT, TECH_NEED, GAME_LV_NEED
//     call SaveStr(tdht,$ID$,tdht_name,"$NAME$")
//     call SaveInteger(tdht,$ID$,tdht_cat,$CAT$)
//     call SaveInteger(tdht,$ID$,tdht_tech_need,$TECH_NEED$)
//     call SaveInteger(tdht,$ID$,tdht_game_lv_need,$GAME_LV_NEED$)
//     call TECH_TREES[$CAT$].addItem($ID$)
//     set TECH_TREE_COUNT[$CAT$] = TECH_TREE_COUNT[$CAT$] + 1
//     set TECH_COUNT = TECH_COUNT + 1
// //! endtextmacro
// //! runtextmacro InitTechData("tKMANA", "閫€榄斿垉", "TT_BLADE", "0","1")
//         
//         set k = 0
//         loop
//             exitwhen k > TT_COUNT - 1
//             set s = s + I2S(randtree[k])
//             set k = k + 1
//         endloop
//         //call BJDebugMsg("rand tree " + s)
//===========================================================================
//TESH.scrollpos=97
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Buffer
//===========================================================================
//TESH.scrollpos=156
//TESH.alwaysfold=0
//===========================================================================
// Trigger: BurnBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
    
    
    
    function s__BurnBuffer_addBuffer takes integer this returns nothing
        local integer burnlv= s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]
        set s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=burnlv + 1
        set s__BurnBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl", s__IBufferStruct_u[this], "origin")
    endfunction
    
    function s__BurnBuffer_action takes integer this returns nothing
        if ModuloInteger(s__IBufferStruct_count[this], 25) == 0 then
            call FireDamage(s__BurnBuffer_source[this] , s__IBufferStruct_u[this] , s__BurnBuffer_dam[this])
        endif
    endfunction
    
    function s__BurnBuffer_removeBuffer takes integer this returns nothing
        set s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])] - 1
        set s__BurnBuffer_source[this]=null
        call DestroyEffect(s__BurnBuffer_e[this])
        set s__BurnBuffer_e[this]=null
    endfunction
    
    function s__BurnBuffer_create takes unit u,integer count,unit source,real dam returns integer
        local integer m= s__BurnBuffer__allocate(u , count)
        set s__BurnBuffer_source[m]=source
        set s__BurnBuffer_dam[m]=dam
        return m
    endfunction
    
//===========================================================================
// Trigger: HorroBuffer
//
// //! runtextmacro BuffType("Burn")
//     //! runtextmacro SetBuffName("鐕冪儳")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒扮伀鐒扮噧鐑х殑鎸佺画浼ゅ")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFire.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         if ModuloInteger(Tick, 10) == 0 then
//             call FireDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer burnlv = Material[this.unit].burnlv
//         set this.e = AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl",this.unit,"origin")
//         set Material[this.unit].burnlv = burnlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].burnlv = Material[this.unit].burnlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
    
    
    function s__HorroBuffer_addBuffer takes integer this returns nothing
        set s__Material_horro[s__Material__staticgetindex(s__IBufferStruct_u[this])]=true
        set s__HorroBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl", s__IBufferStruct_u[this], "origin")
        call HorrorMove(s__IBufferStruct_u[this])
        call UnitAddAbility(s__IBufferStruct_u[this], aBAN_ATTACK)
        call DisableAllAbi(s__IBufferStruct_u[this])
    endfunction
    
    function s__HorroBuffer_action takes integer this returns nothing
        if ModuloInteger(s__IBufferStruct_count[this], 100) == 0 then
            call HorrorMove(s__IBufferStruct_u[this])
        endif
    endfunction
    
    function s__HorroBuffer_removeBuffer takes integer this returns nothing
        set s__Material_horro[s__Material__staticgetindex(s__IBufferStruct_u[this])]=false
        set s__HorroBuffer_source[this]=null
        call DestroyEffect(s__HorroBuffer_e[this])
        call UnitRemoveAbility(s__IBufferStruct_u[this], aBAN_ATTACK)
        call EnableAllAbi(s__IBufferStruct_u[this])
        set s__HorroBuffer_e[this]=null
    endfunction
    
    function s__HorroBuffer_create takes unit u,unit source,integer count returns integer
        local integer m= s__HorroBuffer__allocate(u , count)
        set s__HorroBuffer_source[m]=source
        return m
    endfunction
    
//===========================================================================
// Trigger: BleedBuffer
//
// //! runtextmacro BuffType("Bleed")
//     //! runtextmacro SetBuffName("娴佽")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶅彈鍒版祦琛€鐨勬寔缁激瀹?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNGhoulFrenzy.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     
//     private real dam
//     
//     private unit source
//     
//     private method periodic takes nothing returns nothing
//         if ModuloInteger(Tick, 10) == 0 then
//             call NormalDamage(this.source, this.unit, this.dam)
//         endif
//     endmethod
//     
//     implement T32x
//     
//     method setDamage takes real dam, unit source returns nothing
//         set this.dam = dam
//         set this.source = source
//     endmethod
//     
//     method onApply takes nothing returns nothing
//         local integer bleedlv = Material[this.unit].bleedlv
//         set this.e = AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl",this.unit,"chest")
//         set Material[this.unit].bleedlv = bleedlv + 1
//         call this.startPeriodic()
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         set Material[this.unit].bleedlv = Material[this.unit].bleedlv - 1
//         call this.stopPeriodic()
//         call DestroyEffect(this.e)
//         set e = null
//         set source = null
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=11
//TESH.alwaysfold=0
    
    
    
    function s__BleedBuffer_addBuffer takes integer this returns nothing
        local integer bleedlv= s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]
        set s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=bleedlv + 1
        set s__BleedBuffer_e[this]=AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl", s__IBufferStruct_u[this], "chest")
    endfunction
    
    function s__BleedBuffer_action takes integer this returns nothing
        if ModuloInteger(s__IBufferStruct_count[this], 25) == 0 then
            call NormalDamage(s__BleedBuffer_source[this] , s__IBufferStruct_u[this] , s__BleedBuffer_dam[this])
        endif
    endfunction
    
    function s__BleedBuffer_removeBuffer takes integer this returns nothing
        set s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])] - 1
        set s__BleedBuffer_source[this]=null
        call DestroyEffect(s__BleedBuffer_e[this])
        set s__BleedBuffer_e[this]=null
    endfunction
    
    function s__BleedBuffer_create takes unit u,integer count,unit source,real dam returns integer
        local integer m= s__BleedBuffer__allocate(u , count)
        set s__BleedBuffer_source[m]=source
        set s__BleedBuffer_dam[m]=dam
        return m
    endfunction
    
//===========================================================================
// Trigger: IceSlowBuffer
//
// //! runtextmacro BuffType("IceSlow")
//     //! runtextmacro SetBuffName("瀵掑啺")
//     //! runtextmacro SetBuffAlignment("NEGATIVE")
//     //! runtextmacro SetBuffTooltip("鐩爣鐨勭Щ鍔ㄩ€熷害鍜屾敾鍑婚€熷害閮介檷浣庝簡")
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNFrost.blp")
// //! runtextmacro BuffStruct()
//     private effect e
//     method onApply takes nothing returns nothing
//         call Status[this.unit].addStun()
//         //set this.e=AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl",this.unit,"body")
//     endmethod
//     method onRemove takes nothing returns nothing
//         call Status[this.unit].removeStun()
//         call DestroyEffect(this.e)
//     endmethod
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
    function s__IceSlowBuffer_addBuffer takes integer this returns nothing
        call s__Status_addStun(s__Status__staticgetindex(s__IBufferStruct_u[this]))
        set s__IceSlowBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl", s__IBufferStruct_u[this], "origin")
    endfunction
    
    function s__IceSlowBuffer_removeBuffer takes integer this returns nothing
        call s__Status_removeStun(s__Status__staticgetindex(s__IBufferStruct_u[this]))
        call DestroyEffect(s__IceSlowBuffer_e[this])
        set s__IceSlowBuffer_e[this]=null
    endfunction
// Trigger: AutoAimBuffer
//
// //! runtextmacro BuffType("AutoAimBuff")
//     //! runtextmacro SetBuffName("杈呭姪灏勫嚮")
//     //! runtextmacro SetBuffAlignment("POSITIVE")
//     //! runtextmacro SetBuffTooltip("璇ュ崟浣嶈兘澶熻繘琛岀簿纭皠鍑?)
//     //! runtextmacro SetBuffIcon("ReplaceableTextures\\CommandButtons\\BTNScout.blp")
// //! runtextmacro BuffStruct()
//     method onApply takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r + 1
//     endmethod
//     
//     method onRemove takes nothing returns nothing
//         local real r = EquipmentData[.unit].heroData.shoot_rist
//         set EquipmentData[.unit].heroData.shoot_rist = r - 1
//     endmethod
//     
// //! runtextmacro EndBuff()
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
    function s__AutoAimBuffer_addBuffer takes integer this returns nothing
        local real r= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]=r + 1
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\TrueshotAura\\TrueshotAura.mdl", s__IBufferStruct_u[this], "origin"))
    endfunction
    
    function s__AutoAimBuffer_removeBuffer takes integer this returns nothing
        local real r= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]=r - 1
    endfunction
// Trigger: Debuff
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
//===========================================================================
// Trigger: BufferFunction
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Constants
//===========================================================================
//TESH.scrollpos=45
//TESH.alwaysfold=0
//===========================================================================
// Trigger: PlayerHero
//
// function PlayerHeroCondition takes nothing returns nothing
//     local unit tu = GetTriggerUnit()
//     local player owner = GetOwningPlayer(tu)
//     local integer pid = GetPlayerId(owner)
//     call BJDebugMsg("HERO EnTER")
//     if GetUnitTypeId(tu) == HERO then
//         
//         set heros[pid] = tu
//     endif
//     set tu = null
//     set owner = null
// endfunction
// function InitPlayerHero takes nothing returns nothing
// local trigger playerhero_t=CreateTrigger()
// local integer i = 0
// loop
//     exitwhen i >=4
//     set heros[i] = null
// endloop
// call TriggerRegisterEnterRectSimple( playerhero_t, GetPlayableMapRect() )
// call TriggerAddCondition(playerhero_t,function PlayerHeroCondition)
// set playerhero_t=null
// endfunction
// endlibrary
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function CreateHero takes integer pid,real x,real y returns unit
    local unit hero= CreateUnit(Player(pid), HERO, x, y, 0)
    local unit tech= CreateUnit(Player(pid), TECH_UNIT, x, y, 0)
    call UnitAddAbility(hero, SHOOT_SPEED)
    call SetUnitAbilityLevel(hero, SHOOT_SPEED, 1)
    set heros[pid]=hero
    set techs[pid]=tech
    set tech=null
    return hero
endfunction
//===========================================================================
// Trigger: FocuseHero
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_FocuseHeroConditions takes nothing returns boolean
    return ( ( GetUnitTypeId(GetTriggerUnit()) == 'H004' ) )
endfunction
function Trig_FocuseHeroActions takes nothing returns nothing
    local player p= GetTriggerPlayer()
    local integer id= GetPlayerId(p)
    local location l= Location(GetUnitX(heros[id]), GetUnitY(heros[id]))
    call PanCameraToTimedLocForPlayer(p, l, 1)
    call RemoveLocation(l)
    set l=null
    set p=null
endfunction
//===========================================================================
function InitTrig_FocuseHero takes nothing returns nothing
    set gg_trg_FocuseHero=CreateTrigger()
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(0), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(1), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(2), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(3), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(4), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(5), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(6), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(7), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(8), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(9), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(10), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(11), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(12), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(13), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(14), true)
        call TriggerRegisterPlayerSelectionEventBJ(gg_trg_FocuseHero, Player(15), true)
    call TriggerAddCondition(gg_trg_FocuseHero, Condition(function Trig_FocuseHeroConditions))
    call TriggerAddAction(gg_trg_FocuseHero, function Trig_FocuseHeroActions)
endfunction
//===========================================================================
// Trigger: ItemData
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemEquip
//===========================================================================
//TESH.scrollpos=16
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemType
//
//     integer GUN=4
//     integer HAND=1
//     integer ARMOR=2
//     integer SHOE=3
//     integer OTHER=5
//     integer LONGTERM=7
//     integer STATIC=6
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: UnitId
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: FakeMan
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterDead
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ShootTarget
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTypeData
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterBonus
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
//===========================================================================
// Trigger: MonsterTargetGroup
//===========================================================================
//TESH.scrollpos=21
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DeathEffect
//===========================================================================
function Trig_DeathEffectActions takes nothing returns nothing
    call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl", GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit())))
endfunction
//===========================================================================
function InitTrig_DeathEffect takes nothing returns nothing
    set gg_trg_DeathEffect=CreateTrigger()
    call TriggerRegisterPlayerUnitEventSimple(gg_trg_DeathEffect, Player(11), EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddAction(gg_trg_DeathEffect, function Trig_DeathEffectActions)
endfunction
//===========================================================================
// Trigger: Difficulty
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: EffectString
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SkillLearn
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: DoublePacket
//===========================================================================
//TESH.scrollpos=93
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Missle
//
//             if HasLiveEnemyUnitInRange(owner, 300) then
//                 //set this.active = true
//                 call BJDebugMsg("active")
//             endif
// function rangeExplodeDamage takes unit source ,real x ,real y ,real radius, real damage returns nothing
//===========================================================================
//TESH.scrollpos=106
//TESH.alwaysfold=0
// Trigger: MissleFactory
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Gun
//===========================================================================
//TESH.scrollpos=33
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: Shooter
//
//     method shoot takes vector dir returns nothing
//         local real ec = getEnergyConsume()
//         local vector vdir
//         local integer lst = EquipmentData[owner].heroData.last_shoot_tick
//         local integer i = 1
//         local integer interval = R2I(I2R(getModuleTick()) * (1 - EquipmentData[owner].heroData.shoot_speed_buff))
//         if  Tick - lst >= interval then
//             loop
//                 exitwhen i > shootCount()
//                 set i = i + 1
//                 set vdir = getShootVector()
//                 if not EquipmentData[owner].heroData.reload and EquipmentData[owner].heroData.shoot_energy >= ec then
//                     set EquipmentData[owner].heroData.last_shoot_tick = Tick
//                     call energyConsume()
//                     call backForce(getShootDir())
//                     call subshoot(vdir)
//                 else
//                     if not EquipmentData[owner].heroData.reload then
//                         set EquipmentData[owner].heroData.reload = true
//                     endif
//                     call DisplayFloatText(GetUnitX(owner),GetUnitY(owner),"!",0.1)
//                 endif
//             endloop
//         endif
//     endmethod
//===========================================================================
//TESH.scrollpos=114
//TESH.alwaysfold=0
//===========================================================================
// Trigger: HeroData
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
        
        
        //===========================================================================
// Trigger: EquipmentData
//===========================================================================
//TESH.scrollpos=33
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: HeroStatus
//
// function Trig_HeroStatusActions takes nothing returns nothing
//     call SetHeroStr( GetAttacker(), ( GetHeroAgi(null, false) + 1 ), true )
// endfunction
// //===========================================================================
// function InitTrig_HeroStatus takes nothing returns nothing
//     set gg_trg_HeroStatus = CreateTrigger()
// #ifdef DEBUG
//     call YDWESaveTriggerName(gg_trg_HeroStatus, "HeroStatus")
// #endif
//     call TriggerRegisterUnitEvent( gg_trg_HeroStatus, null, EVENT_UNIT_HERO_SKILL )
//     call TriggerAddAction(gg_trg_HeroStatus, function Trig_HeroStatusActions)
// endfunction
//===========================================================================
//TESH.scrollpos=8
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Velocity
//===========================================================================
//TESH.scrollpos=147
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: Material
//
// //! textmacro RegisterMaterial takes ID,CLAZZ,HARDNESS,BOUNCE,VOLUME,WEIGHT,AIRK,FKL,GOUND_ACTION
//===========================================================================
//TESH.scrollpos=84
//TESH.alwaysfold=0
    
//===========================================================================
// Trigger: PhysicsSystem
//===========================================================================
//TESH.scrollpos=10
//TESH.alwaysfold=0
    //===========================================================================
// Trigger: bordercontrol
//===========================================================================
function Trig_bordercontrolActions takes nothing returns nothing
    call RemoveUnit(GetTriggerUnit())
endfunction
//===========================================================================
function InitTrig_bordercontrol takes nothing returns nothing
    set gg_trg_bordercontrol=CreateTrigger()
    call YDWETriggerRegisterLeaveRectSimpleNull(gg_trg_bordercontrol , GetPlayableMapRect())
    call TriggerAddAction(gg_trg_bordercontrol, function Trig_bordercontrolActions)
endfunction
//===========================================================================
// Trigger: TargetFilter
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
//===========================================================================
// Trigger: ItemInfo
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_fConditions takes nothing returns boolean
    return ( ( GetItemType(GetManipulatedItem()) == ITEM_TYPE_PERMANENT ) )
endfunction
function Trig_fActions takes nothing returns nothing
    local item itm= GetManipulatedItem()
    local unit tu= GetTriggerUnit()
    local integer fd= s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]
    local integer data= getItemTypeData(GetItemTypeId(itm))
    local string msg= s__ItemTypeData_name[data] + "\n"
//textmacro instance: AddFeatureData("1")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f1[fd]] > 0 then
            set msg=msg + s__ItemFeature_name[s__ItemFeatureData_f1[fd]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f1[fd]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f1[fd]]) + ") " + R2S(s__ItemFeature_origin[s__ItemFeatureData_f1[fd]] + s__ItemFeature_lv[s__ItemFeatureData_f1[fd]] * s__ItemFeature_step[s__ItemFeatureData_f1[fd]]) + "\n"
        endif
//end of: AddFeatureData("1")
//textmacro instance: AddFeatureData("2")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f2[fd]] > 0 then
            set msg=msg + s__ItemFeature_name[s__ItemFeatureData_f2[fd]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f2[fd]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f2[fd]]) + ") " + R2S(s__ItemFeature_origin[s__ItemFeatureData_f2[fd]] + s__ItemFeature_lv[s__ItemFeatureData_f2[fd]] * s__ItemFeature_step[s__ItemFeatureData_f2[fd]]) + "\n"
        endif
//end of: AddFeatureData("2")
//textmacro instance: AddFeatureData("3")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f3[fd]] > 0 then
            set msg=msg + s__ItemFeature_name[s__ItemFeatureData_f3[fd]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f3[fd]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f3[fd]]) + ") " + R2S(s__ItemFeature_origin[s__ItemFeatureData_f3[fd]] + s__ItemFeature_lv[s__ItemFeatureData_f3[fd]] * s__ItemFeature_step[s__ItemFeatureData_f3[fd]]) + "\n"
        endif
//end of: AddFeatureData("3")
//textmacro instance: AddFeatureData("4")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f4[fd]] > 0 then
            set msg=msg + s__ItemFeature_name[s__ItemFeatureData_f4[fd]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f4[fd]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f4[fd]]) + ") " + R2S(s__ItemFeature_origin[s__ItemFeatureData_f4[fd]] + s__ItemFeature_lv[s__ItemFeatureData_f4[fd]] * s__ItemFeature_step[s__ItemFeatureData_f4[fd]]) + "\n"
        endif
//end of: AddFeatureData("4")
//textmacro instance: AddFeatureData("5")
        if s__ItemFeature_maxlv[s__ItemFeatureData_f5[fd]] > 0 then
            set msg=msg + s__ItemFeature_name[s__ItemFeatureData_f5[fd]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f5[fd]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f5[fd]]) + ") " + R2S(s__ItemFeature_origin[s__ItemFeatureData_f5[fd]] + s__ItemFeature_lv[s__ItemFeatureData_f5[fd]] * s__ItemFeature_step[s__ItemFeatureData_f5[fd]]) + "\n"
        endif
//end of: AddFeatureData("5")
    call DisplayText(GetOwningPlayer(tu) , msg)
    set itm=null
    set tu=null
    call s__ItemTypeData_deallocate(data)
endfunction
//===========================================================================
function InitTrig_ItemInfo takes nothing returns nothing
    set gg_trg_ItemInfo=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_ItemInfo, EVENT_PLAYER_UNIT_USE_ITEM)
    call TriggerAddCondition(gg_trg_ItemInfo, Condition(function Trig_fConditions))
    call TriggerAddAction(gg_trg_ItemInfo, function Trig_fActions)
endfunction
//===========================================================================
// Trigger: BOSS1
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: AIStrategy
//===========================================================================
//TESH.scrollpos=28
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIGroup
//===========================================================================
//TESH.scrollpos=21
//TESH.alwaysfold=0
    
    
//===========================================================================
// Trigger: AIData
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDriver
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIHurted
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AIHurtedConditions takes nothing returns boolean
    if ( ( GetOwningPlayer(GetTriggerUnit()) == Player(11) ) ) then
        //call BeHurted(GetTriggerUnit())
    endif
    return false
endfunction
//===========================================================================
function InitTrig_AIHurted takes nothing returns nothing
    set gg_trg_AIHurted=CreateTrigger()
    call YDWESyStemAnyUnitDamagedRegistTrigger(gg_trg_AIHurted)
    call TriggerAddCondition(gg_trg_AIHurted, Condition(function Trig_AIHurtedConditions))
endfunction
//===========================================================================
// Trigger: DummyCaster
//===========================================================================
//TESH.scrollpos=67
//TESH.alwaysfold=0
//
//      ___  _   _  __  __  __  __ __  __
//     |   \| | | |/  |/  |/  |/  |\ \/ /
//     | |) | |_| | / | / | / | / | \  /
//     |___/\____/_/|__/|_|/|__/|_|_|_|__
//         /  _/ /_\ / __\_   _|  __|  _ //        |  |_ / _ \\__ \ | | |  __|  _ /
//         \___\_/ \_\___/ |_| |____|_|\_\         By Jesus4Lyf
//
//      What is DummyCaster?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          DummyCaster is designed to be the perfect dummy caster for dummy abilities.
//          There has been a lot of thought put into this unit type, and dummy casting
//          has evolved over the years of WC3 mapping. These days, best practise is that
//          damage is triggered, and the effects of an ability such as slow or stun
//          are applied through a global dummy caster (which is owned by Neutral Hostile).
//
//          A lot of thought has been put into this unit. It has no mana, because if
//          it had mana then it could potentially run out and suddenly fail without
//          an apparent reason. It has no movement speed or casting time, allowing it
//          to instantly cast. Hence, this library only exposes one thing. A "DUMMY"
//          unit constant (global variable).
//
//          You may provide this unit with a model by having a model imported into the
//          path "Dummy.mdx". The purpose of this is allowing the same unit type
//          to be created dynamically for special effect attachment.
//
//          The rawcode of the "Dummy Caster" type is 'dumy'.
//
//          Upon issueing the order to cast a spell using the DUMMY global, as long as
//          the spell is instant, the casting will occur before the next line of
//          JASS code is executed, meaning you can cast in a loop or a ForGroup, etc
//          without bugging or dynamically creating (or recycling) dummies.
//
//          The initialiser is in a struct because struct onInit methods are called
//          before library "initializers". This allows abilities to be added on the
//          constant DUMMY unit on map initialisation.
//
//          Spells that this dummy casts should have no mana cost, no cooldown, no
//          cast time and infinite range. They also must be able to be cast from a
//          Neutral Hostile unit to your target, meaning they must be castable on
//          enemies (if you must, you can change the owner of the dummy for the cast,
//          and then change it back if you need to have it target allied units and such).
//
//          Be sure to add your spell to the dummy before trying to cast it! :)
//          Beware of permenantly adding spells with conflicting order ids/strings.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called DummyCaster, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next line (so "external" will line up with this line):
//          external ObjectMerger w3u ushd dumy unam "Dummy Caster" uabi Aloc ucbs 0 ucpt 0 umvs 0 ushu "" umvh 0 umdl "Dummy.mdl" umpi 100000 umpm 100000 umpr 1000 ufoo 0
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Viikuna for demonstrating how to make dummy casters cast instantaneously.
//
//===========================================================================
// Trigger: Status
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=821
//TESH.alwaysfold=0
//
//      ___ _____ _ _____ _   _ ___ 
//     / __|_   _/_\_   _| | | / __|
//     \__ \ | |/ _ \| | | |_| \__ \    By Jesus4Lyf.
//     |___/ |_/_/ \_\_| \____/|___/          v 1.2.8
//
//      What is Status?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Status allows you to apply stuns, silences, disable attacks and much
//          more. Status effects based off dummy casted spells are applied 0.0
//          seconds after the "add" method is called. Status aims to commoditise
//          unit effects in WC3.
//
//      Restrictions
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Disarming spell immune units is not possible. Some status effects will
//          not apply to invulnerable units, namely those which are dummy casted.
//
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Status, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "runtextmacro" will line up with this line):
//          runtextmacro Status__CreateAbilities()
//
//          Go to the object editor, and select abilities. Go to Special > Heroes,
//          and select Disarm (Both). Change Data - Attacks Prevented to Melee, Ranged.
//          For Disarm (Melee), change Attacks Prevented to Melee. For Disarm (Range),
//          change Attacks Prevented to Ranged. Object merger has a bug that does not
//          allow setting this field automatically.
//
//      Methods:
//     藟藟藟藟藟藟藟藟藟藟
//          Statuses (short list):
//              - Disable (addDisable, removeDisable, isDisabled)
//              - Stun (addStun, removeStun, isStunned)
//              - Silence (addSilence, removeSilence, isSilenced)
//              - Doom (addDoom, removeDoom, isDoomed)
//              - DisarmMelee (addDisarmMelee, removeDisarmMelee, isDisarmedMelee)
//              - DisarmRange (addDisarmRange, removeDisarmRange, isDisarmedRange)
//              - Disarm (addDisarm, removeDisarm, isDisarmed) // this is both Melee AND Ranged.
//              - Immobolise (addImmobolise, removeImmobolise, isImmobolised)
//              - Invisible (addInvisible, removeInvisible, isInvisible)
//              - Ghost (addGhost, removeGhost, isGhost)
//              - Invulnerable (addInvulnerable, removeInvulnerable, isInvulnerable)
//              - Immunity (addImmunity, removeImmunity, isImmune)
//              - Pause (addPause, removePause, isPaused)
//              - Hide (addHide, removeHide, isHidden)
//              - Unpath (addUnpath, removeUnpath, isUnpathed)
//              - Hex (addHex, removeHex, isHexed)
//              - Locust (addLocust, removeLocust, isLocust) // does not remove correctly for flying units, use with caution.
//              - NeverMiss (addNeverMiss, removeNeverMiss, isNeverMiss)
//              - AlwaysMiss (addAlwaysMiss, removeAlwaysMiss, isAlwaysMiss)
//              - Untouchable (addUntouchable, removeUntouchable, isUntouchable) // 100% evasion
//              - Banish (addBanish, removeBanish, isBanished)
//              - Phase (addPhase, removePhase, isPhased) // clashes with windwalk, interrupts current order
//              - ResistantSkin (addResistantSkin, removeResistantSkin, isResistantSkin)
//              - ReflectPiercing (addReflectPiercing, removeReflectPiercing, isReflectPiercing)
//
//          Bonuses (short list):
//              - ArmorBonus (modArmorBonus, getArmorBonus)
//              - DamageBonus (modDamageBonus, getDamageBonus)
//              - StrBonus (modStrBonus, getStrBonus)
//              - AgiBonus (modAgiBonus, getAgiBonus)
//              - IntBonus (modIntBonus, getIntBonus)
//              - AttackSpeedBonus (modAttackSpeedBonus, getAttackSpeedBonus)
//              - Health (modHealthBonus, getHealthBonus)
//              - Mana (modManaBonus, getManaBonus)'
//              - HealthRegen (modHealthRegenBonus, getHealthRegenBonus)
//              - HealthRegenPercent (modHealthRegenPercentBonus, getHealthRegenPercentBonus) // percent of max
//              - ManaRegen (modManaRegenBonus, getManaRegenBonus)
//              - ManaRegenPercent (modManaRegenPercentBonus, getManaRegenPercentBonus) // percent of max
//              - MoveSpeed (modMoveSpeedBonus, getMoveSpeedBonus)
//              - MoveSpeedPercent (modMoveSpeedPercentBonus, getMoveSpeedPercentBonus) // percent of current move speed (after normal bonuses).
//
//      How to Use:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Statuses:
//              Status[unit].add?()
//                  - Adds the status effect to the unit.
//                  - This does not add any animation.
//              Status[unit].remove?()
//                  - Removes the status effect added with .add?().
//                  - Will not actually remove it until all added instances are removed.
//              Status[unit].is?() --> boolean
//                  - Checks to see whether or not a unit has a status effect applied.
//
//          Bonuses:
//              Status[unit].mod?(amount)
//                  - Modifies the bonus by the amount given.
//                  - Use a negative value to reverse a bonus.
//                  - Supports giving negative of a bonus.
//              Status[unit].get?()
//                  - Gets the curret total amount for a given bonus.
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Weep: for suggesting that making the ability an ultimate hero ability
//            would allow it to stun magic immune units, and suggesting a simpler
//            target allowance for the ability.
//
//===========================================================================
// Trigger: Heal
//===========================================================================
//TESH.scrollpos=101
//TESH.alwaysfold=0
//////////////////////////////////////////////////////////////
//
//      @@   @@   @@@@@@    @@@    @    
//      @@   @@   @@       @   @   @
//      @@@@@@@   @@@@@   @ @@@ @  @
//      @@   @@   @@      @     @  @
//      @@   @@   @@@@@@  @     @  @@@@@@@@
//
//                by kingking
//
//           This version : v1.0.6
//
//  This library is used to simulate heal events.
//  
//  Functions provided :
//  Heal_RegisterEvent(trig)

//  Heal_UnregisterEvent(trig)

//  Heal_Block(real)

//  Heal_BlockAll()

//  Heal_EnableEvent(boolean)

//  Heal_GetSource() -> unit

//  Heal_GetTarget() -> unit

//  Heal_GetAmount() -> real

//  Heal_GetType() -> HealType

//  HealUnit(healer, target, amount, healtype)

//  
//  Default heal type :

//
//  Heal type creation :

//
//  Requires :


/////////////////////////////////////////////////////////////
// Trigger: ABC
//===========================================================================
//TESH.scrollpos=105
//TESH.alwaysfold=0
//==============================================================================
//  ABC -- STRUCT ATTACHMENT SYSTEM BY COHADAR -- v6.1
//==============================================================================
//==============================================================================
//  Quick function index:
//==============================================================================
//
//    ----------------------------------------------------------------------
//      Set Functions - these functions attach struct to a handle
//    ----------------------------------------------------------------------
//    SetTimerStructA(timer, struct)
//    SetTimerStructB(timer, struct)
//    SetTimerStructC(timer, struct)
//
//    SetTriggerStructA(trigger, struct)
//    SetTriggerStructB(trigger, struct)
//    SetTriggerStructC(trigger, struct)
//
//    SetDialogStructA(dialog, struct)
//    SetDialogStructB(dialog, struct)
//    SetDialogStructC(dialog, struct)
//
//    SetRegionStructA(region, struct)
//    SetRegionStructB(region, struct)
//    SetRegionStructC(region, struct)
//
//    ----------------------------------------------------------------------
//      Get Functions - these functions retrieve attached structs
//    ----------------------------------------------------------------------
//    GetTimerStructA(timer) -> struct
//    GetTimerStructB(timer) -> struct
//    GetTimerStructC(timer) -> struct
//
//    GetTriggerStructA(trigger) -> struct
//    GetTriggerStructB(trigger) -> struct
//    GetTriggerStructC(trigger) -> struct
//
//    GetDialogStructA(dialog) -> struct
//    GetDialogStructB(dialog) -> struct
//    GetDialogStructC(dialog) -> struct
//
//    GetRegionStructA(region) -> struct
//    GetRegionStructB(region) -> struct
//    GetRegionStructC(region) -> struct
//
//    ----------------------------------------------------------------------
//      Clear Functions - these functions clear and return attached value
//    ----------------------------------------------------------------------
//    ClearTimerStructA(timer) -> struct
//    ClearTimerStructB(timer) -> struct
//    ClearTimerStructC(timer) -> struct
//
//    ClearTriggerStructA(trigger) -> struct
//    ClearTriggerStructB(trigger) -> struct
//    ClearTriggerStructC(trigger) -> struct
//
//    ClearDialogStructA(dialog) -> struct
//    ClearDialogStructB(dialog) -> struct
//    ClearDialogStructC(dialog) -> struct
//
//    ClearRegionStructA(region) -> struct
//    ClearRegionStructB(region) -> struct
//    ClearRegionStructC(region) -> struct
//
//==============================================================================
//==============================================================================
//  DOCUMENTATION:
//==============================================================================
//
//  PURPOUSE OF ABC:
//       * Type safe handle attaching.
//      
//       * Currently supported handle types are timer, trigger, dialog and region
//
//  PROS: 
//       * ABC is faster than gamecache based systems.
//
//       * You can attach up to 3 structs on the same handle
//         
//       * System reports collision, and clearing of non-existent value.
//
//       * This system will work even if your map leaks
//         and will NOT slow down because of it.
//
//  CONS:
//       * you must manually clear the stored value - REMEMBER THIS RULE!!!
//         Don't forget to use Clear functions
//
//  DETAILS:
//       * You can use Get to check if struct is attached to handle
//         It will return 0 if it is not.
//
//       * ABC will not interfere with other attachment systems
//         You can freely use any other system alongside ABC
//
//       * For unit attaching I recommend using PUI
//
//  SPECIAL THANKS TO: 
//       * NagelBagel - for finding errors in versions 4.3 and 4.4
//       * Here-b-Trollz - for testing ABC and for making cool spells with it.
//       * Toadcop - for being pain in the ass and for pushing me to improve ABC.
//       * emjlr3 - for pointing out the need for non-generic trigger attachments
//       * PandaMine - I found a bug in ABC by examining his HSAS vs ABC test
//       * All those people out there who use and support my systems
//         Thank you guys.
//
//  HOW TO IMPORT:
//       * Just create a trigger named ABC
//       * convert it to text and replace the whole trigger text with this one
//
//==============================================================================
//==============================================================================
//  Macro function cores
//==============================================================================
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//==============================================================================
//==============================================================================
//  END OF ABC STRUCT ATTACHMENT SYSTEM
//==============================================================================//===========================================================================
// Trigger: AII
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: Table
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Height
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AddEffectZ
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
// Trigger: Move
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: Vector
//===========================================================================
//TESH.scrollpos=69
//TESH.alwaysfold=0
// Trigger: FloatText
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Text
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Direction
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: SpellStruck
//===========================================================================
//TESH.scrollpos=40
//TESH.alwaysfold=0
//
//
//      Spell Struct
//          By Jesus4Lyf.
//       Version 1.0.7.
//
//      What is SpellStruct?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          SpellStruct is a system designed for the sake of rapid spell development.
//          It grants features which can be entirely encapsulated in a struct type per
//          ability. It handles event response creation, timer attachment, trigger
//          attachment, area of effect (AoE) enumeration, unit attachment, and all
//          spells made using it should be automatically MUI/leakless and rather efficient.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called SpellStruct, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//    _______________________
//    ||                   ||
//    || SpellStruct Usage ||
//    ||                   ||
//    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//      Writing a Simple SpellStruct:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - To use SpellStruct, write SpellStructs. These are structs which extend
//            SpellStruct, and implement SpellStruct.
//
//          - Everything is optional to implement/use, except setting thistype.abil='Axxx'
//            in static method onInit.
//
//          - Example:
//

//      Event Responses:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - The following is a list of event responses that come with SpellStructs.
//
//          - Event responses are stored on your struct as members.

//          - The above event response list may be used anywhere in your SpellStruct,
//            and at any time.
//
//          - You may implement methods which are called when the normal Warcraft III
//            spell events would fire. Some of the Warcraft III event responses are
//            broken for certain events, sometimes intermittently, but these are fixed
//            when using SpellStruct.
//            Also, usually in Warcraft III, these are implemented in a way that cycles
//            through all triggered abilities to see if the spell cast is the spell the
//            trigger is for. In SpellStruct, this is changed so that Warcraft III will
//            jump straight to the method for the spell that was cast.
//
//          - These methods, which are called when events fire, are non-static. This means
//            any members you add in your SpellStruct can be accessed from within the method.
//            This is achieved with unit attachment (internally).
//
//          - Example:
//

//      Disabling Auto-Destruction:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - SpellStructs are created just before the .onChannel event method is
//            called.
//
//          - By default, SpellStructs are automatically destroyed, and this occurs
//            just after the method .onStopCast is called.
//
//          - You may extend this lifetime in two ways. If you wish to manually
//            manage the lifetime of a SpellStruct, you may do either of the following:

//          - Setting thistype.autoDestroyDefault to false causes .autoDestroy to
//            be set to false just before onCreate is called, for all new instances.
//
//          - Setting this.autoDestroy to false stops just the current instance
//            from auto destruction. Setting it back to true will cause the struct
//            to be destroyed if it usually would have been by then, else continue
//            to monitor it for auto destruction.
//
//      Locking:
//     藟藟藟藟藟藟藟藟藟藟
//          - You may also add locks to an instance. This is done using this.addLock(),
//            and this.removeLock(). Calling this.addLock increments a counter, and
//            calling this.removeLock() decrements it. While it is greater than 0,
//            a SpellStruct will not be autodestroyed. Decrementing it back to 0
//            after the .onStopCast method has fired while .autoDestroy is true will
//            destroy the struct automatically. This is a garbage collection mechanism.
//
//          - You may check if a struct has no locks on it by using .isNotLocked.
//
//          - Example:
//

//      Timers:
//     藟藟藟藟藟藟藟藟藟
//          - If you have TimerUtils in your map, SpellStruct will operate using
//            TimerUtils data attachment for timers.
//          - If you don't have TimerUtils, but have Recycle, SpellStruct will
//            attach to Recycled timers using GetHandleId and a hashtable.
//          - If you have neither, SpellStruct will create timers dynamically,
//            and pause and destroy them when they are done with. Attachment
//            will be done with GetHandleId and a hashtable.
//
//          - .startTimer(method, period) will start a timer for the given method,
//            for the current spell instance. This means all spell event responses
//            will be available from within the callback. This timer will keep
//            firing until you stop it using .stopTimer(method).
//
//          - Starting a timer in this way automatically adds a lock to the struct,
//            and stopping a timer removes a lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will stop all timers for
//            that struct automatically.
//
//          - Because it attaches both the method to call and the struct instance
//            to the timer, and then fires the method with .execute(), it is
//            recommended that you use this only for timers that are reasonably
//            infrequent. Using T32x with SpellStruct is recommended for high
//            frequency (low period) timers.
//
//          - Example:
//

//      Triggers:
//     藟藟藟藟藟藟藟藟藟藟藟
//          - Trigger attaching works using GetHandleId and a hashtable.
//
//          - .createTrigger(method) will create a trigger with the method as it's
//            action. Do not use DestroyTrigger to remove this trigger, you must
//            use .destroyTrigger(method) to destroy it instead. This saves having
//            to store the trigger in any sort of variable, generally. Destroying
//            a trigger using SpellStruct has protection against the double free
//            bug in Warcraft III, even if you use TriggerSleepAction.
//
//          - Creating a trigger in this way automatically adds a lock to the struct,
//            and destroying it removes this lock. This is to guarantee that when
//            a timer method fires, all data is available and valid (while a struct
//            has locks, it will not be auto destroyed).
//
//          - Manually calling .destroy on a spell struct will destroy all triggers
//            for that struct automatically.
//
//          - Example:
//

//      AoE (Area of Effect) enumeration:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - You may set the AoE of a spell instance using set this.aoe = x, or you
//            may set the default value for the aoe of a spell using set
//            thistype.defaultAoE = x. This will set the value of .aoe to the value
//            specified before onCreate is called.
//
//          - You may enumerate the units in AoE of the target point, the current
//            position of the targetted object, or the caster. This requires a unit
//            filter to be applied.
//
//          - This enum does not clear the group before hand, like native enums.
//            Actually, it should even be safe to use with dynamic groups.
//

//          - You may also skip groups altogether and do actions for all units within
//            aoe of the target point/target/caster.
//

//          - You may also check, for a single unit, to see if it is within the AoE
//            of the target point, target or caster, using the following:
//            - this.isUnitInAoE(myUnit) // within aoe of target point.
//            - this.isUnitInAoETarget(myUnit) // within aoe of target.
//            - this.isUnitInAoECaster(myUnit) // within aoe of caster.
//          - The above return booleans.
//
//          - All AoE functionality takes into account the collision size of the
//            enumerated units. This matches better with Warcraft III AoE detection,
//            which highlights units the spell will hit in green for AoE abilities.
//
//      Miscellaneous:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - call this.forGroup(g, callback method takes unit)
//            Example:
//

//          - real this.getDistanceToTargetWidget() // The distance between the caster and the target widget.
//          - real this.getDistanceToTargetPoint()  // The distance between the caster and the original point targetted.
//          - real this.getAngleToTargetWidget()    // The angle from the caster to the target object (in radians).
//          - real this.getAngleToTargetPoint()    // The angle from the caster to the target location (in radians).
//
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me with the interface hint to make the methods
//            optional.
//
//===========================================================================
// Trigger: Timer Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: HashKeyManager
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: T32
//===========================================================================
//TESH.scrollpos=15
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ Timer32 ~~ By Jesus4Lyf ~~ Version 1.06 ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Timer32?
//         - Timer32 implements a fully optimised timer loop for a struct.
//         - Instances can be added to the loop, which will call .periodic every
//           PERIOD until .stopPeriodic() is called.
//
//    =Pros=
//         - Efficient.
//         - Simple.
//
//    =Cons=
//         - Only allows one period.
//         - The called method must be named ".periodic".
//
//    Methods:
//         - struct.startPeriodic()
//         - struct.stopPeriodic()
//
//         - private method periodic takes nothing returns nothing
//
//           This must be defined in structs that implement Periodic Module.
//           It will be executed by the module every PERIOD until .stopPeriodic() is called.
//           Put "implement T32x" BELOW this method.
//
//    Modules:
//         - T32x
//           Has no safety on .stopPeriodic or .startPeriodic (except debug messages
//           to warn).
//
//         - T32xs
//           Has safety on .stopPeriodic and .startPeriodic so if they are called
//           multiple times, or while otherwise are already stopped/started respectively,
//           no error will occur, the call will be ignored.
//
//         - T32
//           The original, old version of the T32 module. This remains for backwards
//           compatability, and is deprecated. The periodic method must return a boolean,
//           false to continue running or true to stop.
//
//  Details:
//         - Uses one timer.
//
//         - Do not, within a .periodic method, follow a .stopPeriodic call with a
//           .startPeriodic call.
//
//  How to import:
//         - Create a trigger named T32.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Infinitegde for finding a bug in the debug message that actually altered
//           system operation (when in debug mode).
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: HashTable
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Distance
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: AIDS
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=69
//TESH.alwaysfold=0
//  
//        _   ___ ___  ___    _______________________________________________
//       /_\ |_ _|   \/ __|   ||     A D V A N C E D   I N D E X I N G     ||
//      / _ \ | || |) \__ \   ||                  A N D                    ||
//     /_/ \_\___|___/|___/   ||         D A T A   S T O R A G E           ||
//            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.1.0
//      What is AIDS?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          AIDS assigns unique integers between 1 and 8191 to units which enter
//          the map. These can be used for arrays and data attaching.
//          
//          AIDS also allows you to define structs which are created automatically
//          when units enter the map, and filtering which units should be indexed
//          as well as for which units these structs should be created.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Simply create a new trigger object called AIDS, go to 'Edit -> Convert
//          to Custom Text', and replace everything that's there with this script.
//
//          Save the map, close it, reopen it, and then delete the "!" from the
//          FAR left side of the next lines (so "external" will line up with this line):
//          external ObjectMerger w3a Adef AIDS anam "State Detection" ansf "(AIDS)" aart "" arac 0
//
//          At the top of the script, there is a 'UnitIndexingFilter' constant
//          function. If the function returns true for the unit, then that unit
//          will be automatically indexed. Setting this to true will automatically
//          index all units. Setting it to false will disable automatic indexing.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function GetUnitId takes unit u returns integer
//              - This returns the index of an indexed unit. This will return 0
//                if the unit has not been indexed.
//              - This function inlines. It does not check if the unit needs an
//                index. This function is for the speed freaks.
//              - Always use this if 'UnitIndexingFilter' simply returns true.
//
//          function GetUnitIndex takes unit u returns integer
//              - This will return the index of a unit if it has one, or assign
//                an index if the unit doesn't have one (and return the new index).
//              - Use this if 'UnitIndexingFilter' doesn't return true.
//
//          function GetIndexUnit takes integer index returns unit
//              - This returns the unit which has been assigned the 'index'.
//
//      AIDS Structs:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - Insert: //! runtextmacro AIDS() at the top of a struct to make it
//            an AIDS struct.
//          - AIDS structs cannot be created or destroyed manually. Instead, they
//            are automatically created when an appropriate unit enters the map.
//          - You cannot give members default values in their declaration.
//            (eg: private integer i=5 is not allowed)
//          - You cannot use array members.
//          - AIDS structs must "extend array". This will remove some unused
//            functions and enforce the above so there will be no mistakes.
//          - There are four optional methods you can use in AIDS structs:
//              - AIDS_onCreate takes nothing returns nothing
//                  - This is called when the struct is 'created' for the unit.
//                  - In here you can assign members their default values, which
//                    you would usually assign in their declarations.
//                    (eg: set this.i=5)
//              - AIDS_onDestroy takes nothing returns nothing
//                  - This is called when the struct is 'destroyed' for the unit.
//                  - This is your substitute to the normal onDestroy method.
//              - AIDS_filter takes unit u returns boolean
//                  - This is similar to the constant filter in the main system.
//                  - Each unit that enters the map will be tested by each AIDS
//                    struct filter. If it returns true for that unit, that unit
//                    will be indexed if it was not already, the AIDS struct will
//                    have its AIDS_onCreate method called, and later have its
//                    AIDS_onDestroy method called when the index is recycled.
//                  - Not declaring this will use the default AIDS filter instead.
//              - AIDS_onInit takes nothing returns nothing
//                  - This is because I stole your onInit function with my textmacro.
//          - You can use '.unit' from any AIDS struct to get the unit for which
//            the struct is for.
//          - The structs id will be the units index, so getting the struct for
//            a unit inlines to a single native call, and you can typecast between
//            different AIDS structs. This is the premise of AIDS.
//          - Never create or destroy AIDS structs directly.
//          - You can call .AIDS_addLock() and AIDS_removeLock() to increase or
//            decrease the lock level on the struct. If a struct's lock level is
//            not 0, it will not be destroyed until it is reduced to 0. Locks just
//            put off AIDS struct destruction in case you wish to attach to a timer
//            or something which must expire before the struct data disappears.
//            Hence, not freeing all locks will leak the struct (and index).
//
//      PUI and AutoIndex:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - AIDS includes the PUI textmacros and the AutoIndex module, because
//            these systems are not compatible with AIDS but have valid and distinct
//            uses.
//          - The PUI textmacros are better to use for spells than AIDS structs,
//            because they are not created for all units, just those targetted by
//            the spell (or whatever else is necessary).
//          - The AutoData module is good for very simple array syntax for data
//            attachment (although I don't recommend that people actually use it,
//            it's here mostly for compatability). Note that unlike the PUI textmacros,
//            units must pass the AIDS filter in order for this module to work with
//            them. This is exactly as the same as in AutoIndex itself (AutoIndex
//            has a filter too).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for writing 90% of this user documentation, challenging my
//            interface, doing some testing, suggesting improvements and inspiring
//            me to re-do my code to include GetUnitIndex as non-inlining.
//          - grim001, for writing the AutoData module, and AutoIndex. I used the
//            on-enter-map method that he used. Full credits for the AutoData module.
//          - Cohadar, for writing his PUI textmacros. Full credits to him for these,
//            except for my slight optimisations for this system.
//            Also, I have used an optimised version of his PeriodicRecycler from
//            PUI in this system to avoid needing a RemoveUnitEx function.
//          - Vexorian, for helping Cohadar on the PUI textmacro.
//          - Larcenist, for suggesting the AIDS acronym. Originally he suggested
//            'Alternative Index Detection System', but obviously I came up with
//            something better. In fact, I'd say it looks like the acronym was
//            an accident. Kinda neat, don't you think? :P
//
//      Final Notes:
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          - With most systems, I wouldn't usually add substitutes for alternative
//            systems. However, UnitData systems are an exception, because they
//            are incompatible with eachother. Since using this system forbids
//            people from using the real PUI or AutoIndex, and a lot of resources
//            use either of these, it made sense not to break them all.
//
//          - If this documentation confused you as to how to use the system, just
//            leave everything as default and use GetUnitId everywhere.
//
//          - To use this like PUI (if you don't like spamming indices) simply
//            make the AIDS filter return false, and use GetUnitIndex.
//
// Trigger: AIDSCleaner
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AIDSCleanerActions takes nothing returns nothing
    local unit tu= GetTriggerUnit()
    call s__EquipmentData_stopPeriodic(s__EquipmentData__staticgetindex(tu))
endfunction
//===========================================================================
function InitTrig_AIDSCleaner takes nothing returns nothing
    set gg_trg_AIDSCleaner=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_AIDSCleaner, EVENT_PLAYER_UNIT_DEATH)
    call YDWETriggerRegisterLeaveRectSimpleNull(gg_trg_AIDSCleaner , GetPlayableMapRect())
    call TriggerAddCondition(gg_trg_AIDSCleaner, Condition(function Trig_AIDSCleanerActions))
endfunction
//===========================================================================
// Trigger: Event
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  ~~    Event     ~~    By Jesus4Lyf    ~~    Version 1.04    ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Event?
//         - Event simulates Warcraft III events. They can be created,
//           registered for, fired and also destroyed.
//         - Event, therefore, can also be used like a trigger "group".
//         - This was created when there was an influx of event style systems 
//           emerging that could really benefit from a standardised custom
//           events snippet. Many users were trying to achieve the same thing
//           and making the same kind of errors. This snippet aims to solve that.
//
//  Functions:
//         - Event.create()       --> Creates a new Event.
//         - .destroy()           --> Destroys an Event.
//         - .fire()              --> Fires all triggers which have been
//                                    registered on this Event.
//         - .register(trigger)   --> Registers another trigger on this Event.
//         - .unregister(trigger) --> Unregisters a trigger from this Event.
//
//  Details:
//         - Event is extremely efficient and lightweight.
//         - It is safe to use with dynamic triggers.
//         - Internally, it is just a linked list. Very simple.
//
//  How to import:
//         - Create a trigger named Event.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Builder Bob for the trigger destroy detection method.
//         - Azlier for inspiring this by ripping off my dodgier code.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: Damage
//===========================================================================
//TESH.scrollpos=63
//TESH.alwaysfold=0
//  
//      ___   _     __  __   _   ___  ____    _______________________________
//     |   \ /_\   /  |/  | /_\ /  _\|  __|   ||      D E A L   I T ,      ||
//     | |) / _ \ / / | / |/ _ \| |/||  __|   ||    D E T E C T   I T ,    ||
//     |___/_/ \_/_/|__/|_|_/ \_\___/|____|   ||     B L O C K   I T .     ||
//                            By Jesus4Lyf    藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//                                                                    v 1.0.1
//      What is Damage?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Damage is a damage dealing, detection and blocking system. It implements
//          all such functionality. It also provides a means to detect what type
//          of damage was dealt, so long as all damage in your map is dealt using
//          this system's deal damage functions (except for basic attacks).
//
//          It is completely recursively defined, meaning if you deal damage on
//          taking damage, the type detection and other features like blocking
//          will not malfunction.
//          
//      How to implement?
//     藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟藟
//          Create a new trigger object called Damage, go to 'Edit -> Convert to
//          Custom Text', and replace everything that's there with this script.
//
//          At the top of the script, there is a '//! external ObjectMerger' line.
//          Save your map, close your map, reopen your map, and then comment out this
//          line. Damage is now implemented. This line creates a dummy ability used
//          in the system in some circumstances with damage blocking.
//
//      Functions:
//     藟藟藟藟藟藟藟藟藟藟藟藟
//          function Damage_RegisterEvent takes trigger whichTrigger returns nothing
//              - This registers a special "any unit takes damage" event.
//              - This event supports dynamic trigger use.
//              - Only triggers registered on this event may block damage.
//
//          function Damage_GetType takes nothing returns damagetype
//              - This will get the type of damage dealt, like an event response,
//                for when using a unit takes damage event (or the special event above).
//
//          function Damage_Block takes real amount returns nothing
//          function Damage_BlockAll takes nothing returns nothing
//              - For use only with Damage_RegisterEvent.
//              - Blocks 'amount' of the damage dealt.
//              - Multiple blocks at once work correctly.
//              - Blocking more than 100% of the damage will block 100% instead.
//              - Damage_BlockAll blocks 100% of the damage being dealt.
//
//          function Damage_EnableEvent takes boolean enable returns nothing
//              - For disabling and re-enabling the special event.
//              - Use it to deal damage which you do not want to be detected by
//                the special event.
//
//          function UnitDamageTargetEx takes lots of things returns boolean
//              - Replaces UnitDamageTarget in your map, with the same arguments.
//
//          function Damage_Physical takes unit source, unit target, real amount,
//            attacktype whichType, boolean attack, boolean ranged returns boolean
//              - A clean wrapper for physical damage.
//              - 'attack' determines if this is to be treated as a real physical
//                attack or just physical type damage.
//              - 'ranged' determines if this is to be treated as a ranged or melee
//                attack.
//
//          function Damage_Spell takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for spell damage.
//
//          function Damage_Pure takes unit source, unit target, real amount returns boolean
//              - A clean wrapper for pure type damage (universal type, 100% damage).
//          
//      Thanks:
//     藟藟藟藟藟藟藟藟藟
//          - Romek, for helping me find a better way to think about damage blocking.
//
//===========================================================================
// Trigger: CustomDamage
//===========================================================================
//TESH.scrollpos=99
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Custom Congregation
//===========================================================================
//TESH.scrollpos=10
//TESH.alwaysfold=0
// Trigger: List Module
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Group Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: CreateItem
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
function Trig_CreateItemActions takes nothing returns nothing
    local integer i= 0
    call YDWEPolledWaitNull(1.00)
    //call CreateItemEx('I003',0,0)
    //call CreateItemEx('I002',0,0)
    //call CreateItemEx(iRETURN,0,0)
    //call CreateItemEx(iREACT,0,0)
    //call CreateItemEx(iELECTRIC,0,0)
    //call CreateItemEx(iBLINK,0,0)
    //call CreateItemEx(iTRANSPORT,0,0)
    //call CreateItemEx(iAUTOAIM,0,0)
    //call CreateItemEx(iLEAVE,0,0)
    //call CreateItemEx(iBKGRENADE,0,0)
    //call CreateItemEx(iPSGRENADE,0,0)
    //call CreateItemEx(iMINE,0,0)
    call CreateItemEx('I00P' , 0 , 0)
    call CreateItemEx('I00Q' , 0 , 0)
    call CreateItemEx('I00S' , 0 , 0)
    call CreateItemEx('I00R' , 0 , 0)
    call CreateItemEx('I001' , 0 , 0)
    loop
        exitwhen i > 0
        //call CreateItemEx(i100G,-300,0)
        set i=i + 1
    endloop
    set i=0
    loop
        exitwhen i > 0
        //call CreateItemEx(iFREEUP,-300,-100)
        set i=i + 1
    endloop
    set i=0
    loop
        exitwhen i > 0
        //call CreateItemEx(iEXP,-300,-200)
        set i=i + 1
    endloop
endfunction
//===========================================================================
function InitTrig_CreateItem takes nothing returns nothing
    set gg_trg_CreateItem=CreateTrigger()
    call TriggerAddAction(gg_trg_CreateItem, function Trig_CreateItemActions)
endfunction
//===========================================================================
// Trigger: 12 澶嶅埗 2 澶嶅埗 3
//===========================================================================
function Trig_12________2________3Actions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_12________2________3 takes nothing returns nothing
    set gg_trg_12________2________3=CreateTrigger()
    call TriggerAddAction(gg_trg_12________2________3, function Trig_12________2________3Actions)
endfunction
//===========================================================================
// Trigger: camera
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_cameraActions takes nothing returns nothing
    call SetCameraFieldForPlayer(Player(0), CAMERA_FIELD_TARGET_DISTANCE, 2500.00, 0.50)
endfunction
//===========================================================================
function InitTrig_camera takes nothing returns nothing
    set gg_trg_camera=CreateTrigger()
    call TriggerAddAction(gg_trg_camera, function Trig_cameraActions)
endfunction
//===========================================================================
// Trigger: inittest
//===========================================================================
//TESH.scrollpos=18
//TESH.alwaysfold=0
function Trig_inittestActions takes nothing returns nothing
    local unit u
    local unit hero
    local unit ally
    local real x= GetRandomReal(GetRectMinX(gg_rct_start), GetRectMaxX(gg_rct_start))
    local real y= GetRandomReal(GetRectMinY(gg_rct_start), GetRectMaxY(gg_rct_start))
    local integer i= 0
    //call CreateFogModifierRectBJ( true, Player(0), FOG_OF_WAR_VISIBLE, GetPlayableMapRect() )
    call CreateFogModifierRectBJ(true, Player(11), FOG_OF_WAR_VISIBLE, GetPlayableMapRect())
    //set hero = CreateHero(0,x, y )
    set hero=CreateHero(0 , 0 , 0)
    //set g_camera_lock = true
    set g_fog=true
    //set boss1 = gg_unit_u002_0161
    //call LockAgain()
    //set ally = CreateUnit(Player(11),'h003',0,-700,0)
    //set ally = CreateUnit(Player(0),EVIL_MARIN,0,-100,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-500,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-600,0)
    //set ally = CreateUnit(Player(0),'ewsp',0,-700,0)
    //call SetUnitLifeBJ( ally, 1000.00 )
    call BeMonsterTarget(hero)
    set bj_forLoopAIndex=1
    set bj_forLoopAIndexEnd=0
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call CreateUnit(Player(11), 'u000', GetRandomReal(- 10000.00, 10000.00), GetRandomReal(- 10000.00, 10000.00), bj_UNIT_FACING)
        call CreateUnit(Player(11), 'z000', GetRandomReal(- 10000.00, 10000.00), GetRandomReal(- 10000.00, 10000.00), bj_UNIT_FACING)
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
    set boss1=CreateUnit(Player(11), 'u002', 2300, - 40, 0)
    set u=null
    set hero=null
    
    loop
        exitwhen i >= 3
        if heros[i] != null then
            //call SetCameraTargetControllerNoZForPlayer( Player(i), heros[i], 0, 0, false )
        endif
        set i=i + 1
    endloop
    //call GamePlay_StartRoom()
endfunction
//===========================================================================
function InitTrig_inittest takes nothing returns nothing
    set gg_trg_inittest=CreateTrigger()
    call TriggerAddAction(gg_trg_inittest, function Trig_inittestActions)
endfunction
//===========================================================================
// Trigger: AIAttack
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
// Trigger: 12 澶嶅埗 2 澶嶅埗 3 澶嶅埗
//===========================================================================
function Trig_12________2________3_______uActions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_12________2________3_______u takes nothing returns nothing
    set gg_trg_12________2________3_______u=CreateTrigger()
    call TriggerAddAction(gg_trg_12________2________3_______u, function Trig_12________2________3_______uActions)
endfunction
//===========================================================================
// Trigger: 12 澶嶅埗 2 澶嶅埗 3 澶嶅埗 2
//===========================================================================
function Trig_12________2________3________2Actions takes nothing returns nothing
endfunction
//===========================================================================
function InitTrig_12________2________3________2 takes nothing returns nothing
    set gg_trg_12________2________3________2=CreateTrigger()
    call TriggerAddAction(gg_trg_12________2________3________2, function Trig_12________2________3________2Actions)
endfunction
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    //Function not found: call InitTrig_StartRoom()
    //Function not found: call InitTrig_level1()
    //Function not found: call InitTrig_InitJobData()
    //Function not found: call InitTrig_Save()
    //Function not found: call InitTrig_Strong()
    //Function not found: call InitTrig_ItemJump()
    //Function not found: call InitTrig_GunSpell()
    //Function not found: call InitTrig_Jump()
    //Function not found: call InitTrig_JumpFacingStore()
    //Function not found: call InitTrig_InjectionSpeedUp()
    //Function not found: call InitTrig_RegisterSpell()
    //Function not found: call InitTrig_Darts()
    //Function not found: call InitTrig_RetrunDarts()
    //Function not found: call InitTrig_SmartDarts()
    //Function not found: call InitTrig_ShoulderCannon()
    //Function not found: call InitTrig_ItemRetrunDarts()
    //Function not found: call InitTrig_LeaveDarts()
    //Function not found: call InitTrig_BackGrenade()
    //Function not found: call InitTrig_Mine()
    //Function not found: call InitTrig_PushGrenade()
    //Function not found: call InitTrig_Blink()
    //Function not found: call InitTrig_Transport()
    //Function not found: call InitTrig_ElectricWhip()
    //Function not found: call InitTrig_AutoAim()
    //Function not found: call InitTrig_ShootBack()
    call InitTrig_TeckLock()
    call InitTrig_Register()
    call InitTrig_RegisterFly()
    //Function not found: call InitTrig_FogControl()
    //Function not found: call InitTrig_CameraLock()
    //Function not found: call InitTrig_Movie()
    //Function not found: call InitTrig_GV()
    call InitTrig_LearnAbility()
    call InitTrig_TriggerKillHpBuff()
    call InitTrig_TriggerHorro()
    call InitTrig_HorrorOrderFilter()
    //Function not found: call InitTrig_HorrorOrder()
    //Function not found: call InitTrig_OrderId()
    //Function not found: call InitTrig_ShootSpeed()
    //Function not found: call InitTrig_Radiation()
    //Function not found: call InitTrig_ArrayList()
    //Function not found: call InitTrig_ChooseTech()
    //Function not found: call InitTrig_ChooseBonus()
    call InitTrig_TechLevelUp()
    //Function not found: call InitTrig_TechData()
    //Function not found: call InitTrig_Transform()
    //Function not found: call InitTrig_DialogSystem()
    //Function not found: call InitTrig_Buffer()
    //Function not found: call InitTrig_BurnBuffer()
    //Function not found: call InitTrig_HorroBuffer()
    //Function not found: call InitTrig_BleedBuffer()
    //Function not found: call InitTrig_IceSlowBuffer()
    //Function not found: call InitTrig_AutoAimBuffer()
    //Function not found: call InitTrig_Debuff()
    //Function not found: call InitTrig_BufferFunction()
    //Function not found: call InitTrig_Constants()
    //Function not found: call InitTrig_PlayerHero()
    call InitTrig_FocuseHero()
    //Function not found: call InitTrig_ItemData()
    //Function not found: call InitTrig_ItemEquip()
    //Function not found: call InitTrig_ItemType()
    //Function not found: call InitTrig_UnitId()
    //Function not found: call InitTrig_FakeMan()
    //Function not found: call InitTrig_MonsterDead()
    //Function not found: call InitTrig_ShootTarget()
    //Function not found: call InitTrig_MonsterTypeData()
    //Function not found: call InitTrig_MonsterBonus()
    //Function not found: call InitTrig_MonsterTargetGroup()
    call InitTrig_DeathEffect()
    //Function not found: call InitTrig_Difficulty()
    //Function not found: call InitTrig_EffectString()
    //Function not found: call InitTrig_SkillLearn()
    //Function not found: call InitTrig_DoublePacket()
    //Function not found: call InitTrig_Missle()
    //Function not found: call InitTrig_MissleFactory()
    //Function not found: call InitTrig_Gun()
    //Function not found: call InitTrig_Shooter()
    //Function not found: call InitTrig_HeroData()
    //Function not found: call InitTrig_EquipmentData()
    //Function not found: call InitTrig_HeroStatus()
    //Function not found: call InitTrig_Velocity()
    //Function not found: call InitTrig_Material()
    //Function not found: call InitTrig_PhysicsSystem()
    call InitTrig_bordercontrol()
    //Function not found: call InitTrig_TargetFilter()
    call InitTrig_ItemInfo()
    //Function not found: call InitTrig_BOSS1()
    //Function not found: call InitTrig_AIStrategy()
    //Function not found: call InitTrig_AIGroup()
    //Function not found: call InitTrig_AIData()
    //Function not found: call InitTrig_AIDriver()
    call InitTrig_AIHurted()
    //Function not found: call InitTrig_DummyCaster()
    //Function not found: call InitTrig_Status()
    //Function not found: call InitTrig_Heal()
    //Function not found: call InitTrig_ABC()
    //Function not found: call InitTrig_AII()
    //Function not found: call InitTrig_Table()
    //Function not found: call InitTrig_Height()
    //Function not found: call InitTrig_AddEffectZ()
    //Function not found: call InitTrig_Move()
    //Function not found: call InitTrig_Vector()
    //Function not found: call InitTrig_FloatText()
    //Function not found: call InitTrig_Text()
    //Function not found: call InitTrig_Direction()
    //Function not found: call InitTrig_SpellStruck()
    //Function not found: call InitTrig_Timer_Utils()
    //Function not found: call InitTrig_HashKeyManager()
    //Function not found: call InitTrig_T32()
    //Function not found: call InitTrig_HashTable()
    //Function not found: call InitTrig_Distance()
    //Function not found: call InitTrig_AIDS()
    call InitTrig_AIDSCleaner()
    //Function not found: call InitTrig_Event()
    //Function not found: call InitTrig_Damage()
    //Function not found: call InitTrig_CustomDamage()
    //Function not found: call InitTrig_Custom_Congregation()
    //Function not found: call InitTrig_List_Module()
    //Function not found: call InitTrig_Group_Utils()
    call InitTrig_CreateItem()
    call InitTrig_12________2________3()
    call InitTrig_camera()
    call InitTrig_inittest()
    //Function not found: call InitTrig_AIAttack()
    call InitTrig_12________2________3_______u()
    call InitTrig_12________2________3________2()
endfunction
//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute(gg_trg_TeckLock)
    call ConditionalTriggerExecute(gg_trg_Status)
    call ConditionalTriggerExecute(gg_trg_ABC)
    call ConditionalTriggerExecute(gg_trg_CreateItem)
    call ConditionalTriggerExecute(gg_trg_camera)
    call ConditionalTriggerExecute(gg_trg_inittest)
endfunction
//***************************************************************************
//*
//*  Players
//*
//***************************************************************************
function InitCustomPlayerSlots takes nothing returns nothing
    // Player 0
    call SetPlayerStartLocation(Player(0), 0)
    call ForcePlayerStartLocation(Player(0), 0)
    call SetPlayerColor(Player(0), ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(0), true)
    call SetPlayerController(Player(0), MAP_CONTROL_USER)
    // Player 1
    call SetPlayerStartLocation(Player(1), 1)
    call ForcePlayerStartLocation(Player(1), 1)
    call SetPlayerColor(Player(1), ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(1), true)
    call SetPlayerController(Player(1), MAP_CONTROL_USER)
    // Player 2
    call SetPlayerStartLocation(Player(2), 2)
    call ForcePlayerStartLocation(Player(2), 2)
    call SetPlayerColor(Player(2), ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(2), true)
    call SetPlayerController(Player(2), MAP_CONTROL_USER)
    // Player 11
    call SetPlayerStartLocation(Player(11), 3)
    call ForcePlayerStartLocation(Player(11), 3)
    call SetPlayerColor(Player(11), ConvertPlayerColor(11))
    call SetPlayerRacePreference(Player(11), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(11), true)
    call SetPlayerController(Player(11), MAP_CONTROL_COMPUTER)
endfunction
function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam(Player(0), 0)
    call SetPlayerTeam(Player(1), 0)
    call SetPlayerTeam(Player(2), 0)
    //   Allied
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(1), true)
    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(1), true)
    // Force: TRIGSTR_149
    call SetPlayerTeam(Player(11), 1)
endfunction
function InitAllyPriorities takes nothing returns nothing
    call SetStartLocPrioCount(0, 2)
    call SetStartLocPrio(0, 0, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrioCount(1, 2)
    call SetStartLocPrio(1, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrioCount(2, 2)
    call SetStartLocPrio(2, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 1, 1, MAP_LOC_PRIO_HIGH)
endfunction
//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************
//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds(- 9472.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), - 9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), - 9472.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 9216.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 9472.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), - 9728.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCDalaran\\DNCDalaranTerrain\\DNCDalaranTerrain.mdl", "Environment\\DNC\\DNCDalaran\\DNCDalaranUnit\\DNCDalaranUnit.mdl")
    call NewSoundEnvironment("Default")
    call SetAmbientDaySound("DalaranDay")
    call SetAmbientNightSound("DalaranNight")
    call SetMapMusic("Music", true, 0)
    call CreateRegions()
    call CreateAllItems()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs38273971")
call ExecuteFunc("ABC___Init")
call ExecuteFunc("InitAIAttack")
call ExecuteFunc("AIDS__InitAIDS")
call ExecuteFunc("InitHashTable")
call ExecuteFunc("InitHeroStatus")
call ExecuteFunc("InitLevel1")
call ExecuteFunc("InitMonsterDead")
call ExecuteFunc("InitMonsterTypeData")
call ExecuteFunc("InitRegisterSpell")
call ExecuteFunc("ShootBackInitializer")
call ExecuteFunc("InitSkillLearn")
call ExecuteFunc("T32__OnInit")
call ExecuteFunc("InitTechData")
call ExecuteFunc("Init")
call ExecuteFunc("InitializeYD")
call ExecuteFunc("InitAIStrategy")
call ExecuteFunc("InitConstants")
call ExecuteFunc("Damage__OnInit")
call ExecuteFunc("InitDoublePacket")
call ExecuteFunc("Heal___Init")
call ExecuteFunc("InitItemData")
call ExecuteFunc("InitJumpFacingStore")
call ExecuteFunc("InitMonsterBonus")
call ExecuteFunc("InitMove")
call ExecuteFunc("InitSave")
call ExecuteFunc("CameraLockInit")
call ExecuteFunc("FakeManInit")
call ExecuteFunc("FogControlInit")
call ExecuteFunc("InitItemEquip")
call ExecuteFunc("InitShootTarget")
call ExecuteFunc("InitStrong")
call ExecuteFunc("InitAIGroup")
call ExecuteFunc("BufferStructInit")
call ExecuteFunc("InitChooseBonus")
call ExecuteFunc("InitChooseTech")
call ExecuteFunc("InitMonsterTargetGroup")
call ExecuteFunc("InitRadiation")
call ExecuteFunc("InitTransform")
call ExecuteFunc("MissleInit")

    call InitGlobals()
    call InitCustomTriggers()
    call RunInitializationTriggers()
endfunction
//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************
function config takes nothing returns nothing
    call SetMapName("TRIGSTR_138")
    call SetMapDescription("TRIGSTR_140")
    call SetPlayers(4)
    call SetTeams(4)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
    call DefineStartLocation(0, 7296.0, - 1792.0)
    call DefineStartLocation(1, 7296.0, - 1792.0)
    call DefineStartLocation(2, 7296.0, - 1792.0)
    call DefineStartLocation(3, 6400.0, - 3136.0)
    // Player setup
    call InitCustomPlayerSlots()
    call InitCustomTeams()
    call InitAllyPriorities()
endfunction
//===========================================================================  
//===========================================================================  
//自定义事件 
//===========================================================================
//===========================================================================   




//Struct method generated initializers/callers:

//Functions for BigArrays:
function sa__AII___ItemStruct_onDeath takes nothing returns boolean

            call sc__AII___ItemStruct_manageLock((GetItemUserData(AII___HashedItem[AII___Hash(GetTriggerWidget())])),false) //Get the attached item.
set f__result_boolean= false
   return true
endfunction
function sa__AII___ItemStruct_manageLock takes nothing returns boolean
local integer this=f__arg_this
local boolean b=f__arg_boolean1
            if b then
                set s__AII___ItemStruct_lockLevel[this]=s__AII___ItemStruct_lockLevel[this] + 1
            else
                set s__AII___ItemStruct_lockLevel[this]=s__AII___ItemStruct_lockLevel[this] - 1
                if s__AII___ItemStruct_lockLevel[this] == 0 then
                    call s__AII___ItemStruct_remove(this)
                endif
            endif
   return true
endfunction
function sa__Event_Event__destroyNode takes nothing returns boolean
local integer this=f__arg_this
set s__Event_next[s__Event_prev[this]]=s__Event_next[this]
            set s__Event_prev[s__Event_next[this]]=s__Event_prev[this]
            call s__Event_deallocate(this)
   return true
endfunction
function sa__Material__staticgetindex takes nothing returns boolean
    set f__result_integer=s__Material__staticgetindex(f__arg_unit1)
   return true
endfunction
function sa__Material_AIDS_filter takes nothing returns boolean
    set f__result_boolean=s__Material_AIDS_filter(f__arg_unit1)
   return true
endfunction
function sa__Material_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
        local integer ut= GetUnitTypeId(s__Material__get_unit(this))
        set s__Material_burnlv[this]=0
        set s__Material_bleedlv[this]=0
        set s__Material_horro[this]=false
        set s__Material_horro_dmg[this]=HORRO_DMG
        set s__Material_anti_horro[this]=0
        set s__Material_clazz[this]=MC_UNIT
        set s__Material_hardness[this]=10
        set s__Material_bounce[this]=0.2
        set s__Material_volume[this]=100
        set s__Material_weight[this]=100
        set s__Material_airk[this]=0.75
        set s__Material_fakelv[this]=LV_FREEZ
        set s__Material_shot_tick[this]=0
        set s__Material_shot_fast_buff[this]=0
        set s__Material_last_shoot[this]=0
        set s__Material_last_issue[this]=0
        if ut == ONE_WALL or ut == ONE_WALL_BREAKABLE then
            set s__Material_clazz[this]=MC_WALL
        elseif ut == 'ncop' or ut == 'ncp2' or ut == 'ncp3' then
            set s__Material_clazz[this]=MC_RING
        elseif ut == HERO then
            set s__Material_clazz[this]=MC_UNIT
            set s__Material_hardness[this]=10
            set s__Material_bounce[this]=0.2
            set s__Material_volume[this]=150
            set s__Material_weight[this]=100
            set s__Material_airk[this]=0.75
            set s__Material_fakelv[this]=LV_ACTIVE
            set s__Material_ground_action[this]=GROUND_BOUNCE
            set s__Material_horro_dmg[this]=0.01
            set s__Material_anti_horro[this]=0
            set s__Material_kill_hp[this]=0
elseif ut == 'e000' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e001' then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e002' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e003' then
    set s__Material_clazz[this]=MC_ARROW
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=1
    set s__Material_volume[this]=75
    set s__Material_weight[this]=2
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_SMOOTH
elseif ut == 'e004' then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e009' then
    set s__Material_clazz[this]=MC_STONE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=5
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e00A' then
    set s__Material_clazz[this]=MC_STONE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=5
    set s__Material_airk[this]=0.005
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e00B' then
    set s__Material_clazz[this]=MC_MINE
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=200
    set s__Material_weight[this]=30
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_STICK
elseif ut == bICE_MISSLE then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == bFIRE_MISSLE then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == MAGIC then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == DUMMY_TYPE then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == bELECTRIC then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == TECH_UNIT then
    set s__Material_clazz[this]=MC_EFFECT
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e00E' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=150
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
elseif ut == 'e00F' then
    set s__Material_clazz[this]=MC_BULLET
    set s__Material_hardness[this]=100
    set s__Material_bounce[this]=0.5
    set s__Material_volume[this]=50
    set s__Material_weight[this]=0.01
    set s__Material_airk[this]=0
    set s__Material_fakelv[this]=LV_DESTORY
    set s__Material_ground_action[this]=GROUND_DESTROY
        endif
   return true
endfunction
function sa__Material_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__SmartDartsFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__SmartDartsFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultMissleFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__DefaultMissleFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ShootGunMissleFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__ShootGunMissleFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SmallDartsFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__SmallDartsFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ReturnDartsFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__ReturnDartsFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__LeaveDartsFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__LeaveDartsFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__IceMissleFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__IceMissleFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__FireMissleFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__FireMissleFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Velocity__staticgetindex takes nothing returns boolean
    set f__result_integer=s__Velocity__staticgetindex(f__arg_unit1)
   return true
endfunction
function sa__Velocity_AIDS_filter takes nothing returns boolean
    set f__result_boolean=s__Velocity_AIDS_filter(f__arg_unit1)
   return true
endfunction
function sa__Velocity_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
        if GetUnitTypeId(s__Velocity__get_unit(this)) == HERO then
            set s__Velocity_v[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_a[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_vu[this]=s__VelocityUnit_create(s__Velocity__get_unit(this))
        else
            set s__Velocity_v[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_a[this]=s__vector_create(0 , 0 , 0)
            set s__Velocity_vu[this]=s__VelocityUnit_create(s__Velocity__get_unit(this))
        endif
   return true
endfunction
function sa__Velocity_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call s__vector_deallocate(s__Velocity_v[this])
        call s__vector_deallocate(s__Velocity_a[this])
        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
        call s__VelocityUnit_deallocate(s__Velocity_vu[this])
   return true
endfunction
function sa__Velocity_periodic takes nothing returns boolean
local integer this=f__arg_this
        local real x= GetUnitX(s__Velocity__get_unit(this))
        local real y= GetUnitY(s__Velocity__get_unit(this))
        local real z= getUnitHeight(s__Velocity__get_unit(this))
        local real v
        local real a= s__vector_getLength(s__Velocity_a[this])
        local real fz
        local real tx
        local real ty
        local real tz
        local real f1
        local real f2
        local real af
        local real fs
        local real as
        local unit tu= null
        local string clazz= s__Material_clazz[s__Material__staticgetindex(s__Velocity__get_unit(this))]
        local integer gravity
        local boolean unitHitWall= false
        local real addon= 0
        if IsUnitAliveBJ(s__Velocity__get_unit(this)) then
            set fz=GetUnitFlyHeight(s__Velocity__get_unit(this))
            if fz > 0.1 then
                if clazz == MC_UNIT or clazz == MC_STONE or clazz == MC_MINE then
                    set gravity=s__vector_create(0 , 0 , - 2)
                    call s__vector_add(s__Velocity_v[this],gravity)
                endif
            endif
            if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                call sc__IMissle_step(s__Velocity_missleStruct[this])
            endif
            set v=s__vector_getLength(s__Velocity_v[this])
            if v > 0 then
                set tz=z + s__vector_z[s__Velocity_v[this]]
                set tx=x + s__vector_x[s__Velocity_v[this]]
                set ty=y + s__vector_y[s__Velocity_v[this]]
                call MoveUnit(s__Velocity__get_unit(this) , tx , ty , tz)
                if fz < 0.1 and s__vector_z[s__Velocity_v[this]] < 0 then
                    if s__Material_ground_action[s__Material__staticgetindex(s__Velocity__get_unit(this))] == GROUND_DESTROY then
                        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
                    elseif s__Material_ground_action[s__Material__staticgetindex(s__Velocity__get_unit(this))] == GROUND_STICK then
                        call s__vector_setLength(s__Velocity_v[this],0)
                    endif
                endif
                if clazz == MC_UNIT or clazz == MC_ARROW or clazz == MC_STONE or clazz == MC_MINE then
                    set f2=s__Material_airk[s__Material__staticgetindex(s__Velocity__get_unit(this))] * v * v / 10
                    if fz > 0.1 or clazz == MC_ARROW then
                        set af=f2 / s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))]
                    else
                        set f1=s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))] * g * u / 20
                        set af=( f1 + f2 ) / s__Material_weight[s__Material__staticgetindex(s__Velocity__get_unit(this))]
                    endif
                    if af >= v then
                        call s__vector_setLength(s__Velocity_v[this],0)
                    else
                        call s__vector_setLength(s__Velocity_v[this],v - af)
                    endif
                endif
                if getTerrianHeight(tx , ty) > z + 5 then
                    if clazz == MC_BULLET or clazz == MC_STONE then
                        call sc__IMissle_deallocate(s__Velocity_missleStruct[this])
                    elseif clazz == MC_ARROW then
                    elseif clazz == MC_UNIT then
                        if v > DAMAGE_SPEED then
                            call UnitHitWall(s__Velocity__get_unit(this) , s__Velocity__get_unit(this) , v , getDir(x , y , tx , ty) , true)
                        endif
                        set unitHitWall=true
                    elseif clazz == MC_MINE then
                        set unitHitWall=true
                    endif
                endif
                if clazz == MC_BULLET or clazz == MC_ARROW then
                    call sc__IMissle_refreshDamagedGroup(s__Velocity_missleStruct[this])
                endif
                if IsUnitAliveBJ(s__Velocity__get_unit(this)) then
                    if GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this))) < 3 then
                        if IsBoss(s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this)))])]]) then
                            set addon=s__Material_volume[s__Material__staticgetindex(s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(heros[GetPlayerId(GetOwningPlayer(s__Velocity__get_unit(this)))])]])]
                        endif
                    endif
                    if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                        set tu=HasLiveUnitInRange(s__Velocity__get_unit(this) , addon + RMaxBJ(s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))], v + BULLET_RANGE_ADDON))
                    elseif clazz == MC_UNIT then
                        set tu=GetNearestLiveUnitOrWall(s__Velocity__get_unit(this) , s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))])
                    endif
                    if tu != null then
                        if clazz == MC_BULLET or clazz == MC_ARROW or clazz == MC_STONE then
                            call BulletCollision(s__Velocity__get_unit(this) , tu , addon + RMaxBJ(s__Material_volume[s__Material__staticgetindex(s__Velocity__get_unit(this))], v + BULLET_RANGE_ADDON))
                        elseif clazz == MC_UNIT then
                            if IsUnitInGroup(s__Velocity__get_unit(this), COLLISION_GROUP) and IsUnitInGroup(tu, COLLISION_GROUP) then
                            else
                                call UnitCollision(s__Velocity__get_unit(this) , tu)
                                call GroupAddUnit(COLLISION_GROUP, s__Velocity__get_unit(this))
                                call GroupAddUnit(COLLISION_GROUP, tu)
                            endif
                        endif
                    endif
                endif
            endif
            if a > 0 then
                if v == 0 and clazz == MC_UNIT then
                    set as=g * us / 30
                    if a > as then
                        call s__vector_add(s__Velocity_v[this],s__Velocity_a[this])
                    endif
                else
                    call s__vector_add(s__Velocity_v[this],s__Velocity_a[this])
                endif
            endif
            if unitHitWall then
                call s__vector_setLength(s__Velocity_v[this],0)
            endif
        else
            call s__VelocityUnit_deallocate(s__Velocity_vu[this])
        endif
        set tu=null
   return true
endfunction
function sa__VelocityUnit_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        set s__VelocityUnit_target[this]=null
        call s__VelocityUnit_removeList(this)
   return true
endfunction
function sa__VelocityUnit_loopMoveAllMissles takes nothing returns boolean

         local string fakeManLv
         local integer m= s__VelocityUnit_getFirst()
             loop
                 exitwhen m == 0
                 set fakeManLv=s__RealMan_CheckLevel(GetUnitX(s__VelocityUnit_target[m]) , GetUnitY(s__VelocityUnit_target[m]) , s__Material_fakelv[s__Material__staticgetindex(s__VelocityUnit_target[m])])
                 if fakeManLv == LV_ACTIVE then
                    call sc__Velocity_periodic(sc__Velocity__staticgetindex(s__VelocityUnit_target[m]))
                 elseif fakeManLv == LV_DESTORY then
                    call KillUnit(s__VelocityUnit_target[m])
                 endif
                 set m=s__VelocityUnit_getNext(m)
             endloop
   return true
endfunction
function sa__ElectricWhipFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__ElectricWhipFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BackGrenadeFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__BackGrenadeFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__PushGrenadeFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__PushGrenadeFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__MineFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__MineFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ShoulderCannonFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__ShoulderCannonFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SpearMissleFactory_createMissle takes nothing returns boolean
    set f__result_integer=s__SpearMissleFactory_createMissle(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultTypeData_create takes nothing returns boolean

local integer s=s__DefaultTypeData__allocate()
call s__DefaultTypeData_addList(s)
set f__result_integer= s
   return true
endfunction
function sa__DefaultTypeData_onDestroy takes nothing returns boolean
local integer this=f__arg_this
call s__DefaultTypeData_removeList(this)
    set f__arg_this=this
   return true
endfunction
function sa__DefaultTypeData_getTypeId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 123
   return true
endfunction
function sa__DefaultTypeData_getDeadGold takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 2
   return true
endfunction
function sa__DefaultTypeData_getDeadWood takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 0
   return true
endfunction
function sa__MonsterTargetGroupManager_create takes nothing returns boolean

    local integer dag=s__MonsterTargetGroupManager__allocate()
    call s__MonsterTargetGroupManager_startPeriodic(dag)
set f__result_integer= dag
   return true
endfunction
function sa__MonsterTargetGroupManager_onDestroy takes nothing returns boolean
local integer this=f__arg_this
    call s__MonsterTargetGroupManager_stopPeriodic(this)
   return true
endfunction
function sa__MonsterTargetGroupManager_periodic takes nothing returns boolean
local integer this=f__arg_this
    local unit u
    local group tg
    local group ydl_group
    local unit ydl_unit
    local unit u2
    if ModuloInteger(Tick, 200) == 0 then
        set tg=NewGroup()
        call GroupAddGroup(MonsterTargetGroup, tg)
        set u=FirstOfGroup(tg)
        loop
            exitwhen u == null
            if IsUnitAliveBJ(u) then
                set ydl_group=NewGroup()
                call GroupEnumUnitsInRange(ydl_group, GetUnitX(u), GetUnitY(u), 1500, null)
                loop
                    set ydl_unit=FirstOfGroup(ydl_group)
                    exitwhen ydl_unit == null
                    call GroupRemoveUnit(ydl_group, ydl_unit)
                    if u != ydl_unit and IsAIUnit(ydl_unit) and IsLiveEnemyUnit(u , ydl_unit) then
                        call GroupAddUnit(MeleeGroup, ydl_unit)
                        call TargetInRange(ydl_unit , u , DistanceTwoUnits(u , ydl_unit))
                    endif
                endloop
                call ReleaseGroup(ydl_group)
                set ydl_group=null
                set ydl_unit=null
            else
                call NotMonsterTarget(u)
            endif
            call GroupRemoveUnit(tg, u)
            set u=FirstOfGroup(tg)
        endloop
        set u=null
        call GroupRefresh(tg)
        call GroupAddGroup(MeleeGroup, tg)
        loop
            set u2=FirstOfGroup(tg)
            exitwhen u2 == null
            call GroupRemoveUnit(tg, u2)
            if DistanceTwoUnits(u2 , s__AIData_targetUnit[s__AIData__staticgetindex(u2)]) > 1500 then
                call GroupRemoveUnit(MeleeGroup, u2)
                call TargetOutRange(u2)
            endif
        endloop
        set u2=null
        call ReleaseGroup(tg)
        set tg=null
    endif
   return true
endfunction
function sa__AIData__staticgetindex takes nothing returns boolean
    set f__result_integer=s__AIData__staticgetindex(f__arg_unit1)
   return true
endfunction
function sa__AIData_AIDS_filter takes nothing returns boolean
    set f__result_boolean=s__AIData_AIDS_filter(f__arg_unit1)
   return true
endfunction
function sa__AIData_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
set s__AIData_targetUnit[this]=GetNearestEnemyInGroup(s__AIData__get_unit(this) , MonsterTargetGroup)
set s__AIData_last_change[this]=Tick
set s__AIData_strategy[this]=s__DefaultAIStrategy_findStrategy(GetUnitTypeId(s__AIData__get_unit(this)))
call GetInMap(s__AIData__get_unit(this))
   return true
endfunction
function sa__AIData_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
set s__AIData_currentAIGroup[this]=0
set s__AIData_targetUnit[this]=null
   return true
endfunction
function sa__RealMan_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call s__RealMan_removeList(this)
   return true
endfunction
function sa__Status__get_unit takes nothing returns boolean
local integer this=f__arg_this
set f__result_unit= GetIndexUnit(this)
   return true
endfunction
function sa__Status_stopPeriodic takes nothing returns boolean
local integer this=f__arg_this
            if s__Status_T32xs___runningPeriodic[this] then
                set s__Status_T32xs___next[s__Status_T32xs___prev[this]]=s__Status_T32xs___next[this]
                set s__Status_T32xs___prev[s__Status_T32xs___next[this]]=s__Status_T32xs___prev[this]
                set s__Status_T32xs___runningPeriodic[this]=false
            endif
   return true
endfunction
function sa__ItemFeatureData_construct takes nothing returns boolean
local integer did=f__arg_integer1
        local integer f1
        local integer f2
        local integer f3
        local integer f4
        local integer f5
        local integer id= did - 'I000'
        local integer gun= 0
        local integer ifd= 0
    set f1=s__ItemFeature_create(LoadStr(ifht1, id, ifht_name) , LoadReal(ifht1, id, ifht_origin) , LoadReal(ifht1, id, ifht_step) , LoadInteger(ifht1, id, ifht_lv) , LoadInteger(ifht1, id, ifht_max_lv) , LoadInteger(ifht1, id, ifht_gold) , LoadInteger(ifht1, id, ifht_wood))
    set f2=s__ItemFeature_create(LoadStr(ifht2, id, ifht_name) , LoadReal(ifht2, id, ifht_origin) , LoadReal(ifht2, id, ifht_step) , LoadInteger(ifht2, id, ifht_lv) , LoadInteger(ifht2, id, ifht_max_lv) , LoadInteger(ifht2, id, ifht_gold) , LoadInteger(ifht2, id, ifht_wood))
    set f3=s__ItemFeature_create(LoadStr(ifht3, id, ifht_name) , LoadReal(ifht3, id, ifht_origin) , LoadReal(ifht3, id, ifht_step) , LoadInteger(ifht3, id, ifht_lv) , LoadInteger(ifht3, id, ifht_max_lv) , LoadInteger(ifht3, id, ifht_gold) , LoadInteger(ifht3, id, ifht_wood))
    set f4=s__ItemFeature_create(LoadStr(ifht4, id, ifht_name) , LoadReal(ifht4, id, ifht_origin) , LoadReal(ifht4, id, ifht_step) , LoadInteger(ifht4, id, ifht_lv) , LoadInteger(ifht4, id, ifht_max_lv) , LoadInteger(ifht4, id, ifht_gold) , LoadInteger(ifht4, id, ifht_wood))
    set f5=s__ItemFeature_create(LoadStr(ifht5, id, ifht_name) , LoadReal(ifht5, id, ifht_origin) , LoadReal(ifht5, id, ifht_step) , LoadInteger(ifht5, id, ifht_lv) , LoadInteger(ifht5, id, ifht_max_lv) , LoadInteger(ifht5, id, ifht_gold) , LoadInteger(ifht5, id, ifht_wood))
        set ifd=s__ItemFeatureData_create(f1 , f2 , f3 , f4 , f5 , gun)
        if LoadInteger(idht, did - 'I000', idht_item_type) == GUN then
            if did == 'I001' then
                set gun=s__HumanRifle_create(null , ifd)
            elseif did == 'I00R' then
                set gun=s__SpearRifle_create(null , ifd)
            elseif did == 'I00S' then
                set gun=s__FireShotgun_create(null , ifd)
            endif
        endif
        set s__ItemFeatureData_gun[ifd]=gun
set f__result_integer= ifd
   return true
endfunction
function sa__IndividualItemData__get_item takes nothing returns boolean
local integer this=f__arg_this
set f__result_item= s__AII___ItemStruct_it[(this)]
   return true
endfunction
function sa__EquipmentData__staticgetindex takes nothing returns boolean
    set f__result_integer=s__EquipmentData__staticgetindex(f__arg_unit1)
   return true
endfunction
function sa__EquipmentData_AIDS_filter takes nothing returns boolean
    set f__result_boolean=s__EquipmentData_AIDS_filter(f__arg_unit1)
   return true
endfunction
function sa__EquipmentData_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
        set s__EquipmentData_heroData[this]=s__IHeroData__allocate()
        set s__IHeroData_bullets[s__EquipmentData_heroData[this]]=sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]])
        set s__IHeroData_shoot_energy_max[s__EquipmentData_heroData[this]]=100
        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]=100
        set s__IHeroData_shoot_energy_reg[s__EquipmentData_heroData[this]]=1
        set s__IHeroData_shoot_range_buff[s__EquipmentData_heroData[this]]=0
        set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_a_shoot_back[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_kill_mana_percent[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_mana_boom_percent[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_up_point[s__EquipmentData_heroData[this]]=10
        set s__IHeroData_bonus_point[s__EquipmentData_heroData[this]]=0
        set s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]=s__TechCounter__allocate()
        set s___TechCounter_cnt[s__TechCounter_cnt[s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]]+TT_GENERAL]=1
        set s__TechCounter_size[s__IHeroData_tech_counter[s__EquipmentData_heroData[this]]]=1
        set s__IHeroData_save[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_strong[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_antrad[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_doge[s__EquipmentData_heroData[this]]=0
        set s__IHeroData_frezz[s__EquipmentData_heroData[this]]=0.0
        set s__IHeroData_fire_charge[s__EquipmentData_heroData[this]]=1.0
        set s__IHeroData_machine_gun_buff[s__EquipmentData_heroData[this]]=1.0
        set s__IHeroData_vision[s__EquipmentData_heroData[this]]=2300
        call s__EquipmentData_startPeriodic(this)
        call s__EquipmentData_AIDS_addLock(this)
   return true
endfunction
function sa__EquipmentData_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__EquipmentData_periodic takes nothing returns boolean
local integer this=f__arg_this
        local boolean reload= s__IHeroData_reload[s__EquipmentData_heroData[this]]
        local real c= s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]
        local real max= s__IHeroData_shoot_energy_max[s__EquipmentData_heroData[this]]
        local real n= RMinBJ(max, c + s__IHeroData_shoot_energy_reg[s__EquipmentData_heroData[this]])
        if reload and c < max then
            set s__IHeroData_shoot_energy[s__EquipmentData_heroData[this]]=n
            if n == max then
                if IsHero(s__EquipmentData__get_unit(this)) then
                    set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
                    call UnitRemoveAbility(s__EquipmentData__get_unit(this), 'Abun')
                    call SetPlayerState(GetOwningPlayer(s__EquipmentData__get_unit(this)), PLAYER_STATE_RESOURCE_LUMBER, sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]]))
                    call DisplayFloatText(GetUnitX(s__EquipmentData__get_unit(this)) , GetUnitY(s__EquipmentData__get_unit(this)) , "R" , 1)
                else
                    set s__IHeroData_reload[s__EquipmentData_heroData[this]]=false
                    call UnitRemoveAbility(s__EquipmentData__get_unit(this), 'Abun')
                    set s__IHeroData_bullets[s__EquipmentData_heroData[this]]=sc__IShooter_getClipSize(s__IGun_shooter[s__EquipmentData_gun[this]])
                    call DisplayFloatText(GetUnitX(s__EquipmentData__get_unit(this)) , GetUnitY(s__EquipmentData__get_unit(this)) , "R" , 1)
                endif
            endif
        endif
   return true
endfunction
function sa__Damage__Detector_AIDS_onCreate takes nothing returns boolean
local integer this=f__arg_this
            set s__Damage__Detector_t[this]=CreateTrigger()
            call TriggerAddCondition(s__Damage__Detector_t[this], s__Damage__Detector_ACTIONS_COND)
            call TriggerRegisterUnitEvent(s__Damage__Detector_t[this], s__Damage__Detector__get_unit(this), EVENT_UNIT_DAMAGED)
   return true
endfunction
function sa__Damage__Detector_AIDS_onDestroy takes nothing returns boolean
local integer this=f__arg_this
            call DestroyTrigger(s__Damage__Detector_t[this])
   return true
endfunction
function sa__Damage__Detector_AIDS_onInit takes nothing returns boolean

            set s__Damage__Detector_ACTIONS_COND=Condition(function Damage__OnDamageActions)
   return true
endfunction
function sa__vector_setLength takes nothing returns boolean
local integer this=f__arg_this
local real length=f__arg_real1
            local real l= SquareRoot(s__vector_x[this] * s__vector_x[this] + s__vector_y[this] * s__vector_y[this] + s__vector_z[this] * s__vector_z[this])
            if l == 0.0 then
return true
            endif
            set l=length / l
            set s__vector_x[this]=s__vector_x[this] * l
            set s__vector_y[this]=s__vector_y[this] * l
            set s__vector_z[this]=s__vector_z[this] * l
   return true
endfunction
function sa__AbstractShooter_tick takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AbstractShooter_periodic takes nothing returns boolean
local integer this=f__arg_this
        call sc__IShooter_tick(this)
   return true
endfunction
function sa__AbstractShooter_create takes nothing returns boolean
    set f__result_integer=s__AbstractShooter_create(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__AbstractShooter_shoothz takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 10
   return true
endfunction
function sa__AbstractShooter_getClipSize takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 10
   return true
endfunction
function sa__AbstractShooter_shootCount takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1
   return true
endfunction
function sa__AbstractShooter_getRist takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 100.0
   return true
endfunction
function sa__AbstractShooter_getOriginSpeed takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 60.0
   return true
endfunction
function sa__AbstractShooter_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
   return true
endfunction
function sa__AbstractShooter_getEnergyConsume takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1
   return true
endfunction
function sa__AbstractShooter_subshoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
   return true
endfunction
function sa__AbstractShooter_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call s__AbstractShooter_stopPeriodic(this)
        set s__IShooter_owner[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__DefaultAIStrategy_create takes nothing returns boolean

local integer s=s__DefaultAIStrategy__allocate()
call s__DefaultAIStrategy_addList(s)
set f__result_integer= s
   return true
endfunction
function sa__DefaultAIStrategy_onDestroy takes nothing returns boolean
local integer this=f__arg_this
call s__DefaultAIStrategy_removeList(this)
    set f__arg_this=this
   return true
endfunction
function sa__DefaultAIStrategy_support takes nothing returns boolean
local integer this=f__arg_this
local integer typeid=f__arg_integer1
set f__result_boolean= false
   return true
endfunction
function sa__DefaultAIStrategy_targetInRange takes nothing returns boolean
    call s__DefaultAIStrategy_targetInRange(f__arg_this,f__arg_unit1,f__arg_unit2,f__arg_real1)
   return true
endfunction
function sa__DefaultAIStrategy_targetOutRange takes nothing returns boolean
    call s__DefaultAIStrategy_targetOutRange(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIStrategy_beHurted takes nothing returns boolean
    call s__DefaultAIStrategy_beHurted(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIStrategy_getInMap takes nothing returns boolean
    call s__DefaultAIStrategy_getInMap(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Boss1AIStrategy_targetInRange takes nothing returns boolean
    call s__Boss1AIStrategy_targetInRange(f__arg_this,f__arg_unit1,f__arg_unit2,f__arg_real1)
   return true
endfunction
function sa__Boss1AIStrategy_targetOutRange takes nothing returns boolean
    call s__Boss1AIStrategy_targetOutRange(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Boss1AIStrategy_support takes nothing returns boolean
local integer this=f__arg_this
local integer typeid=f__arg_integer1
    if typeid == 'u002' or typeid == 'u004' then
set f__result_boolean= true
return true
    endif
set f__result_boolean= false
   return true
endfunction
function sa__DefaultGun_fire takes nothing returns boolean
local integer this=f__arg_this
        if s__IShooter_owner[s__IGun_shooter[this]] != null then
            call sc__IShooter_shoot(s__IGun_shooter[this],s__vector_create(0 , 0 , 0))
        endif
   return true
endfunction
function sa__DefaultGun_setOwner takes nothing returns boolean
    call s__DefaultGun_setOwner(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultGun_stopFire takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultGun_getGunType takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= SHOOT_GUN
   return true
endfunction
function sa__DefaultGun_create takes nothing returns boolean
    set f__result_integer=s__DefaultGun_create(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__DefaultGun_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call sc__IShooter_deallocate(s__IGun_shooter[this])
        call sc__IMissleFactory_deallocate(s__IGun_factory[this])
    set f__arg_this=this
   return true
endfunction
function sa__SpellStruct__get_isNotLocked takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= s__SpellStruct_lockLevel[this] == 0
   return true
endfunction
function sa__SpellStruct__get_casterX takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= GetUnitX(s__SpellStruct_caster[this])
   return true
endfunction
function sa__SpellStruct__get_casterY takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= GetUnitY(s__SpellStruct_caster[this])
   return true
endfunction
function sa__SpellStruct_create takes nothing returns boolean

            local integer this=s__SpellStruct__allocate()
            set s__SpellStruct_abilId[this]=GetSpellAbilityId()
            set s__SpellStruct_caster[this]=GetTriggerUnit()
            set s__SpellStruct_owner[this]=GetOwningPlayer(s__SpellStruct_caster[this])
            set s__SpellStruct_level[this]=GetUnitAbilityLevel(s__SpellStruct_caster[this], s__SpellStruct_abilId[this])
            set s__SpellStruct_order[this]=GetUnitCurrentOrder(s__SpellStruct_caster[this])
            set s__SpellStruct_targetUnit[this]=GetSpellTargetUnit()
            if s__SpellStruct_targetUnit[this] == null then
                set s__SpellStruct_targetDest[this]=GetSpellTargetDestructable()
                if s__SpellStruct_targetDest[this] == null then
                    set s__SpellStruct_targetItem[this]=GetSpellTargetItem()
                    if s__SpellStruct_targetItem[this] == null then
                        set s__SpellStruct_targetWidget[this]=null
                        set s__SpellStruct_loc=GetSpellTargetLoc()
                        if s__SpellStruct_loc == null then
                            set s__SpellStruct_targetX[this]=GetUnitX(s__SpellStruct_caster[this])
                            set s__SpellStruct_targetY[this]=GetUnitY(s__SpellStruct_caster[this])
                        else
                            set s__SpellStruct_targetX[this]=GetLocationX(s__SpellStruct_loc)
                            set s__SpellStruct_targetY[this]=GetLocationY(s__SpellStruct_loc)
                            call RemoveLocation(s__SpellStruct_loc)
                            set s__SpellStruct_loc=null // worthwhile
endif
                    else
                        set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetItem[this]
                        set s__SpellStruct_targetX[this]=GetItemX(s__SpellStruct_targetItem[this])
                        set s__SpellStruct_targetY[this]=GetItemY(s__SpellStruct_targetItem[this])
                    endif
                else
                    set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetDest[this]
                    set s__SpellStruct_targetItem[this]=null
                    set s__SpellStruct_targetX[this]=GetWidgetX(s__SpellStruct_targetDest[this]) // shorter
set s__SpellStruct_targetY[this]=GetWidgetY(s__SpellStruct_targetDest[this])
                endif
            else
                set s__SpellStruct_targetWidget[this]=s__SpellStruct_targetUnit[this]
                set s__SpellStruct_targetDest[this]=null
                set s__SpellStruct_targetItem[this]=null
                set s__SpellStruct_targetX[this]=GetUnitX(s__SpellStruct_targetUnit[this])
                set s__SpellStruct_targetY[this]=GetUnitY(s__SpellStruct_targetUnit[this])
            endif
            set s__SpellStruct_attachHead=s__SpellStruct__ChainAttach__allocate()
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct_timerAttachments[this]=s__SpellStruct_attachHead
            set s__SpellStruct_attachHead=s__SpellStruct__ChainAttach__allocate()
            set s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct__ChainAttach_prev[s__SpellStruct_attachHead]=s__SpellStruct_attachHead
            set s__SpellStruct_triggerAttachments[this]=s__SpellStruct_attachHead
set f__result_integer= this
   return true
endfunction
function sa__SpellStruct_destroy takes nothing returns boolean
local integer this=f__arg_this
            if s__SpellStruct_hasStoppedCasting[this] then
                set s__SpellStruct_hasStoppedCasting[this]=false // random double free protection on autoDestroy stuff.
else
                call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            endif
            set s__SpellStruct_attachHead=s__SpellStruct_timerAttachments[this]
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]
            loop
                exitwhen s__SpellStruct_attachNode == s__SpellStruct_attachHead
            call ReleaseTimer(s__SpellStruct__ChainAttach_timer[s__SpellStruct_attachNode])
                call RemoveSavedInteger(SpellStruct__STORE, this, s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode])
                set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            endloop
            call s__SpellStruct__ChainAttach_deallocate(s__SpellStruct_timerAttachments[this])
            set s__SpellStruct_attachHead=s__SpellStruct_triggerAttachments[this]
            set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachHead]
            loop
                exitwhen s__SpellStruct_attachNode == s__SpellStruct_attachHead
        call RemoveSavedInteger(SpellStruct__STORE, GetHandleId(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode]), SpellStruct__TRIGGER_DATA)
                call DestroyTrigger(s__SpellStruct__ChainAttach_trigger[s__SpellStruct_attachNode])
                call RemoveSavedInteger(SpellStruct__STORE, this, s__SpellStruct__ChainAttach_callback[s__SpellStruct_attachNode])
                set s__SpellStruct_attachNode=s__SpellStruct__ChainAttach_next[s__SpellStruct_attachNode]
            endloop
            call s__SpellStruct__ChainAttach_deallocate(s__SpellStruct_triggerAttachments[this])
            call sc__SpellStruct__DefaultsInterface_deallocate(this)
   return true
endfunction
function sa__DefaultAIGroup_create takes nothing returns boolean

    local integer dag=s__DefaultAIGroup__allocate()
    set s__IAIGroup_g[dag]=NewGroup()
    set s__IAIGroup_tg[dag]=NewGroup()
    call GroupAddGroup(s__IAIGroup_g[dag], s__IAIGroup_tg[dag])
    call s__DefaultAIGroup_startPeriodic(dag)
set f__result_integer= dag
   return true
endfunction
function sa__DefaultAIGroup_shouldLoop takes nothing returns boolean
    set f__result_boolean=s__DefaultAIGroup_shouldLoop(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIGroup_afterLoop takes nothing returns boolean
    call s__DefaultAIGroup_afterLoop(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIGroup_getInterval takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 15
   return true
endfunction
function sa__DefaultAIGroup_ailoop takes nothing returns boolean
    call s__DefaultAIGroup_ailoop(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIGroup_onDestroy takes nothing returns boolean
local integer this=f__arg_this
    call s__DefaultAIGroup_stopPeriodic(this)
    call ReleaseGroup(s__IAIGroup_g[this])
    call ReleaseGroup(s__IAIGroup_tg[this])
    set f__arg_this=this
   return true
endfunction
function sa__DefaultAIGroup_periodic takes nothing returns boolean
local integer this=f__arg_this
    local unit u
    if ModuloInteger(Tick, s__DefaultAIGroup_getInterval(this)) == 0 then
    set u=FirstOfGroup(s__IAIGroup_tg[this])
    if u == null then
        call GroupRefresh(s__IAIGroup_tg[this])
        call GroupAddGroup(s__IAIGroup_g[this], s__IAIGroup_tg[this])
    else
        call GroupRemoveUnit(s__IAIGroup_tg[this], u)
        if IsUnitInGroup(u, s__IAIGroup_g[this]) then
            if IsUnitAliveBJ(u) then
                if s__DefaultAIGroup_shouldLoop(this,u) then
                    call s__DefaultAIGroup_ailoop(this,u)
                    call s__DefaultAIGroup_afterLoop(this,u)
                endif
            else
                call sc__DefaultAIGroup_removeUnit(this,u)
            endif
        endif
        set u=null
    endif
    endif
   return true
endfunction
function sa__DefaultAIGroup_addUnit takes nothing returns boolean
    call s__DefaultAIGroup_addUnit(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultAIGroup_removeUnit takes nothing returns boolean
    call s__DefaultAIGroup_removeUnit(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__DefaultDialog_create takes nothing returns boolean
local string name=f__arg_string1
local player p=f__arg_player1
        local integer g=s__DefaultDialog__allocate()
        set s__IDialog_d[g]=DialogCreate()
        set s__IDialog_dtr[g]=CreateTrigger()
        set s__IDialog_p[g]=p
        set s__IDialog_name[g]=name
        set s__IDialog_choses_size[g]=0
        call DialogSetMessage(s__IDialog_d[g], name)
        call SetDialogStructA(s__IDialog_d[g] , g)
        call TriggerRegisterDialogEvent(s__IDialog_dtr[g], s__IDialog_d[g])
        call TriggerAddCondition(s__IDialog_dtr[g], Condition(function CancelDialog))
set f__result_integer= g
   return true
endfunction
function sa__DefaultDialog_button_clicked takes nothing returns boolean
    call s__DefaultDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__DefaultDialog_init takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultDialog_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        local integer i= 0
        loop
            exitwhen i >= s__IDialog_choses_size[this]
            if GetButtonStructA(s___IDialog_choses[s__IDialog_choses[this]+i]) != 0 then
                call ClearButtonStructA(s___IDialog_choses[s__IDialog_choses[this]+i])
                set s___IDialog_choses[s__IDialog_choses[this]+i]=null
                set i=i + 1
            endif
        endloop
        call DialogClear(s__IDialog_d[this])
        call DialogDestroy(s__IDialog_d[this])
        call TriggerClearConditions(s__IDialog_dtr[this])
        call DestroyTrigger(s__IDialog_dtr[this])
        set s__IDialog_cancel_button[this]=null
        set s__IDialog_d[this]=null
        set s__IDialog_dtr[this]=null
        set s__IDialog_p[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__DefaultDialog_display takes nothing returns boolean
local integer this=f__arg_this
        call sc__IDialog_init(this)
        set s__IDialog_cancel_button[this]=DialogAddButton(s__IDialog_d[this], "鍙栨秷", 0)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
   return true
endfunction
function sa__ChangeAbDialog_create takes nothing returns boolean
local string name=f__arg_string1
local player p=f__arg_player1
local integer t=f__arg_integer1
local integer oi=f__arg_integer2
local integer ni=f__arg_integer3
        local integer g=s__ChangeAbDialog__allocate(name , p)
        set s__ChangeAbDialog_oi[g]=oi
        set s__ChangeAbDialog_ni[g]=ni
        set s__ChangeAbDialog_t[g]=t
set f__result_integer= g
   return true
endfunction
function sa__ChangeAbDialog_button_clicked takes nothing returns boolean
    call s__ChangeAbDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__ChangeAbDialog_init takes nothing returns boolean
local integer this=f__arg_this
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
   return true
endfunction
function sa__ChangeGunDialog_create takes nothing returns boolean
    set f__result_integer=s__ChangeGunDialog_create(f__arg_string1,f__arg_player1,f__arg_integer1,f__arg_integer2,f__arg_integer3,f__arg_item1)
   return true
endfunction
function sa__ChangeGunDialog_button_clicked takes nothing returns boolean
    call s__ChangeGunDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__ChangeGunDialog_init takes nothing returns boolean
local integer this=f__arg_this
        local button b
        local string s= "鍒囨崲"
        set b=DialogAddButton(s__IDialog_d[this], s, 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
   return true
endfunction
function sa__TransformDialog_create takes nothing returns boolean
local string name=f__arg_string1
local player p=f__arg_player1
local integer fd=f__arg_integer1
        local integer g=s__TransformDialog__allocate(name , p)
        set s__TransformDialog_fd[g]=fd
set f__result_integer= g
   return true
endfunction
function sa__TransformDialog_button_clicked takes nothing returns boolean
    call s__TransformDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__TransformDialog_init takes nothing returns boolean
local integer this=f__arg_this
        local button b
        local string s
        if s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f1[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 1)
            call SetButtonStructA(b , s__ItemFeatureData_f1[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
        if s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f2[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 2)
            call SetButtonStructA(b , s__ItemFeatureData_f2[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
        if s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f3[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 3)
            call SetButtonStructA(b , s__ItemFeatureData_f3[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
        if s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f4[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 4)
            call SetButtonStructA(b , s__ItemFeatureData_f4[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
        if s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 and s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] < s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] then
            set s=s__ItemFeature_name[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + " (" + I2S(s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]]) + "/" + I2S(s__ItemFeature_maxlv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]]) + ") "
            if s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 then
                set s=s + "+" + " " + R2S(s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]])
            else
                set s=s + "-" + " " + R2S(- s__ItemFeature_step[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]])
            endif
            set s=s + " " + I2S(s__ItemFeature_gold[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + 1 )) + "G"
            if s__ItemFeature_wood[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] > 0 then
                set s=s + " " + I2S(s__ItemFeature_wood[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] * ( s__ItemFeature_lv[s__ItemFeatureData_f5[s__TransformDialog_fd[this]]] + 1 )) + "P"
            endif
            set b=DialogAddButton(s__IDialog_d[this], s, 5)
            call SetButtonStructA(b , s__ItemFeatureData_f5[s__TransformDialog_fd[this]])
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        endif
        set b=null
   return true
endfunction
function sa__FreeTransformDialog_button_clicked takes nothing returns boolean
    call s__FreeTransformDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__ChooseTechDialog_button_clicked takes nothing returns boolean
    call s__ChooseTechDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__ChooseTechDialog_init takes nothing returns boolean
local integer this=f__arg_this
        local button b
        local unit hero= heros[GetPlayerId(s__IDialog_p[this])]
        local integer tech1= s__ChooseTechDialog_getHotestTech(this,hero , - 1 , - 1 , - 1 , - 1)
        local integer tech2= s__ChooseTechDialog_getHotestTech(this,hero , tech1 , - 1 , - 1 , - 1)
        local integer tech3= s__ChooseTechDialog_getHotestTech(this,hero , tech1 , tech2 , - 1 , - 1)
        local string s1
        local string s2
        local string s3
        local string s4
        local string s5
        if tech1 > 0 then
            set s1=LoadStr(tdht, tech1, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s1, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech1))
            set b=null
        endif
        if tech2 > 0 then
            set s2=LoadStr(tdht, tech2, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s2, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech2))
            set b=null
        endif
        if tech3 > 0 then
            set s3=LoadStr(tdht, tech3, tdht_name)
            set b=DialogAddButton(s__IDialog_d[this], s3, 0)
            set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
            set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
            call SetButtonStructA(b , s__ButtonTech_create(tech3))
            set b=null
        endif
        set s___IDialog_choses[s__IDialog_choses[this]+3]=DialogAddButton(s__IDialog_d[this], "涓ょ偣绉戞妧鐐?, 0)
   return true
endfunction
function sa__ChooseTechDialog_display takes nothing returns boolean
local integer this=f__arg_this
        call s__ChooseTechDialog_init(this)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
   return true
endfunction
function sa__ChooseBonusDialog_button_clicked takes nothing returns boolean
    call s__ChooseBonusDialog_button_clicked(f__arg_this,f__arg_button1)
   return true
endfunction
function sa__ChooseBonusDialog_init takes nothing returns boolean
local integer this=f__arg_this
        local button b
        local unit hero= heros[GetPlayerId(s__IDialog_p[this])]
        set b=DialogAddButton(s__IDialog_d[this], "閲戝竵+100", 0)
        set s___IDialog_choses[s__IDialog_choses[this]+s__IDialog_choses_size[this]]=b
        set s__IDialog_choses_size[this]=s__IDialog_choses_size[this] + 1
        set b=null
   return true
endfunction
function sa__ChooseBonusDialog_display takes nothing returns boolean
local integer this=f__arg_this
        call s__ChooseBonusDialog_init(this)
        call DialogDisplay(s__IDialog_p[this], s__IDialog_d[this], true)
   return true
endfunction
function sa__DefaultBufferStruct_condition takes nothing returns boolean
local integer this=f__arg_this
        set s__IBufferStruct_count[this]=s__IBufferStruct_count[this] - 1
        call sc__IBufferStruct_action(this)
set f__result_boolean= s__IBufferStruct_count[this] >= 0 and IsUnitAliveBJ(s__IBufferStruct_u[this])
   return true
endfunction
function sa__DefaultBufferStruct_action takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultBufferStruct_addBuffer takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultBufferStruct_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultBufferStruct_init takes nothing returns boolean
    call s__DefaultBufferStruct_init(f__arg_this,f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__DefaultBufferStruct_start takes nothing returns boolean
local integer this=f__arg_this
        set s__IBufferStruct_flag[this]=true
        call sc__IBufferStruct_addBuffer(this)
   return true
endfunction
function sa__DefaultBufferStruct_create takes nothing returns boolean
    set f__result_integer=s__DefaultBufferStruct_create(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__DefaultBufferStruct_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        if s__IBufferStruct_flag[this] then
            call sc__IBufferStruct_removeBuffer(this)
        endif
        set s__IBufferStruct_u[this]=null
        call s__DefaultBufferStruct_removeList(this)
        call sc__IBufferStruct_finish(this)
    set f__arg_this=this
   return true
endfunction
function sa__DefaultBufferStruct_finish takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__DefaultBufferStruct_loopMoveAll takes nothing returns boolean

         local boolean r
         local integer m= s__DefaultBufferStruct_getFirst()
             loop
                 exitwhen m == 0
                 if s__IBufferStruct_flag[m] then
                     set r=sc__IBufferStruct_condition(m)
                     if r then
                     else
                        call sc__IBufferStruct_deallocate(m)
                     endif
                     set m=s__DefaultBufferStruct_getNext(m)
                 endif
             endloop
   return true
endfunction
function sa__BoundUnitEffectStruct_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__BoundUnitEffectStruct_eu[this]=CreateUnit(GetOwningPlayer(s__IBufferStruct_u[this]), s__BoundUnitEffectStruct_uid[this], GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), GetUnitFacing(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_bais[this])
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
        call SetUnitAnimation(s__BoundUnitEffectStruct_eu[this], s__BoundUnitEffectStruct_animate[this])
   return true
endfunction
function sa__BoundUnitEffectStruct_action takes nothing returns boolean
local integer this=f__arg_this
        call SetUnitX(s__BoundUnitEffectStruct_eu[this], GetUnitX(s__IBufferStruct_u[this]))
        call SetUnitY(s__BoundUnitEffectStruct_eu[this], GetUnitY(s__IBufferStruct_u[this]))
        call SetUnitFlyHeight(s__BoundUnitEffectStruct_eu[this], GetUnitFlyHeight(s__IBufferStruct_u[this]) + s__BoundUnitEffectStruct_z[this], 0)
   return true
endfunction
function sa__BoundUnitEffectStruct_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        call KillUnit(s__BoundUnitEffectStruct_eu[this])
   return true
endfunction
function sa__BoundUnitEffectStruct_finish takes nothing returns boolean
local integer this=f__arg_this
        set s__BoundUnitEffectStruct_eu[this]=null
   return true
endfunction
function sa__ElectricWhipBufferStruct_condition takes nothing returns boolean
local integer this=f__arg_this
        local real dis= DistanceTwoUnits(s__ElectricWhipBufferStruct_source[this] , s__IBufferStruct_u[this])
        set s__IBufferStruct_count[this]=s__IBufferStruct_count[this] - 1
        call sc__ElectricWhipBufferStruct_action(this)
set f__result_boolean= s__IBufferStruct_count[this] >= 0 and dis > 200 and IsUnitAliveBJ(s__ElectricWhipBufferStruct_source[this]) and IsUnitAliveBJ(s__IBufferStruct_u[this])
   return true
endfunction
function sa__ElectricWhipBufferStruct_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__ElectricWhipBufferStruct_l[this]=AddLightningEx("CLPB", false, GetUnitX(s__ElectricWhipBufferStruct_source[this]), GetUnitY(s__ElectricWhipBufferStruct_source[this]), getUnitHeight(s__ElectricWhipBufferStruct_source[this]), GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), getUnitHeight(s__IBufferStruct_u[this]))
   return true
endfunction
function sa__ElectricWhipBufferStruct_action takes nothing returns boolean
local integer this=f__arg_this
        local integer returnForce
        set returnForce=s__ElectricWhipBufferStruct_getReturnForce(this)
        call s__ElectricWhipBufferStruct_removef(this,s__ElectricWhipBufferStruct_pref[this])
        set s__vector_x[s__ElectricWhipBufferStruct_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__ElectricWhipBufferStruct_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__ElectricWhipBufferStruct_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call s__ElectricWhipBufferStruct_addf(this,s__ElectricWhipBufferStruct_pref[this])
        call LightningDamage(s__ElectricWhipBufferStruct_source[this] , s__IBufferStruct_u[this] , s__ElectricWhipBufferStruct_dam[this] / 50)
        call MoveLightningEx(s__ElectricWhipBufferStruct_l[this], false, GetUnitX(s__ElectricWhipBufferStruct_source[this]), GetUnitY(s__ElectricWhipBufferStruct_source[this]), getUnitHeight(s__ElectricWhipBufferStruct_source[this]), GetUnitX(s__IBufferStruct_u[this]), GetUnitY(s__IBufferStruct_u[this]), getUnitHeight(s__IBufferStruct_u[this]))
   return true
endfunction
function sa__ElectricWhipBufferStruct_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        call DestroyLightning(s__ElectricWhipBufferStruct_l[this])
        call s__ElectricWhipBufferStruct_removef(this,s__ElectricWhipBufferStruct_pref[this])
        call s__vector_deallocate(s__ElectricWhipBufferStruct_pref[this])
        set s__ElectricWhipBufferStruct_l[this]=null
        set s__ElectricWhipBufferStruct_source[this]=null
        set s__IBufferStruct_u[this]=null
   return true
endfunction
function sa__ElectricWhipBufferStruct_finish takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__PushForceStruct_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        call AddForce(s__IBufferStruct_u[this] , s__PushForceStruct_fc[this])
   return true
endfunction
function sa__PushForceStruct_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        call RemoveForce(s__IBufferStruct_u[this] , s__PushForceStruct_fc[this])
   return true
endfunction
function sa__PushForceStruct_create takes nothing returns boolean
    set f__result_integer=s__PushForceStruct_create(f__arg_unit1,f__arg_integer1,f__arg_integer2)
   return true
endfunction
function sa__PushForceStruct_finish takes nothing returns boolean
local integer this=f__arg_this
        call s__vector_deallocate(s__PushForceStruct_fc[this])
   return true
endfunction
function sa__Missle_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e000'
   return true
endfunction
function sa__Missle_refreshDamagedGroup takes nothing returns boolean
local integer this=f__arg_this
        local group newGroup
        local unit ydl_unit
        if not IsUnitGroupEmptyBJ(s__IMissle_damaged[this]) then
            set newGroup=CreateGroup()
            loop
            set ydl_unit=FirstOfGroup(s__IMissle_damaged[this])
            exitwhen ydl_unit == null
            call GroupRemoveUnit(s__IMissle_damaged[this], ydl_unit)
            if DistanceTwoUnits(s__IMissle_missle[this] , ydl_unit) <= REDAMAGE_DISTANCE then
                call GroupAddUnit(newGroup, ydl_unit)
            endif
            endloop
            set s__IMissle_damaged[this]=newGroup
        endif
        set newGroup=null
        set ydl_unit=null
   return true
endfunction
function sa__Missle_troughDamage takes nothing returns boolean
    call s__Missle_troughDamage(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Missle_doDamage takes nothing returns boolean
local integer this=f__arg_this
local real radius=f__arg_real1
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
   return true
endfunction
function sa__Missle_damageEnemy takes nothing returns boolean
    call s__Missle_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Missle_debuffEnemy takes nothing returns boolean
    call s__Missle_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Missle_healAlly takes nothing returns boolean
    call s__Missle_healAlly(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Missle_hitSelf takes nothing returns boolean
    call s__Missle_hitSelf(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__Missle_fireMissle takes nothing returns boolean
local integer this=f__arg_this
local integer vi=f__arg_integer1
        set s__IMissle_missle[this]=CreateUnit(GetOwningPlayer(s__IMissle_owner[this]), sc__IMissle_getMissleId(this), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getDeg(s__vector_y[vi] , s__vector_x[vi]))
        if GetUnitFlyHeight(s__IMissle_owner[this]) > g_sd_th then
            call SetUnitFlyHeight(s__IMissle_missle[this], GetUnitFlyHeight(s__IMissle_owner[this]), 0)
        endif
        set s__IMissle_life[this]=sc__IMissle_getLife(this)
        set s__IMissle_origin_life[this]=s__IMissle_life[this]
        call sc__IMissle_onFire(this)
        set s__IMissle_started[this]=true
        call s__vector_deallocate(s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])])
        set s__Velocity_v[sc__Velocity__staticgetindex(s__IMissle_missle[this])]=vi
        set s__Velocity_missleStruct[sc__Velocity__staticgetindex(s__IMissle_missle[this])]=this
   return true
endfunction
function sa__Missle_onFire takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Missle_substep takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Missle_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 30
   return true
endfunction
function sa__Missle_create takes nothing returns boolean
    set f__result_integer=s__Missle_create(f__arg_unit1)
   return true
endfunction
function sa__Missle_step takes nothing returns boolean
local integer this=f__arg_this
        set s__IMissle_life[this]=s__IMissle_life[this] - 1
        call sc__IMissle_substep(this)
        if s__IMissle_life[this] <= 0 then
            call sc__IMissle_deallocate(this)
        endif
   return true
endfunction
function sa__Missle_getFinalDamage takes nothing returns boolean
local integer this=f__arg_this
        local real od= sc__IMissle_getOriginalDamage(this)
set f__result_real= od
   return true
endfunction
function sa__Missle_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 50.0
   return true
endfunction
function sa__Missle_explode takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Missle_onDestroy takes nothing returns boolean
local integer this=f__arg_this
        call sc__IMissle_explode(this)
        set s__IMissle_owner[this]=null
        call KillUnit(s__IMissle_missle[this])
        call GroupClear(s__IMissle_damaged[this])
        call DestroyGroup(s__IMissle_damaged[this])
        set s__IMissle_damaged[this]=null
        set s__IMissle_missle[this]=null
    set f__arg_this=this
   return true
endfunction
function sa__TroughMissle_damageEnemy takes nothing returns boolean
    call s__TroughMissle_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__TroughMissle_troughDamage takes nothing returns boolean
    call s__TroughMissle_troughDamage(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ShootGunMissle_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 15
   return true
endfunction
function sa__IceMissle_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= bICE_MISSLE
   return true
endfunction
function sa__IceMissle_damageEnemy takes nothing returns boolean
    call s__IceMissle_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__IceMissle_debuffEnemy takes nothing returns boolean
    call s__IceMissle_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__FireMissle_damageEnemy takes nothing returns boolean
    call s__FireMissle_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__FireMissle_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= bFIRE_MISSLE
   return true
endfunction
function sa__FireMissle_debuffEnemy takes nothing returns boolean
    call s__FireMissle_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SmallDarts_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e002'
   return true
endfunction
function sa__SmallDarts_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 100.0
   return true
endfunction
function sa__SmallDarts_damageEnemy takes nothing returns boolean
    call s__SmallDarts_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ElectricWhip_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= bELECTRIC
   return true
endfunction
function sa__ElectricWhip_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 0.0
   return true
endfunction
function sa__ElectricWhip_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= R2I(getf2value(s__IMissle_owner[this] , iELECTRIC))
   return true
endfunction
function sa__ElectricWhip_debuffEnemy takes nothing returns boolean
    call s__ElectricWhip_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ElectricWhip_onFire takes nothing returns boolean
local integer this=f__arg_this
        set s__ElectricWhip_l[this]=AddLightningEx("CLPB", false, GetUnitX(s__IMissle_missle[this]), GetUnitY(s__IMissle_missle[this]), getUnitHeight(s__IMissle_missle[this]), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getUnitHeight(s__IMissle_owner[this]))
   return true
endfunction
function sa__ElectricWhip_substep takes nothing returns boolean
local integer this=f__arg_this
        call MoveLightningEx(s__ElectricWhip_l[this], false, GetUnitX(s__IMissle_missle[this]), GetUnitY(s__IMissle_missle[this]), getUnitHeight(s__IMissle_missle[this]), GetUnitX(s__IMissle_owner[this]), GetUnitY(s__IMissle_owner[this]), getUnitHeight(s__IMissle_owner[this]))
   return true
endfunction
function sa__ElectricWhip_explode takes nothing returns boolean
local integer this=f__arg_this
        call DestroyLightning(s__ElectricWhip_l[this])
   return true
endfunction
function sa__ReturnDarts_getMissleId takes nothing returns boolean
local integer this=f__arg_this
        set s__ReturnDarts_pref[this]=s__vector_create(0 , 0 , 0)
set f__result_integer= 'e003'
   return true
endfunction
function sa__ReturnDarts_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 130.0
   return true
endfunction
function sa__ReturnDarts_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 10000
   return true
endfunction
function sa__ReturnDarts_debuffEnemy takes nothing returns boolean
    call s__ReturnDarts_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ReturnDarts_hitSelf takes nothing returns boolean
    call s__ReturnDarts_hitSelf(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ReturnDarts_getFinalDamage takes nothing returns boolean
local integer this=f__arg_this
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__ReturnDarts_getOriginalDamage(this)
        set itm=null
set f__result_real= od + daminc
   return true
endfunction
function sa__ReturnDarts_troughDamage takes nothing returns boolean
    call s__ReturnDarts_troughDamage(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ReturnDarts_explode takes nothing returns boolean
local integer this=f__arg_this
        call s__vector_deallocate(s__ReturnDarts_pref[this])
   return true
endfunction
function sa__ReturnDarts_substep takes nothing returns boolean
local integer this=f__arg_this
        local integer returnForce
        set returnForce=s__ReturnDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__ReturnDarts_pref[this])
        set s__vector_x[s__ReturnDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__ReturnDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__ReturnDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__ReturnDarts_pref[this])
   return true
endfunction
function sa__LeaveDarts_getMissleId takes nothing returns boolean
local integer this=f__arg_this
        set s__LeaveDarts_pref[this]=s__vector_create(0 , 0 , 0)
set f__result_integer= 'e003'
   return true
endfunction
function sa__LeaveDarts_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 100.0
   return true
endfunction
function sa__LeaveDarts_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1000
   return true
endfunction
function sa__LeaveDarts_debuffEnemy takes nothing returns boolean
    call s__LeaveDarts_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__LeaveDarts_getFinalDamage takes nothing returns boolean
local integer this=f__arg_this
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__LeaveDarts_getOriginalDamage(this)
        set itm=null
set f__result_real= od + daminc
   return true
endfunction
function sa__LeaveDarts_troughDamage takes nothing returns boolean
    call s__LeaveDarts_troughDamage(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__LeaveDarts_explode takes nothing returns boolean
local integer this=f__arg_this
        call s__vector_deallocate(s__LeaveDarts_pref[this])
   return true
endfunction
function sa__LeaveDarts_substep takes nothing returns boolean
local integer this=f__arg_this
        local integer returnForce
        set returnForce=s__LeaveDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__LeaveDarts_pref[this])
        set s__vector_x[s__LeaveDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__LeaveDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__LeaveDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__LeaveDarts_pref[this])
   return true
endfunction
function sa__BackGrenade_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e009'
   return true
endfunction
function sa__BackGrenade_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 100.0
   return true
endfunction
function sa__BackGrenade_debuffEnemy takes nothing returns boolean
    call s__BackGrenade_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BackGrenade_damageEnemy takes nothing returns boolean
    call s__BackGrenade_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BackGrenade_explode takes nothing returns boolean
local integer this=f__arg_this
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iBKGRENADE)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real radius= s__ItemFeature_getValue(f2)
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
        call DestroyEffect(AddSpecialEffect(E_TUNDER_CLAP, x, y))
        set itm=null
   return true
endfunction
function sa__BackGrenade_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 300
   return true
endfunction
function sa__PushGrenade_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e00A'
   return true
endfunction
function sa__PushGrenade_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 100.0
   return true
endfunction
function sa__PushGrenade_debuffEnemy takes nothing returns boolean
    call s__PushGrenade_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__PushGrenade_damageEnemy takes nothing returns boolean
    call s__PushGrenade_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__PushGrenade_explode takes nothing returns boolean
local integer this=f__arg_this
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iPSGRENADE)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real radius= s__ItemFeature_getValue(f2)
        call missleRangeOneTimeActionToUnit(this , x , y , radius , s__IMissle_damaged[this])
        call DestroyEffect(AddSpecialEffect(E_CLAP, x, y))
        set itm=null
   return true
endfunction
function sa__PushGrenade_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 300
   return true
endfunction
function sa__Mine_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e00B'
   return true
endfunction
function sa__Mine_substep takes nothing returns boolean
local integer this=f__arg_this
        if s__Mine_active[this] == false then
            if s__IMissle_life[this] < sc__Mine_getLife(this) - sc__Mine_getDeployTime(this) and HasLiveEnemyUnitInRange(s__IMissle_missle[this] , 200) != null then
                set s__Mine_active[this]=true
            endif
        else
            if s__Mine_count[this] > 0 then
                set s__Mine_count[this]=s__Mine_count[this] - 1
            else
                call sc__IMissle_deallocate(this)
            endif
        endif
   return true
endfunction
function sa__Mine_explode takes nothing returns boolean
local integer this=f__arg_this
        local real x= GetUnitX(s__IMissle_missle[this])
        local real y= GetUnitY(s__IMissle_missle[this])
        call DestroyEffect(AddSpecialEffect(E_MINE_EXPLODE, x, y))
        call rangeExplodeDamage(s__IMissle_owner[this] , x , y , 200 , 300)
   return true
endfunction
function sa__Mine_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 3000
   return true
endfunction
function sa__Mine_getDeployTime takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 122
   return true
endfunction
function sa__Mine_create takes nothing returns boolean
    set f__result_integer=s__Mine_create(f__arg_unit1)
   return true
endfunction
function sa__ShoulderCannonMissle_damageEnemy takes nothing returns boolean
    call s__ShoulderCannonMissle_damageEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__ShoulderCannonMissle_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 30
   return true
endfunction
function sa__ShoulderCannonMissle_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 400.0
   return true
endfunction
function sa__ShoulderCannonMissle_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e00E'
   return true
endfunction
function sa__SpearMissle_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 30
   return true
endfunction
function sa__SpearMissle_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= g_missle_damage + 20
   return true
endfunction
function sa__SpearMissle_getMissleId takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 'e00F'
   return true
endfunction
function sa__SmartDarts_getMissleId takes nothing returns boolean
local integer this=f__arg_this
        set s__SmartDarts_pref[this]=s__vector_create(0 , 0 , 0)
set f__result_integer= 'e003'
   return true
endfunction
function sa__SmartDarts_getOriginalDamage takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 130.0
   return true
endfunction
function sa__SmartDarts_getLife takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 10000
   return true
endfunction
function sa__SmartDarts_debuffEnemy takes nothing returns boolean
    call s__SmartDarts_debuffEnemy(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SmartDarts_create takes nothing returns boolean
    set f__result_integer=s__SmartDarts_create(f__arg_unit1,f__arg_unit2)
   return true
endfunction
function sa__SmartDarts_hitSelf takes nothing returns boolean
    call s__SmartDarts_hitSelf(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SmartDarts_getFinalDamage takes nothing returns boolean
local integer this=f__arg_this
        local item itm= GetItemByTypeId(s__IMissle_owner[this] , iRETURN)
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real daminc= s__ItemFeature_getValue(f2)
        local real od= s__SmartDarts_getOriginalDamage(this)
        set itm=null
set f__result_real= od + daminc
   return true
endfunction
function sa__SmartDarts_troughDamage takes nothing returns boolean
    call s__SmartDarts_troughDamage(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__SmartDarts_explode takes nothing returns boolean
local integer this=f__arg_this
        call s__vector_deallocate(s__SmartDarts_pref[this])
   return true
endfunction
function sa__SmartDarts_substep takes nothing returns boolean
local integer this=f__arg_this
        local integer returnForce
        set returnForce=s__SmartDarts_getReturnForce(this)
        call RemoveForce(s__IMissle_missle[this] , s__SmartDarts_pref[this])
        set s__vector_x[s__SmartDarts_pref[this]]=s__vector_x[returnForce]
        set s__vector_y[s__SmartDarts_pref[this]]=s__vector_y[returnForce]
        set s__vector_z[s__SmartDarts_pref[this]]=s__vector_z[returnForce]
        call s__vector_deallocate(returnForce)
        call AddForce(s__IMissle_missle[this] , s__SmartDarts_pref[this])
   return true
endfunction
function sa__AutoAimBuffer_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        local real r= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]=r + 1
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\TrueshotAura\\TrueshotAura.mdl", s__IBufferStruct_u[this], "origin"))
   return true
endfunction
function sa__AutoAimBuffer_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        local real r= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]
        set s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IBufferStruct_u[this])]]=r - 1
   return true
endfunction
function sa__SingleShooter_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
   return true
endfunction
function sa__ShoulderCannonShooter_tick takes nothing returns boolean
local integer this=f__arg_this
        local integer v
        if ModuloInteger(Tick - s__ShoulderCannonShooter_t[this], 4) == 0 then
            if s__ShoulderCannonShooter_c[this] > 0 then
                set v=s__vector_create(s__vector_x[s__ShoulderCannonShooter_d[this]] , s__vector_y[s__ShoulderCannonShooter_d[this]] , s__vector_z[s__ShoulderCannonShooter_d[this]])
                call s__vector_rotate(v,s__vector_create(0 , 0 , 1) , 0.1 * ( 3 - s__ShoulderCannonShooter_c[this] ))
                call sc__IMissle_fireMissle(sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this]),v)
                set s__ShoulderCannonShooter_c[this]=s__ShoulderCannonShooter_c[this] - 1
            else
                call sc__IShooter_deallocate(this)
            endif
        endif
   return true
endfunction
function sa__ShoulderCannonShooter_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call s__vector_rotate(dir,s__vector_create(0 , 0 , 1) , - 0.1)
        set s__ShoulderCannonShooter_d[this]=dir
        call sc__IMissle_fireMissle(m,dir)
        set s__ShoulderCannonShooter_t[this]=Tick
   return true
endfunction
function sa__GrenadeThrower_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
   return true
endfunction
function sa__MineThrower_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
   return true
endfunction
function sa__DefaultShooter_shoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer ec= sc__IShooter_getEnergyConsume(this)
        local integer vdir
        local integer i= 1
        local integer n= 0
        set n=( s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])] + sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])] ) / SHOTHZ
        set s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])]=ModuloInteger(s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])] + sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])], SHOTHZ)
        if n == 0 then
            if ( ( GetTimeOfDay() - s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])] ) / 0.005 ) * ( sc__IShooter_shoothz(this) + s__Material_shot_fast_buff[s__Material__staticgetindex(s__IShooter_owner[this])] ) > 100 then
                set n=1
                set s__Material_shot_tick[s__Material__staticgetindex(s__IShooter_owner[this])]=0
            endif
        endif
        loop
            exitwhen i > n * sc__IShooter_shootCount(this)
            set i=i + 1
            set vdir=sc__DefaultShooter_getShootVector(this)
            if IsHero(s__IShooter_owner[this]) then
                if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] and GetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER) >= ec then
                    call sc__DefaultShooter_energyConsume(this,ec)
                    call sc__DefaultShooter_backForce(this,sc__DefaultShooter_getShootDir(this))
                    call sc__IShooter_subshoot(this,vdir)
                    set s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])]=GetTimeOfDay()
                else
                    if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] then
                        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        call SetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER, 0)
                        call UnitAddAbility(s__IShooter_owner[this], 'Abun')
                        set s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=true
                    endif
                    call DisplayFloatText(GetUnitX(s__IShooter_owner[this]) , GetUnitY(s__IShooter_owner[this]) , "!" , 1)
                endif
            else
                if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] and s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] >= ec then
                    call sc__DefaultShooter_energyConsume(this,ec)
                    call sc__DefaultShooter_backForce(this,sc__DefaultShooter_getShootDir(this))
                    call sc__IShooter_subshoot(this,vdir)
                    set s__Material_last_shoot[s__Material__staticgetindex(s__IShooter_owner[this])]=GetTimeOfDay()
                else
                    if not s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] then
                        set s__IHeroData_shoot_energy[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        set s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=0
                        call UnitAddAbility(s__IShooter_owner[this], 'Abun')
                        set s__IHeroData_reload[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=true
                    endif
                    call DisplayFloatText(GetUnitX(s__IShooter_owner[this]) , GetUnitY(s__IShooter_owner[this]) , "!" , 1)
                endif
            endif
        endloop
   return true
endfunction
function sa__DefaultShooter_getShootDir takes nothing returns boolean
local integer this=f__arg_this
        local unit target= s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real ux= GetUnitX(s__IShooter_owner[this])
        local real uy= GetUnitY(s__IShooter_owner[this])
        local real tx= GetUnitX(target)
        local real ty= GetUnitY(target)
        local real dir= getDir(ux , uy , tx , ty)
        set target=null
set f__result_real= dir
   return true
endfunction
function sa__DefaultShooter_getShootVector takes nothing returns boolean
local integer this=f__arg_this
        local unit target= s__IHeroData_shoot_target[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real ux= GetUnitX(s__IShooter_owner[this])
        local real uy= GetUnitY(s__IShooter_owner[this])
        local real uz= getUnitHeight(s__IShooter_owner[this])
        local real tx= GetUnitX(target)
        local real ty= GetUnitY(target)
        local real tz= getUnitHeight(target)
        local real rr= GetRandomReal(0, 2 * pi)
        local real hr= s__IHeroData_shoot_rist[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
        local real rist= sc__IShooter_getRist(this) * RMaxBJ(0, ( 1 - hr )) * SquareRoot(Pow(ty - uy, 2) + Pow(tx - ux, 2)) / 900
        local real tx2= GetUnitX(target) + Cos(rr) * rist
        local real ty2= GetUnitY(target) + Sin(rr) * rist
        local integer t= s__vector_create(tx2 - ux , ty2 - uy , tz - uz)
        call s__vector_setLength(t,s__DefaultShooter_getSpeed(this))
set f__result_integer= t
   return true
endfunction
function sa__DefaultShooter_subshoot takes nothing returns boolean
local integer this=f__arg_this
local integer dir=f__arg_integer1
        local integer m=sc__IMissleFactory_createMissle(s__IShooter_factory[this],s__IShooter_owner[this])
        call sc__IMissle_fireMissle(m,dir)
   return true
endfunction
function sa__DefaultShooter_getEnergyConsume takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1
   return true
endfunction
function sa__DefaultShooter_energyConsume takes nothing returns boolean
local integer this=f__arg_this
local integer consume=f__arg_integer1
        local integer l
        if IsHero(s__IShooter_owner[this]) then
            set l=GetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER)
            call SetPlayerState(GetOwningPlayer(s__IShooter_owner[this]), PLAYER_STATE_RESOURCE_LUMBER, l - consume)
        else
            set l=s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]
            set s__IHeroData_bullets[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]]=l - consume
        endif
   return true
endfunction
function sa__DefaultShooter_backForce takes nothing returns boolean
local integer this=f__arg_this
local real vdir=f__arg_real1
        local real facing= vdir + pi
        call Push(s__IShooter_owner[this] , facing , s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__IShooter_owner[this])]] , 0 , 5)
   return true
endfunction
function sa__ShootGunShooter_getEnergyConsume takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1
   return true
endfunction
function sa__ShootGunShooter_shootCount takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 12
   return true
endfunction
function sa__ShootGunShooter_getRist takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 200.0
   return true
endfunction
function sa__ShootGunShooter_getOriginSpeed takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 80.0
   return true
endfunction
function sa__MachineGunShooter_shoothz takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 100
   return true
endfunction
function sa__MachineGunShooter_getEnergyConsume takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 1
   return true
endfunction
function sa__MachineGunShooter_getClipSize takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= 100
   return true
endfunction
function sa__ItemJump_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ItemJump_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real facing= getFacing(s__SpellStruct_caster[this])
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iJUMP)
        local integer f1= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local integer f2= s__ItemFeatureData_f2[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real d= s__ItemFeature_getValue(f2)
        local real h= s__ItemFeature_getValue(f1)
        local integer v= s__vector_create(d * Cos(facing) , d * Sin(facing) , h)
        call AddVelocity(s__SpellStruct_caster[this] , v)
   return true
endfunction
function sa__ItemJump_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Jump_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__Jump_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real facing= s__IHeroData_jump_direction[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]
        local real d= 13
        local real h= 35
        local integer v= s__vector_create(d * Cos(facing) , d * Sin(facing) , h)
        call IssueImmediateOrder(s__SpellStruct_caster[this], "stop")
        call AddVelocity(s__SpellStruct_caster[this] , v)
   return true
endfunction
function sa__Jump_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__InjectionSpeedUp_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__InjectionSpeedUp_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real facing= getFacing(s__SpellStruct_caster[this])
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iSPEED)
        local integer f= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real speed= s__ItemFeature_origin[f] + s__ItemFeature_lv[f] * s__ItemFeature_step[f]
        call Push(s__SpellStruct_caster[this] , facing , speed , 0 , 30)
        call s__DefaultBufferStruct_start(s__BoundUnitEffectStruct_create(s__SpellStruct_caster[this] , 30 , 'e001' , - 90 , "stand" , 70))
   return true
endfunction
function sa__InjectionSpeedUp_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Darts_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__Darts_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local unit tu= GetNearestEnemy(s__SpellStruct_caster[this] , 1000)
        local real speed= s__Darts_getSpeed(this)
        local real dd
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , s__SmallDartsFactory__allocate())
        local integer dir
        if ( tu == null ) then
            set dd=getFacing(s__SpellStruct_caster[this])
            set dir=s__vector_create(speed * Cos(dd) , speed * Sin(dd) , 0)
        else
            set dir=getDirVector(s__SpellStruct_caster[this] , tu , speed)
        endif
        call sc__IShooter_shoot(shooter,dir)
        set tu=null
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__Darts_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ReturnDartsSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ReturnDartsSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__ReturnDartsSpell_getSpeed(this)
        local integer factory= s__ReturnDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ReturnDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__ReturnDartsSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__SmartDartsSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__SmartDartsSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__SmartDartsSpell_getSpeed(this)
        local integer factory= s__SmartDartsFactory_create(s__SpellStruct_targetUnit[this])
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call BJDebugMsg("fire")
        call s__vector_setLength(dir,s__SmartDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__SmartDartsSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ShoulderCannonSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ShoulderCannonSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__ShoulderCannonSpell_getSpeed(this)
        local integer factory= s__ShoulderCannonFactory__allocate()
        local integer shooter= s__ShoulderCannonShooter_create(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ShoulderCannonSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
   return true
endfunction
function sa__ShoulderCannonSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ItemReturnDartsSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ItemReturnDartsSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__ItemReturnDartsSpell_getSpeed(this)
        local integer factory= s__ReturnDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__ItemReturnDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__ItemReturnDartsSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__LeaveDartsSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__LeaveDartsSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__LeaveDartsSpell_getSpeed(this)
        local integer factory= s__LeaveDartsFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , 0)
        call s__vector_setLength(dir,s__LeaveDartsSpell_getSpeed(this))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__LeaveDartsSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__BackGrenadeSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__BackGrenadeSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__BackGrenadeSpell_getSpeed(this)
        local integer factory= s__BackGrenadeFactory__allocate()
        local integer shooter= s__GrenadeThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= GetGrenadeVector(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real v= GetGrenadeTrajectory(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        call s__vector_setLength(dir,RMinBJ(v, speed))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__BackGrenadeSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__MineSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__MineSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local integer factory= s__MineFactory__allocate()
        local integer shooter= s__MineThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= s__vector_create(0 , 0 , 0)
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__MineSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__PushGrenadeSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__PushGrenadeSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real speed= s__PushGrenadeSpell_getSpeed(this)
        local integer factory= s__PushGrenadeFactory__allocate()
        local integer shooter= s__GrenadeThrower__allocate(s__SpellStruct_caster[this] , factory)
        local integer dir= GetGrenadeVector(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real v= GetGrenadeTrajectory(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        call s__vector_setLength(dir,RMinBJ(v, speed))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__PushGrenadeSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__Blink_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__Blink_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real dis= DistanceTwo(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real max= getf1value(s__SpellStruct_caster[this] , iBLINK)
        local real r= RMinBJ(max, dis)
        local real ang= getDir(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real tx= s__SpellStruct__get_casterX(this) + r * Cos(ang)
        local real ty= s__SpellStruct__get_casterY(this) + r * Sin(ang)
        call DestroyEffect(AddSpecialEffect(E_BLINK_CASTER, s__SpellStruct__get_casterX(this), s__SpellStruct__get_casterY(this)))
        call SetUnitX(s__SpellStruct_caster[this], tx)
        call SetUnitY(s__SpellStruct_caster[this], ty)
        call DestroyEffect(AddSpecialEffect(E_BLINK_TARGET, tx, ty))
   return true
endfunction
function sa__Transport_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__Transport_onFinish takes nothing returns boolean
local integer this=f__arg_this
        local real dis= DistanceTwo(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real max= getf1value(s__SpellStruct_caster[this] , iTRANSPORT)
        local real r= RMinBJ(max, dis)
        local real ang= getDir(s__SpellStruct__get_casterX(this) , s__SpellStruct__get_casterY(this) , s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
        local real tx= s__SpellStruct__get_casterX(this) + r * Cos(ang)
        local real ty= s__SpellStruct__get_casterY(this) + r * Sin(ang)
        call DestroyEffect(AddSpecialEffect(E_TRANSPORT_CASTER, s__SpellStruct__get_casterX(this), s__SpellStruct__get_casterY(this)))
        call SetUnitX(s__SpellStruct_caster[this], tx)
        call SetUnitY(s__SpellStruct_caster[this], ty)
        call DestroyEffect(AddSpecialEffect(E_TRANSPORT_TARGET, tx, ty))
   return true
endfunction
function sa__ElectricWhipSpell_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ElectricWhipSpell_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local integer factory= s__ElectricWhipFactory__allocate()
        local integer shooter= s__SingleShooter__allocate(s__SpellStruct_caster[this] , factory)
        local real uz= getUnitHeight(s__SpellStruct_caster[this])
        local real tz
        local integer dir
        if s__SpellStruct_targetUnit[this] == null then
            set tz=getTerrianHeight(s__SpellStruct_targetX[this] , s__SpellStruct_targetY[this])
            set dir=s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , tz - uz)
        else
            set tz=getUnitHeight(s__SpellStruct_targetUnit[this])
            set dir=s__vector_create(s__SpellStruct_targetX[this] - s__SpellStruct__get_casterX(this) , s__SpellStruct_targetY[this] - s__SpellStruct__get_casterY(this) , tz - uz)
        endif
        call s__vector_setLength(dir,getf1value(s__SpellStruct_caster[this] , iELECTRIC))
        call sc__IShooter_shoot(shooter,dir)
        call sc__IShooter_deallocate(shooter)
   return true
endfunction
function sa__ElectricWhipSpell_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__AutoAim_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__AutoAim_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real time= getf1value(s__SpellStruct_caster[this] , iAUTOAIM)
        call s__DefaultBufferStruct_start(s__AutoAimBuffer__allocate(s__SpellStruct_caster[this] , R2I(time * 50)))
   return true
endfunction
function sa__ShootBack_cleanup takes nothing returns boolean
local integer this=f__arg_this
call RemoveSavedInteger(SpellStruct__STORE, s__SpellStruct_abilId[this], GetHandleId(s__SpellStruct_caster[this]))
            set s__SpellStruct_hasStoppedCasting[this]=true // can't be readonly because of this.
if s__SpellStruct__get_autoDestroy(this) and s__SpellStruct__get_isNotLocked(this) then
                call s__SpellStruct_destroy((this)) // Jasshelper bug? Had to typecast "this".
endif
   return true
endfunction
function sa__ShootBack_onChannel takes nothing returns boolean
local integer this=f__arg_this
        local real facing= getFacing(s__SpellStruct_caster[this]) + pi
        local item itm= GetItemByTypeId(s__SpellStruct_caster[this] , iREACT)
        local integer f= s__ItemFeatureData_f1[s__IndividualItemData_featureData[s__IndividualItemData__staticgetindex(itm)]]
        local real speed= s__ItemFeature_getValue(f)
        set s__IHeroData_a_shoot_back[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]=s__IHeroData_a_shoot_back[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]] + speed
        set s__IHeroData_a_shoot_back_log[s__EquipmentData_heroData[s__EquipmentData__staticgetindex(s__SpellStruct_caster[this])]]=speed
   return true
endfunction
function sa__ShootBack_onStopCast takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__BurnBuffer_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        local integer burnlv= s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]
        set s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=burnlv + 1
        set s__BurnBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\ImmolationRed\\ImmolationRedDamage.mdl", s__IBufferStruct_u[this], "origin")
   return true
endfunction
function sa__BurnBuffer_action takes nothing returns boolean
local integer this=f__arg_this
        if ModuloInteger(s__IBufferStruct_count[this], 25) == 0 then
            call FireDamage(s__BurnBuffer_source[this] , s__IBufferStruct_u[this] , s__BurnBuffer_dam[this])
        endif
   return true
endfunction
function sa__BurnBuffer_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=s__Material_burnlv[s__Material__staticgetindex(s__IBufferStruct_u[this])] - 1
        set s__BurnBuffer_source[this]=null
        call DestroyEffect(s__BurnBuffer_e[this])
        set s__BurnBuffer_e[this]=null
   return true
endfunction
function sa__BurnBuffer_create takes nothing returns boolean
    set f__result_integer=s__BurnBuffer_create(f__arg_unit1,f__arg_integer1,f__arg_unit2,f__arg_real1)
   return true
endfunction
function sa__HorroBuffer_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__Material_horro[s__Material__staticgetindex(s__IBufferStruct_u[this])]=true
        set s__HorroBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl", s__IBufferStruct_u[this], "origin")
        call HorrorMove(s__IBufferStruct_u[this])
        call UnitAddAbility(s__IBufferStruct_u[this], aBAN_ATTACK)
        call DisableAllAbi(s__IBufferStruct_u[this])
   return true
endfunction
function sa__HorroBuffer_action takes nothing returns boolean
local integer this=f__arg_this
        if ModuloInteger(s__IBufferStruct_count[this], 100) == 0 then
            call HorrorMove(s__IBufferStruct_u[this])
        endif
   return true
endfunction
function sa__HorroBuffer_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__Material_horro[s__Material__staticgetindex(s__IBufferStruct_u[this])]=false
        set s__HorroBuffer_source[this]=null
        call DestroyEffect(s__HorroBuffer_e[this])
        call UnitRemoveAbility(s__IBufferStruct_u[this], aBAN_ATTACK)
        call EnableAllAbi(s__IBufferStruct_u[this])
        set s__HorroBuffer_e[this]=null
   return true
endfunction
function sa__HorroBuffer_create takes nothing returns boolean
    set f__result_integer=s__HorroBuffer_create(f__arg_unit1,f__arg_unit2,f__arg_integer1)
   return true
endfunction
function sa__BleedBuffer_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        local integer bleedlv= s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]
        set s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=bleedlv + 1
        set s__BleedBuffer_e[this]=AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl", s__IBufferStruct_u[this], "chest")
   return true
endfunction
function sa__BleedBuffer_action takes nothing returns boolean
local integer this=f__arg_this
        if ModuloInteger(s__IBufferStruct_count[this], 25) == 0 then
            call NormalDamage(s__BleedBuffer_source[this] , s__IBufferStruct_u[this] , s__BleedBuffer_dam[this])
        endif
   return true
endfunction
function sa__BleedBuffer_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        set s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])]=s__Material_bleedlv[s__Material__staticgetindex(s__IBufferStruct_u[this])] - 1
        set s__BleedBuffer_source[this]=null
        call DestroyEffect(s__BleedBuffer_e[this])
        set s__BleedBuffer_e[this]=null
   return true
endfunction
function sa__BleedBuffer_create takes nothing returns boolean
    set f__result_integer=s__BleedBuffer_create(f__arg_unit1,f__arg_integer1,f__arg_unit2,f__arg_real1)
   return true
endfunction
function sa__IceSlowBuffer_addBuffer takes nothing returns boolean
local integer this=f__arg_this
        call s__Status_addStun(s__Status__staticgetindex(s__IBufferStruct_u[this]))
        set s__IceSlowBuffer_e[this]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl", s__IBufferStruct_u[this], "origin")
   return true
endfunction
function sa__IceSlowBuffer_removeBuffer takes nothing returns boolean
local integer this=f__arg_this
        call s__Status_removeStun(s__Status__staticgetindex(s__IBufferStruct_u[this]))
        call DestroyEffect(s__IceSlowBuffer_e[this])
        set s__IceSlowBuffer_e[this]=null
   return true
endfunction
function sa___prototype37_s__TableArray_clean takes nothing returns boolean
 local integer tb=f__arg_integer1
 local integer end=f__arg_integer2

        local integer i= tb + 4096
        if ( i < end ) then
            call s__TableArray_clean(i , end)
            set end=i
        endif
        loop
            call s__Table_flush(tb)
            set tb=tb + 1
            exitwhen (tb) == end
        endloop
    return true
endfunction
function sa___prototype1_s__ItemJump_create takes nothing returns boolean

            local integer this=s__ItemJump__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ItemJump__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ItemJump_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__Jump_create takes nothing returns boolean

            local integer this=s__Jump__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__Jump__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Jump_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__InjectionSpeedUp_create takes nothing returns boolean

            local integer this=s__InjectionSpeedUp__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__InjectionSpeedUp__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__InjectionSpeedUp_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__Darts_create takes nothing returns boolean

            local integer this=s__Darts__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__Darts__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Darts_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__ReturnDartsSpell_create takes nothing returns boolean

            local integer this=s__ReturnDartsSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ReturnDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ReturnDartsSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__SmartDartsSpell_create takes nothing returns boolean

            local integer this=s__SmartDartsSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__SmartDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__SmartDartsSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__ShoulderCannonSpell_create takes nothing returns boolean

            local integer this=s__ShoulderCannonSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ShoulderCannonSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ShoulderCannonSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__ItemReturnDartsSpell_create takes nothing returns boolean

            local integer this=s__ItemReturnDartsSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ItemReturnDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ItemReturnDartsSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__LeaveDartsSpell_create takes nothing returns boolean

            local integer this=s__LeaveDartsSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__LeaveDartsSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__LeaveDartsSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__BackGrenadeSpell_create takes nothing returns boolean

            local integer this=s__BackGrenadeSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__BackGrenadeSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__BackGrenadeSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__MineSpell_create takes nothing returns boolean

            local integer this=s__MineSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__MineSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__MineSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__PushGrenadeSpell_create takes nothing returns boolean

            local integer this=s__PushGrenadeSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__PushGrenadeSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__PushGrenadeSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__Blink_create takes nothing returns boolean

            local integer this=s__Blink__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__Blink__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Blink_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__Transport_create takes nothing returns boolean

            local integer this=s__Transport__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__Transport__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__Transport_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__ElectricWhipSpell_create takes nothing returns boolean

            local integer this=s__ElectricWhipSpell__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ElectricWhipSpell__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ElectricWhipSpell_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__AutoAim_create takes nothing returns boolean

            local integer this=s__AutoAim__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__AutoAim__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__AutoAim_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction
function sa___prototype1_s__ShootBack_create takes nothing returns boolean

            local integer this=s__ShootBack__allocate()
            call s__SpellStruct__set_autoDestroy(this,s__ShootBack__get_autoDestroyDefault())
            set s__SpellStruct_aoe[this]=s__ShootBack_defaultAoE
                call sc__SpellStruct__DefaultsInterface_onCreate(this) // in case of thread terminate
    set f__result_integer= this
    return true
endfunction

function jasshelper__initstructs38273971 takes nothing returns nothing
    set st__AII___ItemStruct_onDeath=CreateTrigger()
    call TriggerAddCondition(st__AII___ItemStruct_onDeath,Condition( function sa__AII___ItemStruct_onDeath))
    set st__AII___ItemStruct_manageLock=CreateTrigger()
    call TriggerAddCondition(st__AII___ItemStruct_manageLock,Condition( function sa__AII___ItemStruct_manageLock))
    set st__Event_Event__destroyNode=CreateTrigger()
    call TriggerAddCondition(st__Event_Event__destroyNode,Condition( function sa__Event_Event__destroyNode))
    set st__Material__staticgetindex=CreateTrigger()
    call TriggerAddCondition(st__Material__staticgetindex,Condition( function sa__Material__staticgetindex))
    set st__Material_AIDS_filter=CreateTrigger()
    call TriggerAddCondition(st__Material_AIDS_filter,Condition( function sa__Material_AIDS_filter))
    set st__Material_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__Material_AIDS_onCreate,Condition( function sa__Material_AIDS_onCreate))
    set st__Material_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__Material_AIDS_onDestroy,Condition( function sa__Material_AIDS_onDestroy))
    set st__IMissleFactory_createMissle[16]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[16],Condition( function sa__SmartDartsFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[16], function sa__SmartDartsFactory_createMissle)
    set st__IMissleFactory_onDestroy[16]=null
    set st__IMissleFactory_createMissle[17]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[17],Condition( function sa__DefaultMissleFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[17], function sa__DefaultMissleFactory_createMissle)
    set st__IMissleFactory_onDestroy[17]=null
    set st__IMissleFactory_createMissle[18]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[18],Condition( function sa__ShootGunMissleFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[18], function sa__ShootGunMissleFactory_createMissle)
    set st__IMissleFactory_onDestroy[18]=null
    set st__IMissleFactory_createMissle[19]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[19],Condition( function sa__SmallDartsFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[19], function sa__SmallDartsFactory_createMissle)
    set st__IMissleFactory_onDestroy[19]=null
    set st__IMissleFactory_createMissle[20]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[20],Condition( function sa__ReturnDartsFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[20], function sa__ReturnDartsFactory_createMissle)
    set st__IMissleFactory_onDestroy[20]=null
    set st__IMissleFactory_createMissle[21]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[21],Condition( function sa__LeaveDartsFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[21], function sa__LeaveDartsFactory_createMissle)
    set st__IMissleFactory_onDestroy[21]=null
    set st__IMissleFactory_createMissle[22]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[22],Condition( function sa__IceMissleFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[22], function sa__IceMissleFactory_createMissle)
    set st__IMissleFactory_onDestroy[22]=null
    set st__IMissleFactory_createMissle[23]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[23],Condition( function sa__FireMissleFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[23], function sa__FireMissleFactory_createMissle)
    set st__IMissleFactory_onDestroy[23]=null
    set st__Velocity__staticgetindex=CreateTrigger()
    call TriggerAddCondition(st__Velocity__staticgetindex,Condition( function sa__Velocity__staticgetindex))
    set st__Velocity_AIDS_filter=CreateTrigger()
    call TriggerAddCondition(st__Velocity_AIDS_filter,Condition( function sa__Velocity_AIDS_filter))
    set st__Velocity_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__Velocity_AIDS_onCreate,Condition( function sa__Velocity_AIDS_onCreate))
    set st__Velocity_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__Velocity_AIDS_onDestroy,Condition( function sa__Velocity_AIDS_onDestroy))
    set st__Velocity_periodic=CreateTrigger()
    call TriggerAddCondition(st__Velocity_periodic,Condition( function sa__Velocity_periodic))
    set st__VelocityUnit_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__VelocityUnit_onDestroy,Condition( function sa__VelocityUnit_onDestroy))
    set st__VelocityUnit_loopMoveAllMissles=CreateTrigger()
    call TriggerAddCondition(st__VelocityUnit_loopMoveAllMissles,Condition( function sa__VelocityUnit_loopMoveAllMissles))
    set st__IMissleFactory_createMissle[24]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[24],Condition( function sa__ElectricWhipFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[24], function sa__ElectricWhipFactory_createMissle)
    set st__IMissleFactory_onDestroy[24]=null
    set st__IMissleFactory_createMissle[25]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[25],Condition( function sa__BackGrenadeFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[25], function sa__BackGrenadeFactory_createMissle)
    set st__IMissleFactory_onDestroy[25]=null
    set st__IMissleFactory_createMissle[26]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[26],Condition( function sa__PushGrenadeFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[26], function sa__PushGrenadeFactory_createMissle)
    set st__IMissleFactory_onDestroy[26]=null
    set st__IMissleFactory_createMissle[27]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[27],Condition( function sa__MineFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[27], function sa__MineFactory_createMissle)
    set st__IMissleFactory_onDestroy[27]=null
    set st__IMissleFactory_createMissle[28]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[28],Condition( function sa__ShoulderCannonFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[28], function sa__ShoulderCannonFactory_createMissle)
    set st__IMissleFactory_onDestroy[28]=null
    set st__IMissleFactory_createMissle[29]=CreateTrigger()
    call TriggerAddCondition(st__IMissleFactory_createMissle[29],Condition( function sa__SpearMissleFactory_createMissle))
    call TriggerAddAction(st__IMissleFactory_createMissle[29], function sa__SpearMissleFactory_createMissle)
    set st__IMissleFactory_onDestroy[29]=null
    set st__DefaultTypeData_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultTypeData_create,Condition( function sa__DefaultTypeData_create))
    set st__IMonsterTypeData_getTypeId[31]=CreateTrigger()
    call TriggerAddCondition(st__IMonsterTypeData_getTypeId[31],Condition( function sa__DefaultTypeData_getTypeId))
    call TriggerAddAction(st__IMonsterTypeData_getTypeId[31], function sa__DefaultTypeData_getTypeId)
    set st__IMonsterTypeData_getDeadGold[31]=CreateTrigger()
    call TriggerAddCondition(st__IMonsterTypeData_getDeadGold[31],Condition( function sa__DefaultTypeData_getDeadGold))
    call TriggerAddAction(st__IMonsterTypeData_getDeadGold[31], function sa__DefaultTypeData_getDeadGold)
    set st__IMonsterTypeData_getDeadWood[31]=CreateTrigger()
    call TriggerAddCondition(st__IMonsterTypeData_getDeadWood[31],Condition( function sa__DefaultTypeData_getDeadWood))
    call TriggerAddAction(st__IMonsterTypeData_getDeadWood[31], function sa__DefaultTypeData_getDeadWood)
    set st__IMonsterTypeData_onDestroy[31]=CreateTrigger()
    call TriggerAddCondition(st__IMonsterTypeData_onDestroy[31],Condition( function sa__DefaultTypeData_onDestroy))
    set st__MonsterTargetGroupManager_create=CreateTrigger()
    call TriggerAddCondition(st__MonsterTargetGroupManager_create,Condition( function sa__MonsterTargetGroupManager_create))
    set st__MonsterTargetGroupManager_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__MonsterTargetGroupManager_onDestroy,Condition( function sa__MonsterTargetGroupManager_onDestroy))
    set st__MonsterTargetGroupManager_periodic=CreateTrigger()
    call TriggerAddCondition(st__MonsterTargetGroupManager_periodic,Condition( function sa__MonsterTargetGroupManager_periodic))
    set st__AIData__staticgetindex=CreateTrigger()
    call TriggerAddCondition(st__AIData__staticgetindex,Condition( function sa__AIData__staticgetindex))
    set st__AIData_AIDS_filter=CreateTrigger()
    call TriggerAddCondition(st__AIData_AIDS_filter,Condition( function sa__AIData_AIDS_filter))
    set st__AIData_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__AIData_AIDS_onCreate,Condition( function sa__AIData_AIDS_onCreate))
    set st__AIData_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__AIData_AIDS_onDestroy,Condition( function sa__AIData_AIDS_onDestroy))
    set st__RealMan_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__RealMan_onDestroy,Condition( function sa__RealMan_onDestroy))
    set st__Status__get_unit=CreateTrigger()
    call TriggerAddCondition(st__Status__get_unit,Condition( function sa__Status__get_unit))
    set st__Status_stopPeriodic=CreateTrigger()
    call TriggerAddCondition(st__Status_stopPeriodic,Condition( function sa__Status_stopPeriodic))
    set st__SpellStruct__DefaultsInterface_onCreate[100]=null
    set st__SpellStruct__DefaultsInterface_onCreate[150]=null
    set st__SpellStruct__DefaultsInterface_onCreate[151]=null
    set st__SpellStruct__DefaultsInterface_onCreate[152]=null
    set st__SpellStruct__DefaultsInterface_onCreate[153]=null
    set st__SpellStruct__DefaultsInterface_onCreate[154]=null
    set st__SpellStruct__DefaultsInterface_onCreate[155]=null
    set st__SpellStruct__DefaultsInterface_onCreate[156]=null
    set st__SpellStruct__DefaultsInterface_onCreate[157]=null
    set st__SpellStruct__DefaultsInterface_onCreate[158]=null
    set st__SpellStruct__DefaultsInterface_onCreate[159]=null
    set st__SpellStruct__DefaultsInterface_onCreate[160]=null
    set st__SpellStruct__DefaultsInterface_onCreate[161]=null
    set st__SpellStruct__DefaultsInterface_onCreate[162]=null
    set st__SpellStruct__DefaultsInterface_onCreate[163]=null
    set st__SpellStruct__DefaultsInterface_onCreate[164]=null
    set st__SpellStruct__DefaultsInterface_onCreate[165]=null
    set st__SpellStruct__DefaultsInterface_onCreate[166]=null
    set st__SpellStruct__DefaultsInterface_onChannel[100]=null
    set st__SpellStruct__DefaultsInterface_onChannel[163]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[100]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[150]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[151]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[152]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[153]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[154]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[155]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[156]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[157]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[158]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[159]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[160]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[161]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[162]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[163]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[164]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[165]=null
    set st__SpellStruct__DefaultsInterface_onStartCast[166]=null
    set st__SpellStruct__DefaultsInterface_onEffect[100]=null
    set st__SpellStruct__DefaultsInterface_onEffect[150]=null
    set st__SpellStruct__DefaultsInterface_onEffect[151]=null
    set st__SpellStruct__DefaultsInterface_onEffect[152]=null
    set st__SpellStruct__DefaultsInterface_onEffect[153]=null
    set st__SpellStruct__DefaultsInterface_onEffect[154]=null
    set st__SpellStruct__DefaultsInterface_onEffect[155]=null
    set st__SpellStruct__DefaultsInterface_onEffect[156]=null
    set st__SpellStruct__DefaultsInterface_onEffect[157]=null
    set st__SpellStruct__DefaultsInterface_onEffect[158]=null
    set st__SpellStruct__DefaultsInterface_onEffect[159]=null
    set st__SpellStruct__DefaultsInterface_onEffect[160]=null
    set st__SpellStruct__DefaultsInterface_onEffect[161]=null
    set st__SpellStruct__DefaultsInterface_onEffect[162]=null
    set st__SpellStruct__DefaultsInterface_onEffect[163]=null
    set st__SpellStruct__DefaultsInterface_onEffect[164]=null
    set st__SpellStruct__DefaultsInterface_onEffect[165]=null
    set st__SpellStruct__DefaultsInterface_onEffect[166]=null
    set st__SpellStruct__DefaultsInterface_onFinish[100]=null
    set st__SpellStruct__DefaultsInterface_onFinish[150]=null
    set st__SpellStruct__DefaultsInterface_onFinish[151]=null
    set st__SpellStruct__DefaultsInterface_onFinish[152]=null
    set st__SpellStruct__DefaultsInterface_onFinish[153]=null
    set st__SpellStruct__DefaultsInterface_onFinish[154]=null
    set st__SpellStruct__DefaultsInterface_onFinish[155]=null
    set st__SpellStruct__DefaultsInterface_onFinish[156]=null
    set st__SpellStruct__DefaultsInterface_onFinish[157]=null
    set st__SpellStruct__DefaultsInterface_onFinish[158]=null
    set st__SpellStruct__DefaultsInterface_onFinish[159]=null
    set st__SpellStruct__DefaultsInterface_onFinish[160]=null
    set st__SpellStruct__DefaultsInterface_onFinish[161]=null
    set st__SpellStruct__DefaultsInterface_onFinish[162]=null
    set st__SpellStruct__DefaultsInterface_onFinish[164]=null
    set st__SpellStruct__DefaultsInterface_onFinish[165]=null
    set st__SpellStruct__DefaultsInterface_onFinish[166]=null
    set st__SpellStruct__DefaultsInterface_onStopCast[100]=null
    set st__SpellStruct__DefaultsInterface_onStopCast[162]=null
    set st__SpellStruct__DefaultsInterface_onStopCast[163]=null
    set st__SpellStruct__DefaultsInterface_onStopCast[165]=null
    set st__SpellStruct__DefaultsInterface_cleanup[100]=null
    set st__ItemFeatureData_construct=CreateTrigger()
    call TriggerAddCondition(st__ItemFeatureData_construct,Condition( function sa__ItemFeatureData_construct))
    set st__IndividualItemData__get_item=CreateTrigger()
    call TriggerAddCondition(st__IndividualItemData__get_item,Condition( function sa__IndividualItemData__get_item))
    set st__EquipmentData__staticgetindex=CreateTrigger()
    call TriggerAddCondition(st__EquipmentData__staticgetindex,Condition( function sa__EquipmentData__staticgetindex))
    set st__EquipmentData_AIDS_filter=CreateTrigger()
    call TriggerAddCondition(st__EquipmentData_AIDS_filter,Condition( function sa__EquipmentData_AIDS_filter))
    set st__EquipmentData_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__EquipmentData_AIDS_onCreate,Condition( function sa__EquipmentData_AIDS_onCreate))
    set st__EquipmentData_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__EquipmentData_AIDS_onDestroy,Condition( function sa__EquipmentData_AIDS_onDestroy))
    set st__EquipmentData_periodic=CreateTrigger()
    call TriggerAddCondition(st__EquipmentData_periodic,Condition( function sa__EquipmentData_periodic))
    set st__Damage__Detector_AIDS_onCreate=CreateTrigger()
    call TriggerAddCondition(st__Damage__Detector_AIDS_onCreate,Condition( function sa__Damage__Detector_AIDS_onCreate))
    set st__Damage__Detector_AIDS_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__Damage__Detector_AIDS_onDestroy,Condition( function sa__Damage__Detector_AIDS_onDestroy))
    set st__Damage__Detector_AIDS_onInit=CreateTrigger()
    call TriggerAddCondition(st__Damage__Detector_AIDS_onInit,Condition( function sa__Damage__Detector_AIDS_onInit))
    set st__vector_setLength=CreateTrigger()
    call TriggerAddCondition(st__vector_setLength,Condition( function sa__vector_setLength))
    set st__IShooter_tick[140]=CreateTrigger()
    set st__IShooter_tick[141]=st__IShooter_tick[140]
    set st__IShooter_tick[143]=st__IShooter_tick[140]
    set st__IShooter_tick[144]=st__IShooter_tick[140]
    set st__IShooter_tick[145]=st__IShooter_tick[140]
    set st__IShooter_tick[146]=st__IShooter_tick[145]
    set st__IShooter_tick[147]=st__IShooter_tick[145]
    call TriggerAddCondition(st__IShooter_tick[140],Condition( function sa__AbstractShooter_tick))
    call TriggerAddAction(st__IShooter_tick[140], function sa__AbstractShooter_tick)
    set st__AbstractShooter_periodic=CreateTrigger()
    call TriggerAddCondition(st__AbstractShooter_periodic,Condition( function sa__AbstractShooter_periodic))
    set st__AbstractShooter_create=CreateTrigger()
    call TriggerAddCondition(st__AbstractShooter_create,Condition( function sa__AbstractShooter_create))
    set st__IShooter_shoothz[140]=CreateTrigger()
    set st__IShooter_shoothz[141]=st__IShooter_shoothz[140]
    set st__IShooter_shoothz[142]=st__IShooter_shoothz[140]
    set st__IShooter_shoothz[143]=st__IShooter_shoothz[140]
    set st__IShooter_shoothz[144]=st__IShooter_shoothz[140]
    set st__IShooter_shoothz[145]=st__IShooter_shoothz[140]
    set st__IShooter_shoothz[146]=st__IShooter_shoothz[145]
    call TriggerAddCondition(st__IShooter_shoothz[140],Condition( function sa__AbstractShooter_shoothz))
    call TriggerAddAction(st__IShooter_shoothz[140], function sa__AbstractShooter_shoothz)
    set st__IShooter_getClipSize[140]=CreateTrigger()
    set st__IShooter_getClipSize[141]=st__IShooter_getClipSize[140]
    set st__IShooter_getClipSize[142]=st__IShooter_getClipSize[140]
    set st__IShooter_getClipSize[143]=st__IShooter_getClipSize[140]
    set st__IShooter_getClipSize[144]=st__IShooter_getClipSize[140]
    set st__IShooter_getClipSize[145]=st__IShooter_getClipSize[140]
    set st__IShooter_getClipSize[146]=st__IShooter_getClipSize[145]
    call TriggerAddCondition(st__IShooter_getClipSize[140],Condition( function sa__AbstractShooter_getClipSize))
    call TriggerAddAction(st__IShooter_getClipSize[140], function sa__AbstractShooter_getClipSize)
    set st__IShooter_shootCount[140]=CreateTrigger()
    set st__IShooter_shootCount[141]=st__IShooter_shootCount[140]
    set st__IShooter_shootCount[142]=st__IShooter_shootCount[140]
    set st__IShooter_shootCount[143]=st__IShooter_shootCount[140]
    set st__IShooter_shootCount[144]=st__IShooter_shootCount[140]
    set st__IShooter_shootCount[145]=st__IShooter_shootCount[140]
    set st__IShooter_shootCount[147]=st__IShooter_shootCount[145]
    call TriggerAddCondition(st__IShooter_shootCount[140],Condition( function sa__AbstractShooter_shootCount))
    call TriggerAddAction(st__IShooter_shootCount[140], function sa__AbstractShooter_shootCount)
    set st__IShooter_getRist[140]=CreateTrigger()
    set st__IShooter_getRist[141]=st__IShooter_getRist[140]
    set st__IShooter_getRist[142]=st__IShooter_getRist[140]
    set st__IShooter_getRist[143]=st__IShooter_getRist[140]
    set st__IShooter_getRist[144]=st__IShooter_getRist[140]
    set st__IShooter_getRist[145]=st__IShooter_getRist[140]
    set st__IShooter_getRist[147]=st__IShooter_getRist[145]
    call TriggerAddCondition(st__IShooter_getRist[140],Condition( function sa__AbstractShooter_getRist))
    call TriggerAddAction(st__IShooter_getRist[140], function sa__AbstractShooter_getRist)
    set st__IShooter_getOriginSpeed[140]=CreateTrigger()
    set st__IShooter_getOriginSpeed[141]=st__IShooter_getOriginSpeed[140]
    set st__IShooter_getOriginSpeed[142]=st__IShooter_getOriginSpeed[140]
    set st__IShooter_getOriginSpeed[143]=st__IShooter_getOriginSpeed[140]
    set st__IShooter_getOriginSpeed[144]=st__IShooter_getOriginSpeed[140]
    set st__IShooter_getOriginSpeed[145]=st__IShooter_getOriginSpeed[140]
    set st__IShooter_getOriginSpeed[147]=st__IShooter_getOriginSpeed[145]
    call TriggerAddCondition(st__IShooter_getOriginSpeed[140],Condition( function sa__AbstractShooter_getOriginSpeed))
    call TriggerAddAction(st__IShooter_getOriginSpeed[140], function sa__AbstractShooter_getOriginSpeed)
    set st__IShooter_shoot[140]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoot[140],Condition( function sa__AbstractShooter_shoot))
    call TriggerAddAction(st__IShooter_shoot[140], function sa__AbstractShooter_shoot)
    set st__IShooter_getEnergyConsume[140]=CreateTrigger()
    set st__IShooter_getEnergyConsume[141]=st__IShooter_getEnergyConsume[140]
    set st__IShooter_getEnergyConsume[142]=st__IShooter_getEnergyConsume[140]
    set st__IShooter_getEnergyConsume[143]=st__IShooter_getEnergyConsume[140]
    set st__IShooter_getEnergyConsume[144]=st__IShooter_getEnergyConsume[140]
    call TriggerAddCondition(st__IShooter_getEnergyConsume[140],Condition( function sa__AbstractShooter_getEnergyConsume))
    call TriggerAddAction(st__IShooter_getEnergyConsume[140], function sa__AbstractShooter_getEnergyConsume)
    set st__IShooter_subshoot[140]=CreateTrigger()
    set st__IShooter_subshoot[141]=st__IShooter_subshoot[140]
    set st__IShooter_subshoot[142]=st__IShooter_subshoot[140]
    set st__IShooter_subshoot[143]=st__IShooter_subshoot[140]
    set st__IShooter_subshoot[144]=st__IShooter_subshoot[140]
    call TriggerAddCondition(st__IShooter_subshoot[140],Condition( function sa__AbstractShooter_subshoot))
    call TriggerAddAction(st__IShooter_subshoot[140], function sa__AbstractShooter_subshoot)
    set st__IShooter_onDestroy[140]=CreateTrigger()
    set st__IShooter_onDestroy[141]=st__IShooter_onDestroy[140]
    set st__IShooter_onDestroy[142]=st__IShooter_onDestroy[140]
    set st__IShooter_onDestroy[143]=st__IShooter_onDestroy[140]
    set st__IShooter_onDestroy[144]=st__IShooter_onDestroy[140]
    set st__IShooter_onDestroy[145]=st__IShooter_onDestroy[140]
    set st__IShooter_onDestroy[146]=st__IShooter_onDestroy[145]
    set st__IShooter_onDestroy[147]=st__IShooter_onDestroy[145]
    call TriggerAddCondition(st__IShooter_onDestroy[140],Condition( function sa__AbstractShooter_onDestroy))
    set st__DefaultAIStrategy_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultAIStrategy_create,Condition( function sa__DefaultAIStrategy_create))
    set st__IAIStrategy_support[81]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_support[81],Condition( function sa__DefaultAIStrategy_support))
    call TriggerAddAction(st__IAIStrategy_support[81], function sa__DefaultAIStrategy_support)
    set st__IAIStrategy_targetInRange[81]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_targetInRange[81],Condition( function sa__DefaultAIStrategy_targetInRange))
    call TriggerAddAction(st__IAIStrategy_targetInRange[81], function sa__DefaultAIStrategy_targetInRange)
    set st__IAIStrategy_targetOutRange[81]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_targetOutRange[81],Condition( function sa__DefaultAIStrategy_targetOutRange))
    call TriggerAddAction(st__IAIStrategy_targetOutRange[81], function sa__DefaultAIStrategy_targetOutRange)
    set st__IAIStrategy_beHurted[81]=CreateTrigger()
    set st__IAIStrategy_beHurted[82]=st__IAIStrategy_beHurted[81]
    call TriggerAddCondition(st__IAIStrategy_beHurted[81],Condition( function sa__DefaultAIStrategy_beHurted))
    call TriggerAddAction(st__IAIStrategy_beHurted[81], function sa__DefaultAIStrategy_beHurted)
    set st__IAIStrategy_getInMap[81]=CreateTrigger()
    set st__IAIStrategy_getInMap[82]=st__IAIStrategy_getInMap[81]
    call TriggerAddCondition(st__IAIStrategy_getInMap[81],Condition( function sa__DefaultAIStrategy_getInMap))
    call TriggerAddAction(st__IAIStrategy_getInMap[81], function sa__DefaultAIStrategy_getInMap)
    set st__IAIStrategy_onDestroy[81]=CreateTrigger()
    set st__IAIStrategy_onDestroy[82]=st__IAIStrategy_onDestroy[81]
    call TriggerAddCondition(st__IAIStrategy_onDestroy[81],Condition( function sa__DefaultAIStrategy_onDestroy))
    set st__IAIStrategy_targetInRange[82]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_targetInRange[82],Condition( function sa__Boss1AIStrategy_targetInRange))
    call TriggerAddAction(st__IAIStrategy_targetInRange[82], function sa__Boss1AIStrategy_targetInRange)
    set st__IAIStrategy_targetOutRange[82]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_targetOutRange[82],Condition( function sa__Boss1AIStrategy_targetOutRange))
    call TriggerAddAction(st__IAIStrategy_targetOutRange[82], function sa__Boss1AIStrategy_targetOutRange)
    set st__IAIStrategy_support[82]=CreateTrigger()
    call TriggerAddCondition(st__IAIStrategy_support[82],Condition( function sa__Boss1AIStrategy_support))
    call TriggerAddAction(st__IAIStrategy_support[82], function sa__Boss1AIStrategy_support)
    set st__IGun_fire[86]=CreateTrigger()
    set st__IGun_fire[87]=st__IGun_fire[86]
    set st__IGun_fire[88]=st__IGun_fire[86]
    set st__IGun_fire[89]=st__IGun_fire[86]
    set st__IGun_fire[90]=st__IGun_fire[86]
    set st__IGun_fire[91]=st__IGun_fire[86]
    call TriggerAddCondition(st__IGun_fire[86],Condition( function sa__DefaultGun_fire))
    call TriggerAddAction(st__IGun_fire[86], function sa__DefaultGun_fire)
    set st__IGun_setOwner[86]=CreateTrigger()
    set st__IGun_setOwner[87]=st__IGun_setOwner[86]
    set st__IGun_setOwner[88]=st__IGun_setOwner[86]
    set st__IGun_setOwner[89]=st__IGun_setOwner[86]
    set st__IGun_setOwner[90]=st__IGun_setOwner[86]
    set st__IGun_setOwner[91]=st__IGun_setOwner[86]
    call TriggerAddCondition(st__IGun_setOwner[86],Condition( function sa__DefaultGun_setOwner))
    call TriggerAddAction(st__IGun_setOwner[86], function sa__DefaultGun_setOwner)
    set st__IGun_stopFire[86]=CreateTrigger()
    set st__IGun_stopFire[87]=st__IGun_stopFire[86]
    set st__IGun_stopFire[88]=st__IGun_stopFire[86]
    set st__IGun_stopFire[89]=st__IGun_stopFire[86]
    set st__IGun_stopFire[90]=st__IGun_stopFire[86]
    set st__IGun_stopFire[91]=st__IGun_stopFire[86]
    call TriggerAddCondition(st__IGun_stopFire[86],Condition( function sa__DefaultGun_stopFire))
    call TriggerAddAction(st__IGun_stopFire[86], function sa__DefaultGun_stopFire)
    set st__IGun_getGunType[86]=CreateTrigger()
    set st__IGun_getGunType[87]=st__IGun_getGunType[86]
    set st__IGun_getGunType[88]=st__IGun_getGunType[86]
    set st__IGun_getGunType[89]=st__IGun_getGunType[86]
    set st__IGun_getGunType[90]=st__IGun_getGunType[86]
    set st__IGun_getGunType[91]=st__IGun_getGunType[86]
    call TriggerAddCondition(st__IGun_getGunType[86],Condition( function sa__DefaultGun_getGunType))
    call TriggerAddAction(st__IGun_getGunType[86], function sa__DefaultGun_getGunType)
    set st__DefaultGun_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultGun_create,Condition( function sa__DefaultGun_create))
    set st__IGun_onDestroy[86]=CreateTrigger()
    set st__IGun_onDestroy[87]=st__IGun_onDestroy[86]
    set st__IGun_onDestroy[88]=st__IGun_onDestroy[86]
    set st__IGun_onDestroy[89]=st__IGun_onDestroy[86]
    set st__IGun_onDestroy[90]=st__IGun_onDestroy[86]
    set st__IGun_onDestroy[91]=st__IGun_onDestroy[86]
    call TriggerAddCondition(st__IGun_onDestroy[86],Condition( function sa__DefaultGun_onDestroy))
    set st__SpellStruct__get_isNotLocked=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__get_isNotLocked,Condition( function sa__SpellStruct__get_isNotLocked))
    set st__SpellStruct__get_casterX=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__get_casterX,Condition( function sa__SpellStruct__get_casterX))
    set st__SpellStruct__get_casterY=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__get_casterY,Condition( function sa__SpellStruct__get_casterY))
    set st__SpellStruct_create=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct_create,Condition( function sa__SpellStruct_create))
    set st__SpellStruct_destroy=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct_destroy,Condition( function sa__SpellStruct_destroy))
    set st__SpellStruct__DefaultsInterface_onDestroy[100]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[150]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[151]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[152]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[153]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[154]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[155]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[156]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[157]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[158]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[159]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[160]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[161]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[162]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[163]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[164]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[165]=null
    set st__SpellStruct__DefaultsInterface_onDestroy[166]=null
    set st__DefaultAIGroup_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultAIGroup_create,Condition( function sa__DefaultAIGroup_create))
    set st__IAIGroup_shouldLoop[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_shouldLoop[106],Condition( function sa__DefaultAIGroup_shouldLoop))
    call TriggerAddAction(st__IAIGroup_shouldLoop[106], function sa__DefaultAIGroup_shouldLoop)
    set st__IAIGroup_afterLoop[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_afterLoop[106],Condition( function sa__DefaultAIGroup_afterLoop))
    call TriggerAddAction(st__IAIGroup_afterLoop[106], function sa__DefaultAIGroup_afterLoop)
    set st__IAIGroup_getInterval[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_getInterval[106],Condition( function sa__DefaultAIGroup_getInterval))
    call TriggerAddAction(st__IAIGroup_getInterval[106], function sa__DefaultAIGroup_getInterval)
    set st__IAIGroup_ailoop[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_ailoop[106],Condition( function sa__DefaultAIGroup_ailoop))
    call TriggerAddAction(st__IAIGroup_ailoop[106], function sa__DefaultAIGroup_ailoop)
    set st__DefaultAIGroup_periodic=CreateTrigger()
    call TriggerAddCondition(st__DefaultAIGroup_periodic,Condition( function sa__DefaultAIGroup_periodic))
    set st__IAIGroup_addUnit[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_addUnit[106],Condition( function sa__DefaultAIGroup_addUnit))
    call TriggerAddAction(st__IAIGroup_addUnit[106], function sa__DefaultAIGroup_addUnit)
    set st__IAIGroup_removeUnit[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_removeUnit[106],Condition( function sa__DefaultAIGroup_removeUnit))
    call TriggerAddAction(st__IAIGroup_removeUnit[106], function sa__DefaultAIGroup_removeUnit)
    set st__IAIGroup_onDestroy[106]=CreateTrigger()
    call TriggerAddCondition(st__IAIGroup_onDestroy[106],Condition( function sa__DefaultAIGroup_onDestroy))
    set st__DefaultDialog_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultDialog_create,Condition( function sa__DefaultDialog_create))
    set st__IDialog_button_clicked[109]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[109],Condition( function sa__DefaultDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[109], function sa__DefaultDialog_button_clicked)
    set st__IDialog_init[109]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_init[109],Condition( function sa__DefaultDialog_init))
    call TriggerAddAction(st__IDialog_init[109], function sa__DefaultDialog_init)
    set st__IDialog_display[109]=CreateTrigger()
    set st__IDialog_display[110]=st__IDialog_display[109]
    set st__IDialog_display[111]=st__IDialog_display[109]
    set st__IDialog_display[112]=st__IDialog_display[109]
    set st__IDialog_display[113]=st__IDialog_display[112]
    call TriggerAddCondition(st__IDialog_display[109],Condition( function sa__DefaultDialog_display))
    call TriggerAddAction(st__IDialog_display[109], function sa__DefaultDialog_display)
    set st__IDialog_onDestroy[109]=CreateTrigger()
    set st__IDialog_onDestroy[110]=st__IDialog_onDestroy[109]
    set st__IDialog_onDestroy[111]=st__IDialog_onDestroy[109]
    set st__IDialog_onDestroy[112]=st__IDialog_onDestroy[109]
    set st__IDialog_onDestroy[113]=st__IDialog_onDestroy[112]
    set st__IDialog_onDestroy[115]=st__IDialog_onDestroy[109]
    set st__IDialog_onDestroy[116]=st__IDialog_onDestroy[109]
    call TriggerAddCondition(st__IDialog_onDestroy[109],Condition( function sa__DefaultDialog_onDestroy))
    set st__ChangeAbDialog_create=CreateTrigger()
    call TriggerAddCondition(st__ChangeAbDialog_create,Condition( function sa__ChangeAbDialog_create))
    set st__IDialog_button_clicked[110]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[110],Condition( function sa__ChangeAbDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[110], function sa__ChangeAbDialog_button_clicked)
    set st__IDialog_init[110]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_init[110],Condition( function sa__ChangeAbDialog_init))
    call TriggerAddAction(st__IDialog_init[110], function sa__ChangeAbDialog_init)
    set st__ChangeGunDialog_create=CreateTrigger()
    call TriggerAddCondition(st__ChangeGunDialog_create,Condition( function sa__ChangeGunDialog_create))
    set st__IDialog_button_clicked[111]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[111],Condition( function sa__ChangeGunDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[111], function sa__ChangeGunDialog_button_clicked)
    set st__IDialog_init[111]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_init[111],Condition( function sa__ChangeGunDialog_init))
    call TriggerAddAction(st__IDialog_init[111], function sa__ChangeGunDialog_init)
    set st__TransformDialog_create=CreateTrigger()
    call TriggerAddCondition(st__TransformDialog_create,Condition( function sa__TransformDialog_create))
    set st__IDialog_button_clicked[112]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[112],Condition( function sa__TransformDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[112], function sa__TransformDialog_button_clicked)
    set st__IDialog_init[112]=CreateTrigger()
    set st__IDialog_init[113]=st__IDialog_init[112]
    call TriggerAddCondition(st__IDialog_init[112],Condition( function sa__TransformDialog_init))
    call TriggerAddAction(st__IDialog_init[112], function sa__TransformDialog_init)
    set st__IDialog_button_clicked[113]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[113],Condition( function sa__FreeTransformDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[113], function sa__FreeTransformDialog_button_clicked)
    set st__IDialog_button_clicked[115]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[115],Condition( function sa__ChooseTechDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[115], function sa__ChooseTechDialog_button_clicked)
    set st__IDialog_init[115]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_init[115],Condition( function sa__ChooseTechDialog_init))
    call TriggerAddAction(st__IDialog_init[115], function sa__ChooseTechDialog_init)
    set st__IDialog_display[115]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_display[115],Condition( function sa__ChooseTechDialog_display))
    call TriggerAddAction(st__IDialog_display[115], function sa__ChooseTechDialog_display)
    set st__IDialog_button_clicked[116]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_button_clicked[116],Condition( function sa__ChooseBonusDialog_button_clicked))
    call TriggerAddAction(st__IDialog_button_clicked[116], function sa__ChooseBonusDialog_button_clicked)
    set st__IDialog_init[116]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_init[116],Condition( function sa__ChooseBonusDialog_init))
    call TriggerAddAction(st__IDialog_init[116], function sa__ChooseBonusDialog_init)
    set st__IDialog_display[116]=CreateTrigger()
    call TriggerAddCondition(st__IDialog_display[116],Condition( function sa__ChooseBonusDialog_display))
    call TriggerAddAction(st__IDialog_display[116], function sa__ChooseBonusDialog_display)
    set st__IBufferStruct_condition[118]=CreateTrigger()
    set st__IBufferStruct_condition[119]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[122]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[167]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[168]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[169]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[170]=st__IBufferStruct_condition[118]
    set st__IBufferStruct_condition[171]=st__IBufferStruct_condition[118]
    call TriggerAddCondition(st__IBufferStruct_condition[118],Condition( function sa__DefaultBufferStruct_condition))
    call TriggerAddAction(st__IBufferStruct_condition[118], function sa__DefaultBufferStruct_condition)
    set st__IBufferStruct_action[118]=CreateTrigger()
    set st__IBufferStruct_action[122]=st__IBufferStruct_action[118]
    set st__IBufferStruct_action[170]=st__IBufferStruct_action[118]
    set st__IBufferStruct_action[171]=st__IBufferStruct_action[118]
    call TriggerAddCondition(st__IBufferStruct_action[118],Condition( function sa__DefaultBufferStruct_action))
    call TriggerAddAction(st__IBufferStruct_action[118], function sa__DefaultBufferStruct_action)
    set st__IBufferStruct_addBuffer[118]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[118],Condition( function sa__DefaultBufferStruct_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[118], function sa__DefaultBufferStruct_addBuffer)
    set st__IBufferStruct_removeBuffer[118]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[118],Condition( function sa__DefaultBufferStruct_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[118], function sa__DefaultBufferStruct_removeBuffer)
    set st__IBufferStruct_init[118]=CreateTrigger()
    set st__IBufferStruct_init[119]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[120]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[122]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[167]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[168]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[169]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[170]=st__IBufferStruct_init[118]
    set st__IBufferStruct_init[171]=st__IBufferStruct_init[118]
    call TriggerAddCondition(st__IBufferStruct_init[118],Condition( function sa__DefaultBufferStruct_init))
    call TriggerAddAction(st__IBufferStruct_init[118], function sa__DefaultBufferStruct_init)
    set st__DefaultBufferStruct_start=CreateTrigger()
    call TriggerAddCondition(st__DefaultBufferStruct_start,Condition( function sa__DefaultBufferStruct_start))
    set st__DefaultBufferStruct_create=CreateTrigger()
    call TriggerAddCondition(st__DefaultBufferStruct_create,Condition( function sa__DefaultBufferStruct_create))
    set st__IBufferStruct_finish[118]=CreateTrigger()
    set st__IBufferStruct_finish[167]=st__IBufferStruct_finish[118]
    set st__IBufferStruct_finish[168]=st__IBufferStruct_finish[118]
    set st__IBufferStruct_finish[169]=st__IBufferStruct_finish[118]
    set st__IBufferStruct_finish[170]=st__IBufferStruct_finish[118]
    set st__IBufferStruct_finish[171]=st__IBufferStruct_finish[118]
    call TriggerAddCondition(st__IBufferStruct_finish[118],Condition( function sa__DefaultBufferStruct_finish))
    call TriggerAddAction(st__IBufferStruct_finish[118], function sa__DefaultBufferStruct_finish)
    set st__DefaultBufferStruct_loopMoveAll=CreateTrigger()
    call TriggerAddCondition(st__DefaultBufferStruct_loopMoveAll,Condition( function sa__DefaultBufferStruct_loopMoveAll))
    set st__IBufferStruct_onDestroy[118]=CreateTrigger()
    set st__IBufferStruct_onDestroy[119]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[120]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[122]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[167]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[168]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[169]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[170]=st__IBufferStruct_onDestroy[118]
    set st__IBufferStruct_onDestroy[171]=st__IBufferStruct_onDestroy[118]
    call TriggerAddCondition(st__IBufferStruct_onDestroy[118],Condition( function sa__DefaultBufferStruct_onDestroy))
    set st__IBufferStruct_addBuffer[119]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[119],Condition( function sa__BoundUnitEffectStruct_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[119], function sa__BoundUnitEffectStruct_addBuffer)
    set st__IBufferStruct_action[119]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_action[119],Condition( function sa__BoundUnitEffectStruct_action))
    call TriggerAddAction(st__IBufferStruct_action[119], function sa__BoundUnitEffectStruct_action)
    set st__IBufferStruct_removeBuffer[119]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[119],Condition( function sa__BoundUnitEffectStruct_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[119], function sa__BoundUnitEffectStruct_removeBuffer)
    set st__IBufferStruct_finish[119]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_finish[119],Condition( function sa__BoundUnitEffectStruct_finish))
    call TriggerAddAction(st__IBufferStruct_finish[119], function sa__BoundUnitEffectStruct_finish)
    set st__IBufferStruct_condition[120]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_condition[120],Condition( function sa__ElectricWhipBufferStruct_condition))
    call TriggerAddAction(st__IBufferStruct_condition[120], function sa__ElectricWhipBufferStruct_condition)
    set st__IBufferStruct_addBuffer[120]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[120],Condition( function sa__ElectricWhipBufferStruct_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[120], function sa__ElectricWhipBufferStruct_addBuffer)
    set st__IBufferStruct_action[120]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_action[120],Condition( function sa__ElectricWhipBufferStruct_action))
    call TriggerAddAction(st__IBufferStruct_action[120], function sa__ElectricWhipBufferStruct_action)
    set st__IBufferStruct_removeBuffer[120]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[120],Condition( function sa__ElectricWhipBufferStruct_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[120], function sa__ElectricWhipBufferStruct_removeBuffer)
    set st__IBufferStruct_finish[120]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_finish[120],Condition( function sa__ElectricWhipBufferStruct_finish))
    call TriggerAddAction(st__IBufferStruct_finish[120], function sa__ElectricWhipBufferStruct_finish)
    set st__IBufferStruct_addBuffer[122]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[122],Condition( function sa__PushForceStruct_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[122], function sa__PushForceStruct_addBuffer)
    set st__IBufferStruct_removeBuffer[122]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[122],Condition( function sa__PushForceStruct_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[122], function sa__PushForceStruct_removeBuffer)
    set st__PushForceStruct_create=CreateTrigger()
    call TriggerAddCondition(st__PushForceStruct_create,Condition( function sa__PushForceStruct_create))
    set st__IBufferStruct_finish[122]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_finish[122],Condition( function sa__PushForceStruct_finish))
    call TriggerAddAction(st__IBufferStruct_finish[122], function sa__PushForceStruct_finish)
    set st__IMissle_getMissleId[124]=CreateTrigger()
    set st__IMissle_getMissleId[125]=st__IMissle_getMissleId[124]
    set st__IMissle_getMissleId[126]=st__IMissle_getMissleId[124]
    call TriggerAddCondition(st__IMissle_getMissleId[124],Condition( function sa__Missle_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[124], function sa__Missle_getMissleId)
    set st__IMissle_refreshDamagedGroup[124]=CreateTrigger()
    set st__IMissle_refreshDamagedGroup[125]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[131]=st__IMissle_refreshDamagedGroup[125]
    set st__IMissle_refreshDamagedGroup[132]=st__IMissle_refreshDamagedGroup[125]
    set st__IMissle_refreshDamagedGroup[138]=st__IMissle_refreshDamagedGroup[125]
    set st__IMissle_refreshDamagedGroup[126]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[127]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[128]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[129]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[130]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[133]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[134]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[135]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[136]=st__IMissle_refreshDamagedGroup[124]
    set st__IMissle_refreshDamagedGroup[137]=st__IMissle_refreshDamagedGroup[124]
    call TriggerAddCondition(st__IMissle_refreshDamagedGroup[124],Condition( function sa__Missle_refreshDamagedGroup))
    call TriggerAddAction(st__IMissle_refreshDamagedGroup[124], function sa__Missle_refreshDamagedGroup)
    set st__IMissle_troughDamage[124]=CreateTrigger()
    set st__IMissle_troughDamage[126]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[127]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[128]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[129]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[130]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[133]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[134]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[135]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[136]=st__IMissle_troughDamage[124]
    set st__IMissle_troughDamage[137]=st__IMissle_troughDamage[124]
    call TriggerAddCondition(st__IMissle_troughDamage[124],Condition( function sa__Missle_troughDamage))
    call TriggerAddAction(st__IMissle_troughDamage[124], function sa__Missle_troughDamage)
    set st__IMissle_doDamage[124]=CreateTrigger()
    set st__IMissle_doDamage[125]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[131]=st__IMissle_doDamage[125]
    set st__IMissle_doDamage[132]=st__IMissle_doDamage[125]
    set st__IMissle_doDamage[138]=st__IMissle_doDamage[125]
    set st__IMissle_doDamage[126]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[127]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[128]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[129]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[130]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[133]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[134]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[135]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[136]=st__IMissle_doDamage[124]
    set st__IMissle_doDamage[137]=st__IMissle_doDamage[124]
    call TriggerAddCondition(st__IMissle_doDamage[124],Condition( function sa__Missle_doDamage))
    call TriggerAddAction(st__IMissle_doDamage[124], function sa__Missle_doDamage)
    set st__IMissle_damageEnemy[124]=CreateTrigger()
    set st__IMissle_damageEnemy[126]=st__IMissle_damageEnemy[124]
    set st__IMissle_damageEnemy[130]=st__IMissle_damageEnemy[124]
    set st__IMissle_damageEnemy[135]=st__IMissle_damageEnemy[124]
    set st__IMissle_damageEnemy[137]=st__IMissle_damageEnemy[124]
    call TriggerAddCondition(st__IMissle_damageEnemy[124],Condition( function sa__Missle_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[124], function sa__Missle_damageEnemy)
    set st__IMissle_debuffEnemy[124]=CreateTrigger()
    set st__IMissle_debuffEnemy[125]=st__IMissle_debuffEnemy[124]
    set st__IMissle_debuffEnemy[126]=st__IMissle_debuffEnemy[124]
    set st__IMissle_debuffEnemy[129]=st__IMissle_debuffEnemy[124]
    set st__IMissle_debuffEnemy[135]=st__IMissle_debuffEnemy[124]
    set st__IMissle_debuffEnemy[136]=st__IMissle_debuffEnemy[124]
    set st__IMissle_debuffEnemy[137]=st__IMissle_debuffEnemy[124]
    call TriggerAddCondition(st__IMissle_debuffEnemy[124],Condition( function sa__Missle_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[124], function sa__Missle_debuffEnemy)
    set st__IMissle_healAlly[124]=CreateTrigger()
    set st__IMissle_healAlly[125]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[131]=st__IMissle_healAlly[125]
    set st__IMissle_healAlly[132]=st__IMissle_healAlly[125]
    set st__IMissle_healAlly[138]=st__IMissle_healAlly[125]
    set st__IMissle_healAlly[126]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[127]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[128]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[129]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[130]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[133]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[134]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[135]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[136]=st__IMissle_healAlly[124]
    set st__IMissle_healAlly[137]=st__IMissle_healAlly[124]
    call TriggerAddCondition(st__IMissle_healAlly[124],Condition( function sa__Missle_healAlly))
    call TriggerAddAction(st__IMissle_healAlly[124], function sa__Missle_healAlly)
    set st__IMissle_hitSelf[124]=CreateTrigger()
    set st__IMissle_hitSelf[125]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[132]=st__IMissle_hitSelf[125]
    set st__IMissle_hitSelf[126]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[127]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[128]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[129]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[130]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[133]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[134]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[135]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[136]=st__IMissle_hitSelf[124]
    set st__IMissle_hitSelf[137]=st__IMissle_hitSelf[124]
    call TriggerAddCondition(st__IMissle_hitSelf[124],Condition( function sa__Missle_hitSelf))
    call TriggerAddAction(st__IMissle_hitSelf[124], function sa__Missle_hitSelf)
    set st__IMissle_fireMissle[124]=CreateTrigger()
    set st__IMissle_fireMissle[125]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[131]=st__IMissle_fireMissle[125]
    set st__IMissle_fireMissle[132]=st__IMissle_fireMissle[125]
    set st__IMissle_fireMissle[138]=st__IMissle_fireMissle[125]
    set st__IMissle_fireMissle[126]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[127]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[128]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[129]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[130]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[133]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[134]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[135]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[136]=st__IMissle_fireMissle[124]
    set st__IMissle_fireMissle[137]=st__IMissle_fireMissle[124]
    call TriggerAddCondition(st__IMissle_fireMissle[124],Condition( function sa__Missle_fireMissle))
    call TriggerAddAction(st__IMissle_fireMissle[124], function sa__Missle_fireMissle)
    set st__IMissle_onFire[124]=CreateTrigger()
    set st__IMissle_onFire[125]=st__IMissle_onFire[124]
    set st__IMissle_onFire[131]=st__IMissle_onFire[125]
    set st__IMissle_onFire[132]=st__IMissle_onFire[125]
    set st__IMissle_onFire[138]=st__IMissle_onFire[125]
    set st__IMissle_onFire[126]=st__IMissle_onFire[124]
    set st__IMissle_onFire[127]=st__IMissle_onFire[124]
    set st__IMissle_onFire[128]=st__IMissle_onFire[124]
    set st__IMissle_onFire[129]=st__IMissle_onFire[124]
    set st__IMissle_onFire[133]=st__IMissle_onFire[124]
    set st__IMissle_onFire[134]=st__IMissle_onFire[124]
    set st__IMissle_onFire[135]=st__IMissle_onFire[124]
    set st__IMissle_onFire[136]=st__IMissle_onFire[124]
    set st__IMissle_onFire[137]=st__IMissle_onFire[124]
    call TriggerAddCondition(st__IMissle_onFire[124],Condition( function sa__Missle_onFire))
    call TriggerAddAction(st__IMissle_onFire[124], function sa__Missle_onFire)
    set st__IMissle_substep[124]=CreateTrigger()
    set st__IMissle_substep[125]=st__IMissle_substep[124]
    set st__IMissle_substep[126]=st__IMissle_substep[124]
    set st__IMissle_substep[127]=st__IMissle_substep[124]
    set st__IMissle_substep[128]=st__IMissle_substep[124]
    set st__IMissle_substep[129]=st__IMissle_substep[124]
    set st__IMissle_substep[133]=st__IMissle_substep[124]
    set st__IMissle_substep[134]=st__IMissle_substep[124]
    set st__IMissle_substep[136]=st__IMissle_substep[124]
    set st__IMissle_substep[137]=st__IMissle_substep[124]
    call TriggerAddCondition(st__IMissle_substep[124],Condition( function sa__Missle_substep))
    call TriggerAddAction(st__IMissle_substep[124], function sa__Missle_substep)
    set st__IMissle_getLife[124]=CreateTrigger()
    set st__IMissle_getLife[125]=st__IMissle_getLife[124]
    set st__IMissle_getLife[127]=st__IMissle_getLife[124]
    set st__IMissle_getLife[128]=st__IMissle_getLife[124]
    set st__IMissle_getLife[129]=st__IMissle_getLife[124]
    call TriggerAddCondition(st__IMissle_getLife[124],Condition( function sa__Missle_getLife))
    call TriggerAddAction(st__IMissle_getLife[124], function sa__Missle_getLife)
    set st__Missle_create=CreateTrigger()
    call TriggerAddCondition(st__Missle_create,Condition( function sa__Missle_create))
    set st__IMissle_step[124]=CreateTrigger()
    set st__IMissle_step[125]=st__IMissle_step[124]
    set st__IMissle_step[131]=st__IMissle_step[125]
    set st__IMissle_step[132]=st__IMissle_step[125]
    set st__IMissle_step[138]=st__IMissle_step[125]
    set st__IMissle_step[126]=st__IMissle_step[124]
    set st__IMissle_step[127]=st__IMissle_step[124]
    set st__IMissle_step[128]=st__IMissle_step[124]
    set st__IMissle_step[129]=st__IMissle_step[124]
    set st__IMissle_step[130]=st__IMissle_step[124]
    set st__IMissle_step[133]=st__IMissle_step[124]
    set st__IMissle_step[134]=st__IMissle_step[124]
    set st__IMissle_step[135]=st__IMissle_step[124]
    set st__IMissle_step[136]=st__IMissle_step[124]
    set st__IMissle_step[137]=st__IMissle_step[124]
    call TriggerAddCondition(st__IMissle_step[124],Condition( function sa__Missle_step))
    call TriggerAddAction(st__IMissle_step[124], function sa__Missle_step)
    set st__IMissle_getFinalDamage[124]=CreateTrigger()
    set st__IMissle_getFinalDamage[125]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[126]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[127]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[128]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[129]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[130]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[133]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[134]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[135]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[136]=st__IMissle_getFinalDamage[124]
    set st__IMissle_getFinalDamage[137]=st__IMissle_getFinalDamage[124]
    call TriggerAddCondition(st__IMissle_getFinalDamage[124],Condition( function sa__Missle_getFinalDamage))
    call TriggerAddAction(st__IMissle_getFinalDamage[124], function sa__Missle_getFinalDamage)
    set st__IMissle_getOriginalDamage[124]=CreateTrigger()
    set st__IMissle_getOriginalDamage[125]=st__IMissle_getOriginalDamage[124]
    set st__IMissle_getOriginalDamage[126]=st__IMissle_getOriginalDamage[124]
    set st__IMissle_getOriginalDamage[127]=st__IMissle_getOriginalDamage[124]
    set st__IMissle_getOriginalDamage[128]=st__IMissle_getOriginalDamage[124]
    set st__IMissle_getOriginalDamage[135]=st__IMissle_getOriginalDamage[124]
    call TriggerAddCondition(st__IMissle_getOriginalDamage[124],Condition( function sa__Missle_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[124], function sa__Missle_getOriginalDamage)
    set st__IMissle_explode[124]=CreateTrigger()
    set st__IMissle_explode[125]=st__IMissle_explode[124]
    set st__IMissle_explode[126]=st__IMissle_explode[124]
    set st__IMissle_explode[127]=st__IMissle_explode[124]
    set st__IMissle_explode[128]=st__IMissle_explode[124]
    set st__IMissle_explode[129]=st__IMissle_explode[124]
    set st__IMissle_explode[136]=st__IMissle_explode[124]
    set st__IMissle_explode[137]=st__IMissle_explode[124]
    call TriggerAddCondition(st__IMissle_explode[124],Condition( function sa__Missle_explode))
    call TriggerAddAction(st__IMissle_explode[124], function sa__Missle_explode)
    set st__IMissle_onDestroy[124]=CreateTrigger()
    set st__IMissle_onDestroy[125]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[131]=st__IMissle_onDestroy[125]
    set st__IMissle_onDestroy[132]=st__IMissle_onDestroy[125]
    set st__IMissle_onDestroy[138]=st__IMissle_onDestroy[125]
    set st__IMissle_onDestroy[126]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[127]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[128]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[129]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[130]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[133]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[134]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[135]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[136]=st__IMissle_onDestroy[124]
    set st__IMissle_onDestroy[137]=st__IMissle_onDestroy[124]
    call TriggerAddCondition(st__IMissle_onDestroy[124],Condition( function sa__Missle_onDestroy))
    set st__IMissle_damageEnemy[125]=CreateTrigger()
    set st__IMissle_damageEnemy[131]=st__IMissle_damageEnemy[125]
    set st__IMissle_damageEnemy[132]=st__IMissle_damageEnemy[125]
    set st__IMissle_damageEnemy[138]=st__IMissle_damageEnemy[125]
    call TriggerAddCondition(st__IMissle_damageEnemy[125],Condition( function sa__TroughMissle_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[125], function sa__TroughMissle_damageEnemy)
    set st__IMissle_troughDamage[125]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_troughDamage[125],Condition( function sa__TroughMissle_troughDamage))
    call TriggerAddAction(st__IMissle_troughDamage[125], function sa__TroughMissle_troughDamage)
    set st__IMissle_getLife[126]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[126],Condition( function sa__ShootGunMissle_getLife))
    call TriggerAddAction(st__IMissle_getLife[126], function sa__ShootGunMissle_getLife)
    set st__IMissle_getMissleId[127]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[127],Condition( function sa__IceMissle_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[127], function sa__IceMissle_getMissleId)
    set st__IMissle_damageEnemy[127]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[127],Condition( function sa__IceMissle_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[127], function sa__IceMissle_damageEnemy)
    set st__IMissle_debuffEnemy[127]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[127],Condition( function sa__IceMissle_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[127], function sa__IceMissle_debuffEnemy)
    set st__IMissle_damageEnemy[128]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[128],Condition( function sa__FireMissle_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[128], function sa__FireMissle_damageEnemy)
    set st__IMissle_getMissleId[128]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[128],Condition( function sa__FireMissle_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[128], function sa__FireMissle_getMissleId)
    set st__IMissle_debuffEnemy[128]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[128],Condition( function sa__FireMissle_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[128], function sa__FireMissle_debuffEnemy)
    set st__IMissle_getMissleId[129]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[129],Condition( function sa__SmallDarts_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[129], function sa__SmallDarts_getMissleId)
    set st__IMissle_getOriginalDamage[129]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[129],Condition( function sa__SmallDarts_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[129], function sa__SmallDarts_getOriginalDamage)
    set st__IMissle_damageEnemy[129]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[129],Condition( function sa__SmallDarts_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[129], function sa__SmallDarts_damageEnemy)
    set st__IMissle_getMissleId[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[130],Condition( function sa__ElectricWhip_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[130], function sa__ElectricWhip_getMissleId)
    set st__IMissle_getOriginalDamage[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[130],Condition( function sa__ElectricWhip_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[130], function sa__ElectricWhip_getOriginalDamage)
    set st__IMissle_getLife[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[130],Condition( function sa__ElectricWhip_getLife))
    call TriggerAddAction(st__IMissle_getLife[130], function sa__ElectricWhip_getLife)
    set st__IMissle_debuffEnemy[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[130],Condition( function sa__ElectricWhip_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[130], function sa__ElectricWhip_debuffEnemy)
    set st__IMissle_onFire[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_onFire[130],Condition( function sa__ElectricWhip_onFire))
    call TriggerAddAction(st__IMissle_onFire[130], function sa__ElectricWhip_onFire)
    set st__IMissle_substep[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_substep[130],Condition( function sa__ElectricWhip_substep))
    call TriggerAddAction(st__IMissle_substep[130], function sa__ElectricWhip_substep)
    set st__IMissle_explode[130]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[130],Condition( function sa__ElectricWhip_explode))
    call TriggerAddAction(st__IMissle_explode[130], function sa__ElectricWhip_explode)
    set st__IMissle_getMissleId[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[131],Condition( function sa__ReturnDarts_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[131], function sa__ReturnDarts_getMissleId)
    set st__IMissle_getOriginalDamage[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[131],Condition( function sa__ReturnDarts_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[131], function sa__ReturnDarts_getOriginalDamage)
    set st__IMissle_getLife[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[131],Condition( function sa__ReturnDarts_getLife))
    call TriggerAddAction(st__IMissle_getLife[131], function sa__ReturnDarts_getLife)
    set st__IMissle_debuffEnemy[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[131],Condition( function sa__ReturnDarts_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[131], function sa__ReturnDarts_debuffEnemy)
    set st__IMissle_hitSelf[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_hitSelf[131],Condition( function sa__ReturnDarts_hitSelf))
    call TriggerAddAction(st__IMissle_hitSelf[131], function sa__ReturnDarts_hitSelf)
    set st__IMissle_getFinalDamage[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getFinalDamage[131],Condition( function sa__ReturnDarts_getFinalDamage))
    call TriggerAddAction(st__IMissle_getFinalDamage[131], function sa__ReturnDarts_getFinalDamage)
    set st__IMissle_troughDamage[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_troughDamage[131],Condition( function sa__ReturnDarts_troughDamage))
    call TriggerAddAction(st__IMissle_troughDamage[131], function sa__ReturnDarts_troughDamage)
    set st__IMissle_explode[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[131],Condition( function sa__ReturnDarts_explode))
    call TriggerAddAction(st__IMissle_explode[131], function sa__ReturnDarts_explode)
    set st__IMissle_substep[131]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_substep[131],Condition( function sa__ReturnDarts_substep))
    call TriggerAddAction(st__IMissle_substep[131], function sa__ReturnDarts_substep)
    set st__IMissle_getMissleId[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[132],Condition( function sa__LeaveDarts_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[132], function sa__LeaveDarts_getMissleId)
    set st__IMissle_getOriginalDamage[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[132],Condition( function sa__LeaveDarts_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[132], function sa__LeaveDarts_getOriginalDamage)
    set st__IMissle_getLife[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[132],Condition( function sa__LeaveDarts_getLife))
    call TriggerAddAction(st__IMissle_getLife[132], function sa__LeaveDarts_getLife)
    set st__IMissle_debuffEnemy[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[132],Condition( function sa__LeaveDarts_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[132], function sa__LeaveDarts_debuffEnemy)
    set st__IMissle_getFinalDamage[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getFinalDamage[132],Condition( function sa__LeaveDarts_getFinalDamage))
    call TriggerAddAction(st__IMissle_getFinalDamage[132], function sa__LeaveDarts_getFinalDamage)
    set st__IMissle_troughDamage[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_troughDamage[132],Condition( function sa__LeaveDarts_troughDamage))
    call TriggerAddAction(st__IMissle_troughDamage[132], function sa__LeaveDarts_troughDamage)
    set st__IMissle_explode[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[132],Condition( function sa__LeaveDarts_explode))
    call TriggerAddAction(st__IMissle_explode[132], function sa__LeaveDarts_explode)
    set st__IMissle_substep[132]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_substep[132],Condition( function sa__LeaveDarts_substep))
    call TriggerAddAction(st__IMissle_substep[132], function sa__LeaveDarts_substep)
    set st__IMissle_getMissleId[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[133],Condition( function sa__BackGrenade_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[133], function sa__BackGrenade_getMissleId)
    set st__IMissle_getOriginalDamage[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[133],Condition( function sa__BackGrenade_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[133], function sa__BackGrenade_getOriginalDamage)
    set st__IMissle_debuffEnemy[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[133],Condition( function sa__BackGrenade_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[133], function sa__BackGrenade_debuffEnemy)
    set st__IMissle_damageEnemy[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[133],Condition( function sa__BackGrenade_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[133], function sa__BackGrenade_damageEnemy)
    set st__IMissle_explode[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[133],Condition( function sa__BackGrenade_explode))
    call TriggerAddAction(st__IMissle_explode[133], function sa__BackGrenade_explode)
    set st__IMissle_getLife[133]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[133],Condition( function sa__BackGrenade_getLife))
    call TriggerAddAction(st__IMissle_getLife[133], function sa__BackGrenade_getLife)
    set st__IMissle_getMissleId[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[134],Condition( function sa__PushGrenade_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[134], function sa__PushGrenade_getMissleId)
    set st__IMissle_getOriginalDamage[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[134],Condition( function sa__PushGrenade_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[134], function sa__PushGrenade_getOriginalDamage)
    set st__IMissle_debuffEnemy[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[134],Condition( function sa__PushGrenade_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[134], function sa__PushGrenade_debuffEnemy)
    set st__IMissle_damageEnemy[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[134],Condition( function sa__PushGrenade_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[134], function sa__PushGrenade_damageEnemy)
    set st__IMissle_explode[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[134],Condition( function sa__PushGrenade_explode))
    call TriggerAddAction(st__IMissle_explode[134], function sa__PushGrenade_explode)
    set st__IMissle_getLife[134]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[134],Condition( function sa__PushGrenade_getLife))
    call TriggerAddAction(st__IMissle_getLife[134], function sa__PushGrenade_getLife)
    set st__IMissle_getMissleId[135]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[135],Condition( function sa__Mine_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[135], function sa__Mine_getMissleId)
    set st__IMissle_substep[135]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_substep[135],Condition( function sa__Mine_substep))
    call TriggerAddAction(st__IMissle_substep[135], function sa__Mine_substep)
    set st__IMissle_explode[135]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[135],Condition( function sa__Mine_explode))
    call TriggerAddAction(st__IMissle_explode[135], function sa__Mine_explode)
    set st__IMissle_getLife[135]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[135],Condition( function sa__Mine_getLife))
    call TriggerAddAction(st__IMissle_getLife[135], function sa__Mine_getLife)
    set st__Mine_getDeployTime=CreateTrigger()
    call TriggerAddCondition(st__Mine_getDeployTime,Condition( function sa__Mine_getDeployTime))
    set st__Mine_create=CreateTrigger()
    call TriggerAddCondition(st__Mine_create,Condition( function sa__Mine_create))
    set st__IMissle_damageEnemy[136]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_damageEnemy[136],Condition( function sa__ShoulderCannonMissle_damageEnemy))
    call TriggerAddAction(st__IMissle_damageEnemy[136], function sa__ShoulderCannonMissle_damageEnemy)
    set st__IMissle_getLife[136]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[136],Condition( function sa__ShoulderCannonMissle_getLife))
    call TriggerAddAction(st__IMissle_getLife[136], function sa__ShoulderCannonMissle_getLife)
    set st__IMissle_getOriginalDamage[136]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[136],Condition( function sa__ShoulderCannonMissle_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[136], function sa__ShoulderCannonMissle_getOriginalDamage)
    set st__IMissle_getMissleId[136]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[136],Condition( function sa__ShoulderCannonMissle_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[136], function sa__ShoulderCannonMissle_getMissleId)
    set st__IMissle_getLife[137]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[137],Condition( function sa__SpearMissle_getLife))
    call TriggerAddAction(st__IMissle_getLife[137], function sa__SpearMissle_getLife)
    set st__IMissle_getOriginalDamage[137]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[137],Condition( function sa__SpearMissle_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[137], function sa__SpearMissle_getOriginalDamage)
    set st__IMissle_getMissleId[137]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[137],Condition( function sa__SpearMissle_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[137], function sa__SpearMissle_getMissleId)
    set st__IMissle_getMissleId[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getMissleId[138],Condition( function sa__SmartDarts_getMissleId))
    call TriggerAddAction(st__IMissle_getMissleId[138], function sa__SmartDarts_getMissleId)
    set st__IMissle_getOriginalDamage[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getOriginalDamage[138],Condition( function sa__SmartDarts_getOriginalDamage))
    call TriggerAddAction(st__IMissle_getOriginalDamage[138], function sa__SmartDarts_getOriginalDamage)
    set st__IMissle_getLife[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getLife[138],Condition( function sa__SmartDarts_getLife))
    call TriggerAddAction(st__IMissle_getLife[138], function sa__SmartDarts_getLife)
    set st__IMissle_debuffEnemy[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_debuffEnemy[138],Condition( function sa__SmartDarts_debuffEnemy))
    call TriggerAddAction(st__IMissle_debuffEnemy[138], function sa__SmartDarts_debuffEnemy)
    set st__SmartDarts_create=CreateTrigger()
    call TriggerAddCondition(st__SmartDarts_create,Condition( function sa__SmartDarts_create))
    set st__IMissle_hitSelf[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_hitSelf[138],Condition( function sa__SmartDarts_hitSelf))
    call TriggerAddAction(st__IMissle_hitSelf[138], function sa__SmartDarts_hitSelf)
    set st__IMissle_getFinalDamage[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_getFinalDamage[138],Condition( function sa__SmartDarts_getFinalDamage))
    call TriggerAddAction(st__IMissle_getFinalDamage[138], function sa__SmartDarts_getFinalDamage)
    set st__IMissle_troughDamage[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_troughDamage[138],Condition( function sa__SmartDarts_troughDamage))
    call TriggerAddAction(st__IMissle_troughDamage[138], function sa__SmartDarts_troughDamage)
    set st__IMissle_explode[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_explode[138],Condition( function sa__SmartDarts_explode))
    call TriggerAddAction(st__IMissle_explode[138], function sa__SmartDarts_explode)
    set st__IMissle_substep[138]=CreateTrigger()
    call TriggerAddCondition(st__IMissle_substep[138],Condition( function sa__SmartDarts_substep))
    call TriggerAddAction(st__IMissle_substep[138], function sa__SmartDarts_substep)
    set st__IBufferStruct_addBuffer[171]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[171],Condition( function sa__AutoAimBuffer_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[171], function sa__AutoAimBuffer_addBuffer)
    set st__IBufferStruct_removeBuffer[171]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[171],Condition( function sa__AutoAimBuffer_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[171], function sa__AutoAimBuffer_removeBuffer)
    set st__IShooter_shoot[141]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoot[141],Condition( function sa__SingleShooter_shoot))
    call TriggerAddAction(st__IShooter_shoot[141], function sa__SingleShooter_shoot)
    set st__IShooter_tick[142]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_tick[142],Condition( function sa__ShoulderCannonShooter_tick))
    call TriggerAddAction(st__IShooter_tick[142], function sa__ShoulderCannonShooter_tick)
    set st__IShooter_shoot[142]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoot[142],Condition( function sa__ShoulderCannonShooter_shoot))
    call TriggerAddAction(st__IShooter_shoot[142], function sa__ShoulderCannonShooter_shoot)
    set st__IShooter_shoot[143]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoot[143],Condition( function sa__GrenadeThrower_shoot))
    call TriggerAddAction(st__IShooter_shoot[143], function sa__GrenadeThrower_shoot)
    set st__IShooter_shoot[144]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoot[144],Condition( function sa__MineThrower_shoot))
    call TriggerAddAction(st__IShooter_shoot[144], function sa__MineThrower_shoot)
    set st__IShooter_shoot[145]=CreateTrigger()
    set st__IShooter_shoot[146]=st__IShooter_shoot[145]
    set st__IShooter_shoot[147]=st__IShooter_shoot[145]
    call TriggerAddCondition(st__IShooter_shoot[145],Condition( function sa__DefaultShooter_shoot))
    call TriggerAddAction(st__IShooter_shoot[145], function sa__DefaultShooter_shoot)
    set st__DefaultShooter_getShootDir=CreateTrigger()
    call TriggerAddCondition(st__DefaultShooter_getShootDir,Condition( function sa__DefaultShooter_getShootDir))
    set st__DefaultShooter_getShootVector=CreateTrigger()
    call TriggerAddCondition(st__DefaultShooter_getShootVector,Condition( function sa__DefaultShooter_getShootVector))
    set st__IShooter_subshoot[145]=CreateTrigger()
    set st__IShooter_subshoot[146]=st__IShooter_subshoot[145]
    set st__IShooter_subshoot[147]=st__IShooter_subshoot[145]
    call TriggerAddCondition(st__IShooter_subshoot[145],Condition( function sa__DefaultShooter_subshoot))
    call TriggerAddAction(st__IShooter_subshoot[145], function sa__DefaultShooter_subshoot)
    set st__IShooter_getEnergyConsume[145]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getEnergyConsume[145],Condition( function sa__DefaultShooter_getEnergyConsume))
    call TriggerAddAction(st__IShooter_getEnergyConsume[145], function sa__DefaultShooter_getEnergyConsume)
    set st__DefaultShooter_energyConsume=CreateTrigger()
    call TriggerAddCondition(st__DefaultShooter_energyConsume,Condition( function sa__DefaultShooter_energyConsume))
    set st__DefaultShooter_backForce=CreateTrigger()
    call TriggerAddCondition(st__DefaultShooter_backForce,Condition( function sa__DefaultShooter_backForce))
    set st__IShooter_getEnergyConsume[146]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getEnergyConsume[146],Condition( function sa__ShootGunShooter_getEnergyConsume))
    call TriggerAddAction(st__IShooter_getEnergyConsume[146], function sa__ShootGunShooter_getEnergyConsume)
    set st__IShooter_shootCount[146]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shootCount[146],Condition( function sa__ShootGunShooter_shootCount))
    call TriggerAddAction(st__IShooter_shootCount[146], function sa__ShootGunShooter_shootCount)
    set st__IShooter_getRist[146]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getRist[146],Condition( function sa__ShootGunShooter_getRist))
    call TriggerAddAction(st__IShooter_getRist[146], function sa__ShootGunShooter_getRist)
    set st__IShooter_getOriginSpeed[146]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getOriginSpeed[146],Condition( function sa__ShootGunShooter_getOriginSpeed))
    call TriggerAddAction(st__IShooter_getOriginSpeed[146], function sa__ShootGunShooter_getOriginSpeed)
    set st__IShooter_shoothz[147]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_shoothz[147],Condition( function sa__MachineGunShooter_shoothz))
    call TriggerAddAction(st__IShooter_shoothz[147], function sa__MachineGunShooter_shoothz)
    set st__IShooter_getEnergyConsume[147]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getEnergyConsume[147],Condition( function sa__MachineGunShooter_getEnergyConsume))
    call TriggerAddAction(st__IShooter_getEnergyConsume[147], function sa__MachineGunShooter_getEnergyConsume)
    set st__IShooter_getClipSize[147]=CreateTrigger()
    call TriggerAddCondition(st__IShooter_getClipSize[147],Condition( function sa__MachineGunShooter_getClipSize))
    call TriggerAddAction(st__IShooter_getClipSize[147], function sa__MachineGunShooter_getClipSize)
    set st__SpellStruct__DefaultsInterface_cleanup[150]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[150],Condition( function sa__ItemJump_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[150], function sa__ItemJump_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[150]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[150],Condition( function sa__ItemJump_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[150], function sa__ItemJump_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[150]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[150],Condition( function sa__ItemJump_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[150], function sa__ItemJump_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[151]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[151],Condition( function sa__Jump_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[151], function sa__Jump_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[151]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[151],Condition( function sa__Jump_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[151], function sa__Jump_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[151]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[151],Condition( function sa__Jump_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[151], function sa__Jump_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[152]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[152],Condition( function sa__InjectionSpeedUp_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[152], function sa__InjectionSpeedUp_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[152]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[152],Condition( function sa__InjectionSpeedUp_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[152], function sa__InjectionSpeedUp_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[152]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[152],Condition( function sa__InjectionSpeedUp_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[152], function sa__InjectionSpeedUp_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[153]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[153],Condition( function sa__Darts_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[153], function sa__Darts_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[153]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[153],Condition( function sa__Darts_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[153], function sa__Darts_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[153]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[153],Condition( function sa__Darts_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[153], function sa__Darts_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[154]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[154],Condition( function sa__ReturnDartsSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[154], function sa__ReturnDartsSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[154]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[154],Condition( function sa__ReturnDartsSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[154], function sa__ReturnDartsSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[154]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[154],Condition( function sa__ReturnDartsSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[154], function sa__ReturnDartsSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[155]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[155],Condition( function sa__SmartDartsSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[155], function sa__SmartDartsSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[155]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[155],Condition( function sa__SmartDartsSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[155], function sa__SmartDartsSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[155]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[155],Condition( function sa__SmartDartsSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[155], function sa__SmartDartsSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[156]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[156],Condition( function sa__ShoulderCannonSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[156], function sa__ShoulderCannonSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[156]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[156],Condition( function sa__ShoulderCannonSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[156], function sa__ShoulderCannonSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[156]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[156],Condition( function sa__ShoulderCannonSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[156], function sa__ShoulderCannonSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[157]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[157],Condition( function sa__ItemReturnDartsSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[157], function sa__ItemReturnDartsSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[157]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[157],Condition( function sa__ItemReturnDartsSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[157], function sa__ItemReturnDartsSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[157]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[157],Condition( function sa__ItemReturnDartsSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[157], function sa__ItemReturnDartsSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[158]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[158],Condition( function sa__LeaveDartsSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[158], function sa__LeaveDartsSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[158]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[158],Condition( function sa__LeaveDartsSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[158], function sa__LeaveDartsSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[158]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[158],Condition( function sa__LeaveDartsSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[158], function sa__LeaveDartsSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[159]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[159],Condition( function sa__BackGrenadeSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[159], function sa__BackGrenadeSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[159]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[159],Condition( function sa__BackGrenadeSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[159], function sa__BackGrenadeSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[159]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[159],Condition( function sa__BackGrenadeSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[159], function sa__BackGrenadeSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[160]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[160],Condition( function sa__MineSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[160], function sa__MineSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[160]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[160],Condition( function sa__MineSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[160], function sa__MineSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[160]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[160],Condition( function sa__MineSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[160], function sa__MineSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[161]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[161],Condition( function sa__PushGrenadeSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[161], function sa__PushGrenadeSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[161]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[161],Condition( function sa__PushGrenadeSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[161], function sa__PushGrenadeSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[161]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[161],Condition( function sa__PushGrenadeSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[161], function sa__PushGrenadeSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[162]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[162],Condition( function sa__Blink_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[162], function sa__Blink_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[162]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[162],Condition( function sa__Blink_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[162], function sa__Blink_onChannel)
    set st__SpellStruct__DefaultsInterface_cleanup[163]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[163],Condition( function sa__Transport_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[163], function sa__Transport_cleanup)
    set st__SpellStruct__DefaultsInterface_onFinish[163]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onFinish[163],Condition( function sa__Transport_onFinish))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onFinish[163], function sa__Transport_onFinish)
    set st__SpellStruct__DefaultsInterface_cleanup[164]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[164],Condition( function sa__ElectricWhipSpell_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[164], function sa__ElectricWhipSpell_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[164]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[164],Condition( function sa__ElectricWhipSpell_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[164], function sa__ElectricWhipSpell_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[164]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[164],Condition( function sa__ElectricWhipSpell_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[164], function sa__ElectricWhipSpell_onStopCast)
    set st__SpellStruct__DefaultsInterface_cleanup[165]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[165],Condition( function sa__AutoAim_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[165], function sa__AutoAim_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[165]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[165],Condition( function sa__AutoAim_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[165], function sa__AutoAim_onChannel)
    set st__SpellStruct__DefaultsInterface_cleanup[166]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_cleanup[166],Condition( function sa__ShootBack_cleanup))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_cleanup[166], function sa__ShootBack_cleanup)
    set st__SpellStruct__DefaultsInterface_onChannel[166]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onChannel[166],Condition( function sa__ShootBack_onChannel))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onChannel[166], function sa__ShootBack_onChannel)
    set st__SpellStruct__DefaultsInterface_onStopCast[166]=CreateTrigger()
    call TriggerAddCondition(st__SpellStruct__DefaultsInterface_onStopCast[166],Condition( function sa__ShootBack_onStopCast))
    call TriggerAddAction(st__SpellStruct__DefaultsInterface_onStopCast[166], function sa__ShootBack_onStopCast)
    set st__IBufferStruct_addBuffer[167]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[167],Condition( function sa__BurnBuffer_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[167], function sa__BurnBuffer_addBuffer)
    set st__IBufferStruct_action[167]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_action[167],Condition( function sa__BurnBuffer_action))
    call TriggerAddAction(st__IBufferStruct_action[167], function sa__BurnBuffer_action)
    set st__IBufferStruct_removeBuffer[167]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[167],Condition( function sa__BurnBuffer_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[167], function sa__BurnBuffer_removeBuffer)
    set st__BurnBuffer_create=CreateTrigger()
    call TriggerAddCondition(st__BurnBuffer_create,Condition( function sa__BurnBuffer_create))
    set st__IBufferStruct_addBuffer[168]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[168],Condition( function sa__HorroBuffer_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[168], function sa__HorroBuffer_addBuffer)
    set st__IBufferStruct_action[168]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_action[168],Condition( function sa__HorroBuffer_action))
    call TriggerAddAction(st__IBufferStruct_action[168], function sa__HorroBuffer_action)
    set st__IBufferStruct_removeBuffer[168]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[168],Condition( function sa__HorroBuffer_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[168], function sa__HorroBuffer_removeBuffer)
    set st__HorroBuffer_create=CreateTrigger()
    call TriggerAddCondition(st__HorroBuffer_create,Condition( function sa__HorroBuffer_create))
    set st__IBufferStruct_addBuffer[169]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[169],Condition( function sa__BleedBuffer_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[169], function sa__BleedBuffer_addBuffer)
    set st__IBufferStruct_action[169]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_action[169],Condition( function sa__BleedBuffer_action))
    call TriggerAddAction(st__IBufferStruct_action[169], function sa__BleedBuffer_action)
    set st__IBufferStruct_removeBuffer[169]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[169],Condition( function sa__BleedBuffer_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[169], function sa__BleedBuffer_removeBuffer)
    set st__BleedBuffer_create=CreateTrigger()
    call TriggerAddCondition(st__BleedBuffer_create,Condition( function sa__BleedBuffer_create))
    set st__IBufferStruct_addBuffer[170]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_addBuffer[170],Condition( function sa__IceSlowBuffer_addBuffer))
    call TriggerAddAction(st__IBufferStruct_addBuffer[170], function sa__IceSlowBuffer_addBuffer)
    set st__IBufferStruct_removeBuffer[170]=CreateTrigger()
    call TriggerAddCondition(st__IBufferStruct_removeBuffer[170],Condition( function sa__IceSlowBuffer_removeBuffer))
    call TriggerAddAction(st__IBufferStruct_removeBuffer[170], function sa__IceSlowBuffer_removeBuffer)
    set st___prototype37[1]=CreateTrigger()
    call TriggerAddAction(st___prototype37[1],function sa___prototype37_s__TableArray_clean)
    call TriggerAddCondition(st___prototype37[1],Condition(function sa___prototype37_s__TableArray_clean))
    set st___prototype1[1]=CreateTrigger()
    call TriggerAddAction(st___prototype1[1],function sa___prototype1_s__ItemJump_create)
    call TriggerAddCondition(st___prototype1[1],Condition(function sa___prototype1_s__ItemJump_create))
    set st___prototype1[2]=CreateTrigger()
    call TriggerAddAction(st___prototype1[2],function sa___prototype1_s__Jump_create)
    call TriggerAddCondition(st___prototype1[2],Condition(function sa___prototype1_s__Jump_create))
    set st___prototype1[3]=CreateTrigger()
    call TriggerAddAction(st___prototype1[3],function sa___prototype1_s__InjectionSpeedUp_create)
    call TriggerAddCondition(st___prototype1[3],Condition(function sa___prototype1_s__InjectionSpeedUp_create))
    set st___prototype1[4]=CreateTrigger()
    call TriggerAddAction(st___prototype1[4],function sa___prototype1_s__Darts_create)
    call TriggerAddCondition(st___prototype1[4],Condition(function sa___prototype1_s__Darts_create))
    set st___prototype1[5]=CreateTrigger()
    call TriggerAddAction(st___prototype1[5],function sa___prototype1_s__ReturnDartsSpell_create)
    call TriggerAddCondition(st___prototype1[5],Condition(function sa___prototype1_s__ReturnDartsSpell_create))
    set st___prototype1[6]=CreateTrigger()
    call TriggerAddAction(st___prototype1[6],function sa___prototype1_s__SmartDartsSpell_create)
    call TriggerAddCondition(st___prototype1[6],Condition(function sa___prototype1_s__SmartDartsSpell_create))
    set st___prototype1[7]=CreateTrigger()
    call TriggerAddAction(st___prototype1[7],function sa___prototype1_s__ShoulderCannonSpell_create)
    call TriggerAddCondition(st___prototype1[7],Condition(function sa___prototype1_s__ShoulderCannonSpell_create))
    set st___prototype1[8]=CreateTrigger()
    call TriggerAddAction(st___prototype1[8],function sa___prototype1_s__ItemReturnDartsSpell_create)
    call TriggerAddCondition(st___prototype1[8],Condition(function sa___prototype1_s__ItemReturnDartsSpell_create))
    set st___prototype1[9]=CreateTrigger()
    call TriggerAddAction(st___prototype1[9],function sa___prototype1_s__LeaveDartsSpell_create)
    call TriggerAddCondition(st___prototype1[9],Condition(function sa___prototype1_s__LeaveDartsSpell_create))
    set st___prototype1[10]=CreateTrigger()
    call TriggerAddAction(st___prototype1[10],function sa___prototype1_s__BackGrenadeSpell_create)
    call TriggerAddCondition(st___prototype1[10],Condition(function sa___prototype1_s__BackGrenadeSpell_create))
    set st___prototype1[11]=CreateTrigger()
    call TriggerAddAction(st___prototype1[11],function sa___prototype1_s__MineSpell_create)
    call TriggerAddCondition(st___prototype1[11],Condition(function sa___prototype1_s__MineSpell_create))
    set st___prototype1[12]=CreateTrigger()
    call TriggerAddAction(st___prototype1[12],function sa___prototype1_s__PushGrenadeSpell_create)
    call TriggerAddCondition(st___prototype1[12],Condition(function sa___prototype1_s__PushGrenadeSpell_create))
    set st___prototype1[13]=CreateTrigger()
    call TriggerAddAction(st___prototype1[13],function sa___prototype1_s__Blink_create)
    call TriggerAddCondition(st___prototype1[13],Condition(function sa___prototype1_s__Blink_create))
    set st___prototype1[14]=CreateTrigger()
    call TriggerAddAction(st___prototype1[14],function sa___prototype1_s__Transport_create)
    call TriggerAddCondition(st___prototype1[14],Condition(function sa___prototype1_s__Transport_create))
    set st___prototype1[15]=CreateTrigger()
    call TriggerAddAction(st___prototype1[15],function sa___prototype1_s__ElectricWhipSpell_create)
    call TriggerAddCondition(st___prototype1[15],Condition(function sa___prototype1_s__ElectricWhipSpell_create))
    set st___prototype1[16]=CreateTrigger()
    call TriggerAddAction(st___prototype1[16],function sa___prototype1_s__AutoAim_create)
    call TriggerAddCondition(st___prototype1[16],Condition(function sa___prototype1_s__AutoAim_create))
    set st___prototype1[17]=CreateTrigger()
    call TriggerAddAction(st___prototype1[17],function sa___prototype1_s__ShootBack_create)
    call TriggerAddCondition(st___prototype1[17],Condition(function sa___prototype1_s__ShootBack_create))



call ExecuteFunc("s__AII___Initializer_AII___AIIInit___onInit")

















































































call ExecuteFunc("s__EquipmentData_T32xs___onInit")










call ExecuteFunc("s__IndividualItemData_AII___onInit")








call ExecuteFunc("s__Status_Status___StatusInit___onInit")
call ExecuteFunc("s__Status_Status___TwoPowArray___onInit")
call ExecuteFunc("s__Status_Status___StaticPeriodic___onInit")
call ExecuteFunc("s__Status_T32xs___onInit")




call ExecuteFunc("s__DefaultAIGroup_T32x___onInit")















call ExecuteFunc("s__MonsterTargetGroupManager_T32x___onInit")



















call ExecuteFunc("s__AbstractShooter_T32xs___onInit")




































    call ExecuteFunc("s__AII___ItemStruct_onInit")
    call ExecuteFunc("s__DummyCaster___Initializer_onInit")
    call ExecuteFunc("s__Material_onInit")
    call ExecuteFunc("s__Damage__Detector_onInit")
    call ExecuteFunc("s__EquipmentData_onInit")
    call ExecuteFunc("s__SpellStruct__Init_onInit")
    call ExecuteFunc("s__Status_onInit")
    call ExecuteFunc("s__AIData_onInit")
    call ExecuteFunc("s__Velocity_onInit")
    call ExecuteFunc("s__ItemJump_onInit")
    call ExecuteFunc("s__Jump_onInit")
    call ExecuteFunc("s__InjectionSpeedUp_onInit")
    call ExecuteFunc("s__Darts_onInit")
    call ExecuteFunc("s__ReturnDartsSpell_onInit")
    call ExecuteFunc("s__SmartDartsSpell_onInit")
    call ExecuteFunc("s__ShoulderCannonSpell_onInit")
    call ExecuteFunc("s__ItemReturnDartsSpell_onInit")
    call ExecuteFunc("s__LeaveDartsSpell_onInit")
    call ExecuteFunc("s__BackGrenadeSpell_onInit")
    call ExecuteFunc("s__MineSpell_onInit")
    call ExecuteFunc("s__PushGrenadeSpell_onInit")
    call ExecuteFunc("s__Blink_onInit")
    call ExecuteFunc("s__Transport_onInit")
    call ExecuteFunc("s__ElectricWhipSpell_onInit")
    call ExecuteFunc("s__AutoAim_onInit")
    call ExecuteFunc("s__ShootBack_onInit")
endfunction
